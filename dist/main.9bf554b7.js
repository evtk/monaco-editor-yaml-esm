var wI = Object.defineProperty;
var SI = (s, e, t) => e in s ? wI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var La = (s, e, t) => (SI(s, typeof e != "symbol" ? e + "" : e, t), t);
globalThis && globalThis.__awaiter;
let yI = typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function LI(s, e) {
  let t;
  return e.length === 0 ? t = s : t = s.replace(/\{(\d+)\}/g, (i, n) => {
    const r = n[0], o = e[r];
    let a = i;
    return typeof o == "string" ? a = o : (typeof o == "number" || typeof o == "boolean" || o === void 0 || o === null) && (a = String(o)), a;
  }), yI && (t = "\uFF3B" + t.replace(/[aouei]/g, "$&$&") + "\uFF3D"), t;
}
function p(s, e, ...t) {
  return LI(e, t);
}
var Bm;
const Uc = "en";
let of = !1, af = !1, Wd = !1, Ik = !1, cb = !1, hb = !1, qu, Vm = Uc, kI, pr;
const it = typeof self == "object" ? self : typeof global == "object" ? global : {};
let ti;
typeof it.vscode < "u" && typeof it.vscode.process < "u" ? ti = it.vscode.process : typeof process < "u" && (ti = process);
const DI = typeof ((Bm = ti == null ? void 0 : ti.versions) === null || Bm === void 0 ? void 0 : Bm.electron) == "string", EI = DI && (ti == null ? void 0 : ti.type) === "renderer";
if (typeof navigator == "object" && !EI)
  pr = navigator.userAgent, of = pr.indexOf("Windows") >= 0, af = pr.indexOf("Macintosh") >= 0, hb = (pr.indexOf("Macintosh") >= 0 || pr.indexOf("iPad") >= 0 || pr.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, Wd = pr.indexOf("Linux") >= 0, cb = !0, p({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_"), qu = Uc, Vm = qu;
else if (typeof ti == "object") {
  of = ti.platform === "win32", af = ti.platform === "darwin", Wd = ti.platform === "linux", Wd && !!ti.env.SNAP && ti.env.SNAP_REVISION, ti.env.CI || ti.env.BUILD_ARTIFACTSTAGINGDIRECTORY, qu = Uc, Vm = Uc;
  const s = ti.env.VSCODE_NLS_CONFIG;
  if (s)
    try {
      const e = JSON.parse(s), t = e.availableLanguages["*"];
      qu = e.locale, Vm = t || Uc, kI = e._translationsConfigFile;
    } catch {
    }
  Ik = !0;
} else
  console.error("Unable to resolve platform.");
const Vi = of, Ie = af, _i = Wd, sh = Ik, rc = cb, xI = cb && typeof it.importScripts == "function", Ml = hb, ds = pr, II = typeof it.postMessage == "function" && !it.importScripts, Nk = (() => {
  if (II) {
    const s = [];
    it.addEventListener("message", (t) => {
      if (t.data && t.data.vscodeScheduleAsyncWork)
        for (let i = 0, n = s.length; i < n; i++) {
          const r = s[i];
          if (r.id === t.data.vscodeScheduleAsyncWork) {
            s.splice(i, 1), r.callback();
            return;
          }
        }
    });
    let e = 0;
    return (t) => {
      const i = ++e;
      s.push({
        id: i,
        callback: t
      }), it.postMessage({ vscodeScheduleAsyncWork: i }, "*");
    };
  }
  return (s) => setTimeout(s);
})(), dn = af || hb ? 2 : of ? 1 : 3;
let Iv = !0, Nv = !1;
function Tk() {
  if (!Nv) {
    Nv = !0;
    const s = new Uint8Array(2);
    s[0] = 1, s[1] = 2, Iv = new Uint16Array(s.buffer)[0] === (2 << 8) + 1;
  }
  return Iv;
}
const Mk = !!(ds && ds.indexOf("Chrome") >= 0), NI = !!(ds && ds.indexOf("Firefox") >= 0), TI = !!(!Mk && ds && ds.indexOf("Safari") >= 0), MI = !!(ds && ds.indexOf("Edg/") >= 0);
ds && ds.indexOf("Android") >= 0;
var ge;
(function(s) {
  function e(L) {
    return L && typeof L == "object" && typeof L[Symbol.iterator] == "function";
  }
  s.is = e;
  const t = Object.freeze([]);
  function i() {
    return t;
  }
  s.empty = i;
  function* n(L) {
    yield L;
  }
  s.single = n;
  function r(L) {
    return L || t;
  }
  s.from = r;
  function o(L) {
    return !L || L[Symbol.iterator]().next().done === !0;
  }
  s.isEmpty = o;
  function a(L) {
    return L[Symbol.iterator]().next().value;
  }
  s.first = a;
  function l(L, E) {
    for (const k of L)
      if (E(k))
        return !0;
    return !1;
  }
  s.some = l;
  function c(L, E) {
    for (const k of L)
      if (E(k))
        return k;
  }
  s.find = c;
  function* h(L, E) {
    for (const k of L)
      E(k) && (yield k);
  }
  s.filter = h;
  function* u(L, E) {
    let k = 0;
    for (const y of L)
      yield E(y, k++);
  }
  s.map = u;
  function* d(...L) {
    for (const E of L)
      for (const k of E)
        yield k;
  }
  s.concat = d;
  function* f(L) {
    for (const E of L)
      for (const k of E)
        yield k;
  }
  s.concatNested = f;
  function m(L, E, k) {
    let y = k;
    for (const S of L)
      y = E(y, S);
    return y;
  }
  s.reduce = m;
  function _(L, E) {
    let k = 0;
    for (const y of L)
      E(y, k++);
  }
  s.forEach = _;
  function* b(L, E, k = L.length) {
    for (E < 0 && (E += L.length), k < 0 ? k += L.length : k > L.length && (k = L.length); E < k; E++)
      yield L[E];
  }
  s.slice = b;
  function v(L, E = Number.POSITIVE_INFINITY) {
    const k = [];
    if (E === 0)
      return [k, L];
    const y = L[Symbol.iterator]();
    for (let S = 0; S < E; S++) {
      const D = y.next();
      if (D.done)
        return [k, s.empty()];
      k.push(D.value);
    }
    return [k, { [Symbol.iterator]() {
      return y;
    } }];
  }
  s.consume = v;
  function C(L) {
    return v(L)[0];
  }
  s.collect = C;
  function w(L, E, k = (y, S) => y === S) {
    const y = L[Symbol.iterator](), S = E[Symbol.iterator]();
    for (; ; ) {
      const D = y.next(), T = S.next();
      if (D.done !== T.done)
        return !1;
      if (D.done)
        return !0;
      if (!k(D.value, T.value))
        return !1;
    }
  }
  s.equals = w;
})(ge || (ge = {}));
class qe {
  constructor(e) {
    this.element = e, this.next = qe.Undefined, this.prev = qe.Undefined;
  }
}
qe.Undefined = new qe(void 0);
class Ei {
  constructor() {
    this._first = qe.Undefined, this._last = qe.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === qe.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== qe.Undefined; ) {
      const t = e.next;
      e.prev = qe.Undefined, e.next = qe.Undefined, e = t;
    }
    this._first = qe.Undefined, this._last = qe.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, t) {
    const i = new qe(e);
    if (this._first === qe.Undefined)
      this._first = i, this._last = i;
    else if (t) {
      const r = this._last;
      this._last = i, i.prev = r, r.next = i;
    } else {
      const r = this._first;
      this._first = i, i.next = r, r.prev = i;
    }
    this._size += 1;
    let n = !1;
    return () => {
      n || (n = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== qe.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== qe.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== qe.Undefined && e.next !== qe.Undefined) {
      const t = e.prev;
      t.next = e.next, e.next.prev = t;
    } else
      e.prev === qe.Undefined && e.next === qe.Undefined ? (this._first = qe.Undefined, this._last = qe.Undefined) : e.next === qe.Undefined ? (this._last = this._last.prev, this._last.next = qe.Undefined) : e.prev === qe.Undefined && (this._first = this._first.next, this._first.prev = qe.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== qe.Undefined; )
      yield e.element, e = e.next;
  }
}
const Ak = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function AI(s = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const t of Ak)
    s.indexOf(t) >= 0 || (e += "\\" + t);
  return e += "\\s]+)", new RegExp(e, "g");
}
const ub = AI();
function Rk(s) {
  let e = ub;
  if (s && s instanceof RegExp)
    if (s.global)
      e = s;
    else {
      let t = "g";
      s.ignoreCase && (t += "i"), s.multiline && (t += "m"), s.unicode && (t += "u"), e = new RegExp(s.source, t);
    }
  return e.lastIndex = 0, e;
}
const Pk = new Ei();
Pk.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function xh(s, e, t, i, n) {
  if (n || (n = ge.first(Pk)), t.length > n.maxLen) {
    let c = s - n.maxLen / 2;
    return c < 0 ? c = 0 : i += c, t = t.substring(c, s + n.maxLen / 2), xh(s, e, t, i, n);
  }
  const r = Date.now(), o = s - 1 - i;
  let a = -1, l = null;
  for (let c = 1; !(Date.now() - r >= n.timeBudget); c++) {
    const h = o - n.windowSize * c;
    e.lastIndex = Math.max(0, h);
    const u = RI(e, t, o, a);
    if (!u && l || (l = u, h <= 0))
      break;
    a = h;
  }
  if (l) {
    const c = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, c;
  }
  return null;
}
function RI(s, e, t, i) {
  let n;
  for (; n = s.exec(e); ) {
    const r = n.index || 0;
    if (r <= t && s.lastIndex >= t)
      return n;
    if (i > 0 && r > i)
      return null;
  }
  return null;
}
function $i(s, e = 0) {
  return s[s.length - (1 + e)];
}
function PI(s) {
  if (s.length === 0)
    throw new Error("Invalid tail call");
  return [s.slice(0, s.length - 1), s[s.length - 1]];
}
function rs(s, e, t = (i, n) => i === n) {
  if (s === e)
    return !0;
  if (!s || !e || s.length !== e.length)
    return !1;
  for (let i = 0, n = s.length; i < n; i++)
    if (!t(s[i], e[i]))
      return !1;
  return !0;
}
function OI(s, e) {
  const t = s.length - 1;
  e < t && (s[e] = s[t]), s.pop();
}
function FI(s, e, t) {
  return BI(s.length, (i) => t(s[i], e));
}
function BI(s, e) {
  let t = 0, i = s - 1;
  for (; t <= i; ) {
    const n = (t + i) / 2 | 0, r = e(n);
    if (r < 0)
      t = n + 1;
    else if (r > 0)
      i = n - 1;
    else
      return n;
  }
  return -(t + 1);
}
function VI(s) {
  return s.filter((e) => !!e);
}
function WI(s) {
  return !Array.isArray(s) || s.length === 0;
}
function Lg(s) {
  return Array.isArray(s) && s.length > 0;
}
function Xr(s, e = (t) => t) {
  const t = /* @__PURE__ */ new Set();
  return s.filter((i) => {
    const n = e(i);
    return t.has(n) ? !1 : (t.add(n), !0);
  });
}
function a_(s, e) {
  const t = HI(s, e);
  if (t !== -1)
    return s[t];
}
function HI(s, e) {
  for (let t = s.length - 1; t >= 0; t--) {
    const i = s[t];
    if (e(i))
      return t;
  }
  return -1;
}
function Ok(s, e) {
  return s.length > 0 ? s[0] : e;
}
function Jt(s, e) {
  let t = typeof e == "number" ? s : 0;
  typeof e == "number" ? t = s : (t = 0, e = s);
  const i = [];
  if (t <= e)
    for (let n = t; n < e; n++)
      i.push(n);
  else
    for (let n = t; n > e; n--)
      i.push(n);
  return i;
}
function kg(s, e, t) {
  const i = s.slice(0, e), n = s.slice(e);
  return i.concat(t, n);
}
function Wm(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.unshift(e));
}
function Gu(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.push(e));
}
function Tv(s, e) {
  for (const t of e)
    s.push(t);
}
function zI(s, e, t) {
  const i = Fk(s, e), n = s.length, r = t.length;
  s.length = n + r;
  for (let o = n - 1; o >= i; o--)
    s[o + r] = s[o];
  for (let o = 0; o < r; o++)
    s[o + i] = t[o];
}
function Mv(s, e, t, i) {
  const n = Fk(s, e), r = s.splice(n, t);
  return zI(s, n, i), r;
}
function Fk(s, e) {
  return e < 0 ? Math.max(e + s.length, 0) : Math.min(e, s.length);
}
var Av;
(function(s) {
  function e(n) {
    return n < 0;
  }
  s.isLessThan = e;
  function t(n) {
    return n > 0;
  }
  s.isGreaterThan = t;
  function i(n) {
    return n === 0;
  }
  s.isNeitherLessOrGreaterThan = i, s.greaterThan = 1, s.lessThan = -1, s.neitherLessOrGreaterThan = 0;
})(Av || (Av = {}));
function Hd(s, e) {
  return (t, i) => e(s(t), s(i));
}
function UI(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) > 0 && (t = n);
  }
  return t;
}
function Bk(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) >= 0 && (t = n);
  }
  return t;
}
function $I(s, e) {
  return UI(s, (t, i) => -e(t, i));
}
class Ih {
  constructor(e) {
    this.items = e, this.firstIdx = 0, this.lastIdx = this.items.length - 1;
  }
  get length() {
    return this.lastIdx - this.firstIdx + 1;
  }
  takeWhile(e) {
    let t = this.firstIdx;
    for (; t < this.items.length && e(this.items[t]); )
      t++;
    const i = t === this.firstIdx ? null : this.items.slice(this.firstIdx, t);
    return this.firstIdx = t, i;
  }
  takeFromEndWhile(e) {
    let t = this.lastIdx;
    for (; t >= 0 && e(this.items[t]); )
      t--;
    const i = t === this.lastIdx ? null : this.items.slice(t + 1, this.lastIdx + 1);
    return this.lastIdx = t, i;
  }
  peek() {
    if (this.length !== 0)
      return this.items[this.firstIdx];
  }
  dequeue() {
    const e = this.items[this.firstIdx];
    return this.firstIdx++, e;
  }
  takeCount(e) {
    const t = this.items.slice(this.firstIdx, this.firstIdx + e);
    return this.firstIdx += e, t;
  }
}
function jI(s) {
  return Array.isArray(s);
}
function Fi(s) {
  return typeof s == "string";
}
function Pi(s) {
  return typeof s == "object" && s !== null && !Array.isArray(s) && !(s instanceof RegExp) && !(s instanceof Date);
}
function KI(s) {
  const e = Object.getPrototypeOf(Uint8Array);
  return typeof s == "object" && s instanceof e;
}
function oc(s) {
  return typeof s == "number" && !isNaN(s);
}
function Rv(s) {
  return !!s && typeof s[Symbol.iterator] == "function";
}
function Vk(s) {
  return s === !0 || s === !1;
}
function Rn(s) {
  return typeof s > "u";
}
function qI(s) {
  return !Ki(s);
}
function Ki(s) {
  return Rn(s) || s === null;
}
function Pn(s, e) {
  if (!s)
    throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
}
function lf(s) {
  return typeof s == "function";
}
function GI(s, e) {
  const t = Math.min(s.length, e.length);
  for (let i = 0; i < t; i++)
    ZI(s[i], e[i]);
}
function ZI(s, e) {
  if (Fi(e)) {
    if (typeof s !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (lf(e)) {
    try {
      if (s instanceof e)
        return;
    } catch {
    }
    if (!Ki(s) && s.constructor === e || e.length === 1 && e.call(void 0, s) === !0)
      return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
function YI(s) {
  let e = [], t = Object.getPrototypeOf(s);
  for (; Object.prototype !== t; )
    e = e.concat(Object.getOwnPropertyNames(t)), t = Object.getPrototypeOf(t);
  return e;
}
function db(s) {
  const e = [];
  for (const t of YI(s))
    typeof s[t] == "function" && e.push(t);
  return e;
}
function QI(s, e) {
  const t = (n) => function() {
    const r = Array.prototype.slice.call(arguments, 0);
    return e(n, r);
  }, i = {};
  for (const n of s)
    i[n] = t(n);
  return i;
}
function Er(s) {
  return s === null ? void 0 : s;
}
function fb(s, e = "Unreachable") {
  throw new Error(e);
}
function Sr(s) {
  if (!s || typeof s != "object" || s instanceof RegExp)
    return s;
  const e = Array.isArray(s) ? [] : {};
  return Object.keys(s).forEach((t) => {
    s[t] && typeof s[t] == "object" ? e[t] = Sr(s[t]) : e[t] = s[t];
  }), e;
}
function XI(s) {
  if (!s || typeof s != "object")
    return s;
  const e = [s];
  for (; e.length > 0; ) {
    const t = e.shift();
    Object.freeze(t);
    for (const i in t)
      if (Wk.call(t, i)) {
        const n = t[i];
        typeof n == "object" && !Object.isFrozen(n) && !KI(n) && e.push(n);
      }
  }
  return s;
}
const Wk = Object.prototype.hasOwnProperty;
function JI(s, e) {
  return l_(s, e, /* @__PURE__ */ new Set());
}
function l_(s, e, t) {
  if (Ki(s))
    return s;
  const i = e(s);
  if (typeof i < "u")
    return i;
  if (jI(s)) {
    const n = [];
    for (const r of s)
      n.push(l_(r, e, t));
    return n;
  }
  if (Pi(s)) {
    if (t.has(s))
      throw new Error("Cannot clone recursive data-structure");
    t.add(s);
    const n = {};
    for (const r in s)
      Wk.call(s, r) && (n[r] = l_(s[r], e, t));
    return t.delete(s), n;
  }
  return s;
}
function sa(s, e, t = !0) {
  return Pi(s) ? (Pi(e) && Object.keys(e).forEach((i) => {
    i in s ? t && (Pi(s[i]) && Pi(e[i]) ? sa(s[i], e[i], t) : s[i] = e[i]) : s[i] = e[i];
  }), s) : e;
}
function en(s, e) {
  if (s === e)
    return !0;
  if (s == null || e === null || e === void 0 || typeof s != typeof e || typeof s != "object" || Array.isArray(s) !== Array.isArray(e))
    return !1;
  let t, i;
  if (Array.isArray(s)) {
    if (s.length !== e.length)
      return !1;
    for (t = 0; t < s.length; t++)
      if (!en(s[t], e[t]))
        return !1;
  } else {
    const n = [];
    for (i in s)
      n.push(i);
    n.sort();
    const r = [];
    for (i in e)
      r.push(i);
    if (r.sort(), !en(n, r))
      return !1;
    for (t = 0; t < n.length; t++)
      if (!en(s[n[t]], e[n[t]]))
        return !1;
  }
  return !0;
}
const zt = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0,
  bracketPairColorizationOptions: {
    enabled: !0,
    independentColorPoolPerBracketType: !1
  }
}, _r = 8;
class Hk {
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class zk {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class ut {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return Dg(e, t);
  }
  compute(e, t, i) {
    return i;
  }
}
class rh {
  constructor(e, t) {
    this.newValue = e, this.didChange = t;
  }
}
function Dg(s, e) {
  if (typeof s != "object" || typeof e != "object" || !s || !e)
    return new rh(e, s !== e);
  if (Array.isArray(s) || Array.isArray(e)) {
    const i = Array.isArray(s) && Array.isArray(e) && rs(s, e);
    return new rh(e, !i);
  }
  let t = !1;
  for (const i in e)
    if (e.hasOwnProperty(i)) {
      const n = Dg(s[i], e[i]);
      n.didChange && (s[i] = n.newValue, t = !0);
    }
  return new rh(s, t);
}
class ac {
  constructor(e) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
  }
  applyUpdate(e, t) {
    return Dg(e, t);
  }
  validate(e) {
    return this.defaultValue;
  }
}
class ra {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return Dg(e, t);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function G(s, e) {
  return typeof s > "u" ? e : s === "false" ? !1 : Boolean(s);
}
class de extends ra {
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return G(e, this.defaultValue);
  }
}
function c_(s, e, t, i) {
  if (typeof s > "u")
    return e;
  let n = parseInt(s, 10);
  return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
}
class Re extends ra {
  constructor(e, t, i, n, r, o = void 0) {
    typeof o < "u" && (o.type = "integer", o.default = i, o.minimum = n, o.maximum = r), super(e, t, i, o), this.minimum = n, this.maximum = r;
  }
  static clampedInt(e, t, i, n) {
    return c_(e, t, i, n);
  }
  validate(e) {
    return Re.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
class ts extends ra {
  constructor(e, t, i, n, r) {
    typeof r < "u" && (r.type = "number", r.default = i), super(e, t, i, r), this.validationFn = n;
  }
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  validate(e) {
    return this.validationFn(ts.float(e, this.defaultValue));
  }
}
class yi extends ra {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return yi.string(e, this.defaultValue);
  }
}
function Rt(s, e, t) {
  return typeof s != "string" || t.indexOf(s) === -1 ? e : s;
}
class ft extends ra {
  constructor(e, t, i, n, r = void 0) {
    typeof r < "u" && (r.type = "string", r.enum = n, r.default = i), super(e, t, i, r), this._allowedValues = n;
  }
  validate(e) {
    return Rt(e, this.defaultValue, this._allowedValues);
  }
}
class Dc extends ut {
  constructor(e, t, i, n, r, o, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = r, a.default = n), super(e, t, i, a), this._allowedValues = r, this._convert = o;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function eN(s) {
  switch (s) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class tN extends ut {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        p("accessibilitySupport.auto", "The editor will use platform APIs to detect when a Screen Reader is attached."),
        p("accessibilitySupport.on", "The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled."),
        p("accessibilitySupport.off", "The editor will never be optimized for usage with a Screen Reader.")
      ],
      default: "auto",
      description: p("accessibilitySupport", "Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class iN extends ut {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(19, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: p("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: p("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: G(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: G(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function nN(s) {
  switch (s) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var Et;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(Et || (Et = {}));
function sN(s) {
  switch (s) {
    case "line":
      return Et.Line;
    case "block":
      return Et.Block;
    case "underline":
      return Et.Underline;
    case "line-thin":
      return Et.LineThin;
    case "block-outline":
      return Et.BlockOutline;
    case "underline-thin":
      return Et.UnderlineThin;
  }
}
class rN extends ac {
  constructor() {
    super(130);
  }
  compute(e, t, i) {
    const n = ["monaco-editor"];
    return t.get(35) && n.push(t.get(35)), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(68) === "default" ? n.push("mouse-default") : t.get(68) === "copy" && n.push("mouse-copy"), t.get(102) && n.push("showUnused"), t.get(128) && n.push("showDeprecated"), n.join(" ");
  }
}
class oN extends de {
  constructor() {
    super(33, "emptySelectionClipboard", !0, { description: p("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class aN extends ut {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(37, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: p("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: e.seedSearchStringFromSelection,
        enumDescriptions: [
          p("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
          p("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
          p("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
        ],
        description: p("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          p("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
          p("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
          p("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
        ],
        description: p("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: p("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: Ie
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: p("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: p("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: G(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : Rt(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : Rt(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: G(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: G(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: G(t.loop, this.defaultValue.loop)
    };
  }
}
class qi extends ut {
  constructor() {
    super(47, "fontLigatures", qi.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: p("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: p("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: p("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? qi.OFF : e === "true" ? qi.ON : e : Boolean(e) ? qi.ON : qi.OFF;
  }
}
qi.OFF = '"liga" off, "calt" off';
qi.ON = '"liga" on, "calt" on';
class lN extends ac {
  constructor() {
    super(46);
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class cN extends ra {
  constructor() {
    super(48, "fontSize", tn.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: tn.fontSize,
      description: p("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    const t = ts.float(e, this.defaultValue);
    return t === 0 ? tn.fontSize : ts.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
class Xn extends ut {
  constructor() {
    super(49, "fontWeight", tn.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: Xn.MINIMUM_VALUE,
          maximum: Xn.MAXIMUM_VALUE,
          errorMessage: p("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: Xn.SUGGESTION_VALUES
        }
      ],
      default: tn.fontWeight,
      description: p("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(Re.clampedInt(e, tn.fontWeight, Xn.MINIMUM_VALUE, Xn.MAXIMUM_VALUE));
  }
}
Xn.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
Xn.MINIMUM_VALUE = 1;
Xn.MAXIMUM_VALUE = 1e3;
class hN extends ut {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        p("editor.gotoLocation.multiple.peek", "Show peek view of the results (default)"),
        p("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a peek view"),
        p("editor.gotoLocation.multiple.goto", "Go to the primary result and enable peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(53, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: p("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": Object.assign({ description: p("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleTypeDefinitions": Object.assign({ description: p("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleDeclarations": Object.assign({ description: p("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleImplementations": Object.assign({ description: p("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleReferences": Object.assign({ description: p("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: p("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: p("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: p("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: p("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: p("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    var t, i, n, r, o;
    if (!e || typeof e != "object")
      return this.defaultValue;
    const a = e;
    return {
      multiple: Rt(a.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: (t = a.multipleDefinitions) !== null && t !== void 0 ? t : Rt(a.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: (i = a.multipleTypeDefinitions) !== null && i !== void 0 ? i : Rt(a.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: (n = a.multipleDeclarations) !== null && n !== void 0 ? n : Rt(a.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: (r = a.multipleImplementations) !== null && r !== void 0 ? r : Rt(a.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: (o = a.multipleReferences) !== null && o !== void 0 ? o : Rt(a.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: yi.string(a.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: yi.string(a.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: yi.string(a.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: yi.string(a.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: yi.string(a.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
    };
  }
}
class uN extends ut {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      sticky: !0,
      above: !0
    };
    super(55, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        minimum: 0,
        maximum: 1e4,
        description: p("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: p("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      },
      "editor.hover.above": {
        type: "boolean",
        default: e.above,
        description: p("hover.above", "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: G(t.enabled, this.defaultValue.enabled),
      delay: Re.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: G(t.sticky, this.defaultValue.sticky),
      above: G(t.above, this.defaultValue.above)
    };
  }
}
class hl extends ac {
  constructor() {
    super(133);
  }
  compute(e, t, i) {
    return hl.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = e.scrollBeyondLastLine ? t - 1 : 0, n = (e.viewLineCount + i) / (e.pixelRatio * e.height), r = Math.floor(e.viewLineCount / n);
    return { typicalViewportLineCount: t, extraLinesBeyondLastLine: i, desiredRatio: n, minimapLineCount: r };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, n = e.outerHeight, r = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(r * n),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: n
      };
    const o = t.stableMinimapLayoutInput, a = o && e.outerHeight === o.outerHeight && e.lineHeight === o.lineHeight && e.typicalHalfwidthCharacterWidth === o.typicalHalfwidthCharacterWidth && e.pixelRatio === o.pixelRatio && e.scrollBeyondLastLine === o.scrollBeyondLastLine && e.minimap.enabled === o.minimap.enabled && e.minimap.side === o.minimap.side && e.minimap.size === o.minimap.size && e.minimap.showSlider === o.minimap.showSlider && e.minimap.renderCharacters === o.minimap.renderCharacters && e.minimap.maxColumn === o.minimap.maxColumn && e.minimap.scale === o.minimap.scale && e.verticalScrollbarWidth === o.verticalScrollbarWidth && e.isViewportWrapping === o.isViewportWrapping, l = e.lineHeight, c = e.typicalHalfwidthCharacterWidth, h = e.scrollBeyondLastLine, u = e.minimap.renderCharacters;
    let d = r >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const f = e.minimap.maxColumn, m = e.minimap.size, _ = e.minimap.side, b = e.verticalScrollbarWidth, v = e.viewLineCount, C = e.remainingWidth, w = e.isViewportWrapping, L = u ? 2 : 3;
    let E = Math.floor(r * n);
    const k = E / r;
    let y = !1, S = !1, D = L * d, T = d / r, M = 1;
    if (m === "fill" || m === "fit") {
      const { typicalViewportLineCount: ne, extraLinesBeyondLastLine: ue, desiredRatio: He, minimapLineCount: Ue } = hl.computeContainedMinimapLineCount({
        viewLineCount: v,
        scrollBeyondLastLine: h,
        height: n,
        lineHeight: l,
        pixelRatio: r
      });
      if (v / Ue > 1)
        y = !0, S = !0, d = 1, D = 1, T = d / r;
      else {
        let bi = !1, Be = d + 1;
        if (m === "fit") {
          const qt = Math.ceil((v + ue) * D);
          w && a && C <= t.stableFitRemainingWidth ? (bi = !0, Be = t.stableFitMaxMinimapScale) : bi = qt > E;
        }
        if (m === "fill" || bi) {
          y = !0;
          const qt = d;
          D = Math.min(l * r, Math.max(1, Math.floor(1 / He))), w && a && C <= t.stableFitRemainingWidth && (Be = t.stableFitMaxMinimapScale), d = Math.min(Be, Math.max(1, Math.floor(D / L))), d > qt && (M = Math.min(2, d / qt)), T = d / r / M, E = Math.ceil(Math.max(ne, v + ue) * D), w ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = C, t.stableFitMaxMinimapScale = d) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
        }
      }
    }
    const P = Math.floor(f * T), V = Math.min(P, Math.max(0, Math.floor((C - b - 2) * T / (c + T))) + _r);
    let U = Math.floor(r * V);
    const K = U / r;
    U = Math.floor(U * M);
    const J = u ? 1 : 2, ee = _ === "left" ? 0 : i - V - b;
    return {
      renderMinimap: J,
      minimapLeft: ee,
      minimapWidth: V,
      minimapHeightIsEditorHeight: y,
      minimapIsSampling: S,
      minimapScale: d,
      minimapLineHeight: D,
      minimapCanvasInnerWidth: U,
      minimapCanvasInnerHeight: E,
      minimapCanvasOuterWidth: K,
      minimapCanvasOuterHeight: k
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, n = t.outerHeight | 0, r = t.lineHeight | 0, o = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, c = t.pixelRatio, h = t.viewLineCount, u = e.get(125), d = u === "inherit" ? e.get(124) : u, f = d === "inherit" ? e.get(120) : d, m = e.get(123), _ = e.get(2), b = t.isDominatedByLongLines, v = e.get(52), C = e.get(62).renderType !== 0, w = e.get(63), L = e.get(96), E = e.get(67), k = e.get(94), y = k.verticalScrollbarSize, S = k.verticalHasArrows, D = k.arrowSize, T = k.horizontalScrollbarSize, M = e.get(60), P = e.get(39), V = e.get(101) !== "never";
    let U;
    if (typeof M == "string" && /^\d+(\.\d+)?ch$/.test(M)) {
      const fo = parseFloat(M.substr(0, M.length - 2));
      U = Re.clampedInt(fo * a, 0, 0, 1e3);
    } else
      U = Re.clampedInt(M, 0, 0, 1e3);
    P && V && (U += 16);
    let K = 0;
    if (C) {
      const fo = Math.max(o, w);
      K = Math.round(fo * l);
    }
    let J = 0;
    v && (J = r);
    let ee = 0, ne = ee + J, ue = ne + K, He = ue + U;
    const Ue = i - J - K - U;
    let rt = !1, bi = !1, Be = -1;
    _ !== 2 && (d === "inherit" && b ? (rt = !0, bi = !0) : f === "on" || f === "bounded" ? bi = !0 : f === "wordWrapColumn" && (Be = m));
    const qt = hl._computeMinimapLayout({
      outerWidth: i,
      outerHeight: n,
      lineHeight: r,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: c,
      scrollBeyondLastLine: L,
      minimap: E,
      verticalScrollbarWidth: y,
      viewLineCount: h,
      remainingWidth: Ue,
      isViewportWrapping: bi
    }, t.memory || new zk());
    qt.renderMinimap !== 0 && qt.minimapLeft === 0 && (ee += qt.minimapWidth, ne += qt.minimapWidth, ue += qt.minimapWidth, He += qt.minimapWidth);
    const lr = Ue - qt.minimapWidth, _a = Math.max(1, Math.floor((lr - y - 2) / a)), Sc = S ? D : 0;
    return bi && (Be = Math.max(1, _a), f === "bounded" && (Be = Math.min(Be, m))), {
      width: i,
      height: n,
      glyphMarginLeft: ee,
      glyphMarginWidth: J,
      lineNumbersLeft: ne,
      lineNumbersWidth: K,
      decorationsLeft: ue,
      decorationsWidth: U,
      contentLeft: He,
      contentWidth: lr,
      minimap: qt,
      viewportColumn: _a,
      isWordWrapMinified: rt,
      isViewportWrapping: bi,
      wrappingColumn: Be,
      verticalScrollbarWidth: y,
      horizontalScrollbarHeight: T,
      overviewRuler: {
        top: Sc,
        width: y,
        height: n - 2 * Sc,
        right: 0
      }
    };
  }
}
class dN extends ut {
  constructor() {
    const e = { enabled: !0 };
    super(59, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("codeActions", "Enables the code action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: G(e.enabled, this.defaultValue.enabled)
    };
  }
}
class fN extends ut {
  constructor() {
    const e = { stickyScroll: { enabled: !1 } };
    super(34, "experimental", e, {
      "editor.experimental.stickyScroll.enabled": {
        type: "boolean",
        default: e.stickyScroll.enabled,
        description: p("editor.experimental.stickyScroll", "Shows the nested current scopes during the scroll at the top of the editor.")
      }
    });
  }
  validate(e) {
    var t;
    return !e || typeof e != "object" ? this.defaultValue : {
      stickyScroll: {
        enabled: G((t = e.stickyScroll) === null || t === void 0 ? void 0 : t.enabled, this.defaultValue.stickyScroll.enabled)
      }
    };
  }
}
class gN extends ut {
  constructor() {
    const e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1 };
    super(129, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: e.enabled,
        description: p("inlayHints.enable", "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          p("editor.inlayHints.on", "Inlay hints are enabled"),
          p("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding `Ctrl+Alt`"),
          p("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding `Ctrl+Alt`"),
          p("editor.inlayHints.off", "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        markdownDescription: p("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        markdownDescription: p("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: e.padding,
        description: p("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"), {
      enabled: Rt(t.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: Re.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: yi.string(t.fontFamily, this.defaultValue.fontFamily),
      padding: G(t.padding, this.defaultValue.padding)
    };
  }
}
class mN extends ts {
  constructor() {
    super(61, "lineHeight", tn.lineHeight, (e) => ts.clamp(e, 0, 150), { markdownDescription: p("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`) });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class pN extends ut {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: !1,
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1
    };
    super(67, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "boolean",
        default: e.autohide,
        description: p("minimap.autohide", "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          p("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          p("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          p("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: p("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: p("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: p("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: p("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: p("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: p("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: G(t.enabled, this.defaultValue.enabled),
      autohide: G(t.autohide, this.defaultValue.autohide),
      size: Rt(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: Rt(t.side, this.defaultValue.side, ["right", "left"]),
      showSlider: Rt(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: G(t.renderCharacters, this.defaultValue.renderCharacters),
      scale: Re.clampedInt(t.scale, 1, 1, 3),
      maxColumn: Re.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
    };
  }
}
function _N(s) {
  return s === "ctrlCmd" ? Ie ? "metaKey" : "ctrlKey" : "altKey";
}
class bN extends ut {
  constructor() {
    super(77, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: p("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: p("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: Re.clampedInt(t.top, 0, 0, 1e3),
      bottom: Re.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class CN extends ut {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !1
    };
    super(78, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: p("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: G(t.enabled, this.defaultValue.enabled),
      cycle: G(t.cycle, this.defaultValue.cycle)
    };
  }
}
class vN extends ac {
  constructor() {
    super(131);
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class wN extends ut {
  constructor() {
    const e = {
      other: "on",
      comments: "off",
      strings: "off"
    }, t = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [p("on", "Quick suggestions show inside the suggest widget"), p("inline", "Quick suggestions show as ghost text"), p("off", "Quick suggestions are disabled")]
      }
    ];
    super(81, "quickSuggestions", e, {
      type: "object",
      additionalProperties: !1,
      properties: {
        strings: {
          anyOf: t,
          default: e.strings,
          description: p("quickSuggestions.strings", "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: t,
          default: e.comments,
          description: p("quickSuggestions.comments", "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: t,
          default: e.other,
          description: p("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: e,
      markdownDescription: p("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", "#editor.suggestOnTriggerCharacters#")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean") {
      const c = e ? "on" : "off";
      return { comments: c, strings: c, other: c };
    }
    if (!e || typeof e != "object")
      return this.defaultValue;
    const { other: t, comments: i, strings: n } = e, r = ["on", "inline", "off"];
    let o, a, l;
    return typeof t == "boolean" ? o = t ? "on" : "off" : o = Rt(t, this.defaultValue.other, r), typeof i == "boolean" ? a = i ? "on" : "off" : a = Rt(i, this.defaultValue.comments, r), typeof n == "boolean" ? l = n ? "on" : "off" : l = Rt(n, this.defaultValue.strings, r), {
      other: o,
      comments: a,
      strings: l
    };
  }
}
class SN extends ut {
  constructor() {
    super(62, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        p("lineNumbers.off", "Line numbers are not rendered."),
        p("lineNumbers.on", "Line numbers are rendered as absolute number."),
        p("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        p("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: p("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function cf(s) {
  const e = s.get(89);
  return e === "editable" ? s.get(83) : e !== "on";
}
class yN extends ut {
  constructor() {
    const e = [], t = { type: "number", description: p("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(93, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: p("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: p("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "number")
          t.push({
            column: Re.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const n = i;
          t.push({
            column: Re.clampedInt(n.column, 0, 0, 1e4),
            color: n.color
          });
        }
      return t.sort((i, n) => i.column - n.column), t;
    }
    return this.defaultValue;
  }
}
function Pv(s, e) {
  if (typeof s != "string")
    return e;
  switch (s) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
class LN extends ut {
  constructor() {
    const e = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1
    };
    super(94, "scrollbar", e, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          p("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
          p("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
          p("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: p("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          p("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
          p("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
          p("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: p("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: e.verticalScrollbarSize,
        description: p("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: e.horizontalScrollbarSize,
        description: p("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: e.scrollByPage,
        description: p("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = Re.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = Re.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: Re.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: Pv(t.vertical, this.defaultValue.vertical),
      horizontal: Pv(t.horizontal, this.defaultValue.horizontal),
      useShadows: G(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: G(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: G(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: G(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: G(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: Re.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: n,
      verticalSliderSize: Re.clampedInt(t.verticalSliderSize, n, 0, 1e3),
      scrollByPage: G(t.scrollByPage, this.defaultValue.scrollByPage)
    };
  }
}
const vn = "inUntrustedWorkspace", go = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
class kN extends ut {
  constructor() {
    const e = {
      nonBasicASCII: vn,
      invisibleCharacters: !0,
      ambiguousCharacters: !0,
      includeComments: vn,
      includeStrings: !0,
      allowedCharacters: {},
      allowedLocales: { _os: !0, _vscode: !0 }
    };
    super(115, "unicodeHighlight", e, {
      [go.nonBasicASCII]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, vn],
        default: e.nonBasicASCII,
        description: p("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
      },
      [go.invisibleCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.invisibleCharacters,
        description: p("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
      },
      [go.ambiguousCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.ambiguousCharacters,
        description: p("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
      },
      [go.includeComments]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, vn],
        default: e.includeComments,
        description: p("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to unicode highlighting.")
      },
      [go.includeStrings]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, vn],
        default: e.includeStrings,
        description: p("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to unicode highlighting.")
      },
      [go.allowedCharacters]: {
        restricted: !0,
        type: "object",
        default: e.allowedCharacters,
        description: p("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [go.allowedLocales]: {
        restricted: !0,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: e.allowedLocales,
        description: p("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
      }
    });
  }
  applyUpdate(e, t) {
    let i = !1;
    t.allowedCharacters && e && (en(e.allowedCharacters, t.allowedCharacters) || (e = Object.assign(Object.assign({}, e), { allowedCharacters: t.allowedCharacters }), i = !0)), t.allowedLocales && e && (en(e.allowedLocales, t.allowedLocales) || (e = Object.assign(Object.assign({}, e), { allowedLocales: t.allowedLocales }), i = !0));
    const n = super.applyUpdate(e, t);
    return i ? new rh(n.newValue, !0) : n;
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      nonBasicASCII: ul(t.nonBasicASCII, vn, [!0, !1, vn]),
      invisibleCharacters: G(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: G(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: ul(t.includeComments, vn, [!0, !1, vn]),
      includeStrings: ul(t.includeStrings, vn, [!0, !1, vn]),
      allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(e, t) {
    if (typeof e != "object" || !e)
      return t;
    const i = {};
    for (const [n, r] of Object.entries(e))
      r === !0 && (i[n] = !0);
    return i;
  }
}
class DN extends ut {
  constructor() {
    const e = {
      enabled: !0,
      mode: "subwordSmart"
    };
    super(57, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: G(t.enabled, this.defaultValue.enabled),
      mode: Rt(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"])
    };
  }
}
class EN extends ut {
  constructor() {
    const e = {
      enabled: zt.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: zt.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(12, "bracketPairColorization", e, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: e.independentColorPoolPerBracketType,
        description: p("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: G(t.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: G(t.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
}
class xN extends ut {
  constructor() {
    const e = {
      bracketPairs: !1,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: !0,
      indentation: !0,
      highlightActiveIndentation: !0
    };
    super(13, "guides", e, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          p("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
          p("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
          p("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
        ],
        default: e.bracketPairs,
        description: p("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          p("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
          p("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
          p("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
        ],
        default: e.bracketPairsHorizontal,
        description: p("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: e.highlightActiveBracketPair,
        description: p("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: e.indentation,
        description: p("editor.guides.indentation", "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [!0, "always", !1],
        enumDescriptions: [
          p("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
          p("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
          p("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
        ],
        default: e.highlightActiveIndentation,
        description: p("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      bracketPairs: ul(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
      bracketPairsHorizontal: ul(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
      highlightActiveBracketPair: G(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: G(t.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: ul(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [!0, !1, "always"])
    };
  }
}
function ul(s, e, t) {
  const i = t.indexOf(s);
  return i === -1 ? e : t[i];
}
class IN extends ut {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !0,
      localityBonus: !1,
      shareSuggestSelections: !1,
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      previewMode: "subwordSmart",
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(108, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          p("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          p("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: p("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: p("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: p("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: p("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: p("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: p("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: p("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: p("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: p("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: p("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: p("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: Rt(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: G(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: G(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: G(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: G(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      showIcons: G(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: G(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: G(t.preview, this.defaultValue.preview),
      previewMode: Rt(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: G(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: G(t.showMethods, this.defaultValue.showMethods),
      showFunctions: G(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: G(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: G(t.showDeprecated, this.defaultValue.showDeprecated),
      showFields: G(t.showFields, this.defaultValue.showFields),
      showVariables: G(t.showVariables, this.defaultValue.showVariables),
      showClasses: G(t.showClasses, this.defaultValue.showClasses),
      showStructs: G(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: G(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: G(t.showModules, this.defaultValue.showModules),
      showProperties: G(t.showProperties, this.defaultValue.showProperties),
      showEvents: G(t.showEvents, this.defaultValue.showEvents),
      showOperators: G(t.showOperators, this.defaultValue.showOperators),
      showUnits: G(t.showUnits, this.defaultValue.showUnits),
      showValues: G(t.showValues, this.defaultValue.showValues),
      showConstants: G(t.showConstants, this.defaultValue.showConstants),
      showEnums: G(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: G(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: G(t.showKeywords, this.defaultValue.showKeywords),
      showWords: G(t.showWords, this.defaultValue.showWords),
      showColors: G(t.showColors, this.defaultValue.showColors),
      showFiles: G(t.showFiles, this.defaultValue.showFiles),
      showReferences: G(t.showReferences, this.defaultValue.showReferences),
      showFolders: G(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: G(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: G(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: G(t.showUsers, this.defaultValue.showUsers),
      showIssues: G(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class NN extends ut {
  constructor() {
    super(104, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: p("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: G(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace)
    };
  }
}
class TN extends ac {
  constructor() {
    super(132);
  }
  compute(e, t, i) {
    return t.get(83) ? !0 : e.tabFocusMode;
  }
}
function MN(s) {
  switch (s) {
    case "none":
      return 0;
    case "same":
      return 1;
    case "indent":
      return 2;
    case "deepIndent":
      return 3;
  }
}
class AN extends ac {
  constructor() {
    super(134);
  }
  compute(e, t, i) {
    const n = t.get(133);
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: n.isWordWrapMinified,
      isViewportWrapping: n.isViewportWrapping,
      wrappingColumn: n.wrappingColumn
    };
  }
}
class RN extends ut {
  constructor() {
    const e = { enabled: !0 };
    super(32, "dropIntoEditor", e, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down `shift` (instead of opening the file in an editor).")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: G(e.enabled, this.defaultValue.enabled)
    };
  }
}
const PN = "Consolas, 'Courier New', monospace", ON = "Menlo, Monaco, 'Courier New', monospace", FN = "'Droid Sans Mono', 'monospace', monospace", tn = {
  fontFamily: Ie ? ON : _i ? FN : PN,
  fontWeight: "normal",
  fontSize: Ie ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, $a = [];
function W(s) {
  return $a[s.id] = s, s;
}
const oa = {
  acceptSuggestionOnCommitCharacter: W(new de(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: p("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`; `) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: W(new ft(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      p("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: p("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: W(new tN()),
  accessibilityPageSize: W(new Re(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: p("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.")
  })),
  ariaLabel: W(new yi(4, "ariaLabel", p("editorViewAccessibleLabel", "Editor content"))),
  autoClosingBrackets: W(new ft(5, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      p("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingDelete: W(new ft(6, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: p("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: W(new ft(7, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: p("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: W(new ft(8, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      p("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: W(new Dc(9, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], eN, {
    enumDescriptions: [
      p("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      p("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      p("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      p("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      p("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: p("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: W(new de(10, "automaticLayout", !1)),
  autoSurround: W(new ft(11, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      p("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      p("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      p("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: p("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  bracketPairColorization: W(new EN()),
  bracketPairGuides: W(new xN()),
  stickyTabStops: W(new de(106, "stickyTabStops", !1, { description: p("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: W(new de(14, "codeLens", !0, { description: p("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: W(new yi(15, "codeLensFontFamily", "", { description: p("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: W(new Re(16, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: p("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to `0`, 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: W(new de(17, "colorDecorators", !0, { description: p("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  columnSelection: W(new de(18, "columnSelection", !1, { description: p("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: W(new iN()),
  contextmenu: W(new de(20, "contextmenu", !0)),
  copyWithSyntaxHighlighting: W(new de(21, "copyWithSyntaxHighlighting", !0, { description: p("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: W(new Dc(22, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], nN, { description: p("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: W(new de(23, "cursorSmoothCaretAnimation", !1, { description: p("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.") })),
  cursorStyle: W(new Dc(24, "cursorStyle", Et.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], sN, { description: p("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: W(new Re(25, "cursorSurroundingLines", 0, 0, 1073741824, { description: p("cursorSurroundingLines", "Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: W(new ft(26, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      p("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      p("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    description: p("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
  })),
  cursorWidth: W(new Re(27, "cursorWidth", 0, 0, 1073741824, { markdownDescription: p("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: W(new de(28, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: W(new de(29, "disableMonospaceOptimizations", !1)),
  domReadOnly: W(new de(30, "domReadOnly", !1)),
  dragAndDrop: W(new de(31, "dragAndDrop", !0, { description: p("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: W(new oN()),
  dropIntoEditor: W(new RN()),
  experimental: W(new fN()),
  extraEditorClassName: W(new yi(35, "extraEditorClassName", "")),
  fastScrollSensitivity: W(new ts(36, "fastScrollSensitivity", 5, (s) => s <= 0 ? 5 : s, { markdownDescription: p("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: W(new aN()),
  fixedOverflowWidgets: W(new de(38, "fixedOverflowWidgets", !1)),
  folding: W(new de(39, "folding", !0, { description: p("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: W(new ft(40, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      p("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      p("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: p("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: W(new de(41, "foldingHighlight", !0, { description: p("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  foldingImportsByDefault: W(new de(42, "foldingImportsByDefault", !1, { description: p("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
  foldingMaximumRegions: W(new Re(
    43,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    { description: p("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
  )),
  unfoldOnClickAfterEndOfLine: W(new de(44, "unfoldOnClickAfterEndOfLine", !1, { description: p("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: W(new yi(45, "fontFamily", tn.fontFamily, { description: p("fontFamily", "Controls the font family.") })),
  fontInfo: W(new lN()),
  fontLigatures2: W(new qi()),
  fontSize: W(new cN()),
  fontWeight: W(new Xn()),
  formatOnPaste: W(new de(50, "formatOnPaste", !1, { description: p("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: W(new de(51, "formatOnType", !1, { description: p("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: W(new de(52, "glyphMargin", !0, { description: p("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: W(new hN()),
  hideCursorInOverviewRuler: W(new de(54, "hideCursorInOverviewRuler", !1, { description: p("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  hover: W(new uN()),
  inDiffEditor: W(new de(56, "inDiffEditor", !1)),
  letterSpacing: W(new ts(58, "letterSpacing", tn.letterSpacing, (s) => ts.clamp(s, -5, 20), { description: p("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: W(new dN()),
  lineDecorationsWidth: W(new ra(60, "lineDecorationsWidth", 10)),
  lineHeight: W(new mN()),
  lineNumbers: W(new SN()),
  lineNumbersMinChars: W(new Re(63, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: W(new de(64, "linkedEditing", !1, { description: p("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing.") })),
  links: W(new de(65, "links", !0, { description: p("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: W(new ft(66, "matchBrackets", "always", ["always", "near", "never"], { description: p("matchBrackets", "Highlight matching brackets.") })),
  minimap: W(new pN()),
  mouseStyle: W(new ft(68, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: W(new ts(69, "mouseWheelScrollSensitivity", 1, (s) => s === 0 ? 1 : s, { markdownDescription: p("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: W(new de(70, "mouseWheelZoom", !1, { markdownDescription: p("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
  multiCursorMergeOverlapping: W(new de(71, "multiCursorMergeOverlapping", !0, { description: p("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: W(new Dc(72, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], _N, {
    markdownEnumDescriptions: [
      p("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      p("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: p({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: W(new ft(73, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      p("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      p("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: p("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  occurrencesHighlight: W(new de(74, "occurrencesHighlight", !0, { description: p("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.") })),
  overviewRulerBorder: W(new de(75, "overviewRulerBorder", !0, { description: p("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: W(new Re(76, "overviewRulerLanes", 3, 0, 3)),
  padding: W(new bN()),
  parameterHints: W(new CN()),
  peekWidgetDefaultFocus: W(new ft(79, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      p("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      p("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: p("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  definitionLinkOpensInPeek: W(new de(80, "definitionLinkOpensInPeek", !1, { description: p("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: W(new wN()),
  quickSuggestionsDelay: W(new Re(82, "quickSuggestionsDelay", 10, 0, 1073741824, { description: p("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: W(new de(83, "readOnly", !1)),
  renameOnType: W(new de(84, "renameOnType", !1, { description: p("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: p("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: W(new de(85, "renderControlCharacters", !0, { description: p("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: !0 })),
  renderFinalNewline: W(new de(86, "renderFinalNewline", !0, { description: p("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: W(new ft(87, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      p("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: p("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: W(new de(88, "renderLineHighlightOnlyWhenFocus", !1, { description: p("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: W(new ft(89, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: W(new ft(90, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      p("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      p("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      p("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: p("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: W(new Re(91, "revealHorizontalRightPadding", 30, 0, 1e3)),
  roundedSelection: W(new de(92, "roundedSelection", !0, { description: p("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: W(new yN()),
  scrollbar: W(new LN()),
  scrollBeyondLastColumn: W(new Re(95, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: p("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: W(new de(96, "scrollBeyondLastLine", !0, { description: p("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: W(new de(97, "scrollPredominantAxis", !0, { description: p("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: W(new de(98, "selectionClipboard", !0, {
    description: p("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: _i
  })),
  selectionHighlight: W(new de(99, "selectionHighlight", !0, { description: p("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: W(new de(100, "selectOnLineNumbers", !0)),
  showFoldingControls: W(new ft(101, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      p("showFoldingControls.always", "Always show the folding controls."),
      p("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
      p("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: p("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: W(new de(102, "showUnused", !0, { description: p("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: W(new de(128, "showDeprecated", !0, { description: p("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: W(new gN()),
  snippetSuggestions: W(new ft(103, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      p("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      p("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      p("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      p("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: p("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: W(new NN()),
  smoothScrolling: W(new de(105, "smoothScrolling", !1, { description: p("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: W(new Re(107, "stopRenderingLineAfter", 1e4, -1, 1073741824)),
  suggest: W(new IN()),
  inlineSuggest: W(new DN()),
  suggestFontSize: W(new Re(109, "suggestFontSize", 0, 0, 1e3, { markdownDescription: p("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: W(new Re(110, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: p("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: W(new de(111, "suggestOnTriggerCharacters", !0, { description: p("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: W(new ft(112, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      p("suggestSelection.first", "Always select the first suggestion."),
      p("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      p("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: p("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: W(new ft(113, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      p("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      p("tabCompletion.off", "Disable tab completions."),
      p("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: p("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: W(new Re(114, "tabIndex", 0, -1, 1073741824)),
  unicodeHighlight: W(new kN()),
  unusualLineTerminators: W(new ft(116, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      p("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      p("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      p("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: p("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: W(new de(117, "useShadowDOM", !0)),
  useTabStops: W(new de(118, "useTabStops", !0, { description: p("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
  wordSeparators: W(new yi(119, "wordSeparators", Ak, { description: p("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: W(new ft(120, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      p("wordWrap.off", "Lines will never wrap."),
      p("wordWrap.on", "Lines will wrap at the viewport width."),
      p({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      p({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: p({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: W(new yi(
    121,
    "wordWrapBreakAfterCharacters",
    " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63"
  )),
  wordWrapBreakBeforeCharacters: W(new yi(
    122,
    "wordWrapBreakBeforeCharacters",
    "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B"
  )),
  wordWrapColumn: W(new Re(123, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: p({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: W(new ft(124, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: W(new ft(125, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  wrappingIndent: W(new Dc(126, "wrappingIndent", 1, "same", ["none", "same", "indent", "deepIndent"], MN, {
    enumDescriptions: [
      p("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
      p("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
      p("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
      p("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
    ],
    description: p("wrappingIndent", "Controls the indentation of wrapped lines.")
  })),
  wrappingStrategy: W(new ft(127, "wrappingStrategy", "simple", ["simple", "advanced"], {
    enumDescriptions: [
      p("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
      p("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
    ],
    description: p("wrappingStrategy", "Controls the algorithm that computes wrapping points.")
  })),
  editorClassName: W(new rN()),
  pixelRatio: W(new vN()),
  tabFocusMode: W(new TN()),
  layoutInfo: W(new hl()),
  wrappingInfo: W(new AN())
};
class BN {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? Al.isErrorNoTelemetry(e) ? new Al(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const Uk = new BN();
function ct(s) {
  ku(s) || Uk.onUnexpectedError(s);
}
function Eg(s) {
  ku(s) || Uk.onUnexpectedExternalError(s);
}
function Ov(s) {
  if (s instanceof Error) {
    const { name: e, message: t } = s, i = s.stacktrace || s.stack;
    return {
      $isError: !0,
      name: e,
      message: t,
      stack: i,
      noTelemetry: Al.isErrorNoTelemetry(s)
    };
  }
  return s;
}
const hf = "Canceled";
function ku(s) {
  return s instanceof Du ? !0 : s instanceof Error && s.name === hf && s.message === hf;
}
class Du extends Error {
  constructor() {
    super(hf), this.name = this.message;
  }
}
function VN() {
  const s = new Error(hf);
  return s.name = s.message, s;
}
function gb(s) {
  return s ? new Error(`Illegal argument: ${s}`) : new Error("Illegal argument");
}
function WN(s) {
  return s ? new Error(`Illegal state: ${s}`) : new Error("Illegal state");
}
class HN extends Error {
  constructor(e) {
    super("NotSupported"), e && (this.message = e);
  }
}
class Al extends Error {
  constructor(e) {
    super(e), this.name = "ErrorNoTelemetry";
  }
  static fromError(e) {
    if (e instanceof Al)
      return e;
    const t = new Al();
    return t.message = e.message, t.stack = e.stack, t;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "ErrorNoTelemetry";
  }
}
class mb extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, mb.prototype);
    debugger;
  }
}
function Yo(s) {
  const e = this;
  let t = !1, i;
  return function() {
    return t || (t = !0, i = s.apply(e, arguments)), i;
  };
}
class zN extends Error {
  constructor(e) {
    super(`Encountered errors while disposing of store. Errors: [${e.join(", ")}]`), this.errors = e;
  }
}
function UN(s) {
  return typeof s.dispose == "function" && s.dispose.length === 0;
}
function je(s) {
  if (ge.is(s)) {
    const e = [];
    for (const t of s)
      if (t)
        try {
          t.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new zN(e);
    return Array.isArray(s) ? [] : s;
  } else if (s)
    return s.dispose(), s;
}
function zr(...s) {
  return ze(() => je(s));
}
function ze(s) {
  return {
    dispose: Yo(() => {
      s();
    })
  };
}
class le {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  get isDisposed() {
    return this._isDisposed;
  }
  clear() {
    try {
      je(this._toDispose.values());
    } finally {
      this._toDispose.clear();
    }
  }
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? le.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
}
le.DISABLE_DISPOSED_WARNING = !1;
class z {
  constructor() {
    this._store = new le(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
}
z.None = Object.freeze({ dispose() {
} });
class $k {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    var t;
    this._isDisposed || e === this._value || ((t = this._value) === null || t === void 0 || t.dispose(), this._value = e);
  }
  clear() {
    this.value = void 0;
  }
  dispose() {
    var e;
    this._isDisposed = !0, (e = this._value) === null || e === void 0 || e.dispose(), this._value = void 0;
  }
  clearAndLeak() {
    const e = this._value;
    return this._value = void 0, e;
  }
}
class $N {
  constructor() {
    this.dispose = () => {
    }, this.unset = () => {
    }, this.isset = () => !1;
  }
  set(e) {
    let t = e;
    return this.unset = () => t = void 0, this.isset = () => t !== void 0, this.dispose = () => {
      t && (t(), t = void 0);
    }, this;
  }
}
class jN {
  constructor(e) {
    this.object = e;
  }
  dispose() {
  }
}
const KN = it.performance && typeof it.performance.now == "function";
class aa {
  constructor(e) {
    this._highResolution = KN && e, this._startTime = this._now(), this._stopTime = -1;
  }
  static create(e = !0) {
    return new aa(e);
  }
  stop() {
    this._stopTime = this._now();
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
  _now() {
    return this._highResolution ? it.performance.now() : Date.now();
  }
}
var Q;
(function(s) {
  s.None = () => z.None;
  function e(k) {
    return (y, S = null, D) => {
      let T = !1, M;
      return M = k((P) => {
        if (!T)
          return M ? M.dispose() : T = !0, y.call(S, P);
      }, null, D), T && M.dispose(), M;
    };
  }
  s.once = e;
  function t(k, y, S) {
    return l((D, T = null, M) => k((P) => D.call(T, y(P)), null, M), S);
  }
  s.map = t;
  function i(k, y, S) {
    return l((D, T = null, M) => k((P) => {
      y(P), D.call(T, P);
    }, null, M), S);
  }
  s.forEach = i;
  function n(k, y, S) {
    return l((D, T = null, M) => k((P) => y(P) && D.call(T, P), null, M), S);
  }
  s.filter = n;
  function r(k) {
    return k;
  }
  s.signal = r;
  function o(...k) {
    return (y, S = null, D) => zr(...k.map((T) => T((M) => y.call(S, M), null, D)));
  }
  s.any = o;
  function a(k, y, S, D) {
    let T = S;
    return t(k, (M) => (T = y(T, M), T), D);
  }
  s.reduce = a;
  function l(k, y) {
    let S;
    const D = {
      onFirstListenerAdd() {
        S = k(T.fire, T);
      },
      onLastListenerRemove() {
        S == null || S.dispose();
      }
    }, T = new A(D);
    return y == null || y.add(T), T.event;
  }
  function c(k, y, S = 100, D = !1, T, M) {
    let P, V, U, K = 0;
    const J = {
      leakWarningThreshold: T,
      onFirstListenerAdd() {
        P = k((ne) => {
          K++, V = y(V, ne), D && !U && (ee.fire(V), V = void 0), clearTimeout(U), U = setTimeout(() => {
            const ue = V;
            V = void 0, U = void 0, (!D || K > 1) && ee.fire(ue), K = 0;
          }, S);
        });
      },
      onLastListenerRemove() {
        P.dispose();
      }
    }, ee = new A(J);
    return M == null || M.add(ee), ee.event;
  }
  s.debounce = c;
  function h(k, y = (D, T) => D === T, S) {
    let D = !0, T;
    return n(k, (M) => {
      const P = D || !y(M, T);
      return D = !1, T = M, P;
    }, S);
  }
  s.latch = h;
  function u(k, y, S) {
    return [
      s.filter(k, y, S),
      s.filter(k, (D) => !y(D), S)
    ];
  }
  s.split = u;
  function d(k, y = !1, S = []) {
    let D = S.slice(), T = k((V) => {
      D ? D.push(V) : P.fire(V);
    });
    const M = () => {
      D == null || D.forEach((V) => P.fire(V)), D = null;
    }, P = new A({
      onFirstListenerAdd() {
        T || (T = k((V) => P.fire(V)));
      },
      onFirstListenerDidAdd() {
        D && (y ? setTimeout(M) : M());
      },
      onLastListenerRemove() {
        T && T.dispose(), T = null;
      }
    });
    return P.event;
  }
  s.buffer = d;
  class f {
    constructor(y) {
      this.event = y, this.disposables = new le();
    }
    map(y) {
      return new f(t(this.event, y, this.disposables));
    }
    forEach(y) {
      return new f(i(this.event, y, this.disposables));
    }
    filter(y) {
      return new f(n(this.event, y, this.disposables));
    }
    reduce(y, S) {
      return new f(a(this.event, y, S, this.disposables));
    }
    latch() {
      return new f(h(this.event, void 0, this.disposables));
    }
    debounce(y, S = 100, D = !1, T) {
      return new f(c(this.event, y, S, D, T, this.disposables));
    }
    on(y, S, D) {
      return this.event(y, S, D);
    }
    once(y, S, D) {
      return e(this.event)(y, S, D);
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  function m(k) {
    return new f(k);
  }
  s.chain = m;
  function _(k, y, S = (D) => D) {
    const D = (...V) => P.fire(S(...V)), T = () => k.on(y, D), M = () => k.removeListener(y, D), P = new A({ onFirstListenerAdd: T, onLastListenerRemove: M });
    return P.event;
  }
  s.fromNodeEventEmitter = _;
  function b(k, y, S = (D) => D) {
    const D = (...V) => P.fire(S(...V)), T = () => k.addEventListener(y, D), M = () => k.removeEventListener(y, D), P = new A({ onFirstListenerAdd: T, onLastListenerRemove: M });
    return P.event;
  }
  s.fromDOMEventEmitter = b;
  function v(k) {
    return new Promise((y) => e(k)(y));
  }
  s.toPromise = v;
  function C(k, y) {
    return y(void 0), k((S) => y(S));
  }
  s.runAndSubscribe = C;
  function w(k, y) {
    let S = null;
    function D(M) {
      S == null || S.dispose(), S = new le(), y(M, S);
    }
    D(void 0);
    const T = k((M) => D(M));
    return ze(() => {
      T.dispose(), S == null || S.dispose();
    });
  }
  s.runAndSubscribeWithStore = w;
  class L {
    constructor(y, S) {
      this.obs = y, this._counter = 0, this._hasChanged = !1;
      const D = {
        onFirstListenerAdd: () => {
          y.addObserver(this);
        },
        onLastListenerRemove: () => {
          y.removeObserver(this);
        }
      };
      this.emitter = new A(D), S && S.add(this.emitter);
    }
    beginUpdate(y) {
      this._counter++;
    }
    handleChange(y, S) {
      this._hasChanged = !0;
    }
    endUpdate(y) {
      --this._counter === 0 && this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this.obs.get()));
    }
  }
  function E(k, y) {
    return new L(k, y).emitter.event;
  }
  s.fromObservable = E;
})(Q || (Q = {}));
class xg {
  constructor(e) {
    this._listenerCount = 0, this._invocationCount = 0, this._elapsedOverall = 0, this._name = `${e}_${xg._idPool++}`;
  }
  start(e) {
    this._stopWatch = new aa(!0), this._listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this._elapsedOverall += e, this._invocationCount += 1, console.info(`did FIRE ${this._name}: elapsed_ms: ${e.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`), this._stopWatch = void 0;
    }
  }
}
xg._idPool = 0;
class pb {
  constructor(e) {
    this.value = e;
  }
  static create() {
    var e;
    return new pb((e = new Error().stack) !== null && e !== void 0 ? e : "");
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class qN {
  constructor(e, t, i) {
    this.callback = e, this.callbackThis = t, this.stack = i, this.subscription = new $N();
  }
  invoke(e) {
    this.callback.call(this.callbackThis, e);
  }
}
class A {
  constructor(e) {
    var t, i;
    this._disposed = !1, this._options = e, this._leakageMon = void 0, this._perfMon = !((t = this._options) === null || t === void 0) && t._profName ? new xg(this._options._profName) : void 0, this._deliveryQueue = (i = this._options) === null || i === void 0 ? void 0 : i.deliveryQueue;
  }
  dispose() {
    var e, t, i, n;
    this._disposed || (this._disposed = !0, this._listeners && this._listeners.clear(), (e = this._deliveryQueue) === null || e === void 0 || e.clear(this), (i = (t = this._options) === null || t === void 0 ? void 0 : t.onLastListenerRemove) === null || i === void 0 || i.call(t), (n = this._leakageMon) === null || n === void 0 || n.dispose());
  }
  get event() {
    return this._event || (this._event = (e, t, i) => {
      var n, r, o;
      this._listeners || (this._listeners = new Ei());
      const a = this._listeners.isEmpty();
      a && ((n = this._options) === null || n === void 0 ? void 0 : n.onFirstListenerAdd) && this._options.onFirstListenerAdd(this);
      let l, c;
      this._leakageMon && this._listeners.size >= 30 && (c = pb.create(), l = this._leakageMon.check(c, this._listeners.size + 1));
      const h = new qN(e, t, c), u = this._listeners.push(h);
      a && ((r = this._options) === null || r === void 0 ? void 0 : r.onFirstListenerDidAdd) && this._options.onFirstListenerDidAdd(this), !((o = this._options) === null || o === void 0) && o.onListenerDidAdd && this._options.onListenerDidAdd(this, e, t);
      const d = h.subscription.set(() => {
        l == null || l(), this._disposed || (u(), this._options && this._options.onLastListenerRemove && (this._listeners && !this._listeners.isEmpty() || this._options.onLastListenerRemove(this)));
      });
      return i instanceof le ? i.add(d) : Array.isArray(i) && i.push(d), d;
    }), this._event;
  }
  fire(e) {
    var t, i;
    if (this._listeners) {
      this._deliveryQueue || (this._deliveryQueue = new GN());
      for (const n of this._listeners)
        this._deliveryQueue.push(this, n, e);
      (t = this._perfMon) === null || t === void 0 || t.start(this._deliveryQueue.size), this._deliveryQueue.deliver(), (i = this._perfMon) === null || i === void 0 || i.stop();
    }
  }
}
class jk {
  constructor() {
    this._queue = new Ei();
  }
  get size() {
    return this._queue.size;
  }
  push(e, t, i) {
    this._queue.push(new ZN(e, t, i));
  }
  clear(e) {
    const t = new Ei();
    for (const i of this._queue)
      i.emitter !== e && t.push(i);
    this._queue = t;
  }
  deliver() {
    for (; this._queue.size > 0; ) {
      const e = this._queue.shift();
      try {
        e.listener.invoke(e.event);
      } catch (t) {
        ct(t);
      }
    }
  }
}
class GN extends jk {
  clear(e) {
    this._queue.clear();
  }
}
class ZN {
  constructor(e, t, i) {
    this.emitter = e, this.listener = t, this.event = i;
  }
}
class uf extends A {
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new Ei(), this._mergeFn = e == null ? void 0 : e.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        const e = Array.from(this._eventQueue);
        this._eventQueue.clear(), super.fire(this._mergeFn(e));
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._listeners && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class YN extends uf {
  constructor(e) {
    var t;
    super(e), this._delay = (t = e.delay) !== null && t !== void 0 ? t : 100;
  }
  fire(e) {
    this._handle || (this.pause(), this._handle = setTimeout(() => {
      this._handle = void 0, this.resume();
    }, this._delay)), super.fire(e);
  }
}
class _b {
  constructor() {
    this.buffers = [];
  }
  wrapEvent(e) {
    return (t, i, n) => e((r) => {
      const o = this.buffers[this.buffers.length - 1];
      o ? o.push(() => t.call(i, r)) : t.call(i, r);
    }, void 0, n);
  }
  bufferEvents(e) {
    const t = [];
    this.buffers.push(t);
    const i = e();
    return this.buffers.pop(), t.forEach((n) => n()), i;
  }
}
class Fv {
  constructor() {
    this.listening = !1, this.inputEvent = Q.None, this.inputEventListener = z.None, this.emitter = new A({
      onFirstListenerDidAdd: () => {
        this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onLastListenerRemove: () => {
        this.listening = !1, this.inputEventListener.dispose();
      }
    }), this.event = this.emitter.event;
  }
  set input(e) {
    this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
  }
  dispose() {
    this.inputEventListener.dispose(), this.emitter.dispose();
  }
}
const Kk = Object.freeze(function(s, e) {
  const t = setTimeout(s.bind(e), 0);
  return { dispose() {
    clearTimeout(t);
  } };
});
var Ii;
(function(s) {
  function e(t) {
    return t === s.None || t === s.Cancelled || t instanceof zd ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
  }
  s.isCancellationToken = e, s.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: Q.None
  }), s.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: Kk
  });
})(Ii || (Ii = {}));
class zd {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? Kk : (this._emitter || (this._emitter = new A()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
class lc {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new zd()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof zd && this._token.cancel() : this._token = Ii.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener && this._parentListener.dispose(), this._token ? this._token instanceof zd && this._token.dispose() : this._token = Ii.None;
  }
}
class bb {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, t) {
    this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const Ud = new bb(), h_ = new bb(), u_ = new bb(), qk = new Array(230), QN = /* @__PURE__ */ Object.create(null), XN = /* @__PURE__ */ Object.create(null), Cb = [];
for (let s = 0; s <= 193; s++)
  Cb[s] = -1;
(function() {
  const s = "", e = [
    [0, 1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", s, s],
    [0, 1, 1, "Hyper", 0, s, 0, s, s, s],
    [0, 1, 2, "Super", 0, s, 0, s, s, s],
    [0, 1, 3, "Fn", 0, s, 0, s, s, s],
    [0, 1, 4, "FnLock", 0, s, 0, s, s, s],
    [0, 1, 5, "Suspend", 0, s, 0, s, s, s],
    [0, 1, 6, "Resume", 0, s, 0, s, s, s],
    [0, 1, 7, "Turbo", 0, s, 0, s, s, s],
    [0, 1, 8, "Sleep", 0, s, 0, "VK_SLEEP", s, s],
    [0, 1, 9, "WakeUp", 0, s, 0, s, s, s],
    [31, 0, 10, "KeyA", 31, "A", 65, "VK_A", s, s],
    [32, 0, 11, "KeyB", 32, "B", 66, "VK_B", s, s],
    [33, 0, 12, "KeyC", 33, "C", 67, "VK_C", s, s],
    [34, 0, 13, "KeyD", 34, "D", 68, "VK_D", s, s],
    [35, 0, 14, "KeyE", 35, "E", 69, "VK_E", s, s],
    [36, 0, 15, "KeyF", 36, "F", 70, "VK_F", s, s],
    [37, 0, 16, "KeyG", 37, "G", 71, "VK_G", s, s],
    [38, 0, 17, "KeyH", 38, "H", 72, "VK_H", s, s],
    [39, 0, 18, "KeyI", 39, "I", 73, "VK_I", s, s],
    [40, 0, 19, "KeyJ", 40, "J", 74, "VK_J", s, s],
    [41, 0, 20, "KeyK", 41, "K", 75, "VK_K", s, s],
    [42, 0, 21, "KeyL", 42, "L", 76, "VK_L", s, s],
    [43, 0, 22, "KeyM", 43, "M", 77, "VK_M", s, s],
    [44, 0, 23, "KeyN", 44, "N", 78, "VK_N", s, s],
    [45, 0, 24, "KeyO", 45, "O", 79, "VK_O", s, s],
    [46, 0, 25, "KeyP", 46, "P", 80, "VK_P", s, s],
    [47, 0, 26, "KeyQ", 47, "Q", 81, "VK_Q", s, s],
    [48, 0, 27, "KeyR", 48, "R", 82, "VK_R", s, s],
    [49, 0, 28, "KeyS", 49, "S", 83, "VK_S", s, s],
    [50, 0, 29, "KeyT", 50, "T", 84, "VK_T", s, s],
    [51, 0, 30, "KeyU", 51, "U", 85, "VK_U", s, s],
    [52, 0, 31, "KeyV", 52, "V", 86, "VK_V", s, s],
    [53, 0, 32, "KeyW", 53, "W", 87, "VK_W", s, s],
    [54, 0, 33, "KeyX", 54, "X", 88, "VK_X", s, s],
    [55, 0, 34, "KeyY", 55, "Y", 89, "VK_Y", s, s],
    [56, 0, 35, "KeyZ", 56, "Z", 90, "VK_Z", s, s],
    [22, 0, 36, "Digit1", 22, "1", 49, "VK_1", s, s],
    [23, 0, 37, "Digit2", 23, "2", 50, "VK_2", s, s],
    [24, 0, 38, "Digit3", 24, "3", 51, "VK_3", s, s],
    [25, 0, 39, "Digit4", 25, "4", 52, "VK_4", s, s],
    [26, 0, 40, "Digit5", 26, "5", 53, "VK_5", s, s],
    [27, 0, 41, "Digit6", 27, "6", 54, "VK_6", s, s],
    [28, 0, 42, "Digit7", 28, "7", 55, "VK_7", s, s],
    [29, 0, 43, "Digit8", 29, "8", 56, "VK_8", s, s],
    [30, 0, 44, "Digit9", 30, "9", 57, "VK_9", s, s],
    [21, 0, 45, "Digit0", 21, "0", 48, "VK_0", s, s],
    [3, 1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", s, s],
    [9, 1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", s, s],
    [1, 1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", s, s],
    [2, 1, 49, "Tab", 2, "Tab", 9, "VK_TAB", s, s],
    [10, 1, 50, "Space", 10, "Space", 32, "VK_SPACE", s, s],
    [83, 0, 51, "Minus", 83, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [81, 0, 52, "Equal", 81, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [87, 0, 53, "BracketLeft", 87, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [89, 0, 54, "BracketRight", 89, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [88, 0, 55, "Backslash", 88, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 0, 56, "IntlHash", 0, s, 0, s, s, s],
    [80, 0, 57, "Semicolon", 80, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [90, 0, 58, "Quote", 90, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [86, 0, 59, "Backquote", 86, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [82, 0, 60, "Comma", 82, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [84, 0, 61, "Period", 84, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [85, 0, 62, "Slash", 85, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [8, 1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", s, s],
    [59, 1, 64, "F1", 59, "F1", 112, "VK_F1", s, s],
    [60, 1, 65, "F2", 60, "F2", 113, "VK_F2", s, s],
    [61, 1, 66, "F3", 61, "F3", 114, "VK_F3", s, s],
    [62, 1, 67, "F4", 62, "F4", 115, "VK_F4", s, s],
    [63, 1, 68, "F5", 63, "F5", 116, "VK_F5", s, s],
    [64, 1, 69, "F6", 64, "F6", 117, "VK_F6", s, s],
    [65, 1, 70, "F7", 65, "F7", 118, "VK_F7", s, s],
    [66, 1, 71, "F8", 66, "F8", 119, "VK_F8", s, s],
    [67, 1, 72, "F9", 67, "F9", 120, "VK_F9", s, s],
    [68, 1, 73, "F10", 68, "F10", 121, "VK_F10", s, s],
    [69, 1, 74, "F11", 69, "F11", 122, "VK_F11", s, s],
    [70, 1, 75, "F12", 70, "F12", 123, "VK_F12", s, s],
    [0, 1, 76, "PrintScreen", 0, s, 0, s, s, s],
    [79, 1, 77, "ScrollLock", 79, "ScrollLock", 145, "VK_SCROLL", s, s],
    [7, 1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", s, s],
    [19, 1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", s, s],
    [14, 1, 80, "Home", 14, "Home", 36, "VK_HOME", s, s],
    [11, 1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", s, s],
    [20, 1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", s, s],
    [13, 1, 83, "End", 13, "End", 35, "VK_END", s, s],
    [12, 1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", s, s],
    [17, 1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", s],
    [15, 1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", s],
    [18, 1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", s],
    [16, 1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", s],
    [78, 1, 89, "NumLock", 78, "NumLock", 144, "VK_NUMLOCK", s, s],
    [108, 1, 90, "NumpadDivide", 108, "NumPad_Divide", 111, "VK_DIVIDE", s, s],
    [103, 1, 91, "NumpadMultiply", 103, "NumPad_Multiply", 106, "VK_MULTIPLY", s, s],
    [106, 1, 92, "NumpadSubtract", 106, "NumPad_Subtract", 109, "VK_SUBTRACT", s, s],
    [104, 1, 93, "NumpadAdd", 104, "NumPad_Add", 107, "VK_ADD", s, s],
    [3, 1, 94, "NumpadEnter", 3, s, 0, s, s, s],
    [94, 1, 95, "Numpad1", 94, "NumPad1", 97, "VK_NUMPAD1", s, s],
    [95, 1, 96, "Numpad2", 95, "NumPad2", 98, "VK_NUMPAD2", s, s],
    [96, 1, 97, "Numpad3", 96, "NumPad3", 99, "VK_NUMPAD3", s, s],
    [97, 1, 98, "Numpad4", 97, "NumPad4", 100, "VK_NUMPAD4", s, s],
    [98, 1, 99, "Numpad5", 98, "NumPad5", 101, "VK_NUMPAD5", s, s],
    [99, 1, 100, "Numpad6", 99, "NumPad6", 102, "VK_NUMPAD6", s, s],
    [100, 1, 101, "Numpad7", 100, "NumPad7", 103, "VK_NUMPAD7", s, s],
    [101, 1, 102, "Numpad8", 101, "NumPad8", 104, "VK_NUMPAD8", s, s],
    [102, 1, 103, "Numpad9", 102, "NumPad9", 105, "VK_NUMPAD9", s, s],
    [93, 1, 104, "Numpad0", 93, "NumPad0", 96, "VK_NUMPAD0", s, s],
    [107, 1, 105, "NumpadDecimal", 107, "NumPad_Decimal", 110, "VK_DECIMAL", s, s],
    [92, 0, 106, "IntlBackslash", 92, "OEM_102", 226, "VK_OEM_102", s, s],
    [58, 1, 107, "ContextMenu", 58, "ContextMenu", 93, s, s, s],
    [0, 1, 108, "Power", 0, s, 0, s, s, s],
    [0, 1, 109, "NumpadEqual", 0, s, 0, s, s, s],
    [71, 1, 110, "F13", 71, "F13", 124, "VK_F13", s, s],
    [72, 1, 111, "F14", 72, "F14", 125, "VK_F14", s, s],
    [73, 1, 112, "F15", 73, "F15", 126, "VK_F15", s, s],
    [74, 1, 113, "F16", 74, "F16", 127, "VK_F16", s, s],
    [75, 1, 114, "F17", 75, "F17", 128, "VK_F17", s, s],
    [76, 1, 115, "F18", 76, "F18", 129, "VK_F18", s, s],
    [77, 1, 116, "F19", 77, "F19", 130, "VK_F19", s, s],
    [0, 1, 117, "F20", 0, s, 0, "VK_F20", s, s],
    [0, 1, 118, "F21", 0, s, 0, "VK_F21", s, s],
    [0, 1, 119, "F22", 0, s, 0, "VK_F22", s, s],
    [0, 1, 120, "F23", 0, s, 0, "VK_F23", s, s],
    [0, 1, 121, "F24", 0, s, 0, "VK_F24", s, s],
    [0, 1, 122, "Open", 0, s, 0, s, s, s],
    [0, 1, 123, "Help", 0, s, 0, s, s, s],
    [0, 1, 124, "Select", 0, s, 0, s, s, s],
    [0, 1, 125, "Again", 0, s, 0, s, s, s],
    [0, 1, 126, "Undo", 0, s, 0, s, s, s],
    [0, 1, 127, "Cut", 0, s, 0, s, s, s],
    [0, 1, 128, "Copy", 0, s, 0, s, s, s],
    [0, 1, 129, "Paste", 0, s, 0, s, s, s],
    [0, 1, 130, "Find", 0, s, 0, s, s, s],
    [0, 1, 131, "AudioVolumeMute", 112, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", s, s],
    [0, 1, 132, "AudioVolumeUp", 113, "AudioVolumeUp", 175, "VK_VOLUME_UP", s, s],
    [0, 1, 133, "AudioVolumeDown", 114, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", s, s],
    [105, 1, 134, "NumpadComma", 105, "NumPad_Separator", 108, "VK_SEPARATOR", s, s],
    [110, 0, 135, "IntlRo", 110, "ABNT_C1", 193, "VK_ABNT_C1", s, s],
    [0, 1, 136, "KanaMode", 0, s, 0, s, s, s],
    [0, 0, 137, "IntlYen", 0, s, 0, s, s, s],
    [0, 1, 138, "Convert", 0, s, 0, s, s, s],
    [0, 1, 139, "NonConvert", 0, s, 0, s, s, s],
    [0, 1, 140, "Lang1", 0, s, 0, s, s, s],
    [0, 1, 141, "Lang2", 0, s, 0, s, s, s],
    [0, 1, 142, "Lang3", 0, s, 0, s, s, s],
    [0, 1, 143, "Lang4", 0, s, 0, s, s, s],
    [0, 1, 144, "Lang5", 0, s, 0, s, s, s],
    [0, 1, 145, "Abort", 0, s, 0, s, s, s],
    [0, 1, 146, "Props", 0, s, 0, s, s, s],
    [0, 1, 147, "NumpadParenLeft", 0, s, 0, s, s, s],
    [0, 1, 148, "NumpadParenRight", 0, s, 0, s, s, s],
    [0, 1, 149, "NumpadBackspace", 0, s, 0, s, s, s],
    [0, 1, 150, "NumpadMemoryStore", 0, s, 0, s, s, s],
    [0, 1, 151, "NumpadMemoryRecall", 0, s, 0, s, s, s],
    [0, 1, 152, "NumpadMemoryClear", 0, s, 0, s, s, s],
    [0, 1, 153, "NumpadMemoryAdd", 0, s, 0, s, s, s],
    [0, 1, 154, "NumpadMemorySubtract", 0, s, 0, s, s, s],
    [0, 1, 155, "NumpadClear", 126, "Clear", 12, "VK_CLEAR", s, s],
    [0, 1, 156, "NumpadClearEntry", 0, s, 0, s, s, s],
    [5, 1, 0, s, 5, "Ctrl", 17, "VK_CONTROL", s, s],
    [4, 1, 0, s, 4, "Shift", 16, "VK_SHIFT", s, s],
    [6, 1, 0, s, 6, "Alt", 18, "VK_MENU", s, s],
    [57, 1, 0, s, 57, "Meta", 0, "VK_COMMAND", s, s],
    [5, 1, 157, "ControlLeft", 5, s, 0, "VK_LCONTROL", s, s],
    [4, 1, 158, "ShiftLeft", 4, s, 0, "VK_LSHIFT", s, s],
    [6, 1, 159, "AltLeft", 6, s, 0, "VK_LMENU", s, s],
    [57, 1, 160, "MetaLeft", 57, s, 0, "VK_LWIN", s, s],
    [5, 1, 161, "ControlRight", 5, s, 0, "VK_RCONTROL", s, s],
    [4, 1, 162, "ShiftRight", 4, s, 0, "VK_RSHIFT", s, s],
    [6, 1, 163, "AltRight", 6, s, 0, "VK_RMENU", s, s],
    [57, 1, 164, "MetaRight", 57, s, 0, "VK_RWIN", s, s],
    [0, 1, 165, "BrightnessUp", 0, s, 0, s, s, s],
    [0, 1, 166, "BrightnessDown", 0, s, 0, s, s, s],
    [0, 1, 167, "MediaPlay", 0, s, 0, s, s, s],
    [0, 1, 168, "MediaRecord", 0, s, 0, s, s, s],
    [0, 1, 169, "MediaFastForward", 0, s, 0, s, s, s],
    [0, 1, 170, "MediaRewind", 0, s, 0, s, s, s],
    [114, 1, 171, "MediaTrackNext", 119, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", s, s],
    [115, 1, 172, "MediaTrackPrevious", 120, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", s, s],
    [116, 1, 173, "MediaStop", 121, "MediaStop", 178, "VK_MEDIA_STOP", s, s],
    [0, 1, 174, "Eject", 0, s, 0, s, s, s],
    [117, 1, 175, "MediaPlayPause", 122, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", s, s],
    [0, 1, 176, "MediaSelect", 123, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", s, s],
    [0, 1, 177, "LaunchMail", 124, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", s, s],
    [0, 1, 178, "LaunchApp2", 125, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", s, s],
    [0, 1, 179, "LaunchApp1", 0, s, 0, "VK_MEDIA_LAUNCH_APP1", s, s],
    [0, 1, 180, "SelectTask", 0, s, 0, s, s, s],
    [0, 1, 181, "LaunchScreenSaver", 0, s, 0, s, s, s],
    [0, 1, 182, "BrowserSearch", 115, "BrowserSearch", 170, "VK_BROWSER_SEARCH", s, s],
    [0, 1, 183, "BrowserHome", 116, "BrowserHome", 172, "VK_BROWSER_HOME", s, s],
    [112, 1, 184, "BrowserBack", 117, "BrowserBack", 166, "VK_BROWSER_BACK", s, s],
    [113, 1, 185, "BrowserForward", 118, "BrowserForward", 167, "VK_BROWSER_FORWARD", s, s],
    [0, 1, 186, "BrowserStop", 0, s, 0, "VK_BROWSER_STOP", s, s],
    [0, 1, 187, "BrowserRefresh", 0, s, 0, "VK_BROWSER_REFRESH", s, s],
    [0, 1, 188, "BrowserFavorites", 0, s, 0, "VK_BROWSER_FAVORITES", s, s],
    [0, 1, 189, "ZoomToggle", 0, s, 0, s, s, s],
    [0, 1, 190, "MailReply", 0, s, 0, s, s, s],
    [0, 1, 191, "MailForward", 0, s, 0, s, s, s],
    [0, 1, 192, "MailSend", 0, s, 0, s, s, s],
    [109, 1, 0, s, 109, "KeyInComposition", 229, s, s, s],
    [111, 1, 0, s, 111, "ABNT_C2", 194, "VK_ABNT_C2", s, s],
    [91, 1, 0, s, 91, "OEM_8", 223, "VK_OEM_8", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_KANA", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_HANGUL", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_JUNJA", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_FINAL", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_HANJA", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_KANJI", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_CONVERT", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_NONCONVERT", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_ACCEPT", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_MODECHANGE", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_SELECT", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_PRINT", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_EXECUTE", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_SNAPSHOT", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_HELP", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_APPS", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_PROCESSKEY", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_PACKET", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_DBE_SBCSCHAR", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_DBE_DBCSCHAR", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_ATTN", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_CRSEL", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_EXSEL", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_EREOF", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_PLAY", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_ZOOM", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_NONAME", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_PA1", s, s],
    [0, 1, 0, s, 0, s, 0, "VK_OEM_CLEAR", s, s]
  ], t = [], i = [];
  for (const n of e) {
    const [r, o, a, l, c, h, u, d, f, m] = n;
    if (i[a] || (i[a] = !0, QN[l] = a, XN[l.toLowerCase()] = a, o && (Cb[a] = c)), !t[c]) {
      if (t[c] = !0, !h)
        throw new Error(`String representation missing for key code ${c} around scan code ${l}`);
      Ud.define(c, h), h_.define(c, f || h), u_.define(c, m || f || h);
    }
    u && (qk[u] = c);
  }
})();
var Mo;
(function(s) {
  function e(a) {
    return Ud.keyCodeToStr(a);
  }
  s.toString = e;
  function t(a) {
    return Ud.strToKeyCode(a);
  }
  s.fromString = t;
  function i(a) {
    return h_.keyCodeToStr(a);
  }
  s.toUserSettingsUS = i;
  function n(a) {
    return u_.keyCodeToStr(a);
  }
  s.toUserSettingsGeneral = n;
  function r(a) {
    return h_.strToKeyCode(a) || u_.strToKeyCode(a);
  }
  s.fromUserSettings = r;
  function o(a) {
    if (a >= 93 && a <= 108)
      return null;
    switch (a) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return Ud.keyCodeToStr(a);
  }
  s.toElectronAccelerator = o;
})(Mo || (Mo = {}));
function JN(s, e) {
  const t = (e & 65535) << 16 >>> 0;
  return (s | t) >>> 0;
}
let dl;
if (typeof it.vscode < "u" && typeof it.vscode.process < "u") {
  const s = it.vscode.process;
  dl = {
    get platform() {
      return s.platform;
    },
    get arch() {
      return s.arch;
    },
    get env() {
      return s.env;
    },
    cwd() {
      return s.cwd();
    }
  };
} else
  typeof process < "u" ? dl = {
    get platform() {
      return process.platform;
    },
    get arch() {
      return process.arch;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env.VSCODE_CWD || process.cwd();
    }
  } : dl = {
    get platform() {
      return Vi ? "win32" : Ie ? "darwin" : "linux";
    },
    get arch() {
    },
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
const d_ = dl.cwd, eT = dl.env, la = dl.platform, tT = 65, iT = 97, nT = 90, sT = 122, Ur = 46, Zt = 47, Mi = 92, hr = 58, rT = 63;
class Gk extends Error {
  constructor(e, t, i) {
    let n;
    typeof t == "string" && t.indexOf("not ") === 0 ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
    const r = e.indexOf(".") !== -1 ? "property" : "argument";
    let o = `The "${e}" ${r} ${n} of type ${t}`;
    o += `. Received type ${typeof i}`, super(o), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function yt(s, e) {
  if (typeof s != "string")
    throw new Gk(e, "string", s);
}
function ye(s) {
  return s === Zt || s === Mi;
}
function f_(s) {
  return s === Zt;
}
function ur(s) {
  return s >= tT && s <= nT || s >= iT && s <= sT;
}
function df(s, e, t, i) {
  let n = "", r = 0, o = -1, a = 0, l = 0;
  for (let c = 0; c <= s.length; ++c) {
    if (c < s.length)
      l = s.charCodeAt(c);
    else {
      if (i(l))
        break;
      l = Zt;
    }
    if (i(l)) {
      if (!(o === c - 1 || a === 1))
        if (a === 2) {
          if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== Ur || n.charCodeAt(n.length - 2) !== Ur) {
            if (n.length > 2) {
              const h = n.lastIndexOf(t);
              h === -1 ? (n = "", r = 0) : (n = n.slice(0, h), r = n.length - 1 - n.lastIndexOf(t)), o = c, a = 0;
              continue;
            } else if (n.length !== 0) {
              n = "", r = 0, o = c, a = 0;
              continue;
            }
          }
          e && (n += n.length > 0 ? `${t}..` : "..", r = 2);
        } else
          n.length > 0 ? n += `${t}${s.slice(o + 1, c)}` : n = s.slice(o + 1, c), r = c - o - 1;
      o = c, a = 0;
    } else
      l === Ur && a !== -1 ? ++a : a = -1;
  }
  return n;
}
function Zk(s, e) {
  if (e === null || typeof e != "object")
    throw new Gk("pathObject", "Object", e);
  const t = e.dir || e.root, i = e.base || `${e.name || ""}${e.ext || ""}`;
  return t ? t === e.root ? `${t}${i}` : `${t}${s}${i}` : i;
}
const xi = {
  resolve(...s) {
    let e = "", t = "", i = !1;
    for (let n = s.length - 1; n >= -1; n--) {
      let r;
      if (n >= 0) {
        if (r = s[n], yt(r, "path"), r.length === 0)
          continue;
      } else
        e.length === 0 ? r = d_() : (r = eT[`=${e}`] || d_(), (r === void 0 || r.slice(0, 2).toLowerCase() !== e.toLowerCase() && r.charCodeAt(2) === Mi) && (r = `${e}\\`));
      const o = r.length;
      let a = 0, l = "", c = !1;
      const h = r.charCodeAt(0);
      if (o === 1)
        ye(h) && (a = 1, c = !0);
      else if (ye(h))
        if (c = !0, ye(r.charCodeAt(1))) {
          let u = 2, d = u;
          for (; u < o && !ye(r.charCodeAt(u)); )
            u++;
          if (u < o && u !== d) {
            const f = r.slice(d, u);
            for (d = u; u < o && ye(r.charCodeAt(u)); )
              u++;
            if (u < o && u !== d) {
              for (d = u; u < o && !ye(r.charCodeAt(u)); )
                u++;
              (u === o || u !== d) && (l = `\\\\${f}\\${r.slice(d, u)}`, a = u);
            }
          }
        } else
          a = 1;
      else
        ur(h) && r.charCodeAt(1) === hr && (l = r.slice(0, 2), a = 2, o > 2 && ye(r.charCodeAt(2)) && (c = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (t = `${r.slice(a)}\\${t}`, i = c, c && e.length > 0)
        break;
    }
    return t = df(t, !i, "\\", ye), i ? `${e}\\${t}` : `${e}${t}` || ".";
  },
  normalize(s) {
    yt(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = 0, i, n = !1;
    const r = s.charCodeAt(0);
    if (e === 1)
      return f_(r) ? "\\" : s;
    if (ye(r))
      if (n = !0, ye(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !ye(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const c = s.slice(l, a);
          for (l = a; a < e && ye(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !ye(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${c}\\${s.slice(l)}\\`;
            a !== l && (i = `\\\\${c}\\${s.slice(l, a)}`, t = a);
          }
        }
      } else
        t = 1;
    else
      ur(r) && s.charCodeAt(1) === hr && (i = s.slice(0, 2), t = 2, e > 2 && ye(s.charCodeAt(2)) && (n = !0, t = 3));
    let o = t < e ? df(s.slice(t), !n, "\\", ye) : "";
    return o.length === 0 && !n && (o = "."), o.length > 0 && ye(s.charCodeAt(e - 1)) && (o += "\\"), i === void 0 ? n ? `\\${o}` : o : n ? `${i}\\${o}` : `${i}${o}`;
  },
  isAbsolute(s) {
    yt(s, "path");
    const e = s.length;
    if (e === 0)
      return !1;
    const t = s.charCodeAt(0);
    return ye(t) || e > 2 && ur(t) && s.charCodeAt(1) === hr && ye(s.charCodeAt(2));
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e, t;
    for (let r = 0; r < s.length; ++r) {
      const o = s[r];
      yt(o, "path"), o.length > 0 && (e === void 0 ? e = t = o : e += `\\${o}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, n = 0;
    if (typeof t == "string" && ye(t.charCodeAt(0))) {
      ++n;
      const r = t.length;
      r > 1 && ye(t.charCodeAt(1)) && (++n, r > 2 && (ye(t.charCodeAt(2)) ? ++n : i = !1));
    }
    if (i) {
      for (; n < e.length && ye(e.charCodeAt(n)); )
        n++;
      n >= 2 && (e = `\\${e.slice(n)}`);
    }
    return xi.normalize(e);
  },
  relative(s, e) {
    if (yt(s, "from"), yt(e, "to"), s === e)
      return "";
    const t = xi.resolve(s), i = xi.resolve(e);
    if (t === i || (s = t.toLowerCase(), e = i.toLowerCase(), s === e))
      return "";
    let n = 0;
    for (; n < s.length && s.charCodeAt(n) === Mi; )
      n++;
    let r = s.length;
    for (; r - 1 > n && s.charCodeAt(r - 1) === Mi; )
      r--;
    const o = r - n;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === Mi; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === Mi; )
      l--;
    const c = l - a, h = o < c ? o : c;
    let u = -1, d = 0;
    for (; d < h; d++) {
      const m = s.charCodeAt(n + d);
      if (m !== e.charCodeAt(a + d))
        break;
      m === Mi && (u = d);
    }
    if (d !== h) {
      if (u === -1)
        return i;
    } else {
      if (c > h) {
        if (e.charCodeAt(a + d) === Mi)
          return i.slice(a + d + 1);
        if (d === 2)
          return i.slice(a + d);
      }
      o > h && (s.charCodeAt(n + d) === Mi ? u = d : d === 2 && (u = 3)), u === -1 && (u = 0);
    }
    let f = "";
    for (d = n + u + 1; d <= r; ++d)
      (d === r || s.charCodeAt(d) === Mi) && (f += f.length === 0 ? ".." : "\\..");
    return a += u, f.length > 0 ? `${f}${i.slice(a, l)}` : (i.charCodeAt(a) === Mi && ++a, i.slice(a, l));
  },
  toNamespacedPath(s) {
    if (typeof s != "string")
      return s;
    if (s.length === 0)
      return "";
    const e = xi.resolve(s);
    if (e.length <= 2)
      return s;
    if (e.charCodeAt(0) === Mi) {
      if (e.charCodeAt(1) === Mi) {
        const t = e.charCodeAt(2);
        if (t !== rT && t !== Ur)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (ur(e.charCodeAt(0)) && e.charCodeAt(1) === hr && e.charCodeAt(2) === Mi)
      return `\\\\?\\${e}`;
    return s;
  },
  dirname(s) {
    yt(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = -1, i = 0;
    const n = s.charCodeAt(0);
    if (e === 1)
      return ye(n) ? s : ".";
    if (ye(n)) {
      if (t = i = 1, ye(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !ye(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && ye(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !ye(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return s;
            a !== l && (t = i = a + 1);
          }
        }
      }
    } else
      ur(n) && s.charCodeAt(1) === hr && (t = e > 2 && ye(s.charCodeAt(2)) ? 3 : 2, i = t);
    let r = -1, o = !0;
    for (let a = e - 1; a >= i; --a)
      if (ye(s.charCodeAt(a))) {
        if (!o) {
          r = a;
          break;
        }
      } else
        o = !1;
    if (r === -1) {
      if (t === -1)
        return ".";
      r = t;
    }
    return s.slice(0, r);
  },
  basename(s, e) {
    e !== void 0 && yt(e, "ext"), yt(s, "path");
    let t = 0, i = -1, n = !0, r;
    if (s.length >= 2 && ur(s.charCodeAt(0)) && s.charCodeAt(1) === hr && (t = 2), e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let o = e.length - 1, a = -1;
      for (r = s.length - 1; r >= t; --r) {
        const l = s.charCodeAt(r);
        if (ye(l)) {
          if (!n) {
            t = r + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = r + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (i = r) : (o = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (r = s.length - 1; r >= t; --r)
      if (ye(s.charCodeAt(r))) {
        if (!n) {
          t = r + 1;
          break;
        }
      } else
        i === -1 && (n = !1, i = r + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    yt(s, "path");
    let e = 0, t = -1, i = 0, n = -1, r = !0, o = 0;
    s.length >= 2 && s.charCodeAt(1) === hr && ur(s.charCodeAt(0)) && (e = i = 2);
    for (let a = s.length - 1; a >= e; --a) {
      const l = s.charCodeAt(a);
      if (ye(l)) {
        if (!r) {
          i = a + 1;
          break;
        }
        continue;
      }
      n === -1 && (r = !1, n = a + 1), l === Ur ? t === -1 ? t = a : o !== 1 && (o = 1) : t !== -1 && (o = -1);
    }
    return t === -1 || n === -1 || o === 0 || o === 1 && t === n - 1 && t === i + 1 ? "" : s.slice(t, n);
  },
  format: Zk.bind(null, "\\"),
  parse(s) {
    yt(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.length;
    let i = 0, n = s.charCodeAt(0);
    if (t === 1)
      return ye(n) ? (e.root = e.dir = s, e) : (e.base = e.name = s, e);
    if (ye(n)) {
      if (i = 1, ye(s.charCodeAt(1))) {
        let u = 2, d = u;
        for (; u < t && !ye(s.charCodeAt(u)); )
          u++;
        if (u < t && u !== d) {
          for (d = u; u < t && ye(s.charCodeAt(u)); )
            u++;
          if (u < t && u !== d) {
            for (d = u; u < t && !ye(s.charCodeAt(u)); )
              u++;
            u === t ? i = u : u !== d && (i = u + 1);
          }
        }
      }
    } else if (ur(n) && s.charCodeAt(1) === hr) {
      if (t <= 2)
        return e.root = e.dir = s, e;
      if (i = 2, ye(s.charCodeAt(2))) {
        if (t === 3)
          return e.root = e.dir = s, e;
        i = 3;
      }
    }
    i > 0 && (e.root = s.slice(0, i));
    let r = -1, o = i, a = -1, l = !0, c = s.length - 1, h = 0;
    for (; c >= i; --c) {
      if (n = s.charCodeAt(c), ye(n)) {
        if (!l) {
          o = c + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = c + 1), n === Ur ? r === -1 ? r = c : h !== 1 && (h = 1) : r !== -1 && (h = -1);
    }
    return a !== -1 && (r === -1 || h === 0 || h === 1 && r === a - 1 && r === o + 1 ? e.base = e.name = s.slice(o, a) : (e.name = s.slice(o, r), e.base = s.slice(o, a), e.ext = s.slice(r, a))), o > 0 && o !== i ? e.dir = s.slice(0, o - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, lt = {
  resolve(...s) {
    let e = "", t = !1;
    for (let i = s.length - 1; i >= -1 && !t; i--) {
      const n = i >= 0 ? s[i] : d_();
      yt(n, "path"), n.length !== 0 && (e = `${n}/${e}`, t = n.charCodeAt(0) === Zt);
    }
    return e = df(e, !t, "/", f_), t ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(s) {
    if (yt(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === Zt, t = s.charCodeAt(s.length - 1) === Zt;
    return s = df(s, !e, "/", f_), s.length === 0 ? e ? "/" : t ? "./" : "." : (t && (s += "/"), e ? `/${s}` : s);
  },
  isAbsolute(s) {
    return yt(s, "path"), s.length > 0 && s.charCodeAt(0) === Zt;
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e;
    for (let t = 0; t < s.length; ++t) {
      const i = s[t];
      yt(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : lt.normalize(e);
  },
  relative(s, e) {
    if (yt(s, "from"), yt(e, "to"), s === e || (s = lt.resolve(s), e = lt.resolve(e), s === e))
      return "";
    const t = 1, i = s.length, n = i - t, r = 1, o = e.length - r, a = n < o ? n : o;
    let l = -1, c = 0;
    for (; c < a; c++) {
      const u = s.charCodeAt(t + c);
      if (u !== e.charCodeAt(r + c))
        break;
      u === Zt && (l = c);
    }
    if (c === a)
      if (o > a) {
        if (e.charCodeAt(r + c) === Zt)
          return e.slice(r + c + 1);
        if (c === 0)
          return e.slice(r + c);
      } else
        n > a && (s.charCodeAt(t + c) === Zt ? l = c : c === 0 && (l = 0));
    let h = "";
    for (c = t + l + 1; c <= i; ++c)
      (c === i || s.charCodeAt(c) === Zt) && (h += h.length === 0 ? ".." : "/..");
    return `${h}${e.slice(r + l)}`;
  },
  toNamespacedPath(s) {
    return s;
  },
  dirname(s) {
    if (yt(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === Zt;
    let t = -1, i = !0;
    for (let n = s.length - 1; n >= 1; --n)
      if (s.charCodeAt(n) === Zt) {
        if (!i) {
          t = n;
          break;
        }
      } else
        i = !1;
    return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : s.slice(0, t);
  },
  basename(s, e) {
    e !== void 0 && yt(e, "ext"), yt(s, "path");
    let t = 0, i = -1, n = !0, r;
    if (e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let o = e.length - 1, a = -1;
      for (r = s.length - 1; r >= 0; --r) {
        const l = s.charCodeAt(r);
        if (l === Zt) {
          if (!n) {
            t = r + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = r + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (i = r) : (o = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (r = s.length - 1; r >= 0; --r)
      if (s.charCodeAt(r) === Zt) {
        if (!n) {
          t = r + 1;
          break;
        }
      } else
        i === -1 && (n = !1, i = r + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    yt(s, "path");
    let e = -1, t = 0, i = -1, n = !0, r = 0;
    for (let o = s.length - 1; o >= 0; --o) {
      const a = s.charCodeAt(o);
      if (a === Zt) {
        if (!n) {
          t = o + 1;
          break;
        }
        continue;
      }
      i === -1 && (n = !1, i = o + 1), a === Ur ? e === -1 ? e = o : r !== 1 && (r = 1) : e !== -1 && (r = -1);
    }
    return e === -1 || i === -1 || r === 0 || r === 1 && e === i - 1 && e === t + 1 ? "" : s.slice(e, i);
  },
  format: Zk.bind(null, "/"),
  parse(s) {
    yt(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.charCodeAt(0) === Zt;
    let i;
    t ? (e.root = "/", i = 1) : i = 0;
    let n = -1, r = 0, o = -1, a = !0, l = s.length - 1, c = 0;
    for (; l >= i; --l) {
      const h = s.charCodeAt(l);
      if (h === Zt) {
        if (!a) {
          r = l + 1;
          break;
        }
        continue;
      }
      o === -1 && (a = !1, o = l + 1), h === Ur ? n === -1 ? n = l : c !== 1 && (c = 1) : n !== -1 && (c = -1);
    }
    if (o !== -1) {
      const h = r === 0 && t ? 1 : r;
      n === -1 || c === 0 || c === 1 && n === o - 1 && n === r + 1 ? e.base = e.name = s.slice(h, o) : (e.name = s.slice(h, n), e.base = s.slice(h, o), e.ext = s.slice(n, o));
    }
    return r > 0 ? e.dir = s.slice(0, r - 1) : t && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
lt.win32 = xi.win32 = xi;
lt.posix = xi.posix = lt;
const Yk = la === "win32" ? xi.normalize : lt.normalize, oT = la === "win32" ? xi.resolve : lt.resolve, aT = la === "win32" ? xi.relative : lt.relative, lT = la === "win32" ? xi.dirname : lt.dirname, Qk = la === "win32" ? xi.basename : lt.basename, cT = la === "win32" ? xi.extname : lt.extname, Uo = la === "win32" ? xi.sep : lt.sep, hT = /^\w[\w\d+.-]*$/, uT = /^\//, dT = /^\/\//;
function Bv(s, e) {
  if (!s.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${s.authority}", path: "${s.path}", query: "${s.query}", fragment: "${s.fragment}"}`);
  if (s.scheme && !hT.test(s.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (s.path) {
    if (s.authority) {
      if (!uT.test(s.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (dT.test(s.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function fT(s, e) {
  return !s && !e ? "file" : s;
}
function gT(s, e) {
  switch (s) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== Dn && (e = Dn + e) : e = Dn;
      break;
  }
  return e;
}
const Xe = "", Dn = "/", mT = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class Le {
  constructor(e, t, i, n, r, o = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || Xe, this.authority = e.authority || Xe, this.path = e.path || Xe, this.query = e.query || Xe, this.fragment = e.fragment || Xe) : (this.scheme = fT(e, o), this.authority = t || Xe, this.path = gT(this.scheme, i || Xe), this.query = n || Xe, this.fragment = r || Xe, Bv(this, o));
  }
  static isUri(e) {
    return e instanceof Le ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  get fsPath() {
    return ff(this, !1);
  }
  with(e) {
    if (!e)
      return this;
    let { scheme: t, authority: i, path: n, query: r, fragment: o } = e;
    return t === void 0 ? t = this.scheme : t === null && (t = Xe), i === void 0 ? i = this.authority : i === null && (i = Xe), n === void 0 ? n = this.path : n === null && (n = Xe), r === void 0 ? r = this.query : r === null && (r = Xe), o === void 0 ? o = this.fragment : o === null && (o = Xe), t === this.scheme && i === this.authority && n === this.path && r === this.query && o === this.fragment ? this : new ka(t, i, n, r, o);
  }
  static parse(e, t = !1) {
    const i = mT.exec(e);
    return i ? new ka(i[2] || Xe, Zu(i[4] || Xe), Zu(i[5] || Xe), Zu(i[7] || Xe), Zu(i[9] || Xe), t) : new ka(Xe, Xe, Xe, Xe, Xe);
  }
  static file(e) {
    let t = Xe;
    if (Vi && (e = e.replace(/\\/g, Dn)), e[0] === Dn && e[1] === Dn) {
      const i = e.indexOf(Dn, 2);
      i === -1 ? (t = e.substring(2), e = Dn) : (t = e.substring(2, i), e = e.substring(i) || Dn);
    }
    return new ka("file", t, e, Xe, Xe);
  }
  static from(e) {
    const t = new ka(e.scheme, e.authority, e.path, e.query, e.fragment);
    return Bv(t, !0), t;
  }
  static joinPath(e, ...t) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return Vi && e.scheme === "file" ? i = Le.file(xi.join(ff(e, !0), ...t)).path : i = lt.join(e.path, ...t), e.with({ path: i });
  }
  toString(e = !1) {
    return g_(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof Le)
        return e;
      {
        const t = new ka(e);
        return t._formatted = e.external, t._fsPath = e._sep === Xk ? e.fsPath : null, t;
      }
    } else
      return e;
  }
}
const Xk = Vi ? 1 : void 0;
class ka extends Le {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = ff(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? g_(this, !0) : (this._formatted || (this._formatted = g_(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = Xk), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
}
const Jk = {
  [58]: "%3A",
  [47]: "%2F",
  [63]: "%3F",
  [35]: "%23",
  [91]: "%5B",
  [93]: "%5D",
  [64]: "%40",
  [33]: "%21",
  [36]: "%24",
  [38]: "%26",
  [39]: "%27",
  [40]: "%28",
  [41]: "%29",
  [42]: "%2A",
  [43]: "%2B",
  [44]: "%2C",
  [59]: "%3B",
  [61]: "%3D",
  [32]: "%20"
};
function Vv(s, e) {
  let t, i = -1;
  for (let n = 0; n < s.length; n++) {
    const r = s.charCodeAt(n);
    if (r >= 97 && r <= 122 || r >= 65 && r <= 90 || r >= 48 && r <= 57 || r === 45 || r === 46 || r === 95 || r === 126 || e && r === 47)
      i !== -1 && (t += encodeURIComponent(s.substring(i, n)), i = -1), t !== void 0 && (t += s.charAt(n));
    else {
      t === void 0 && (t = s.substr(0, n));
      const o = Jk[r];
      o !== void 0 ? (i !== -1 && (t += encodeURIComponent(s.substring(i, n)), i = -1), t += o) : i === -1 && (i = n);
    }
  }
  return i !== -1 && (t += encodeURIComponent(s.substring(i))), t !== void 0 ? t : s;
}
function pT(s) {
  let e;
  for (let t = 0; t < s.length; t++) {
    const i = s.charCodeAt(t);
    i === 35 || i === 63 ? (e === void 0 && (e = s.substr(0, t)), e += Jk[i]) : e !== void 0 && (e += s[t]);
  }
  return e !== void 0 ? e : s;
}
function ff(s, e) {
  let t;
  return s.authority && s.path.length > 1 && s.scheme === "file" ? t = `//${s.authority}${s.path}` : s.path.charCodeAt(0) === 47 && (s.path.charCodeAt(1) >= 65 && s.path.charCodeAt(1) <= 90 || s.path.charCodeAt(1) >= 97 && s.path.charCodeAt(1) <= 122) && s.path.charCodeAt(2) === 58 ? e ? t = s.path.substr(1) : t = s.path[1].toLowerCase() + s.path.substr(2) : t = s.path, Vi && (t = t.replace(/\//g, "\\")), t;
}
function g_(s, e) {
  const t = e ? pT : Vv;
  let i = "", { scheme: n, authority: r, path: o, query: a, fragment: l } = s;
  if (n && (i += n, i += ":"), (r || n === "file") && (i += Dn, i += Dn), r) {
    let c = r.indexOf("@");
    if (c !== -1) {
      const h = r.substr(0, c);
      r = r.substr(c + 1), c = h.indexOf(":"), c === -1 ? i += t(h, !1) : (i += t(h.substr(0, c), !1), i += ":", i += t(h.substr(c + 1), !1)), i += "@";
    }
    r = r.toLowerCase(), c = r.indexOf(":"), c === -1 ? i += t(r, !1) : (i += t(r.substr(0, c), !1), i += r.substr(c));
  }
  if (o) {
    if (o.length >= 3 && o.charCodeAt(0) === 47 && o.charCodeAt(2) === 58) {
      const c = o.charCodeAt(1);
      c >= 65 && c <= 90 && (o = `/${String.fromCharCode(c + 32)}:${o.substr(3)}`);
    } else if (o.length >= 2 && o.charCodeAt(1) === 58) {
      const c = o.charCodeAt(0);
      c >= 65 && c <= 90 && (o = `${String.fromCharCode(c + 32)}:${o.substr(2)}`);
    }
    i += t(o, !0);
  }
  return a && (i += "?", i += t(a, !1)), l && (i += "#", i += e ? l : Vv(l, !1)), i;
}
function e2(s) {
  try {
    return decodeURIComponent(s);
  } catch {
    return s.length > 3 ? s.substr(0, 3) + e2(s.substr(3)) : s;
  }
}
const Wv = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function Zu(s) {
  return s.match(Wv) ? s.replace(Wv, (e) => e2(e)) : s;
}
class O {
  constructor(e, t) {
    this.lineNumber = e, this.column = t;
  }
  with(e = this.lineNumber, t = this.column) {
    return e === this.lineNumber && t === this.column ? this : new O(e, t);
  }
  delta(e = 0, t = 0) {
    return this.with(this.lineNumber + e, this.column + t);
  }
  equals(e) {
    return O.equals(this, e);
  }
  static equals(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
  }
  isBefore(e) {
    return O.isBefore(this, e);
  }
  static isBefore(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
  }
  isBeforeOrEqual(e) {
    return O.isBeforeOrEqual(this, e);
  }
  static isBeforeOrEqual(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
  }
  static compare(e, t) {
    const i = e.lineNumber | 0, n = t.lineNumber | 0;
    if (i === n) {
      const r = e.column | 0, o = t.column | 0;
      return r - o;
    }
    return i - n;
  }
  clone() {
    return new O(this.lineNumber, this.column);
  }
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  static lift(e) {
    return new O(e.lineNumber, e.column);
  }
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
}
class N {
  constructor(e, t, i, n) {
    e > i || e === i && t > n ? (this.startLineNumber = i, this.startColumn = n, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = n);
  }
  isEmpty() {
    return N.isEmpty(this);
  }
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  containsPosition(e) {
    return N.containsPosition(this, e);
  }
  static containsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
  }
  static strictContainsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column <= e.startColumn || t.lineNumber === e.endLineNumber && t.column >= e.endColumn);
  }
  containsRange(e) {
    return N.containsRange(this, e);
  }
  static containsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
  }
  strictContainsRange(e) {
    return N.strictContainsRange(this, e);
  }
  static strictContainsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
  }
  plusRange(e) {
    return N.plusRange(this, e);
  }
  static plusRange(e, t) {
    let i, n, r, o;
    return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, n = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, n = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, n = e.startColumn), t.endLineNumber > e.endLineNumber ? (r = t.endLineNumber, o = t.endColumn) : t.endLineNumber === e.endLineNumber ? (r = t.endLineNumber, o = Math.max(t.endColumn, e.endColumn)) : (r = e.endLineNumber, o = e.endColumn), new N(i, n, r, o);
  }
  intersectRanges(e) {
    return N.intersectRanges(this, e);
  }
  static intersectRanges(e, t) {
    let i = e.startLineNumber, n = e.startColumn, r = e.endLineNumber, o = e.endColumn;
    const a = t.startLineNumber, l = t.startColumn, c = t.endLineNumber, h = t.endColumn;
    return i < a ? (i = a, n = l) : i === a && (n = Math.max(n, l)), r > c ? (r = c, o = h) : r === c && (o = Math.min(o, h)), i > r || i === r && n > o ? null : new N(i, n, r, o);
  }
  equalsRange(e) {
    return N.equalsRange(this, e);
  }
  static equalsRange(e, t) {
    return !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
  }
  getEndPosition() {
    return N.getEndPosition(this);
  }
  static getEndPosition(e) {
    return new O(e.endLineNumber, e.endColumn);
  }
  getStartPosition() {
    return N.getStartPosition(this);
  }
  static getStartPosition(e) {
    return new O(e.startLineNumber, e.startColumn);
  }
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  setEndPosition(e, t) {
    return new N(this.startLineNumber, this.startColumn, e, t);
  }
  setStartPosition(e, t) {
    return new N(e, t, this.endLineNumber, this.endColumn);
  }
  collapseToStart() {
    return N.collapseToStart(this);
  }
  static collapseToStart(e) {
    return new N(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  static fromPositions(e, t = e) {
    return new N(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static lift(e) {
    return e ? new N(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  static areIntersectingOrTouching(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
  }
  static areIntersecting(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
  }
  static compareRangesUsingStarts(e, t) {
    if (e && t) {
      const r = e.startLineNumber | 0, o = t.startLineNumber | 0;
      if (r === o) {
        const a = e.startColumn | 0, l = t.startColumn | 0;
        if (a === l) {
          const c = e.endLineNumber | 0, h = t.endLineNumber | 0;
          if (c === h) {
            const u = e.endColumn | 0, d = t.endColumn | 0;
            return u - d;
          }
          return c - h;
        }
        return a - l;
      }
      return r - o;
    }
    return (e ? 1 : 0) - (t ? 1 : 0);
  }
  static compareRangesUsingEnds(e, t) {
    return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
  }
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
}
class Ce extends N {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = n;
  }
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  equalsSelection(e) {
    return Ce.selectionsEqual(this, e);
  }
  static selectionsEqual(e, t) {
    return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
  }
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  setEndPosition(e, t) {
    return this.getDirection() === 0 ? new Ce(this.startLineNumber, this.startColumn, e, t) : new Ce(e, t, this.startLineNumber, this.startColumn);
  }
  getPosition() {
    return new O(this.positionLineNumber, this.positionColumn);
  }
  getSelectionStart() {
    return new O(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  setStartPosition(e, t) {
    return this.getDirection() === 0 ? new Ce(e, t, this.endLineNumber, this.endColumn) : new Ce(this.endLineNumber, this.endColumn, e, t);
  }
  static fromPositions(e, t = e) {
    return new Ce(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static fromRange(e, t) {
    return t === 0 ? new Ce(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new Ce(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
  }
  static liftSelection(e) {
    return new Ce(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  static selectionsArrEqual(e, t) {
    if (e && !t || !e && t)
      return !1;
    if (!e && !t)
      return !0;
    if (e.length !== t.length)
      return !1;
    for (let i = 0, n = e.length; i < n; i++)
      if (!this.selectionsEqual(e[i], t[i]))
        return !1;
    return !0;
  }
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  static createWithDirection(e, t, i, n, r) {
    return r === 0 ? new Ce(e, t, i, n) : new Ce(i, n, e, t);
  }
}
function _T(s) {
  return s ? s.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
class g {
  constructor(e, t, i) {
    this.id = e, this.definition = t, this.description = i, g._allCodicons.push(this);
  }
  get classNames() {
    return "codicon codicon-" + this.id;
  }
  get classNamesArray() {
    return ["codicon", "codicon-" + this.id];
  }
  get cssSelector() {
    return ".codicon.codicon-" + this.id;
  }
  static getAll() {
    return g._allCodicons;
  }
}
g._allCodicons = [];
g.add = new g("add", { fontCharacter: "\\ea60" });
g.plus = new g("plus", g.add.definition);
g.gistNew = new g("gist-new", g.add.definition);
g.repoCreate = new g("repo-create", g.add.definition);
g.lightbulb = new g("lightbulb", { fontCharacter: "\\ea61" });
g.lightBulb = new g("light-bulb", { fontCharacter: "\\ea61" });
g.repo = new g("repo", { fontCharacter: "\\ea62" });
g.repoDelete = new g("repo-delete", { fontCharacter: "\\ea62" });
g.gistFork = new g("gist-fork", { fontCharacter: "\\ea63" });
g.repoForked = new g("repo-forked", { fontCharacter: "\\ea63" });
g.gitPullRequest = new g("git-pull-request", { fontCharacter: "\\ea64" });
g.gitPullRequestAbandoned = new g("git-pull-request-abandoned", { fontCharacter: "\\ea64" });
g.recordKeys = new g("record-keys", { fontCharacter: "\\ea65" });
g.keyboard = new g("keyboard", { fontCharacter: "\\ea65" });
g.tag = new g("tag", { fontCharacter: "\\ea66" });
g.tagAdd = new g("tag-add", { fontCharacter: "\\ea66" });
g.tagRemove = new g("tag-remove", { fontCharacter: "\\ea66" });
g.person = new g("person", { fontCharacter: "\\ea67" });
g.personFollow = new g("person-follow", { fontCharacter: "\\ea67" });
g.personOutline = new g("person-outline", { fontCharacter: "\\ea67" });
g.personFilled = new g("person-filled", { fontCharacter: "\\ea67" });
g.gitBranch = new g("git-branch", { fontCharacter: "\\ea68" });
g.gitBranchCreate = new g("git-branch-create", { fontCharacter: "\\ea68" });
g.gitBranchDelete = new g("git-branch-delete", { fontCharacter: "\\ea68" });
g.sourceControl = new g("source-control", { fontCharacter: "\\ea68" });
g.mirror = new g("mirror", { fontCharacter: "\\ea69" });
g.mirrorPublic = new g("mirror-public", { fontCharacter: "\\ea69" });
g.star = new g("star", { fontCharacter: "\\ea6a" });
g.starAdd = new g("star-add", { fontCharacter: "\\ea6a" });
g.starDelete = new g("star-delete", { fontCharacter: "\\ea6a" });
g.starEmpty = new g("star-empty", { fontCharacter: "\\ea6a" });
g.comment = new g("comment", { fontCharacter: "\\ea6b" });
g.commentAdd = new g("comment-add", { fontCharacter: "\\ea6b" });
g.alert = new g("alert", { fontCharacter: "\\ea6c" });
g.warning = new g("warning", { fontCharacter: "\\ea6c" });
g.search = new g("search", { fontCharacter: "\\ea6d" });
g.searchSave = new g("search-save", { fontCharacter: "\\ea6d" });
g.logOut = new g("log-out", { fontCharacter: "\\ea6e" });
g.signOut = new g("sign-out", { fontCharacter: "\\ea6e" });
g.logIn = new g("log-in", { fontCharacter: "\\ea6f" });
g.signIn = new g("sign-in", { fontCharacter: "\\ea6f" });
g.eye = new g("eye", { fontCharacter: "\\ea70" });
g.eyeUnwatch = new g("eye-unwatch", { fontCharacter: "\\ea70" });
g.eyeWatch = new g("eye-watch", { fontCharacter: "\\ea70" });
g.circleFilled = new g("circle-filled", { fontCharacter: "\\ea71" });
g.primitiveDot = new g("primitive-dot", { fontCharacter: "\\ea71" });
g.closeDirty = new g("close-dirty", { fontCharacter: "\\ea71" });
g.debugBreakpoint = new g("debug-breakpoint", { fontCharacter: "\\ea71" });
g.debugBreakpointDisabled = new g("debug-breakpoint-disabled", { fontCharacter: "\\ea71" });
g.debugHint = new g("debug-hint", { fontCharacter: "\\ea71" });
g.primitiveSquare = new g("primitive-square", { fontCharacter: "\\ea72" });
g.edit = new g("edit", { fontCharacter: "\\ea73" });
g.pencil = new g("pencil", { fontCharacter: "\\ea73" });
g.info = new g("info", { fontCharacter: "\\ea74" });
g.issueOpened = new g("issue-opened", { fontCharacter: "\\ea74" });
g.gistPrivate = new g("gist-private", { fontCharacter: "\\ea75" });
g.gitForkPrivate = new g("git-fork-private", { fontCharacter: "\\ea75" });
g.lock = new g("lock", { fontCharacter: "\\ea75" });
g.mirrorPrivate = new g("mirror-private", { fontCharacter: "\\ea75" });
g.close = new g("close", { fontCharacter: "\\ea76" });
g.removeClose = new g("remove-close", { fontCharacter: "\\ea76" });
g.x = new g("x", { fontCharacter: "\\ea76" });
g.repoSync = new g("repo-sync", { fontCharacter: "\\ea77" });
g.sync = new g("sync", { fontCharacter: "\\ea77" });
g.clone = new g("clone", { fontCharacter: "\\ea78" });
g.desktopDownload = new g("desktop-download", { fontCharacter: "\\ea78" });
g.beaker = new g("beaker", { fontCharacter: "\\ea79" });
g.microscope = new g("microscope", { fontCharacter: "\\ea79" });
g.vm = new g("vm", { fontCharacter: "\\ea7a" });
g.deviceDesktop = new g("device-desktop", { fontCharacter: "\\ea7a" });
g.file = new g("file", { fontCharacter: "\\ea7b" });
g.fileText = new g("file-text", { fontCharacter: "\\ea7b" });
g.more = new g("more", { fontCharacter: "\\ea7c" });
g.ellipsis = new g("ellipsis", { fontCharacter: "\\ea7c" });
g.kebabHorizontal = new g("kebab-horizontal", { fontCharacter: "\\ea7c" });
g.mailReply = new g("mail-reply", { fontCharacter: "\\ea7d" });
g.reply = new g("reply", { fontCharacter: "\\ea7d" });
g.organization = new g("organization", { fontCharacter: "\\ea7e" });
g.organizationFilled = new g("organization-filled", { fontCharacter: "\\ea7e" });
g.organizationOutline = new g("organization-outline", { fontCharacter: "\\ea7e" });
g.newFile = new g("new-file", { fontCharacter: "\\ea7f" });
g.fileAdd = new g("file-add", { fontCharacter: "\\ea7f" });
g.newFolder = new g("new-folder", { fontCharacter: "\\ea80" });
g.fileDirectoryCreate = new g("file-directory-create", { fontCharacter: "\\ea80" });
g.trash = new g("trash", { fontCharacter: "\\ea81" });
g.trashcan = new g("trashcan", { fontCharacter: "\\ea81" });
g.history = new g("history", { fontCharacter: "\\ea82" });
g.clock = new g("clock", { fontCharacter: "\\ea82" });
g.folder = new g("folder", { fontCharacter: "\\ea83" });
g.fileDirectory = new g("file-directory", { fontCharacter: "\\ea83" });
g.symbolFolder = new g("symbol-folder", { fontCharacter: "\\ea83" });
g.logoGithub = new g("logo-github", { fontCharacter: "\\ea84" });
g.markGithub = new g("mark-github", { fontCharacter: "\\ea84" });
g.github = new g("github", { fontCharacter: "\\ea84" });
g.terminal = new g("terminal", { fontCharacter: "\\ea85" });
g.console = new g("console", { fontCharacter: "\\ea85" });
g.repl = new g("repl", { fontCharacter: "\\ea85" });
g.zap = new g("zap", { fontCharacter: "\\ea86" });
g.symbolEvent = new g("symbol-event", { fontCharacter: "\\ea86" });
g.error = new g("error", { fontCharacter: "\\ea87" });
g.stop = new g("stop", { fontCharacter: "\\ea87" });
g.variable = new g("variable", { fontCharacter: "\\ea88" });
g.symbolVariable = new g("symbol-variable", { fontCharacter: "\\ea88" });
g.array = new g("array", { fontCharacter: "\\ea8a" });
g.symbolArray = new g("symbol-array", { fontCharacter: "\\ea8a" });
g.symbolModule = new g("symbol-module", { fontCharacter: "\\ea8b" });
g.symbolPackage = new g("symbol-package", { fontCharacter: "\\ea8b" });
g.symbolNamespace = new g("symbol-namespace", { fontCharacter: "\\ea8b" });
g.symbolObject = new g("symbol-object", { fontCharacter: "\\ea8b" });
g.symbolMethod = new g("symbol-method", { fontCharacter: "\\ea8c" });
g.symbolFunction = new g("symbol-function", { fontCharacter: "\\ea8c" });
g.symbolConstructor = new g("symbol-constructor", { fontCharacter: "\\ea8c" });
g.symbolBoolean = new g("symbol-boolean", { fontCharacter: "\\ea8f" });
g.symbolNull = new g("symbol-null", { fontCharacter: "\\ea8f" });
g.symbolNumeric = new g("symbol-numeric", { fontCharacter: "\\ea90" });
g.symbolNumber = new g("symbol-number", { fontCharacter: "\\ea90" });
g.symbolStructure = new g("symbol-structure", { fontCharacter: "\\ea91" });
g.symbolStruct = new g("symbol-struct", { fontCharacter: "\\ea91" });
g.symbolParameter = new g("symbol-parameter", { fontCharacter: "\\ea92" });
g.symbolTypeParameter = new g("symbol-type-parameter", { fontCharacter: "\\ea92" });
g.symbolKey = new g("symbol-key", { fontCharacter: "\\ea93" });
g.symbolText = new g("symbol-text", { fontCharacter: "\\ea93" });
g.symbolReference = new g("symbol-reference", { fontCharacter: "\\ea94" });
g.goToFile = new g("go-to-file", { fontCharacter: "\\ea94" });
g.symbolEnum = new g("symbol-enum", { fontCharacter: "\\ea95" });
g.symbolValue = new g("symbol-value", { fontCharacter: "\\ea95" });
g.symbolRuler = new g("symbol-ruler", { fontCharacter: "\\ea96" });
g.symbolUnit = new g("symbol-unit", { fontCharacter: "\\ea96" });
g.activateBreakpoints = new g("activate-breakpoints", { fontCharacter: "\\ea97" });
g.archive = new g("archive", { fontCharacter: "\\ea98" });
g.arrowBoth = new g("arrow-both", { fontCharacter: "\\ea99" });
g.arrowDown = new g("arrow-down", { fontCharacter: "\\ea9a" });
g.arrowLeft = new g("arrow-left", { fontCharacter: "\\ea9b" });
g.arrowRight = new g("arrow-right", { fontCharacter: "\\ea9c" });
g.arrowSmallDown = new g("arrow-small-down", { fontCharacter: "\\ea9d" });
g.arrowSmallLeft = new g("arrow-small-left", { fontCharacter: "\\ea9e" });
g.arrowSmallRight = new g("arrow-small-right", { fontCharacter: "\\ea9f" });
g.arrowSmallUp = new g("arrow-small-up", { fontCharacter: "\\eaa0" });
g.arrowUp = new g("arrow-up", { fontCharacter: "\\eaa1" });
g.bell = new g("bell", { fontCharacter: "\\eaa2" });
g.bold = new g("bold", { fontCharacter: "\\eaa3" });
g.book = new g("book", { fontCharacter: "\\eaa4" });
g.bookmark = new g("bookmark", { fontCharacter: "\\eaa5" });
g.debugBreakpointConditionalUnverified = new g("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" });
g.debugBreakpointConditional = new g("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" });
g.debugBreakpointConditionalDisabled = new g("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" });
g.debugBreakpointDataUnverified = new g("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" });
g.debugBreakpointData = new g("debug-breakpoint-data", { fontCharacter: "\\eaa9" });
g.debugBreakpointDataDisabled = new g("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" });
g.debugBreakpointLogUnverified = new g("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" });
g.debugBreakpointLog = new g("debug-breakpoint-log", { fontCharacter: "\\eaab" });
g.debugBreakpointLogDisabled = new g("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" });
g.briefcase = new g("briefcase", { fontCharacter: "\\eaac" });
g.broadcast = new g("broadcast", { fontCharacter: "\\eaad" });
g.browser = new g("browser", { fontCharacter: "\\eaae" });
g.bug = new g("bug", { fontCharacter: "\\eaaf" });
g.calendar = new g("calendar", { fontCharacter: "\\eab0" });
g.caseSensitive = new g("case-sensitive", { fontCharacter: "\\eab1" });
g.check = new g("check", { fontCharacter: "\\eab2" });
g.checklist = new g("checklist", { fontCharacter: "\\eab3" });
g.chevronDown = new g("chevron-down", { fontCharacter: "\\eab4" });
g.dropDownButton = new g("drop-down-button", g.chevronDown.definition);
g.chevronLeft = new g("chevron-left", { fontCharacter: "\\eab5" });
g.chevronRight = new g("chevron-right", { fontCharacter: "\\eab6" });
g.chevronUp = new g("chevron-up", { fontCharacter: "\\eab7" });
g.chromeClose = new g("chrome-close", { fontCharacter: "\\eab8" });
g.chromeMaximize = new g("chrome-maximize", { fontCharacter: "\\eab9" });
g.chromeMinimize = new g("chrome-minimize", { fontCharacter: "\\eaba" });
g.chromeRestore = new g("chrome-restore", { fontCharacter: "\\eabb" });
g.circleOutline = new g("circle-outline", { fontCharacter: "\\eabc" });
g.debugBreakpointUnverified = new g("debug-breakpoint-unverified", { fontCharacter: "\\eabc" });
g.circleSlash = new g("circle-slash", { fontCharacter: "\\eabd" });
g.circuitBoard = new g("circuit-board", { fontCharacter: "\\eabe" });
g.clearAll = new g("clear-all", { fontCharacter: "\\eabf" });
g.clippy = new g("clippy", { fontCharacter: "\\eac0" });
g.closeAll = new g("close-all", { fontCharacter: "\\eac1" });
g.cloudDownload = new g("cloud-download", { fontCharacter: "\\eac2" });
g.cloudUpload = new g("cloud-upload", { fontCharacter: "\\eac3" });
g.code = new g("code", { fontCharacter: "\\eac4" });
g.collapseAll = new g("collapse-all", { fontCharacter: "\\eac5" });
g.colorMode = new g("color-mode", { fontCharacter: "\\eac6" });
g.commentDiscussion = new g("comment-discussion", { fontCharacter: "\\eac7" });
g.compareChanges = new g("compare-changes", { fontCharacter: "\\eafd" });
g.creditCard = new g("credit-card", { fontCharacter: "\\eac9" });
g.dash = new g("dash", { fontCharacter: "\\eacc" });
g.dashboard = new g("dashboard", { fontCharacter: "\\eacd" });
g.database = new g("database", { fontCharacter: "\\eace" });
g.debugContinue = new g("debug-continue", { fontCharacter: "\\eacf" });
g.debugDisconnect = new g("debug-disconnect", { fontCharacter: "\\ead0" });
g.debugPause = new g("debug-pause", { fontCharacter: "\\ead1" });
g.debugRestart = new g("debug-restart", { fontCharacter: "\\ead2" });
g.debugStart = new g("debug-start", { fontCharacter: "\\ead3" });
g.debugStepInto = new g("debug-step-into", { fontCharacter: "\\ead4" });
g.debugStepOut = new g("debug-step-out", { fontCharacter: "\\ead5" });
g.debugStepOver = new g("debug-step-over", { fontCharacter: "\\ead6" });
g.debugStop = new g("debug-stop", { fontCharacter: "\\ead7" });
g.debug = new g("debug", { fontCharacter: "\\ead8" });
g.deviceCameraVideo = new g("device-camera-video", { fontCharacter: "\\ead9" });
g.deviceCamera = new g("device-camera", { fontCharacter: "\\eada" });
g.deviceMobile = new g("device-mobile", { fontCharacter: "\\eadb" });
g.diffAdded = new g("diff-added", { fontCharacter: "\\eadc" });
g.diffIgnored = new g("diff-ignored", { fontCharacter: "\\eadd" });
g.diffModified = new g("diff-modified", { fontCharacter: "\\eade" });
g.diffRemoved = new g("diff-removed", { fontCharacter: "\\eadf" });
g.diffRenamed = new g("diff-renamed", { fontCharacter: "\\eae0" });
g.diff = new g("diff", { fontCharacter: "\\eae1" });
g.discard = new g("discard", { fontCharacter: "\\eae2" });
g.editorLayout = new g("editor-layout", { fontCharacter: "\\eae3" });
g.emptyWindow = new g("empty-window", { fontCharacter: "\\eae4" });
g.exclude = new g("exclude", { fontCharacter: "\\eae5" });
g.extensions = new g("extensions", { fontCharacter: "\\eae6" });
g.eyeClosed = new g("eye-closed", { fontCharacter: "\\eae7" });
g.fileBinary = new g("file-binary", { fontCharacter: "\\eae8" });
g.fileCode = new g("file-code", { fontCharacter: "\\eae9" });
g.fileMedia = new g("file-media", { fontCharacter: "\\eaea" });
g.filePdf = new g("file-pdf", { fontCharacter: "\\eaeb" });
g.fileSubmodule = new g("file-submodule", { fontCharacter: "\\eaec" });
g.fileSymlinkDirectory = new g("file-symlink-directory", { fontCharacter: "\\eaed" });
g.fileSymlinkFile = new g("file-symlink-file", { fontCharacter: "\\eaee" });
g.fileZip = new g("file-zip", { fontCharacter: "\\eaef" });
g.files = new g("files", { fontCharacter: "\\eaf0" });
g.filter = new g("filter", { fontCharacter: "\\eaf1" });
g.flame = new g("flame", { fontCharacter: "\\eaf2" });
g.foldDown = new g("fold-down", { fontCharacter: "\\eaf3" });
g.foldUp = new g("fold-up", { fontCharacter: "\\eaf4" });
g.fold = new g("fold", { fontCharacter: "\\eaf5" });
g.folderActive = new g("folder-active", { fontCharacter: "\\eaf6" });
g.folderOpened = new g("folder-opened", { fontCharacter: "\\eaf7" });
g.gear = new g("gear", { fontCharacter: "\\eaf8" });
g.gift = new g("gift", { fontCharacter: "\\eaf9" });
g.gistSecret = new g("gist-secret", { fontCharacter: "\\eafa" });
g.gist = new g("gist", { fontCharacter: "\\eafb" });
g.gitCommit = new g("git-commit", { fontCharacter: "\\eafc" });
g.gitCompare = new g("git-compare", { fontCharacter: "\\eafd" });
g.gitMerge = new g("git-merge", { fontCharacter: "\\eafe" });
g.githubAction = new g("github-action", { fontCharacter: "\\eaff" });
g.githubAlt = new g("github-alt", { fontCharacter: "\\eb00" });
g.globe = new g("globe", { fontCharacter: "\\eb01" });
g.grabber = new g("grabber", { fontCharacter: "\\eb02" });
g.graph = new g("graph", { fontCharacter: "\\eb03" });
g.gripper = new g("gripper", { fontCharacter: "\\eb04" });
g.heart = new g("heart", { fontCharacter: "\\eb05" });
g.home = new g("home", { fontCharacter: "\\eb06" });
g.horizontalRule = new g("horizontal-rule", { fontCharacter: "\\eb07" });
g.hubot = new g("hubot", { fontCharacter: "\\eb08" });
g.inbox = new g("inbox", { fontCharacter: "\\eb09" });
g.issueClosed = new g("issue-closed", { fontCharacter: "\\eba4" });
g.issueReopened = new g("issue-reopened", { fontCharacter: "\\eb0b" });
g.issues = new g("issues", { fontCharacter: "\\eb0c" });
g.italic = new g("italic", { fontCharacter: "\\eb0d" });
g.jersey = new g("jersey", { fontCharacter: "\\eb0e" });
g.json = new g("json", { fontCharacter: "\\eb0f" });
g.kebabVertical = new g("kebab-vertical", { fontCharacter: "\\eb10" });
g.key = new g("key", { fontCharacter: "\\eb11" });
g.law = new g("law", { fontCharacter: "\\eb12" });
g.lightbulbAutofix = new g("lightbulb-autofix", { fontCharacter: "\\eb13" });
g.linkExternal = new g("link-external", { fontCharacter: "\\eb14" });
g.link = new g("link", { fontCharacter: "\\eb15" });
g.listOrdered = new g("list-ordered", { fontCharacter: "\\eb16" });
g.listUnordered = new g("list-unordered", { fontCharacter: "\\eb17" });
g.liveShare = new g("live-share", { fontCharacter: "\\eb18" });
g.loading = new g("loading", { fontCharacter: "\\eb19" });
g.location = new g("location", { fontCharacter: "\\eb1a" });
g.mailRead = new g("mail-read", { fontCharacter: "\\eb1b" });
g.mail = new g("mail", { fontCharacter: "\\eb1c" });
g.markdown = new g("markdown", { fontCharacter: "\\eb1d" });
g.megaphone = new g("megaphone", { fontCharacter: "\\eb1e" });
g.mention = new g("mention", { fontCharacter: "\\eb1f" });
g.milestone = new g("milestone", { fontCharacter: "\\eb20" });
g.mortarBoard = new g("mortar-board", { fontCharacter: "\\eb21" });
g.move = new g("move", { fontCharacter: "\\eb22" });
g.multipleWindows = new g("multiple-windows", { fontCharacter: "\\eb23" });
g.mute = new g("mute", { fontCharacter: "\\eb24" });
g.noNewline = new g("no-newline", { fontCharacter: "\\eb25" });
g.note = new g("note", { fontCharacter: "\\eb26" });
g.octoface = new g("octoface", { fontCharacter: "\\eb27" });
g.openPreview = new g("open-preview", { fontCharacter: "\\eb28" });
g.package_ = new g("package", { fontCharacter: "\\eb29" });
g.paintcan = new g("paintcan", { fontCharacter: "\\eb2a" });
g.pin = new g("pin", { fontCharacter: "\\eb2b" });
g.play = new g("play", { fontCharacter: "\\eb2c" });
g.run = new g("run", { fontCharacter: "\\eb2c" });
g.plug = new g("plug", { fontCharacter: "\\eb2d" });
g.preserveCase = new g("preserve-case", { fontCharacter: "\\eb2e" });
g.preview = new g("preview", { fontCharacter: "\\eb2f" });
g.project = new g("project", { fontCharacter: "\\eb30" });
g.pulse = new g("pulse", { fontCharacter: "\\eb31" });
g.question = new g("question", { fontCharacter: "\\eb32" });
g.quote = new g("quote", { fontCharacter: "\\eb33" });
g.radioTower = new g("radio-tower", { fontCharacter: "\\eb34" });
g.reactions = new g("reactions", { fontCharacter: "\\eb35" });
g.references = new g("references", { fontCharacter: "\\eb36" });
g.refresh = new g("refresh", { fontCharacter: "\\eb37" });
g.regex = new g("regex", { fontCharacter: "\\eb38" });
g.remoteExplorer = new g("remote-explorer", { fontCharacter: "\\eb39" });
g.remote = new g("remote", { fontCharacter: "\\eb3a" });
g.remove = new g("remove", { fontCharacter: "\\eb3b" });
g.replaceAll = new g("replace-all", { fontCharacter: "\\eb3c" });
g.replace = new g("replace", { fontCharacter: "\\eb3d" });
g.repoClone = new g("repo-clone", { fontCharacter: "\\eb3e" });
g.repoForcePush = new g("repo-force-push", { fontCharacter: "\\eb3f" });
g.repoPull = new g("repo-pull", { fontCharacter: "\\eb40" });
g.repoPush = new g("repo-push", { fontCharacter: "\\eb41" });
g.report = new g("report", { fontCharacter: "\\eb42" });
g.requestChanges = new g("request-changes", { fontCharacter: "\\eb43" });
g.rocket = new g("rocket", { fontCharacter: "\\eb44" });
g.rootFolderOpened = new g("root-folder-opened", { fontCharacter: "\\eb45" });
g.rootFolder = new g("root-folder", { fontCharacter: "\\eb46" });
g.rss = new g("rss", { fontCharacter: "\\eb47" });
g.ruby = new g("ruby", { fontCharacter: "\\eb48" });
g.saveAll = new g("save-all", { fontCharacter: "\\eb49" });
g.saveAs = new g("save-as", { fontCharacter: "\\eb4a" });
g.save = new g("save", { fontCharacter: "\\eb4b" });
g.screenFull = new g("screen-full", { fontCharacter: "\\eb4c" });
g.screenNormal = new g("screen-normal", { fontCharacter: "\\eb4d" });
g.searchStop = new g("search-stop", { fontCharacter: "\\eb4e" });
g.server = new g("server", { fontCharacter: "\\eb50" });
g.settingsGear = new g("settings-gear", { fontCharacter: "\\eb51" });
g.settings = new g("settings", { fontCharacter: "\\eb52" });
g.shield = new g("shield", { fontCharacter: "\\eb53" });
g.smiley = new g("smiley", { fontCharacter: "\\eb54" });
g.sortPrecedence = new g("sort-precedence", { fontCharacter: "\\eb55" });
g.splitHorizontal = new g("split-horizontal", { fontCharacter: "\\eb56" });
g.splitVertical = new g("split-vertical", { fontCharacter: "\\eb57" });
g.squirrel = new g("squirrel", { fontCharacter: "\\eb58" });
g.starFull = new g("star-full", { fontCharacter: "\\eb59" });
g.starHalf = new g("star-half", { fontCharacter: "\\eb5a" });
g.symbolClass = new g("symbol-class", { fontCharacter: "\\eb5b" });
g.symbolColor = new g("symbol-color", { fontCharacter: "\\eb5c" });
g.symbolCustomColor = new g("symbol-customcolor", { fontCharacter: "\\eb5c" });
g.symbolConstant = new g("symbol-constant", { fontCharacter: "\\eb5d" });
g.symbolEnumMember = new g("symbol-enum-member", { fontCharacter: "\\eb5e" });
g.symbolField = new g("symbol-field", { fontCharacter: "\\eb5f" });
g.symbolFile = new g("symbol-file", { fontCharacter: "\\eb60" });
g.symbolInterface = new g("symbol-interface", { fontCharacter: "\\eb61" });
g.symbolKeyword = new g("symbol-keyword", { fontCharacter: "\\eb62" });
g.symbolMisc = new g("symbol-misc", { fontCharacter: "\\eb63" });
g.symbolOperator = new g("symbol-operator", { fontCharacter: "\\eb64" });
g.symbolProperty = new g("symbol-property", { fontCharacter: "\\eb65" });
g.wrench = new g("wrench", { fontCharacter: "\\eb65" });
g.wrenchSubaction = new g("wrench-subaction", { fontCharacter: "\\eb65" });
g.symbolSnippet = new g("symbol-snippet", { fontCharacter: "\\eb66" });
g.tasklist = new g("tasklist", { fontCharacter: "\\eb67" });
g.telescope = new g("telescope", { fontCharacter: "\\eb68" });
g.textSize = new g("text-size", { fontCharacter: "\\eb69" });
g.threeBars = new g("three-bars", { fontCharacter: "\\eb6a" });
g.thumbsdown = new g("thumbsdown", { fontCharacter: "\\eb6b" });
g.thumbsup = new g("thumbsup", { fontCharacter: "\\eb6c" });
g.tools = new g("tools", { fontCharacter: "\\eb6d" });
g.triangleDown = new g("triangle-down", { fontCharacter: "\\eb6e" });
g.triangleLeft = new g("triangle-left", { fontCharacter: "\\eb6f" });
g.triangleRight = new g("triangle-right", { fontCharacter: "\\eb70" });
g.triangleUp = new g("triangle-up", { fontCharacter: "\\eb71" });
g.twitter = new g("twitter", { fontCharacter: "\\eb72" });
g.unfold = new g("unfold", { fontCharacter: "\\eb73" });
g.unlock = new g("unlock", { fontCharacter: "\\eb74" });
g.unmute = new g("unmute", { fontCharacter: "\\eb75" });
g.unverified = new g("unverified", { fontCharacter: "\\eb76" });
g.verified = new g("verified", { fontCharacter: "\\eb77" });
g.versions = new g("versions", { fontCharacter: "\\eb78" });
g.vmActive = new g("vm-active", { fontCharacter: "\\eb79" });
g.vmOutline = new g("vm-outline", { fontCharacter: "\\eb7a" });
g.vmRunning = new g("vm-running", { fontCharacter: "\\eb7b" });
g.watch = new g("watch", { fontCharacter: "\\eb7c" });
g.whitespace = new g("whitespace", { fontCharacter: "\\eb7d" });
g.wholeWord = new g("whole-word", { fontCharacter: "\\eb7e" });
g.window = new g("window", { fontCharacter: "\\eb7f" });
g.wordWrap = new g("word-wrap", { fontCharacter: "\\eb80" });
g.zoomIn = new g("zoom-in", { fontCharacter: "\\eb81" });
g.zoomOut = new g("zoom-out", { fontCharacter: "\\eb82" });
g.listFilter = new g("list-filter", { fontCharacter: "\\eb83" });
g.listFlat = new g("list-flat", { fontCharacter: "\\eb84" });
g.listSelection = new g("list-selection", { fontCharacter: "\\eb85" });
g.selection = new g("selection", { fontCharacter: "\\eb85" });
g.listTree = new g("list-tree", { fontCharacter: "\\eb86" });
g.debugBreakpointFunctionUnverified = new g("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" });
g.debugBreakpointFunction = new g("debug-breakpoint-function", { fontCharacter: "\\eb88" });
g.debugBreakpointFunctionDisabled = new g("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" });
g.debugStackframeActive = new g("debug-stackframe-active", { fontCharacter: "\\eb89" });
g.circleSmallFilled = new g("circle-small-filled", { fontCharacter: "\\eb8a" });
g.debugStackframeDot = new g("debug-stackframe-dot", g.circleSmallFilled.definition);
g.debugStackframe = new g("debug-stackframe", { fontCharacter: "\\eb8b" });
g.debugStackframeFocused = new g("debug-stackframe-focused", { fontCharacter: "\\eb8b" });
g.debugBreakpointUnsupported = new g("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" });
g.symbolString = new g("symbol-string", { fontCharacter: "\\eb8d" });
g.debugReverseContinue = new g("debug-reverse-continue", { fontCharacter: "\\eb8e" });
g.debugStepBack = new g("debug-step-back", { fontCharacter: "\\eb8f" });
g.debugRestartFrame = new g("debug-restart-frame", { fontCharacter: "\\eb90" });
g.callIncoming = new g("call-incoming", { fontCharacter: "\\eb92" });
g.callOutgoing = new g("call-outgoing", { fontCharacter: "\\eb93" });
g.menu = new g("menu", { fontCharacter: "\\eb94" });
g.expandAll = new g("expand-all", { fontCharacter: "\\eb95" });
g.feedback = new g("feedback", { fontCharacter: "\\eb96" });
g.groupByRefType = new g("group-by-ref-type", { fontCharacter: "\\eb97" });
g.ungroupByRefType = new g("ungroup-by-ref-type", { fontCharacter: "\\eb98" });
g.account = new g("account", { fontCharacter: "\\eb99" });
g.bellDot = new g("bell-dot", { fontCharacter: "\\eb9a" });
g.debugConsole = new g("debug-console", { fontCharacter: "\\eb9b" });
g.library = new g("library", { fontCharacter: "\\eb9c" });
g.output = new g("output", { fontCharacter: "\\eb9d" });
g.runAll = new g("run-all", { fontCharacter: "\\eb9e" });
g.syncIgnored = new g("sync-ignored", { fontCharacter: "\\eb9f" });
g.pinned = new g("pinned", { fontCharacter: "\\eba0" });
g.githubInverted = new g("github-inverted", { fontCharacter: "\\eba1" });
g.debugAlt = new g("debug-alt", { fontCharacter: "\\eb91" });
g.serverProcess = new g("server-process", { fontCharacter: "\\eba2" });
g.serverEnvironment = new g("server-environment", { fontCharacter: "\\eba3" });
g.pass = new g("pass", { fontCharacter: "\\eba4" });
g.stopCircle = new g("stop-circle", { fontCharacter: "\\eba5" });
g.playCircle = new g("play-circle", { fontCharacter: "\\eba6" });
g.record = new g("record", { fontCharacter: "\\eba7" });
g.debugAltSmall = new g("debug-alt-small", { fontCharacter: "\\eba8" });
g.vmConnect = new g("vm-connect", { fontCharacter: "\\eba9" });
g.cloud = new g("cloud", { fontCharacter: "\\ebaa" });
g.merge = new g("merge", { fontCharacter: "\\ebab" });
g.exportIcon = new g("export", { fontCharacter: "\\ebac" });
g.graphLeft = new g("graph-left", { fontCharacter: "\\ebad" });
g.magnet = new g("magnet", { fontCharacter: "\\ebae" });
g.notebook = new g("notebook", { fontCharacter: "\\ebaf" });
g.redo = new g("redo", { fontCharacter: "\\ebb0" });
g.checkAll = new g("check-all", { fontCharacter: "\\ebb1" });
g.pinnedDirty = new g("pinned-dirty", { fontCharacter: "\\ebb2" });
g.passFilled = new g("pass-filled", { fontCharacter: "\\ebb3" });
g.circleLargeFilled = new g("circle-large-filled", { fontCharacter: "\\ebb4" });
g.circleLargeOutline = new g("circle-large-outline", { fontCharacter: "\\ebb5" });
g.combine = new g("combine", { fontCharacter: "\\ebb6" });
g.gather = new g("gather", { fontCharacter: "\\ebb6" });
g.table = new g("table", { fontCharacter: "\\ebb7" });
g.variableGroup = new g("variable-group", { fontCharacter: "\\ebb8" });
g.typeHierarchy = new g("type-hierarchy", { fontCharacter: "\\ebb9" });
g.typeHierarchySub = new g("type-hierarchy-sub", { fontCharacter: "\\ebba" });
g.typeHierarchySuper = new g("type-hierarchy-super", { fontCharacter: "\\ebbb" });
g.gitPullRequestCreate = new g("git-pull-request-create", { fontCharacter: "\\ebbc" });
g.runAbove = new g("run-above", { fontCharacter: "\\ebbd" });
g.runBelow = new g("run-below", { fontCharacter: "\\ebbe" });
g.notebookTemplate = new g("notebook-template", { fontCharacter: "\\ebbf" });
g.debugRerun = new g("debug-rerun", { fontCharacter: "\\ebc0" });
g.workspaceTrusted = new g("workspace-trusted", { fontCharacter: "\\ebc1" });
g.workspaceUntrusted = new g("workspace-untrusted", { fontCharacter: "\\ebc2" });
g.workspaceUnspecified = new g("workspace-unspecified", { fontCharacter: "\\ebc3" });
g.terminalCmd = new g("terminal-cmd", { fontCharacter: "\\ebc4" });
g.terminalDebian = new g("terminal-debian", { fontCharacter: "\\ebc5" });
g.terminalLinux = new g("terminal-linux", { fontCharacter: "\\ebc6" });
g.terminalPowershell = new g("terminal-powershell", { fontCharacter: "\\ebc7" });
g.terminalTmux = new g("terminal-tmux", { fontCharacter: "\\ebc8" });
g.terminalUbuntu = new g("terminal-ubuntu", { fontCharacter: "\\ebc9" });
g.terminalBash = new g("terminal-bash", { fontCharacter: "\\ebca" });
g.arrowSwap = new g("arrow-swap", { fontCharacter: "\\ebcb" });
g.copy = new g("copy", { fontCharacter: "\\ebcc" });
g.personAdd = new g("person-add", { fontCharacter: "\\ebcd" });
g.filterFilled = new g("filter-filled", { fontCharacter: "\\ebce" });
g.wand = new g("wand", { fontCharacter: "\\ebcf" });
g.debugLineByLine = new g("debug-line-by-line", { fontCharacter: "\\ebd0" });
g.inspect = new g("inspect", { fontCharacter: "\\ebd1" });
g.layers = new g("layers", { fontCharacter: "\\ebd2" });
g.layersDot = new g("layers-dot", { fontCharacter: "\\ebd3" });
g.layersActive = new g("layers-active", { fontCharacter: "\\ebd4" });
g.compass = new g("compass", { fontCharacter: "\\ebd5" });
g.compassDot = new g("compass-dot", { fontCharacter: "\\ebd6" });
g.compassActive = new g("compass-active", { fontCharacter: "\\ebd7" });
g.azure = new g("azure", { fontCharacter: "\\ebd8" });
g.issueDraft = new g("issue-draft", { fontCharacter: "\\ebd9" });
g.gitPullRequestClosed = new g("git-pull-request-closed", { fontCharacter: "\\ebda" });
g.gitPullRequestDraft = new g("git-pull-request-draft", { fontCharacter: "\\ebdb" });
g.debugAll = new g("debug-all", { fontCharacter: "\\ebdc" });
g.debugCoverage = new g("debug-coverage", { fontCharacter: "\\ebdd" });
g.runErrors = new g("run-errors", { fontCharacter: "\\ebde" });
g.folderLibrary = new g("folder-library", { fontCharacter: "\\ebdf" });
g.debugContinueSmall = new g("debug-continue-small", { fontCharacter: "\\ebe0" });
g.beakerStop = new g("beaker-stop", { fontCharacter: "\\ebe1" });
g.graphLine = new g("graph-line", { fontCharacter: "\\ebe2" });
g.graphScatter = new g("graph-scatter", { fontCharacter: "\\ebe3" });
g.pieChart = new g("pie-chart", { fontCharacter: "\\ebe4" });
g.bracket = new g("bracket", g.json.definition);
g.bracketDot = new g("bracket-dot", { fontCharacter: "\\ebe5" });
g.bracketError = new g("bracket-error", { fontCharacter: "\\ebe6" });
g.lockSmall = new g("lock-small", { fontCharacter: "\\ebe7" });
g.azureDevops = new g("azure-devops", { fontCharacter: "\\ebe8" });
g.verifiedFilled = new g("verified-filled", { fontCharacter: "\\ebe9" });
g.newLine = new g("newline", { fontCharacter: "\\ebea" });
g.layout = new g("layout", { fontCharacter: "\\ebeb" });
g.layoutActivitybarLeft = new g("layout-activitybar-left", { fontCharacter: "\\ebec" });
g.layoutActivitybarRight = new g("layout-activitybar-right", { fontCharacter: "\\ebed" });
g.layoutPanelLeft = new g("layout-panel-left", { fontCharacter: "\\ebee" });
g.layoutPanelCenter = new g("layout-panel-center", { fontCharacter: "\\ebef" });
g.layoutPanelJustify = new g("layout-panel-justify", { fontCharacter: "\\ebf0" });
g.layoutPanelRight = new g("layout-panel-right", { fontCharacter: "\\ebf1" });
g.layoutPanel = new g("layout-panel", { fontCharacter: "\\ebf2" });
g.layoutSidebarLeft = new g("layout-sidebar-left", { fontCharacter: "\\ebf3" });
g.layoutSidebarRight = new g("layout-sidebar-right", { fontCharacter: "\\ebf4" });
g.layoutStatusbar = new g("layout-statusbar", { fontCharacter: "\\ebf5" });
g.layoutMenubar = new g("layout-menubar", { fontCharacter: "\\ebf6" });
g.layoutCentered = new g("layout-centered", { fontCharacter: "\\ebf7" });
g.layoutSidebarRightOff = new g("layout-sidebar-right-off", { fontCharacter: "\\ec00" });
g.layoutPanelOff = new g("layout-panel-off", { fontCharacter: "\\ec01" });
g.layoutSidebarLeftOff = new g("layout-sidebar-left-off", { fontCharacter: "\\ec02" });
g.target = new g("target", { fontCharacter: "\\ebf8" });
g.indent = new g("indent", { fontCharacter: "\\ebf9" });
g.recordSmall = new g("record-small", { fontCharacter: "\\ebfa" });
g.errorSmall = new g("error-small", { fontCharacter: "\\ebfb" });
g.arrowCircleDown = new g("arrow-circle-down", { fontCharacter: "\\ebfc" });
g.arrowCircleLeft = new g("arrow-circle-left", { fontCharacter: "\\ebfd" });
g.arrowCircleRight = new g("arrow-circle-right", { fontCharacter: "\\ebfe" });
g.arrowCircleUp = new g("arrow-circle-up", { fontCharacter: "\\ebff" });
g.heartFilled = new g("heart-filled", { fontCharacter: "\\ec04" });
g.map = new g("map", { fontCharacter: "\\ec05" });
g.mapFilled = new g("map-filled", { fontCharacter: "\\ec06" });
g.circleSmall = new g("circle-small", { fontCharacter: "\\ec07" });
g.bellSlash = new g("bell-slash", { fontCharacter: "\\ec08" });
g.bellSlashDot = new g("bell-slash-dot", { fontCharacter: "\\ec09" });
g.commentUnresolved = new g("comment-unresolved", { fontCharacter: "\\ec0a" });
g.gitPullRequestGoToChanges = new g("git-pull-request-go-to-changes", { fontCharacter: "\\ec0b" });
g.gitPullRequestNewChanges = new g("git-pull-request-new-changes", { fontCharacter: "\\ec0c" });
g.dialogError = new g("dialog-error", g.error.definition);
g.dialogWarning = new g("dialog-warning", g.warning.definition);
g.dialogInfo = new g("dialog-info", g.info.definition);
g.dialogClose = new g("dialog-close", g.close.definition);
g.treeItemExpanded = new g("tree-item-expanded", g.chevronDown.definition);
g.treeFilterOnTypeOn = new g("tree-filter-on-type-on", g.listFilter.definition);
g.treeFilterOnTypeOff = new g("tree-filter-on-type-off", g.listSelection.definition);
g.treeFilterClear = new g("tree-filter-clear", g.close.definition);
g.treeItemLoading = new g("tree-item-loading", g.loading.definition);
g.menuSelection = new g("menu-selection", g.check.definition);
g.menuSubmenu = new g("menu-submenu", g.chevronRight.definition);
g.menuBarMore = new g("menubar-more", g.more.definition);
g.scrollbarButtonLeft = new g("scrollbar-button-left", g.triangleLeft.definition);
g.scrollbarButtonRight = new g("scrollbar-button-right", g.triangleRight.definition);
g.scrollbarButtonUp = new g("scrollbar-button-up", g.triangleUp.definition);
g.scrollbarButtonDown = new g("scrollbar-button-down", g.triangleDown.definition);
g.toolBarMore = new g("toolbar-more", g.more.definition);
g.quickInputBack = new g("quick-input-back", g.arrowLeft.definition);
var Di;
(function(s) {
  s.iconNameSegment = "[A-Za-z0-9]+", s.iconNameExpression = "[A-Za-z0-9-]+", s.iconModifierExpression = "~[A-Za-z]+", s.iconNameCharacter = "[A-Za-z0-9~-]";
  const e = new RegExp(`^(${s.iconNameExpression})(${s.iconModifierExpression})?$`);
  function t(r) {
    if (r instanceof g)
      return ["codicon", "codicon-" + r.id];
    const o = e.exec(r.id);
    if (!o)
      return t(g.error);
    const [, a, l] = o, c = ["codicon", "codicon-" + a];
    return l && c.push("codicon-modifier-" + l.substr(1)), c;
  }
  s.asClassNameArray = t;
  function i(r) {
    return t(r).join(" ");
  }
  s.asClassName = i;
  function n(r) {
    return "." + t(r).join(".");
  }
  s.asCSSSelector = n;
})(Di || (Di = {}));
var m_ = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class bT {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  fire(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, t) {
    return this._map.set(e, t), this.fire([e]), ze(() => {
      this._map.get(e) === t && (this._map.delete(e), this.fire([e]));
    });
  }
  registerFactory(e, t) {
    var i;
    (i = this._factories.get(e)) === null || i === void 0 || i.dispose();
    const n = new CT(this, e, t);
    return this._factories.set(e, n), ze(() => {
      const r = this._factories.get(e);
      !r || r !== n || (this._factories.delete(e), r.dispose());
    });
  }
  getOrCreate(e) {
    return m_(this, void 0, void 0, function* () {
      const t = this.get(e);
      if (t)
        return t;
      const i = this._factories.get(e);
      return !i || i.isResolved ? null : (yield i.resolve(), this.get(e));
    });
  }
  get(e) {
    return this._map.get(e) || null;
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const i = this._factories.get(e);
    return !!(!i || i.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._map.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[2] : null;
  }
}
class CT extends z {
  constructor(e, t, i) {
    super(), this._registry = e, this._languageId = t, this._factory = i, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  get isResolved() {
    return this._isResolved;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  resolve() {
    return m_(this, void 0, void 0, function* () {
      return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
    });
  }
  _create() {
    return m_(this, void 0, void 0, function* () {
      const e = yield Promise.resolve(this._factory.createTokenizationSupport());
      this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
    });
  }
}
class Nh {
  constructor(e, t, i) {
    this._tokenBrand = void 0, this.offset = e, this.type = t, this.language = i;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
}
class vb {
  constructor(e, t) {
    this._tokenizationResultBrand = void 0, this.tokens = e, this.endState = t;
  }
}
class Ig {
  constructor(e, t) {
    this._encodedTokenizationResultBrand = void 0, this.tokens = e, this.endState = t;
  }
}
var Hv;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, g.symbolMethod), e.set(1, g.symbolFunction), e.set(2, g.symbolConstructor), e.set(3, g.symbolField), e.set(4, g.symbolVariable), e.set(5, g.symbolClass), e.set(6, g.symbolStruct), e.set(7, g.symbolInterface), e.set(8, g.symbolModule), e.set(9, g.symbolProperty), e.set(10, g.symbolEvent), e.set(11, g.symbolOperator), e.set(12, g.symbolUnit), e.set(13, g.symbolValue), e.set(15, g.symbolEnum), e.set(14, g.symbolConstant), e.set(15, g.symbolEnum), e.set(16, g.symbolEnumMember), e.set(17, g.symbolKeyword), e.set(27, g.symbolSnippet), e.set(18, g.symbolText), e.set(19, g.symbolColor), e.set(20, g.symbolFile), e.set(21, g.symbolReference), e.set(22, g.symbolCustomColor), e.set(23, g.symbolFolder), e.set(24, g.symbolTypeParameter), e.set(25, g.account), e.set(26, g.issues);
  function t(r) {
    let o = e.get(r);
    return o || (console.info("No codicon found for CompletionItemKind " + r), o = g.symbolProperty), o;
  }
  s.toIcon = t;
  const i = /* @__PURE__ */ new Map();
  i.set("method", 0), i.set("function", 1), i.set("constructor", 2), i.set("field", 3), i.set("variable", 4), i.set("class", 5), i.set("struct", 6), i.set("interface", 7), i.set("module", 8), i.set("property", 9), i.set("event", 10), i.set("operator", 11), i.set("unit", 12), i.set("value", 13), i.set("constant", 14), i.set("enum", 15), i.set("enum-member", 16), i.set("enumMember", 16), i.set("keyword", 17), i.set("snippet", 27), i.set("text", 18), i.set("color", 19), i.set("file", 20), i.set("reference", 21), i.set("customcolor", 22), i.set("folder", 23), i.set("type-parameter", 24), i.set("typeParameter", 24), i.set("account", 25), i.set("issue", 26);
  function n(r, o) {
    let a = i.get(r);
    return typeof a > "u" && !o && (a = 9), a;
  }
  s.fromString = n;
})(Hv || (Hv = {}));
var zv;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(zv || (zv = {}));
var Uv;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(Uv || (Uv = {}));
var $v;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})($v || ($v = {}));
var jv;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, g.symbolFile), e.set(1, g.symbolModule), e.set(2, g.symbolNamespace), e.set(3, g.symbolPackage), e.set(4, g.symbolClass), e.set(5, g.symbolMethod), e.set(6, g.symbolProperty), e.set(7, g.symbolField), e.set(8, g.symbolConstructor), e.set(9, g.symbolEnum), e.set(10, g.symbolInterface), e.set(11, g.symbolFunction), e.set(12, g.symbolVariable), e.set(13, g.symbolConstant), e.set(14, g.symbolString), e.set(15, g.symbolNumber), e.set(16, g.symbolBoolean), e.set(17, g.symbolArray), e.set(18, g.symbolObject), e.set(19, g.symbolKey), e.set(20, g.symbolNull), e.set(21, g.symbolEnumMember), e.set(22, g.symbolStruct), e.set(23, g.symbolEvent), e.set(24, g.symbolOperator), e.set(25, g.symbolTypeParameter);
  function t(i) {
    let n = e.get(i);
    return n || (console.info("No codicon found for SymbolKind " + i), n = g.symbolProperty), n;
  }
  s.toIcon = t;
})(jv || (jv = {}));
class Qo {
  constructor(e) {
    this.value = e;
  }
}
Qo.Comment = new Qo("comment");
Qo.Imports = new Qo("imports");
Qo.Region = new Qo("region");
var Kv;
(function(s) {
  function e(t) {
    return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string";
  }
  s.is = e;
})(Kv || (Kv = {}));
var qv;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(qv || (qv = {}));
const at = new bT();
var p_;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Disabled = 1] = "Disabled", s[s.Enabled = 2] = "Enabled";
})(p_ || (p_ = {}));
var __;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.Auto = 2] = "Auto";
})(__ || (__ = {}));
var b_;
(function(s) {
  s[s.KeepWhitespace = 1] = "KeepWhitespace", s[s.InsertAsSnippet = 4] = "InsertAsSnippet";
})(b_ || (b_ = {}));
var C_;
(function(s) {
  s[s.Method = 0] = "Method", s[s.Function = 1] = "Function", s[s.Constructor = 2] = "Constructor", s[s.Field = 3] = "Field", s[s.Variable = 4] = "Variable", s[s.Class = 5] = "Class", s[s.Struct = 6] = "Struct", s[s.Interface = 7] = "Interface", s[s.Module = 8] = "Module", s[s.Property = 9] = "Property", s[s.Event = 10] = "Event", s[s.Operator = 11] = "Operator", s[s.Unit = 12] = "Unit", s[s.Value = 13] = "Value", s[s.Constant = 14] = "Constant", s[s.Enum = 15] = "Enum", s[s.EnumMember = 16] = "EnumMember", s[s.Keyword = 17] = "Keyword", s[s.Text = 18] = "Text", s[s.Color = 19] = "Color", s[s.File = 20] = "File", s[s.Reference = 21] = "Reference", s[s.Customcolor = 22] = "Customcolor", s[s.Folder = 23] = "Folder", s[s.TypeParameter = 24] = "TypeParameter", s[s.User = 25] = "User", s[s.Issue = 26] = "Issue", s[s.Snippet = 27] = "Snippet";
})(C_ || (C_ = {}));
var v_;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(v_ || (v_ = {}));
var w_;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.TriggerCharacter = 1] = "TriggerCharacter", s[s.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(w_ || (w_ = {}));
var S_;
(function(s) {
  s[s.EXACT = 0] = "EXACT", s[s.ABOVE = 1] = "ABOVE", s[s.BELOW = 2] = "BELOW";
})(S_ || (S_ = {}));
var y_;
(function(s) {
  s[s.NotSet = 0] = "NotSet", s[s.ContentFlush = 1] = "ContentFlush", s[s.RecoverFromMarkers = 2] = "RecoverFromMarkers", s[s.Explicit = 3] = "Explicit", s[s.Paste = 4] = "Paste", s[s.Undo = 5] = "Undo", s[s.Redo = 6] = "Redo";
})(y_ || (y_ = {}));
var L_;
(function(s) {
  s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(L_ || (L_ = {}));
var k_;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(k_ || (k_ = {}));
var D_;
(function(s) {
  s[s.None = 0] = "None", s[s.Keep = 1] = "Keep", s[s.Brackets = 2] = "Brackets", s[s.Advanced = 3] = "Advanced", s[s.Full = 4] = "Full";
})(D_ || (D_ = {}));
var E_;
(function(s) {
  s[s.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", s[s.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", s[s.accessibilitySupport = 2] = "accessibilitySupport", s[s.accessibilityPageSize = 3] = "accessibilityPageSize", s[s.ariaLabel = 4] = "ariaLabel", s[s.autoClosingBrackets = 5] = "autoClosingBrackets", s[s.autoClosingDelete = 6] = "autoClosingDelete", s[s.autoClosingOvertype = 7] = "autoClosingOvertype", s[s.autoClosingQuotes = 8] = "autoClosingQuotes", s[s.autoIndent = 9] = "autoIndent", s[s.automaticLayout = 10] = "automaticLayout", s[s.autoSurround = 11] = "autoSurround", s[s.bracketPairColorization = 12] = "bracketPairColorization", s[s.guides = 13] = "guides", s[s.codeLens = 14] = "codeLens", s[s.codeLensFontFamily = 15] = "codeLensFontFamily", s[s.codeLensFontSize = 16] = "codeLensFontSize", s[s.colorDecorators = 17] = "colorDecorators", s[s.columnSelection = 18] = "columnSelection", s[s.comments = 19] = "comments", s[s.contextmenu = 20] = "contextmenu", s[s.copyWithSyntaxHighlighting = 21] = "copyWithSyntaxHighlighting", s[s.cursorBlinking = 22] = "cursorBlinking", s[s.cursorSmoothCaretAnimation = 23] = "cursorSmoothCaretAnimation", s[s.cursorStyle = 24] = "cursorStyle", s[s.cursorSurroundingLines = 25] = "cursorSurroundingLines", s[s.cursorSurroundingLinesStyle = 26] = "cursorSurroundingLinesStyle", s[s.cursorWidth = 27] = "cursorWidth", s[s.disableLayerHinting = 28] = "disableLayerHinting", s[s.disableMonospaceOptimizations = 29] = "disableMonospaceOptimizations", s[s.domReadOnly = 30] = "domReadOnly", s[s.dragAndDrop = 31] = "dragAndDrop", s[s.dropIntoEditor = 32] = "dropIntoEditor", s[s.emptySelectionClipboard = 33] = "emptySelectionClipboard", s[s.experimental = 34] = "experimental", s[s.extraEditorClassName = 35] = "extraEditorClassName", s[s.fastScrollSensitivity = 36] = "fastScrollSensitivity", s[s.find = 37] = "find", s[s.fixedOverflowWidgets = 38] = "fixedOverflowWidgets", s[s.folding = 39] = "folding", s[s.foldingStrategy = 40] = "foldingStrategy", s[s.foldingHighlight = 41] = "foldingHighlight", s[s.foldingImportsByDefault = 42] = "foldingImportsByDefault", s[s.foldingMaximumRegions = 43] = "foldingMaximumRegions", s[s.unfoldOnClickAfterEndOfLine = 44] = "unfoldOnClickAfterEndOfLine", s[s.fontFamily = 45] = "fontFamily", s[s.fontInfo = 46] = "fontInfo", s[s.fontLigatures = 47] = "fontLigatures", s[s.fontSize = 48] = "fontSize", s[s.fontWeight = 49] = "fontWeight", s[s.formatOnPaste = 50] = "formatOnPaste", s[s.formatOnType = 51] = "formatOnType", s[s.glyphMargin = 52] = "glyphMargin", s[s.gotoLocation = 53] = "gotoLocation", s[s.hideCursorInOverviewRuler = 54] = "hideCursorInOverviewRuler", s[s.hover = 55] = "hover", s[s.inDiffEditor = 56] = "inDiffEditor", s[s.inlineSuggest = 57] = "inlineSuggest", s[s.letterSpacing = 58] = "letterSpacing", s[s.lightbulb = 59] = "lightbulb", s[s.lineDecorationsWidth = 60] = "lineDecorationsWidth", s[s.lineHeight = 61] = "lineHeight", s[s.lineNumbers = 62] = "lineNumbers", s[s.lineNumbersMinChars = 63] = "lineNumbersMinChars", s[s.linkedEditing = 64] = "linkedEditing", s[s.links = 65] = "links", s[s.matchBrackets = 66] = "matchBrackets", s[s.minimap = 67] = "minimap", s[s.mouseStyle = 68] = "mouseStyle", s[s.mouseWheelScrollSensitivity = 69] = "mouseWheelScrollSensitivity", s[s.mouseWheelZoom = 70] = "mouseWheelZoom", s[s.multiCursorMergeOverlapping = 71] = "multiCursorMergeOverlapping", s[s.multiCursorModifier = 72] = "multiCursorModifier", s[s.multiCursorPaste = 73] = "multiCursorPaste", s[s.occurrencesHighlight = 74] = "occurrencesHighlight", s[s.overviewRulerBorder = 75] = "overviewRulerBorder", s[s.overviewRulerLanes = 76] = "overviewRulerLanes", s[s.padding = 77] = "padding", s[s.parameterHints = 78] = "parameterHints", s[s.peekWidgetDefaultFocus = 79] = "peekWidgetDefaultFocus", s[s.definitionLinkOpensInPeek = 80] = "definitionLinkOpensInPeek", s[s.quickSuggestions = 81] = "quickSuggestions", s[s.quickSuggestionsDelay = 82] = "quickSuggestionsDelay", s[s.readOnly = 83] = "readOnly", s[s.renameOnType = 84] = "renameOnType", s[s.renderControlCharacters = 85] = "renderControlCharacters", s[s.renderFinalNewline = 86] = "renderFinalNewline", s[s.renderLineHighlight = 87] = "renderLineHighlight", s[s.renderLineHighlightOnlyWhenFocus = 88] = "renderLineHighlightOnlyWhenFocus", s[s.renderValidationDecorations = 89] = "renderValidationDecorations", s[s.renderWhitespace = 90] = "renderWhitespace", s[s.revealHorizontalRightPadding = 91] = "revealHorizontalRightPadding", s[s.roundedSelection = 92] = "roundedSelection", s[s.rulers = 93] = "rulers", s[s.scrollbar = 94] = "scrollbar", s[s.scrollBeyondLastColumn = 95] = "scrollBeyondLastColumn", s[s.scrollBeyondLastLine = 96] = "scrollBeyondLastLine", s[s.scrollPredominantAxis = 97] = "scrollPredominantAxis", s[s.selectionClipboard = 98] = "selectionClipboard", s[s.selectionHighlight = 99] = "selectionHighlight", s[s.selectOnLineNumbers = 100] = "selectOnLineNumbers", s[s.showFoldingControls = 101] = "showFoldingControls", s[s.showUnused = 102] = "showUnused", s[s.snippetSuggestions = 103] = "snippetSuggestions", s[s.smartSelect = 104] = "smartSelect", s[s.smoothScrolling = 105] = "smoothScrolling", s[s.stickyTabStops = 106] = "stickyTabStops", s[s.stopRenderingLineAfter = 107] = "stopRenderingLineAfter", s[s.suggest = 108] = "suggest", s[s.suggestFontSize = 109] = "suggestFontSize", s[s.suggestLineHeight = 110] = "suggestLineHeight", s[s.suggestOnTriggerCharacters = 111] = "suggestOnTriggerCharacters", s[s.suggestSelection = 112] = "suggestSelection", s[s.tabCompletion = 113] = "tabCompletion", s[s.tabIndex = 114] = "tabIndex", s[s.unicodeHighlighting = 115] = "unicodeHighlighting", s[s.unusualLineTerminators = 116] = "unusualLineTerminators", s[s.useShadowDOM = 117] = "useShadowDOM", s[s.useTabStops = 118] = "useTabStops", s[s.wordSeparators = 119] = "wordSeparators", s[s.wordWrap = 120] = "wordWrap", s[s.wordWrapBreakAfterCharacters = 121] = "wordWrapBreakAfterCharacters", s[s.wordWrapBreakBeforeCharacters = 122] = "wordWrapBreakBeforeCharacters", s[s.wordWrapColumn = 123] = "wordWrapColumn", s[s.wordWrapOverride1 = 124] = "wordWrapOverride1", s[s.wordWrapOverride2 = 125] = "wordWrapOverride2", s[s.wrappingIndent = 126] = "wrappingIndent", s[s.wrappingStrategy = 127] = "wrappingStrategy", s[s.showDeprecated = 128] = "showDeprecated", s[s.inlayHints = 129] = "inlayHints", s[s.editorClassName = 130] = "editorClassName", s[s.pixelRatio = 131] = "pixelRatio", s[s.tabFocusMode = 132] = "tabFocusMode", s[s.layoutInfo = 133] = "layoutInfo", s[s.wrappingInfo = 134] = "wrappingInfo";
})(E_ || (E_ = {}));
var x_;
(function(s) {
  s[s.TextDefined = 0] = "TextDefined", s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(x_ || (x_ = {}));
var I_;
(function(s) {
  s[s.LF = 0] = "LF", s[s.CRLF = 1] = "CRLF";
})(I_ || (I_ = {}));
var N_;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(N_ || (N_ = {}));
var T_;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(T_ || (T_ = {}));
var M_;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(M_ || (M_ = {}));
var A_;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(A_ || (A_ = {}));
var R_;
(function(s) {
  s[s.DependsOnKbLayout = -1] = "DependsOnKbLayout", s[s.Unknown = 0] = "Unknown", s[s.Backspace = 1] = "Backspace", s[s.Tab = 2] = "Tab", s[s.Enter = 3] = "Enter", s[s.Shift = 4] = "Shift", s[s.Ctrl = 5] = "Ctrl", s[s.Alt = 6] = "Alt", s[s.PauseBreak = 7] = "PauseBreak", s[s.CapsLock = 8] = "CapsLock", s[s.Escape = 9] = "Escape", s[s.Space = 10] = "Space", s[s.PageUp = 11] = "PageUp", s[s.PageDown = 12] = "PageDown", s[s.End = 13] = "End", s[s.Home = 14] = "Home", s[s.LeftArrow = 15] = "LeftArrow", s[s.UpArrow = 16] = "UpArrow", s[s.RightArrow = 17] = "RightArrow", s[s.DownArrow = 18] = "DownArrow", s[s.Insert = 19] = "Insert", s[s.Delete = 20] = "Delete", s[s.Digit0 = 21] = "Digit0", s[s.Digit1 = 22] = "Digit1", s[s.Digit2 = 23] = "Digit2", s[s.Digit3 = 24] = "Digit3", s[s.Digit4 = 25] = "Digit4", s[s.Digit5 = 26] = "Digit5", s[s.Digit6 = 27] = "Digit6", s[s.Digit7 = 28] = "Digit7", s[s.Digit8 = 29] = "Digit8", s[s.Digit9 = 30] = "Digit9", s[s.KeyA = 31] = "KeyA", s[s.KeyB = 32] = "KeyB", s[s.KeyC = 33] = "KeyC", s[s.KeyD = 34] = "KeyD", s[s.KeyE = 35] = "KeyE", s[s.KeyF = 36] = "KeyF", s[s.KeyG = 37] = "KeyG", s[s.KeyH = 38] = "KeyH", s[s.KeyI = 39] = "KeyI", s[s.KeyJ = 40] = "KeyJ", s[s.KeyK = 41] = "KeyK", s[s.KeyL = 42] = "KeyL", s[s.KeyM = 43] = "KeyM", s[s.KeyN = 44] = "KeyN", s[s.KeyO = 45] = "KeyO", s[s.KeyP = 46] = "KeyP", s[s.KeyQ = 47] = "KeyQ", s[s.KeyR = 48] = "KeyR", s[s.KeyS = 49] = "KeyS", s[s.KeyT = 50] = "KeyT", s[s.KeyU = 51] = "KeyU", s[s.KeyV = 52] = "KeyV", s[s.KeyW = 53] = "KeyW", s[s.KeyX = 54] = "KeyX", s[s.KeyY = 55] = "KeyY", s[s.KeyZ = 56] = "KeyZ", s[s.Meta = 57] = "Meta", s[s.ContextMenu = 58] = "ContextMenu", s[s.F1 = 59] = "F1", s[s.F2 = 60] = "F2", s[s.F3 = 61] = "F3", s[s.F4 = 62] = "F4", s[s.F5 = 63] = "F5", s[s.F6 = 64] = "F6", s[s.F7 = 65] = "F7", s[s.F8 = 66] = "F8", s[s.F9 = 67] = "F9", s[s.F10 = 68] = "F10", s[s.F11 = 69] = "F11", s[s.F12 = 70] = "F12", s[s.F13 = 71] = "F13", s[s.F14 = 72] = "F14", s[s.F15 = 73] = "F15", s[s.F16 = 74] = "F16", s[s.F17 = 75] = "F17", s[s.F18 = 76] = "F18", s[s.F19 = 77] = "F19", s[s.NumLock = 78] = "NumLock", s[s.ScrollLock = 79] = "ScrollLock", s[s.Semicolon = 80] = "Semicolon", s[s.Equal = 81] = "Equal", s[s.Comma = 82] = "Comma", s[s.Minus = 83] = "Minus", s[s.Period = 84] = "Period", s[s.Slash = 85] = "Slash", s[s.Backquote = 86] = "Backquote", s[s.BracketLeft = 87] = "BracketLeft", s[s.Backslash = 88] = "Backslash", s[s.BracketRight = 89] = "BracketRight", s[s.Quote = 90] = "Quote", s[s.OEM_8 = 91] = "OEM_8", s[s.IntlBackslash = 92] = "IntlBackslash", s[s.Numpad0 = 93] = "Numpad0", s[s.Numpad1 = 94] = "Numpad1", s[s.Numpad2 = 95] = "Numpad2", s[s.Numpad3 = 96] = "Numpad3", s[s.Numpad4 = 97] = "Numpad4", s[s.Numpad5 = 98] = "Numpad5", s[s.Numpad6 = 99] = "Numpad6", s[s.Numpad7 = 100] = "Numpad7", s[s.Numpad8 = 101] = "Numpad8", s[s.Numpad9 = 102] = "Numpad9", s[s.NumpadMultiply = 103] = "NumpadMultiply", s[s.NumpadAdd = 104] = "NumpadAdd", s[s.NUMPAD_SEPARATOR = 105] = "NUMPAD_SEPARATOR", s[s.NumpadSubtract = 106] = "NumpadSubtract", s[s.NumpadDecimal = 107] = "NumpadDecimal", s[s.NumpadDivide = 108] = "NumpadDivide", s[s.KEY_IN_COMPOSITION = 109] = "KEY_IN_COMPOSITION", s[s.ABNT_C1 = 110] = "ABNT_C1", s[s.ABNT_C2 = 111] = "ABNT_C2", s[s.AudioVolumeMute = 112] = "AudioVolumeMute", s[s.AudioVolumeUp = 113] = "AudioVolumeUp", s[s.AudioVolumeDown = 114] = "AudioVolumeDown", s[s.BrowserSearch = 115] = "BrowserSearch", s[s.BrowserHome = 116] = "BrowserHome", s[s.BrowserBack = 117] = "BrowserBack", s[s.BrowserForward = 118] = "BrowserForward", s[s.MediaTrackNext = 119] = "MediaTrackNext", s[s.MediaTrackPrevious = 120] = "MediaTrackPrevious", s[s.MediaStop = 121] = "MediaStop", s[s.MediaPlayPause = 122] = "MediaPlayPause", s[s.LaunchMediaPlayer = 123] = "LaunchMediaPlayer", s[s.LaunchMail = 124] = "LaunchMail", s[s.LaunchApp2 = 125] = "LaunchApp2", s[s.Clear = 126] = "Clear", s[s.MAX_VALUE = 127] = "MAX_VALUE";
})(R_ || (R_ = {}));
var P_;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(P_ || (P_ = {}));
var O_;
(function(s) {
  s[s.Unnecessary = 1] = "Unnecessary", s[s.Deprecated = 2] = "Deprecated";
})(O_ || (O_ = {}));
var F_;
(function(s) {
  s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
})(F_ || (F_ = {}));
var B_;
(function(s) {
  s[s.UNKNOWN = 0] = "UNKNOWN", s[s.TEXTAREA = 1] = "TEXTAREA", s[s.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", s[s.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", s[s.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", s[s.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", s[s.CONTENT_TEXT = 6] = "CONTENT_TEXT", s[s.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", s[s.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", s[s.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", s[s.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", s[s.SCROLLBAR = 11] = "SCROLLBAR", s[s.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", s[s.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(B_ || (B_ = {}));
var V_;
(function(s) {
  s[s.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", s[s.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", s[s.TOP_CENTER = 2] = "TOP_CENTER";
})(V_ || (V_ = {}));
var W_;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(W_ || (W_ = {}));
var H_;
(function(s) {
  s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.None = 2] = "None", s[s.LeftOfInjectedText = 3] = "LeftOfInjectedText", s[s.RightOfInjectedText = 4] = "RightOfInjectedText";
})(H_ || (H_ = {}));
var z_;
(function(s) {
  s[s.Off = 0] = "Off", s[s.On = 1] = "On", s[s.Relative = 2] = "Relative", s[s.Interval = 3] = "Interval", s[s.Custom = 4] = "Custom";
})(z_ || (z_ = {}));
var U_;
(function(s) {
  s[s.None = 0] = "None", s[s.Text = 1] = "Text", s[s.Blocks = 2] = "Blocks";
})(U_ || (U_ = {}));
var $_;
(function(s) {
  s[s.Smooth = 0] = "Smooth", s[s.Immediate = 1] = "Immediate";
})($_ || ($_ = {}));
var j_;
(function(s) {
  s[s.Auto = 1] = "Auto", s[s.Hidden = 2] = "Hidden", s[s.Visible = 3] = "Visible";
})(j_ || (j_ = {}));
var K_;
(function(s) {
  s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL";
})(K_ || (K_ = {}));
var q_;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(q_ || (q_ = {}));
var G_;
(function(s) {
  s[s.File = 0] = "File", s[s.Module = 1] = "Module", s[s.Namespace = 2] = "Namespace", s[s.Package = 3] = "Package", s[s.Class = 4] = "Class", s[s.Method = 5] = "Method", s[s.Property = 6] = "Property", s[s.Field = 7] = "Field", s[s.Constructor = 8] = "Constructor", s[s.Enum = 9] = "Enum", s[s.Interface = 10] = "Interface", s[s.Function = 11] = "Function", s[s.Variable = 12] = "Variable", s[s.Constant = 13] = "Constant", s[s.String = 14] = "String", s[s.Number = 15] = "Number", s[s.Boolean = 16] = "Boolean", s[s.Array = 17] = "Array", s[s.Object = 18] = "Object", s[s.Key = 19] = "Key", s[s.Null = 20] = "Null", s[s.EnumMember = 21] = "EnumMember", s[s.Struct = 22] = "Struct", s[s.Event = 23] = "Event", s[s.Operator = 24] = "Operator", s[s.TypeParameter = 25] = "TypeParameter";
})(G_ || (G_ = {}));
var Z_;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(Z_ || (Z_ = {}));
var Y_;
(function(s) {
  s[s.Hidden = 0] = "Hidden", s[s.Blink = 1] = "Blink", s[s.Smooth = 2] = "Smooth", s[s.Phase = 3] = "Phase", s[s.Expand = 4] = "Expand", s[s.Solid = 5] = "Solid";
})(Y_ || (Y_ = {}));
var Q_;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(Q_ || (Q_ = {}));
var X_;
(function(s) {
  s[s.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", s[s.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", s[s.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", s[s.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(X_ || (X_ = {}));
var J_;
(function(s) {
  s[s.None = 0] = "None", s[s.Same = 1] = "Same", s[s.Indent = 2] = "Indent", s[s.DeepIndent = 3] = "DeepIndent";
})(J_ || (J_ = {}));
class Eu {
  static chord(e, t) {
    return JN(e, t);
  }
}
Eu.CtrlCmd = 2048;
Eu.Shift = 1024;
Eu.Alt = 512;
Eu.WinCtrl = 256;
function t2() {
  return {
    editor: void 0,
    languages: void 0,
    CancellationTokenSource: lc,
    Emitter: A,
    KeyCode: R_,
    KeyMod: Eu,
    Position: O,
    Range: N,
    Selection: Ce,
    SelectionDirection: K_,
    MarkerSeverity: P_,
    MarkerTag: O_,
    Uri: Le,
    Token: Nh
  };
}
class vT {
  constructor(e) {
    this.fn = e, this.lastCache = void 0, this.lastArgKey = void 0;
  }
  get(e) {
    const t = JSON.stringify(e);
    return this.lastArgKey !== t && (this.lastArgKey = t, this.lastCache = this.fn(e)), this.lastCache;
  }
}
class Gv {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new Map();
  }
  get cachedValues() {
    return this._map;
  }
  get(e) {
    if (this._map.has(e))
      return this._map.get(e);
    const t = this.fn(e);
    return this._map.set(e, t), t;
  }
}
class i2 {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  hasValue() {
    return this._didRun;
  }
  getValue() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  get rawValue() {
    return this._value;
  }
}
var n2;
function wT(s) {
  return !s || typeof s != "string" ? !0 : s.trim().length === 0;
}
const ST = /{(\d+)}/g;
function e1(s, ...e) {
  return e.length === 0 ? s : s.replace(ST, function(t, i) {
    const n = parseInt(i, 10);
    return isNaN(n) || n < 0 || n >= e.length ? t : e[n];
  });
}
function yT(s) {
  return s.replace(/[<>&]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return e;
    }
  });
}
function sr(s) {
  return s.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function wb(s, e) {
  if (!s || !e)
    return s;
  const t = e.length;
  if (t === 0 || s.length === 0)
    return s;
  let i = 0;
  for (; s.indexOf(e, i) === i; )
    i = i + t;
  return s.substring(i);
}
function LT(s, e) {
  if (!s || !e)
    return s;
  const t = e.length, i = s.length;
  if (t === 0 || i === 0)
    return s;
  let n = i, r = -1;
  for (; r = s.lastIndexOf(e, n - 1), !(r === -1 || r + t !== n); ) {
    if (r === 0)
      return "";
    n = r;
  }
  return s.substring(0, n);
}
function kT(s) {
  return s.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function s2(s, e, t = {}) {
  if (!s)
    throw new Error("Cannot create regex from empty string");
  e || (s = sr(s)), t.wholeWord && (/\B/.test(s.charAt(0)) || (s = "\\b" + s), /\B/.test(s.charAt(s.length - 1)) || (s = s + "\\b"));
  let i = "";
  return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(s, i);
}
function DT(s) {
  return s.source === "^" || s.source === "^$" || s.source === "$" || s.source === "^\\s*$" ? !1 : !!(s.exec("") && s.lastIndex === 0);
}
function Hm(s) {
  return (s.global ? "g" : "") + (s.ignoreCase ? "i" : "") + (s.multiline ? "m" : "") + (s.unicode ? "u" : "");
}
function xu(s) {
  return s.split(/\r\n|\r|\n/);
}
function Bi(s) {
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function wi(s, e = 0, t = s.length) {
  for (let i = e; i < t; i++) {
    const n = s.charCodeAt(i);
    if (n !== 32 && n !== 9)
      return s.substring(e, i);
  }
  return s.substring(e, t);
}
function cc(s, e = s.length - 1) {
  for (let t = e; t >= 0; t--) {
    const i = s.charCodeAt(t);
    if (i !== 32 && i !== 9)
      return t;
  }
  return -1;
}
function t1(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function Sb(s, e, t = 0, i = s.length, n = 0, r = e.length) {
  for (; t < i && n < r; t++, n++) {
    const l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l < c)
      return -1;
    if (l > c)
      return 1;
  }
  const o = i - t, a = r - n;
  return o < a ? -1 : o > a ? 1 : 0;
}
function Zv(s, e) {
  return Iu(s, e, 0, s.length, 0, e.length);
}
function Iu(s, e, t = 0, i = s.length, n = 0, r = e.length) {
  for (; t < i && n < r; t++, n++) {
    let l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l === c)
      continue;
    if (l >= 128 || c >= 128)
      return Sb(s.toLowerCase(), e.toLowerCase(), t, i, n, r);
    ja(l) && (l -= 32), ja(c) && (c -= 32);
    const h = l - c;
    if (h !== 0)
      return h;
  }
  const o = i - t, a = r - n;
  return o < a ? -1 : o > a ? 1 : 0;
}
function Yu(s) {
  return s >= 48 && s <= 57;
}
function ja(s) {
  return s >= 97 && s <= 122;
}
function yr(s) {
  return s >= 65 && s <= 90;
}
function Ka(s, e) {
  return s.length === e.length && Iu(s, e) === 0;
}
function yb(s, e) {
  const t = e.length;
  return e.length > s.length ? !1 : Iu(s, e, 0, t) === 0;
}
function i1(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(i) !== e.charCodeAt(i))
      return i;
  return t;
}
function n1(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  const n = s.length - 1, r = e.length - 1;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(n - i) !== e.charCodeAt(r - i))
      return i;
  return t;
}
function Lt(s) {
  return 55296 <= s && s <= 56319;
}
function Rl(s) {
  return 56320 <= s && s <= 57343;
}
function Lb(s, e) {
  return (s - 55296 << 10) + (e - 56320) + 65536;
}
function gf(s, e, t) {
  const i = s.charCodeAt(t);
  if (Lt(i) && t + 1 < e) {
    const n = s.charCodeAt(t + 1);
    if (Rl(n))
      return Lb(i, n);
  }
  return i;
}
function ET(s, e) {
  const t = s.charCodeAt(e - 1);
  if (Rl(t) && e > 1) {
    const i = s.charCodeAt(e - 2);
    if (Lt(i))
      return Lb(i, t);
  }
  return t;
}
class kb {
  constructor(e, t = 0) {
    this._str = e, this._len = e.length, this._offset = t;
  }
  get offset() {
    return this._offset;
  }
  setOffset(e) {
    this._offset = e;
  }
  prevCodePoint() {
    const e = ET(this._str, this._offset);
    return this._offset -= e >= 65536 ? 2 : 1, e;
  }
  nextCodePoint() {
    const e = gf(this._str, this._len, this._offset);
    return this._offset += e >= 65536 ? 2 : 1, e;
  }
  eol() {
    return this._offset >= this._len;
  }
}
class mf {
  constructor(e, t = 0) {
    this._iterator = new kb(e, t);
  }
  get offset() {
    return this._iterator.offset;
  }
  nextGraphemeLength() {
    const e = Ar.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.nextCodePoint());
    for (; !t.eol(); ) {
      const r = t.offset, o = e.getGraphemeBreakType(t.nextCodePoint());
      if (Yv(n, o)) {
        t.setOffset(r);
        break;
      }
      n = o;
    }
    return t.offset - i;
  }
  prevGraphemeLength() {
    const e = Ar.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.prevCodePoint());
    for (; t.offset > 0; ) {
      const r = t.offset, o = e.getGraphemeBreakType(t.prevCodePoint());
      if (Yv(o, n)) {
        t.setOffset(r);
        break;
      }
      n = o;
    }
    return i - t.offset;
  }
  eol() {
    return this._iterator.eol();
  }
}
function Db(s, e) {
  return new mf(s, e).nextGraphemeLength();
}
function r2(s, e) {
  return new mf(s, e).prevGraphemeLength();
}
function xT(s, e) {
  e > 0 && Rl(s.charCodeAt(e)) && e--;
  const t = e + Db(s, e);
  return [t - r2(s, t), t];
}
const IT = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
function Th(s) {
  return IT.test(s);
}
const NT = /^[\t\n\r\x20-\x7E]*$/;
function Eb(s) {
  return NT.test(s);
}
const o2 = /[\u2028\u2029]/;
function a2(s) {
  return o2.test(s);
}
function Jr(s) {
  return s >= 11904 && s <= 55215 || s >= 63744 && s <= 64255 || s >= 65281 && s <= 65374;
}
function xb(s) {
  return s >= 127462 && s <= 127487 || s === 8986 || s === 8987 || s === 9200 || s === 9203 || s >= 9728 && s <= 10175 || s === 11088 || s === 11093 || s >= 127744 && s <= 128591 || s >= 128640 && s <= 128764 || s >= 128992 && s <= 129008 || s >= 129280 && s <= 129535 || s >= 129648 && s <= 129782;
}
const TT = String.fromCharCode(65279);
function Ib(s) {
  return !!(s && s.length > 0 && s.charCodeAt(0) === 65279);
}
function l2(s) {
  return s = s % (2 * 26), s < 26 ? String.fromCharCode(97 + s) : String.fromCharCode(65 + s - 26);
}
function Yv(s, e) {
  return s === 0 ? e !== 5 && e !== 7 : s === 2 && e === 3 ? !1 : s === 4 || s === 2 || s === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(s === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (s === 11 || s === 9) && (e === 9 || e === 10) || (s === 12 || s === 10) && e === 10 || e === 5 || e === 13 || e === 7 || s === 1 || s === 13 && e === 14 || s === 6 && e === 6);
}
class Ar {
  constructor() {
    this._data = MT();
  }
  static getInstance() {
    return Ar._INSTANCE || (Ar._INSTANCE = new Ar()), Ar._INSTANCE;
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127)
      return 0;
    const t = this._data, i = t.length / 3;
    let n = 1;
    for (; n <= i; )
      if (e < t[3 * n])
        n = 2 * n;
      else if (e > t[3 * n + 1])
        n = 2 * n + 1;
      else
        return t[3 * n + 2];
    return 0;
  }
}
Ar._INSTANCE = null;
function MT() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function AT(s, e) {
  if (s === 0)
    return 0;
  const t = RT(s, e);
  if (t !== void 0)
    return t;
  const i = new kb(e, s);
  return i.prevCodePoint(), i.offset;
}
function RT(s, e) {
  const t = new kb(e, s);
  let i = t.prevCodePoint();
  for (; PT(i) || i === 65039 || i === 8419; ) {
    if (t.offset === 0)
      return;
    i = t.prevCodePoint();
  }
  if (!xb(i))
    return;
  let n = t.offset;
  return n > 0 && t.prevCodePoint() === 8205 && (n = t.offset), n;
}
function PT(s) {
  return 127995 <= s && s <= 127999;
}
class _n {
  constructor(e) {
    this.confusableDictionary = e;
  }
  static getInstance(e) {
    return _n.cache.get(Array.from(e));
  }
  static getLocales() {
    return _n._locales.getValue();
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
}
n2 = _n;
_n.ambiguousCharacterData = new i2(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'));
_n.cache = new vT((s) => {
  function e(c) {
    const h = /* @__PURE__ */ new Map();
    for (let u = 0; u < c.length; u += 2)
      h.set(c[u], c[u + 1]);
    return h;
  }
  function t(c, h) {
    const u = new Map(c);
    for (const [d, f] of h)
      u.set(d, f);
    return u;
  }
  function i(c, h) {
    if (!c)
      return h;
    const u = /* @__PURE__ */ new Map();
    for (const [d, f] of c)
      h.has(d) && u.set(d, f);
    return u;
  }
  const n = n2.ambiguousCharacterData.getValue();
  let r = s.filter((c) => !c.startsWith("_") && c in n);
  r.length === 0 && (r = ["_default"]);
  let o;
  for (const c of r) {
    const h = e(n[c]);
    o = i(o, h);
  }
  const a = e(n._common), l = t(a, o);
  return new _n(l);
});
_n._locales = new i2(() => Object.keys(_n.ambiguousCharacterData.getValue()).filter((s) => !s.startsWith("_")));
class $r {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static getData() {
    return this._data || (this._data = new Set($r.getRawData())), this._data;
  }
  static isInvisibleCharacter(e) {
    return $r.getData().has(e);
  }
  static get codePoints() {
    return $r.getData();
  }
}
$r._data = void 0;
class s1 {
  constructor() {
    this._zoomFactor = 1;
  }
  getZoomFactor() {
    return this._zoomFactor;
  }
}
s1.INSTANCE = new s1();
class OT extends z {
  constructor() {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(!0), this._mediaQueryList = null, this._handleChange(!1);
  }
  _handleChange(e) {
    var t;
    (t = this._mediaQueryList) === null || t === void 0 || t.removeEventListener("change", this._listener), this._mediaQueryList = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), e && this._onDidChange.fire();
  }
}
class FT extends z {
  constructor() {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio();
    const e = this._register(new OT());
    this._register(e.onDidChange(() => {
      this._value = this._getPixelRatio(), this._onDidChange.fire(this._value);
    }));
  }
  get value() {
    return this._value;
  }
  _getPixelRatio() {
    const e = document.createElement("canvas").getContext("2d"), t = window.devicePixelRatio || 1, i = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
    return t / i;
  }
}
class BT {
  constructor() {
    this._pixelRatioMonitor = null;
  }
  _getOrCreatePixelRatioMonitor() {
    return this._pixelRatioMonitor || (this._pixelRatioMonitor = new FT()), this._pixelRatioMonitor;
  }
  get value() {
    return this._getOrCreatePixelRatioMonitor().value;
  }
  get onDidChange() {
    return this._getOrCreatePixelRatioMonitor().onDidChange;
  }
}
function Nb(s, e) {
  typeof s == "string" && (s = window.matchMedia(s)), s.addEventListener("change", e);
}
const Mh = new BT();
function c2() {
  return s1.INSTANCE.getZoomFactor();
}
const hc = navigator.userAgent, sn = hc.indexOf("Firefox") >= 0, jr = hc.indexOf("AppleWebKit") >= 0, Tb = hc.indexOf("Chrome") >= 0, rr = !Tb && hc.indexOf("Safari") >= 0, Mb = !Tb && !rr && jr, VT = hc.indexOf("Electron/") >= 0, h2 = hc.indexOf("Android") >= 0;
let r1 = !1;
if (window.matchMedia) {
  const s = window.matchMedia("(display-mode: standalone)");
  r1 = s.matches, Nb(s, ({ matches: e }) => {
    r1 = e;
  });
}
function u2() {
  return r1;
}
const WT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addMatchMediaChangeListener: Nb,
  PixelRatio: Mh,
  getZoomFactor: c2,
  isFirefox: sn,
  isWebKit: jr,
  isChrome: Tb,
  isSafari: rr,
  isWebkitWebView: Mb,
  isElectron: VT,
  isAndroid: h2,
  isStandalone: u2
}, Symbol.toStringTag, { value: "Module" }));
class d2 {
  constructor(e) {
    this.domNode = e, this._maxWidth = "", this._width = "", this._height = "", this._top = "", this._left = "", this._bottom = "", this._right = "", this._fontFamily = "", this._fontWeight = "", this._fontSize = "", this._fontStyle = "", this._fontFeatureSettings = "", this._textDecoration = "", this._lineHeight = "", this._letterSpacing = "", this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    const t = Un(e);
    this._maxWidth !== t && (this._maxWidth = t, this.domNode.style.maxWidth = this._maxWidth);
  }
  setWidth(e) {
    const t = Un(e);
    this._width !== t && (this._width = t, this.domNode.style.width = this._width);
  }
  setHeight(e) {
    const t = Un(e);
    this._height !== t && (this._height = t, this.domNode.style.height = this._height);
  }
  setTop(e) {
    const t = Un(e);
    this._top !== t && (this._top = t, this.domNode.style.top = this._top);
  }
  setLeft(e) {
    const t = Un(e);
    this._left !== t && (this._left = t, this.domNode.style.left = this._left);
  }
  setBottom(e) {
    const t = Un(e);
    this._bottom !== t && (this._bottom = t, this.domNode.style.bottom = this._bottom);
  }
  setRight(e) {
    const t = Un(e);
    this._right !== t && (this._right = t, this.domNode.style.right = this._right);
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    const t = Un(e);
    this._fontSize !== t && (this._fontSize = t, this.domNode.style.fontSize = this._fontSize);
  }
  setFontStyle(e) {
    this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setTextDecoration(e) {
    this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
  }
  setLineHeight(e) {
    const t = Un(e);
    this._lineHeight !== t && (this._lineHeight = t, this.domNode.style.lineHeight = this._lineHeight);
  }
  setLetterSpacing(e) {
    const t = Un(e);
    this._letterSpacing !== t && (this._letterSpacing = t, this.domNode.style.letterSpacing = this._letterSpacing);
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setColor(e) {
    this._color !== e && (this._color = e, this.domNode.style.color = this._color);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function Un(s) {
  return typeof s == "number" ? `${s}px` : s;
}
function me(s) {
  return new d2(s);
}
function mi(s, e) {
  s instanceof d2 ? (s.setFontFamily(e.getMassagedFontFamily()), s.setFontWeight(e.fontWeight), s.setFontSize(e.fontSize), s.setFontFeatureSettings(e.fontFeatureSettings), s.setLineHeight(e.lineHeight), s.setLetterSpacing(e.letterSpacing)) : (s.style.fontFamily = e.getMassagedFontFamily(), s.style.fontWeight = e.fontWeight, s.style.fontSize = e.fontSize + "px", s.style.fontFeatureSettings = e.fontFeatureSettings, s.style.lineHeight = e.lineHeight + "px", s.style.letterSpacing = e.letterSpacing + "px");
}
class HT {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class Ab {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read() {
    this._createDomElements(), document.body.appendChild(this._container), this._readFromDomElements(), document.body.removeChild(this._container), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    mi(t, this._bareFontInfo), e.appendChild(t);
    const i = document.createElement("div");
    mi(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
    const n = document.createElement("div");
    mi(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
    const r = [];
    for (const o of this._requests) {
      let a;
      o.type === 0 && (a = t), o.type === 2 && (a = i), o.type === 1 && (a = n), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      Ab._render(l, o), a.appendChild(l), r.push(l);
    }
    this._container = e, this._testElements = r;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = "\xA0";
      for (let n = 0; n < 8; n++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let n = 0; n < 8; n++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], n = this._testElements[e];
      i.fulfill(n.offsetWidth / 256);
    }
  }
}
function zT(s, e) {
  new Ab(s, e).read();
}
const pf = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new A(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(s) {
    s = Math.min(Math.max(-5, s), 20), this._zoomLevel !== s && (this._zoomLevel = s, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), UT = Ie ? 1.5 : 1.35, zm = 8;
class $o {
  constructor(e) {
    this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  static createFromValidatedSettings(e, t, i) {
    const n = e.get(45), r = e.get(49), o = e.get(48), a = e.get(47), l = e.get(61), c = e.get(58);
    return $o._create(n, r, o, a, l, c, t, i);
  }
  static _create(e, t, i, n, r, o, a, l) {
    r === 0 ? r = UT * i : r < zm && (r = r * i), r = Math.round(r), r < zm && (r = zm);
    const c = 1 + (l ? 0 : pf.getZoomLevel() * 0.1);
    return i *= c, r *= c, new $o({
      pixelRatio: a,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: n,
      lineHeight: r,
      letterSpacing: o
    });
  }
  getId() {
    return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.lineHeight}-${this.letterSpacing}`;
  }
  getMassagedFontFamily() {
    const e = tn.fontFamily, t = $o._wrapInQuotes(this.fontFamily);
    return e && this.fontFamily !== e ? `${t}, ${e}` : t;
  }
  static _wrapInQuotes(e) {
    return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
  }
}
const $T = 1;
class o1 extends $o {
  constructor(e, t) {
    super(e), this._editorStylingBrand = void 0, this.version = $T, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
class jT extends z {
  constructor() {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._cache = new Qv(), this._evictUntrustedReadingsTimeout = -1;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (window.clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  clearAllFontInfos() {
    this._cache = new Qv(), this._onDidChange.fire();
  }
  _writeToCache(e, t) {
    this._cache.put(e, t), !t.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = window.setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings();
    }, 5e3));
  }
  _evictUntrustedReadings() {
    const e = this._cache.getValues();
    let t = !1;
    for (const i of e)
      i.isTrusted || (t = !0, this._cache.remove(i));
    t && this._onDidChange.fire();
  }
  readFontInfo(e) {
    if (!this._cache.has(e)) {
      let t = this._actualReadFontInfo(e);
      (t.typicalHalfwidthCharacterWidth <= 2 || t.typicalFullwidthCharacterWidth <= 2 || t.spaceWidth <= 2 || t.maxDigitWidth <= 2) && (t = new o1({
        pixelRatio: Mh.value,
        fontFamily: t.fontFamily,
        fontWeight: t.fontWeight,
        fontSize: t.fontSize,
        fontFeatureSettings: t.fontFeatureSettings,
        lineHeight: t.lineHeight,
        letterSpacing: t.letterSpacing,
        isMonospace: t.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(t.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(t.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: t.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(t.spaceWidth, 5),
        middotWidth: Math.max(t.middotWidth, 5),
        wsmiddotWidth: Math.max(t.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(t.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t);
    }
    return this._cache.get(e);
  }
  _createRequest(e, t, i, n) {
    const r = new HT(e, t);
    return i.push(r), n == null || n.push(r), r;
  }
  _actualReadFontInfo(e) {
    const t = [], i = [], n = this._createRequest("n", 0, t, i), r = this._createRequest("\uFF4D", 0, t, null), o = this._createRequest(" ", 0, t, i), a = this._createRequest("0", 0, t, i), l = this._createRequest("1", 0, t, i), c = this._createRequest("2", 0, t, i), h = this._createRequest("3", 0, t, i), u = this._createRequest("4", 0, t, i), d = this._createRequest("5", 0, t, i), f = this._createRequest("6", 0, t, i), m = this._createRequest("7", 0, t, i), _ = this._createRequest("8", 0, t, i), b = this._createRequest("9", 0, t, i), v = this._createRequest("\u2192", 0, t, i), C = this._createRequest("\uFFEB", 0, t, null), w = this._createRequest("\xB7", 0, t, i), L = this._createRequest(String.fromCharCode(11825), 0, t, null), E = "|/-_ilm%";
    for (let T = 0, M = E.length; T < M; T++)
      this._createRequest(E.charAt(T), 0, t, i), this._createRequest(E.charAt(T), 1, t, i), this._createRequest(E.charAt(T), 2, t, i);
    zT(e, t);
    const k = Math.max(a.width, l.width, c.width, h.width, u.width, d.width, f.width, m.width, _.width, b.width);
    let y = e.fontFeatureSettings === qi.OFF;
    const S = i[0].width;
    for (let T = 1, M = i.length; y && T < M; T++) {
      const P = S - i[T].width;
      if (P < -1e-3 || P > 1e-3) {
        y = !1;
        break;
      }
    }
    let D = !0;
    return y && C.width !== S && (D = !1), C.width > v.width && (D = !1), new o1({
      pixelRatio: Mh.value,
      fontFamily: e.fontFamily,
      fontWeight: e.fontWeight,
      fontSize: e.fontSize,
      fontFeatureSettings: e.fontFeatureSettings,
      lineHeight: e.lineHeight,
      letterSpacing: e.letterSpacing,
      isMonospace: y,
      typicalHalfwidthCharacterWidth: n.width,
      typicalFullwidthCharacterWidth: r.width,
      canUseHalfwidthRightwardsArrow: D,
      spaceWidth: o.width,
      middotWidth: w.width,
      wsmiddotWidth: L.width,
      maxDigitWidth: k
    }, !0);
  }
}
class Qv {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
const a1 = new jT();
var Nn;
(function(s) {
  s.serviceIds = /* @__PURE__ */ new Map(), s.DI_TARGET = "$di$target", s.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[s.DI_DEPENDENCIES] || [];
  }
  s.getServiceDependencies = e;
})(Nn || (Nn = {}));
const It = Se("instantiationService");
function KT(s, e, t) {
  e[Nn.DI_TARGET] === e ? e[Nn.DI_DEPENDENCIES].push({ id: s, index: t }) : (e[Nn.DI_DEPENDENCIES] = [{ id: s, index: t }], e[Nn.DI_TARGET] = e);
}
function Se(s) {
  if (Nn.serviceIds.has(s))
    return Nn.serviceIds.get(s);
  const e = function(t, i, n) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    KT(e, t, n);
  };
  return e.toString = () => s, Nn.serviceIds.set(s, e), e;
}
const Ct = Se("codeEditorService");
function oh(s, e) {
  if (!s)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
const qT = {
  followsCaret: !0,
  ignoreCharChanges: !0,
  alwaysRevealFirst: !0
};
class GT extends z {
  constructor(e, t = {}) {
    super(), this._onDidUpdate = this._register(new A()), this._editor = e, this._options = sa(t, qT, !1), this.disposed = !1, this.nextIdx = -1, this.ranges = [], this.ignoreSelectionChange = !1, this.revealFirst = Boolean(this._options.alwaysRevealFirst), this._register(this._editor.onDidDispose(() => this.dispose())), this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated())), this._options.followsCaret && this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((i) => {
      this.ignoreSelectionChange || (this.nextIdx = -1);
    })), this._options.alwaysRevealFirst && this._register(this._editor.getModifiedEditor().onDidChangeModel((i) => {
      this.revealFirst = !0;
    })), this._init();
  }
  _init() {
    this._editor.getLineChanges();
  }
  _onDiffUpdated() {
    this._init(), this._compute(this._editor.getLineChanges()), this.revealFirst && this._editor.getLineChanges() !== null && (this.revealFirst = !1, this.nextIdx = -1, this.next(1));
  }
  _compute(e) {
    this.ranges = [], e && e.forEach((t) => {
      !this._options.ignoreCharChanges && t.charChanges ? t.charChanges.forEach((i) => {
        this.ranges.push({
          rhs: !0,
          range: new N(i.modifiedStartLineNumber, i.modifiedStartColumn, i.modifiedEndLineNumber, i.modifiedEndColumn)
        });
      }) : t.modifiedEndLineNumber === 0 ? this.ranges.push({
        rhs: !0,
        range: new N(t.modifiedStartLineNumber, 1, t.modifiedStartLineNumber + 1, 1)
      }) : this.ranges.push({
        rhs: !0,
        range: new N(t.modifiedStartLineNumber, 1, t.modifiedEndLineNumber + 1, 1)
      });
    }), this.ranges.sort((t, i) => N.compareRangesUsingStarts(t.range, i.range)), this._onDidUpdate.fire(this);
  }
  _initIdx(e) {
    let t = !1;
    const i = this._editor.getPosition();
    if (!i) {
      this.nextIdx = 0;
      return;
    }
    for (let n = 0, r = this.ranges.length; n < r && !t; n++) {
      const o = this.ranges[n].range;
      i.isBeforeOrEqual(o.getStartPosition()) && (this.nextIdx = n + (e ? 0 : -1), t = !0);
    }
    t || (this.nextIdx = e ? 0 : this.ranges.length - 1), this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1);
  }
  _move(e, t) {
    if (oh(!this.disposed, "Illegal State - diff navigator has been disposed"), !this.canNavigate())
      return;
    this.nextIdx === -1 ? this._initIdx(e) : e ? (this.nextIdx += 1, this.nextIdx >= this.ranges.length && (this.nextIdx = 0)) : (this.nextIdx -= 1, this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1));
    const i = this.ranges[this.nextIdx];
    this.ignoreSelectionChange = !0;
    try {
      const n = i.range.getStartPosition();
      this._editor.setPosition(n), this._editor.revealRangeInCenter(i.range, t);
    } finally {
      this.ignoreSelectionChange = !1;
    }
  }
  canNavigate() {
    return this.ranges && this.ranges.length > 0;
  }
  next(e = 0) {
    this._move(!0, e);
  }
  previous(e = 0) {
    this._move(!1, e);
  }
  dispose() {
    super.dispose(), this.ranges = [], this.disposed = !0;
  }
}
const Rb = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};
var _f;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(_f || (_f = {}));
var jo;
(function(s) {
  s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
})(jo || (jo = {}));
var Pl;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(Pl || (Pl = {}));
class $d {
  constructor(e) {
    this._textModelResolvedOptionsBrand = void 0, this.tabSize = Math.max(1, e.tabSize | 0), this.indentSize = e.tabSize | 0, this.insertSpaces = Boolean(e.insertSpaces), this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = Boolean(e.trimAutoWhitespace), this.bracketPairColorizationOptions = e.bracketPairColorizationOptions;
  }
  equals(e) {
    return this.tabSize === e.tabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace && en(this.bracketPairColorizationOptions, e.bracketPairColorizationOptions);
  }
  createChangeEvent(e) {
    return {
      tabSize: this.tabSize !== e.tabSize,
      indentSize: this.indentSize !== e.indentSize,
      insertSpaces: this.insertSpaces !== e.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
    };
  }
}
class Ah {
  constructor(e, t) {
    this._findMatchBrand = void 0, this.range = e, this.matches = t;
  }
}
function ZT(s) {
  return s && typeof s.read == "function";
}
class Um {
  constructor(e, t, i, n, r, o) {
    this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = n, this.isAutoWhitespaceEdit = r, this._isTracked = o;
  }
}
class YT {
  constructor(e, t, i) {
    this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
  }
}
class QT {
  constructor(e, t, i) {
    this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
  }
}
function XT(s) {
  return !s.isTooLargeForSyncing() && !s.isForSimpleWidget;
}
var ni;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(ni || (ni = {}));
class $m {
  constructor(e) {
    if (this._neutralCharacter = null, this._neutralCharacterSearched = !1, this.open = e.open, this.close = e.close, this._inString = !0, this._inComment = !0, this._inRegEx = !0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._inString = !1;
            break;
          case "comment":
            this._inComment = !1;
            break;
          case "regex":
            this._inRegEx = !1;
            break;
        }
  }
  isOK(e) {
    switch (e) {
      case 0:
        return !0;
      case 1:
        return this._inComment;
      case 2:
        return this._inString;
      case 3:
        return this._inRegEx;
    }
  }
  shouldAutoClose(e, t) {
    if (e.getTokenCount() === 0)
      return !0;
    const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
    return this.isOK(n);
  }
  _findNeutralCharacterInRange(e, t) {
    for (let i = e; i <= t; i++) {
      const n = String.fromCharCode(i);
      if (!this.open.includes(n) && !this.close.includes(n))
        return n;
    }
    return null;
  }
  findNeutralCharacter() {
    return this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(48, 57)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(97, 122)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(65, 90))), this._neutralCharacter;
  }
}
class JT {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      Ec(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), Ec(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), Ec(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), Ec(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && Ec(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function Ec(s, e, t) {
  s.has(e) ? s.get(e).push(t) : s.set(e, [t]);
}
function Ng(s, e) {
  const t = s.getCount(), i = s.findTokenIndexAtOffset(e), n = s.getLanguageId(i);
  let r = i;
  for (; r + 1 < t && s.getLanguageId(r + 1) === n; )
    r++;
  let o = i;
  for (; o > 0 && s.getLanguageId(o - 1) === n; )
    o--;
  return new e4(s, n, o, r + 1, s.getStartOffset(o), s.getEndOffset(r));
}
class e4 {
  constructor(e, t, i, n, r, o) {
    this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = r, this._lastCharOffset = o;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
}
function Kn(s) {
  return (s & 3) !== 0;
}
class Tg {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new $m(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new $m({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new $m({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBefore = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Tg.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet() {
    return this._autoCloseBefore;
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
}
Tg.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = `;:.,=}])> 
	`;
const Xv = typeof Buffer < "u";
let jm;
class Mg {
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  static wrap(e) {
    return Xv && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new Mg(e);
  }
  toString() {
    return Xv ? this.buffer.toString() : (jm || (jm = new TextDecoder()), jm.decode(this.buffer));
  }
}
function t4(s, e) {
  return s[e + 0] << 0 >>> 0 | s[e + 1] << 8 >>> 0;
}
function i4(s, e, t) {
  s[t + 0] = e & 255, e = e >>> 8, s[t + 1] = e & 255;
}
function Sn(s, e) {
  return s[e] * Math.pow(2, 24) + s[e + 1] * Math.pow(2, 16) + s[e + 2] * Math.pow(2, 8) + s[e + 3];
}
function yn(s, e, t) {
  s[t + 3] = e, e = e >>> 8, s[t + 2] = e, e = e >>> 8, s[t + 1] = e, e = e >>> 8, s[t] = e;
}
function Jv(s, e) {
  return s[e];
}
function ew(s, e, t) {
  s[t] = e;
}
let Km;
function f2() {
  return Km || (Km = new TextDecoder("UTF-16LE")), Km;
}
let qm;
function n4() {
  return qm || (qm = new TextDecoder("UTF-16BE")), qm;
}
let Gm;
function g2() {
  return Gm || (Gm = Tk() ? f2() : n4()), Gm;
}
const m2 = typeof TextDecoder < "u";
let Ol, l1;
m2 ? (Ol = (s) => new r4(s), l1 = s4) : (Ol = (s) => new o4(), l1 = p2);
function s4(s, e, t) {
  const i = new Uint16Array(s.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? p2(s, e, t) : f2().decode(i);
}
function p2(s, e, t) {
  const i = [];
  let n = 0;
  for (let r = 0; r < t; r++) {
    const o = t4(s, e);
    e += 2, i[n++] = String.fromCharCode(o);
  }
  return i.join("");
}
class r4 {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return g2().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  write1(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || Lt(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendASCII(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendASCIIString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class o4 {
  constructor() {
    this._pieces = [], this._piecesLen = 0;
  }
  reset() {
    this._pieces = [], this._piecesLen = 0;
  }
  build() {
    return this._pieces.join("");
  }
  write1(e) {
    this._pieces[this._piecesLen++] = String.fromCharCode(e);
  }
  appendASCII(e) {
    this._pieces[this._piecesLen++] = String.fromCharCode(e);
  }
  appendASCIIString(e) {
    this._pieces[this._piecesLen++] = e;
  }
}
class bf {
  constructor(e, t, i, n, r, o) {
    this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = r, this.reversedRegex = o, this._openSet = bf._toSet(this.open), this._closeSet = bf._toSet(this.close);
  }
  isOpen(e) {
    return this._openSet.has(e);
  }
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function a4(s) {
  const e = s.length;
  s = s.map((o) => [o[0].toLowerCase(), o[1].toLowerCase()]);
  const t = [];
  for (let o = 0; o < e; o++)
    t[o] = o;
  const i = (o, a) => {
    const [l, c] = o, [h, u] = a;
    return l === h || l === u || c === h || c === u;
  }, n = (o, a) => {
    const l = Math.min(o, a), c = Math.max(o, a);
    for (let h = 0; h < e; h++)
      t[h] === c && (t[h] = l);
  };
  for (let o = 0; o < e; o++) {
    const a = s[o];
    for (let l = o + 1; l < e; l++) {
      const c = s[l];
      i(a, c) && n(t[o], t[l]);
    }
  }
  const r = [];
  for (let o = 0; o < e; o++) {
    const a = [], l = [];
    for (let c = 0; c < e; c++)
      if (t[c] === o) {
        const [h, u] = s[c];
        a.push(h), l.push(u);
      }
    a.length > 0 && r.push({
      open: a,
      close: l
    });
  }
  return r;
}
class l4 {
  constructor(e, t) {
    this._richEditBracketsBrand = void 0;
    const i = a4(t);
    this.brackets = i.map((n, r) => new bf(e, r, n.open, n.close, c4(n.open, n.close, i, r), h4(n.open, n.close, i, r))), this.forwardRegex = u4(this.brackets), this.reversedRegex = d4(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const n of this.brackets) {
      for (const r of n.open)
        this.textIsBracket[r] = n, this.textIsOpenBracket[r] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, r.length);
      for (const r of n.close)
        this.textIsBracket[r] = n, this.textIsOpenBracket[r] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, r.length);
    }
  }
}
function _2(s, e, t, i) {
  for (let n = 0, r = e.length; n < r; n++) {
    if (n === t)
      continue;
    const o = e[n];
    for (const a of o.open)
      a.indexOf(s) >= 0 && i.push(a);
    for (const a of o.close)
      a.indexOf(s) >= 0 && i.push(a);
  }
}
function b2(s, e) {
  return s.length - e.length;
}
function Ag(s) {
  if (s.length <= 1)
    return s;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of s)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function c4(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let r = 0, o = n.length; r < o; r++)
    _2(n[r], t, i, n);
  return n = Ag(n), n.sort(b2), n.reverse(), Rg(n);
}
function h4(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let r = 0, o = n.length; r < o; r++)
    _2(n[r], t, i, n);
  return n = Ag(n), n.sort(b2), n.reverse(), Rg(n.map(Pb));
}
function u4(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = Ag(e), Rg(e);
}
function d4(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = Ag(e), Rg(e.map(Pb));
}
function f4(s) {
  const e = /^[\w ]+$/.test(s);
  return s = sr(s), e ? `\\b${s}\\b` : s;
}
function Rg(s) {
  const e = `(${s.map(f4).join(")|(")})`;
  return s2(e, !0);
}
const Pb = function() {
  function s(i) {
    if (m2) {
      const n = new Uint16Array(i.length);
      let r = 0;
      for (let o = i.length - 1; o >= 0; o--)
        n[r++] = i.charCodeAt(o);
      return g2().decode(n);
    } else {
      const n = [];
      let r = 0;
      for (let o = i.length - 1; o >= 0; o--)
        n[r++] = i.charAt(o);
      return n.join("");
    }
  }
  let e = null, t = null;
  return function(n) {
    return e !== n && (e = n, t = s(e)), t;
  };
}();
class cn {
  static _findPrevBracketInText(e, t, i, n) {
    const r = i.match(e);
    if (!r)
      return null;
    const o = i.length - (r.index || 0), a = r[0].length, l = n + o;
    return new N(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, n, r) {
    const a = Pb(i).substring(i.length - r, i.length - n);
    return this._findPrevBracketInText(e, t, a, n);
  }
  static findNextBracketInText(e, t, i, n) {
    const r = i.match(e);
    if (!r)
      return null;
    const o = r.index || 0, a = r[0].length;
    if (a === 0)
      return null;
    const l = n + o;
    return new N(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, n, r) {
    const o = i.substring(n, r);
    return this.findNextBracketInText(e, t, o, n);
  }
}
class g4 {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    const e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const n = i.charAt(i.length - 1);
          e.push(n);
        }
    return Xr(e);
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const n = t.findTokenIndexAtOffset(i - 1);
    if (Kn(t.getStandardTokenType(n)))
      return null;
    const r = this._richEditBrackets.reversedRegex, o = t.getLineContent().substring(0, i - 1) + e, a = cn.findPrevBracketInRange(r, 1, o, 0, o.length);
    if (!a)
      return null;
    const l = o.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const h = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(h) ? {
      matchOpenBracket: l
    } : null;
  }
}
function Qu(s) {
  return s.global && (s.lastIndex = 0), !0;
}
class m4 {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && Qu(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && Qu(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && Qu(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && Qu(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class qa {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = qa._createOpenBracketRegExp(t[0]), n = qa._createCloseBracketRegExp(t[1]);
      i && n && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: n
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, n) {
    if (e >= 3)
      for (let r = 0, o = this._regExpRules.length; r < o; r++) {
        const a = this._regExpRules[r];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: n
        }, {
          reg: a.previousLineText,
          text: t
        }].every((c) => c.reg ? (c.reg.lastIndex = 0, c.reg.test(c.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && n.length > 0)
      for (let r = 0, o = this._brackets.length; r < o; r++) {
        const a = this._brackets[r];
        if (a.openRegExp.test(i) && a.closeRegExp.test(n))
          return { indentAction: ni.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let r = 0, o = this._brackets.length; r < o; r++)
        if (this._brackets[r].openRegExp.test(i))
          return { indentAction: ni.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = sr(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", qa._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = sr(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, qa._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return ct(t), null;
    }
  }
}
const gt = Se("configurationService");
function C2(s, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i in s)
    Ob(t, i, s[i], e);
  return t;
}
function Ob(s, e, t, i) {
  const n = e.split("."), r = n.pop();
  let o = s;
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    let c = o[l];
    switch (typeof c) {
      case "undefined":
        c = o[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(c)}`);
        return;
    }
    o = c;
  }
  if (typeof o == "object" && o !== null)
    try {
      o[r] = t;
    } catch {
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(o)}`);
    }
  else
    i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(o)}`);
}
function p4(s, e) {
  const t = e.split(".");
  v2(s, t);
}
function v2(s, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete s[t];
    return;
  }
  if (Object.keys(s).indexOf(t) !== -1) {
    const i = s[t];
    typeof i == "object" && !Array.isArray(i) && (v2(i, e), Object.keys(i).length === 0 && delete s[t]);
  }
}
function tw(s, e, t) {
  function i(o, a) {
    let l = o;
    for (const c of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[c];
    }
    return l;
  }
  const n = e.split("."), r = i(s, n);
  return typeof r > "u" ? t : r;
}
function _4(s) {
  return s.replace(/[\[\]]/g, "");
}
const Xt = Se("languageService");
class Yn {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const w2 = [];
function Ee(s, e, t) {
  e instanceof Yn || (e = new Yn(e, [], t)), w2.push([s, e]);
}
function iw() {
  return w2;
}
class b4 {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    oh(Fi(e)), oh(Pi(t)), oh(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const Ft = new b4(), zs = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list"
}), Pg = {
  JSONContribution: "base.contributions.json"
};
function C4(s) {
  return s.length > 0 && s.charAt(s.length - 1) === "#" ? s.substring(0, s.length - 1) : s;
}
class v4 {
  constructor() {
    this._onDidChangeSchema = new A(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[C4(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const w4 = new v4();
Ft.add(Pg.JSONContribution, w4);
const uc = {
  Configuration: "base.contributions.configuration"
}, xc = "vscode://schemas/settings/resourceLanguage", nw = Ft.as(Pg.JSONContribution);
class S4 {
  constructor() {
    this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new A(), this._onDidUpdateConfiguration = new A(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: p("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: !1, errorMessage: "Unknown editor configuration setting", allowTrailingCommas: !0, allowComments: !0 }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, nw.registerSchema(xc, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = this.doRegisterConfigurations(e, t);
    nw.registerSchema(xc, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
  }
  registerDefaultConfigurations(e) {
    var t;
    const i = [], n = [];
    for (const { overrides: r, source: o } of e)
      for (const a in r)
        if (i.push(a), Rh.test(a)) {
          const l = this.configurationDefaultsOverrides.get(a), c = (t = l == null ? void 0 : l.valuesSources) !== null && t !== void 0 ? t : /* @__PURE__ */ new Map();
          if (o)
            for (const f of Object.keys(r[a]))
              c.set(f, o);
          const h = Object.assign(Object.assign({}, (l == null ? void 0 : l.value) || {}), r[a]);
          this.configurationDefaultsOverrides.set(a, { source: o, value: h, valuesSources: c });
          const u = _4(a), d = {
            type: "object",
            default: h,
            description: p("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", u),
            $ref: xc,
            defaultDefaultValue: h,
            source: Fi(o) ? void 0 : o,
            defaultValueSource: o
          };
          n.push(...y2(a)), this.configurationProperties[a] = d, this.defaultLanguageConfigurationOverridesNode.properties[a] = d;
        } else {
          this.configurationDefaultsOverrides.set(a, { value: r[a], source: o });
          const l = this.configurationProperties[a];
          l && (this.updatePropertyDefaultValue(a, l), this.updateSchema(a, l));
        }
    this.registerOverrideIdentifiers(n), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i, defaultsOverrides: !0 });
  }
  registerOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(e, t) {
    const i = [];
    return e.forEach((n) => {
      i.push(...this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties)), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
    }), i;
  }
  validateAndRegisterProperties(e, t = !0, i, n, r = 3) {
    var o;
    r = Ki(e.scope) ? r : e.scope;
    const a = [], l = e.properties;
    if (l)
      for (const h in l) {
        const u = l[h];
        if (t && k4(h, u)) {
          delete l[h];
          continue;
        }
        if (u.source = i, u.defaultDefaultValue = l[h].default, this.updatePropertyDefaultValue(h, u), Rh.test(h) ? u.scope = void 0 : (u.scope = Ki(u.scope) ? r : u.scope, u.restricted = Ki(u.restricted) ? !!(n != null && n.includes(h)) : u.restricted), l[h].hasOwnProperty("included") && !l[h].included) {
          this.excludedConfigurationProperties[h] = l[h], delete l[h];
          continue;
        } else
          this.configurationProperties[h] = l[h], !((o = l[h].policy) === null || o === void 0) && o.name && this.policyConfigurations.set(l[h].policy.name, h);
        !l[h].deprecationMessage && l[h].markdownDeprecationMessage && (l[h].deprecationMessage = l[h].markdownDeprecationMessage), a.push(h);
      }
    const c = e.allOf;
    if (c)
      for (const h of c)
        a.push(...this.validateAndRegisterProperties(h, t, i, n, r));
    return a;
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      const n = i.properties;
      if (n)
        for (const o in n)
          this.updateSchema(o, n[o]);
      const r = i.allOf;
      r == null || r.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: p("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: p("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: xc
      };
      this.updatePropertyDefaultValue(t, i);
    }
    this._onDidSchemaChange.fire();
  }
  registerOverridePropertyPatternKey() {
    p("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), p("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    const i = this.configurationDefaultsOverrides.get(e);
    let n = i == null ? void 0 : i.value, r = i == null ? void 0 : i.source;
    Rn(n) && (n = t.defaultDefaultValue, r = void 0), Rn(n) && (n = L4(t.type)), t.default = n, t.defaultValueSource = r;
  }
}
const S2 = "\\[([^\\]]+)\\]", sw = new RegExp(S2, "g"), y4 = `^(${S2})+$`, Rh = new RegExp(y4);
function y2(s) {
  const e = [];
  if (Rh.test(s)) {
    let t = sw.exec(s);
    for (; t != null && t.length; ) {
      const i = t[1].trim();
      i && e.push(i), t = sw.exec(s);
    }
  }
  return Xr(e);
}
function L4(s) {
  switch (Array.isArray(s) ? s[0] : s) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const jd = new S4();
Ft.add(uc.Configuration, jd);
function k4(s, e) {
  var t, i, n, r;
  return s.trim() ? Rh.test(s) ? p("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", s) : jd.getConfigurationProperties()[s] !== void 0 ? p("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", s) : ((t = e.policy) === null || t === void 0 ? void 0 : t.name) && jd.getPolicyConfigurations().get((i = e.policy) === null || i === void 0 ? void 0 : i.name) !== void 0 ? p("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", s, (n = e.policy) === null || n === void 0 ? void 0 : n.name, jd.getPolicyConfigurations().get((r = e.policy) === null || r === void 0 ? void 0 : r.name)) : null : p("config.property.empty", "Cannot register an empty property");
}
const D4 = {
  ModesRegistry: "editor.modesRegistry"
};
class E4 {
  constructor() {
    this._onDidChangeLanguages = new A(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
  }
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
}
const Fl = new E4();
Ft.add(D4.ModesRegistry, Fl);
const os = "plaintext", x4 = ".txt";
Fl.registerLanguage({
  id: os,
  extensions: [x4],
  aliases: [p("plainText.alias", "Plain Text"), "text"],
  mimetypes: [zs.text]
});
Ft.as(uc.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": !1,
      "editor.unicodeHighlight.invisibleCharacters": !1
    }
  }
}]);
class I4 {
  constructor(e, t) {
    this.languageId = e;
    let i;
    t.colorizedBracketPairs ? i = rw(t.colorizedBracketPairs.map((o) => [o[0], o[1]])) : t.brackets ? i = rw(t.brackets.map((o) => [o[0], o[1]]).filter((o) => !(o[0] === "<" && o[1] === ">"))) : i = [];
    const n = new Gv((o) => {
      const a = /* @__PURE__ */ new Set();
      return {
        info: new N4(this, o, a),
        closing: a
      };
    }), r = new Gv((o) => {
      const a = /* @__PURE__ */ new Set();
      return {
        info: new T4(this, o, a),
        opening: a
      };
    });
    for (const [o, a] of i) {
      const l = n.get(o), c = r.get(a);
      l.closing.add(c.info), c.opening.add(l.info);
    }
    this._openingBrackets = new Map([...n.cachedValues].map(([o, a]) => [o, a.info])), this._closingBrackets = new Map([...r.cachedValues].map(([o, a]) => [o, a.info]));
  }
  get openingBrackets() {
    return [...this._openingBrackets.values()];
  }
  get closingBrackets() {
    return [...this._closingBrackets.values()];
  }
  getOpeningBracketInfo(e) {
    return this._openingBrackets.get(e);
  }
  getClosingBracketInfo(e) {
    return this._closingBrackets.get(e);
  }
  getBracketInfo(e) {
    return this.getOpeningBracketInfo(e) || this.getClosingBracketInfo(e);
  }
}
function rw(s) {
  return s.filter(([e, t]) => e !== "" && t !== "");
}
class L2 {
  constructor(e, t) {
    this.config = e, this.bracketText = t;
  }
  get languageId() {
    return this.config.languageId;
  }
}
class N4 extends L2 {
  constructor(e, t, i) {
    super(e, t), this.openedBrackets = i, this.isOpeningBracket = !0;
  }
}
class T4 extends L2 {
  constructor(e, t, i) {
    super(e, t), this.closedBrackets = i, this.isOpeningBracket = !1;
  }
  closes(e) {
    if (e.languageId === this.languageId && e.config !== this.config)
      throw new mb("Brackets from different language configuration cannot be used.");
    return this.closedBrackets.has(e);
  }
  getClosedBrackets() {
    return [...this.closedBrackets];
  }
}
var M4 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, ow = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class Zm {
  constructor(e) {
    this.languageId = e;
  }
  affects(e) {
    return this.languageId ? this.languageId === e : !0;
  }
}
const bs = Se("languageConfigurationService");
let c1 = class extends z {
  constructor(e, t) {
    super(), this.configurationService = e, this.languageService = t, this._registry = this._register(new O4()), this.onDidChangeEmitter = this._register(new A()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
    const i = new Set(Object.values(h1));
    this._register(this.configurationService.onDidChangeConfiguration((n) => {
      const r = n.change.keys.some((a) => i.has(a)), o = n.change.overrides.filter(([a, l]) => l.some((c) => i.has(c))).map(([a]) => a);
      if (r)
        this.configurations.clear(), this.onDidChangeEmitter.fire(new Zm(void 0));
      else
        for (const a of o)
          this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new Zm(a)));
    })), this._register(this._registry.onDidChange((n) => {
      this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new Zm(n.languageId));
    }));
  }
  register(e, t, i) {
    return this._registry.register(e, t, i);
  }
  getLanguageConfiguration(e) {
    let t = this.configurations.get(e);
    return t || (t = A4(e, this._registry, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
  }
};
c1 = M4([
  ow(0, gt),
  ow(1, Xt)
], c1);
function A4(s, e, t, i) {
  let n = e.getLanguageConfiguration(s);
  if (!n) {
    if (!i.isRegisteredLanguageId(s))
      throw new Error(`Language id "${s}" is not configured nor known`);
    n = new Ph(s, {});
  }
  const r = R4(n.languageId, t), o = D2([n.underlyingConfig, r]);
  return new Ph(n.languageId, o);
}
const h1 = {
  brackets: "editor.language.brackets",
  colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function R4(s, e) {
  const t = e.getValue(h1.brackets, {
    overrideIdentifier: s
  }), i = e.getValue(h1.colorizedBracketPairs, {
    overrideIdentifier: s
  });
  return {
    brackets: aw(t),
    colorizedBracketPairs: aw(i)
  };
}
function aw(s) {
  if (!!Array.isArray(s))
    return s.map((e) => {
      if (!(!Array.isArray(e) || e.length !== 2))
        return [e[0], e[1]];
    }).filter((e) => !!e);
}
function k2(s, e, t) {
  const i = s.getLineContent(e);
  let n = wi(i);
  return n.length > t - 1 && (n = n.substring(0, t - 1)), n;
}
function fl(s, e, t) {
  s.tokenization.forceTokenization(e);
  const i = s.tokenization.getLineTokens(e), n = typeof t > "u" ? s.getLineMaxColumn(e) - 1 : t - 1;
  return Ng(i, n);
}
class P4 {
  constructor(e) {
    this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new lw(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, ze(() => {
      for (let n = 0; n < this._entries.length; n++)
        if (this._entries[n] === i) {
          this._entries.splice(n, 1), this._resolved = null;
          break;
        }
    });
  }
  getResolvedConfiguration() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new Ph(this.languageId, e));
    }
    return this._resolved;
  }
  _resolve() {
    return this._entries.length === 0 ? null : (this._entries.sort(lw.cmp), D2(this._entries.map((e) => e.configuration)));
  }
}
function D2(s) {
  let e = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const t of s)
    e = {
      comments: t.comments || e.comments,
      brackets: t.brackets || e.brackets,
      wordPattern: t.wordPattern || e.wordPattern,
      indentationRules: t.indentationRules || e.indentationRules,
      onEnterRules: t.onEnterRules || e.onEnterRules,
      autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
      surroundingPairs: t.surroundingPairs || e.surroundingPairs,
      autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
      folding: t.folding || e.folding,
      colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
      __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
    };
  return e;
}
class lw {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class cw {
  constructor(e) {
    this.languageId = e;
  }
}
class O4 extends z {
  constructor() {
    super(), this._entries = /* @__PURE__ */ new Map(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._register(this.register(os, {
      brackets: [
        ["(", ")"],
        ["[", "]"],
        ["{", "}"]
      ],
      surroundingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: "<", close: ">" },
        { open: '"', close: '"' },
        { open: "'", close: "'" },
        { open: "`", close: "`" }
      ],
      colorizedBracketPairs: [],
      folding: {
        offSide: !0
      }
    }, 0));
  }
  register(e, t, i = 0) {
    let n = this._entries.get(e);
    n || (n = new P4(e), this._entries.set(e, n));
    const r = n.register(t, i);
    return this._onDidChange.fire(new cw(e)), ze(() => {
      r.dispose(), this._onDidChange.fire(new cw(e));
    });
  }
  getLanguageConfiguration(e) {
    const t = this._entries.get(e);
    return (t == null ? void 0 : t.getResolvedConfiguration()) || null;
  }
}
class Ph {
  constructor(e, t) {
    this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new qa(this.underlyingConfig) : null, this.comments = Ph._handleComments(this.underlyingConfig), this.characterPair = new Tg(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || ub, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new m4(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {}, this.bracketsNew = new I4(e, this.underlyingConfig);
  }
  getWordDefinition() {
    return Rk(this.wordDefinition);
  }
  get brackets() {
    return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new l4(this.languageId, this.underlyingConfig.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new g4(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, n) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
  }
  getAutoClosingPairs() {
    return new JT(this.characterPair.getAutoClosingPairs());
  }
  getAutoCloseBeforeSet() {
    return this.characterPair.getAutoCloseBeforeSet();
  }
  getSurroundingPairs() {
    return this.characterPair.getSurroundingPairs();
  }
  static _handleComments(e) {
    const t = e.comments;
    if (!t)
      return null;
    const i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      const [n, r] = t.blockComment;
      i.blockCommentStartToken = n, i.blockCommentEndToken = r;
    }
    return i;
  }
}
Ee(bs, c1);
const Cf = new class {
  clone() {
    return this;
  }
  equals(s) {
    return this === s;
  }
}();
function E2(s, e) {
  return new vb([new Nh(0, "", s)], e);
}
function x2(s, e) {
  const t = new Uint32Array(2);
  return t[0] = 0, t[1] = (s << 0 | 0 << 8 | 0 << 11 | 1 << 15 | 2 << 24) >>> 0, new Ig(t, e === null ? Cf : e);
}
const Kt = Se("modelService");
var hn = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
}, Xu = globalThis && globalThis.__asyncValues || function(s) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = s[Symbol.asyncIterator], t;
  return e ? e.call(s) : (s = typeof __values == "function" ? __values(s) : s[Symbol.iterator](), t = {}, i("next"), i("throw"), i("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function i(r) {
    t[r] = s[r] && function(o) {
      return new Promise(function(a, l) {
        o = s[r](o), n(a, l, o.done, o.value);
      });
    };
  }
  function n(r, o, a, l) {
    Promise.resolve(l).then(function(c) {
      r({ value: c, done: a });
    }, o);
  }
};
function u1(s) {
  return !!s && typeof s.then == "function";
}
function I2(s) {
  const e = new lc(), t = s(e.token), i = new Promise((n, r) => {
    const o = e.token.onCancellationRequested(() => {
      o.dispose(), e.dispose(), r(new Du());
    });
    Promise.resolve(t).then((a) => {
      o.dispose(), e.dispose(), n(a);
    }, (a) => {
      o.dispose(), e.dispose(), r(a);
    });
  });
  return new class {
    cancel() {
      e.cancel();
    }
    then(n, r) {
      return i.then(n, r);
    }
    catch(n) {
      return this.then(void 0, n);
    }
    finally(n) {
      return i.finally(n);
    }
  }();
}
class F4 {
  constructor() {
    this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          this.queuedPromise = null;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((n) => {
        this.activePromise = null, t(n);
      }, (n) => {
        this.activePromise = null, i(n);
      });
    });
  }
}
const B4 = (s, e) => {
  let t = !0;
  const i = setTimeout(() => {
    t = !1, e();
  }, s);
  return {
    isTriggered: () => t,
    dispose: () => {
      clearTimeout(i), t = !1;
    }
  };
}, V4 = (s) => {
  let e = !0;
  return queueMicrotask(() => {
    e && (e = !1, s());
  }), {
    isTriggered: () => e,
    dispose: () => {
      e = !1;
    }
  };
}, N2 = Symbol("MicrotaskDelay");
class Og {
  constructor(e) {
    this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, r) => {
      this.doResolve = n, this.doReject = r;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const n = this.task;
        return this.task = null, n();
      }
    }));
    const i = () => {
      var n;
      this.deferred = null, (n = this.doResolve) === null || n === void 0 || n.call(this, null);
    };
    return this.deferred = t === N2 ? V4(i) : B4(t, i), this.completionPromise;
  }
  isTriggered() {
    var e;
    return !!(!((e = this.deferred) === null || e === void 0) && e.isTriggered());
  }
  cancel() {
    var e;
    this.cancelTimeout(), this.completionPromise && ((e = this.doReject) === null || e === void 0 || e.call(this, new Du()), this.completionPromise = null);
  }
  cancelTimeout() {
    var e;
    (e = this.deferred) === null || e === void 0 || e.dispose(), this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
}
class W4 {
  constructor(e) {
    this.delayer = new Og(e), this.throttler = new F4();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  dispose() {
    this.delayer.dispose();
  }
}
function Oh(s, e) {
  return e ? new Promise((t, i) => {
    const n = setTimeout(() => {
      r.dispose(), t();
    }, s), r = e.onCancellationRequested(() => {
      clearTimeout(n), r.dispose(), i(new Du());
    });
  }) : I2((t) => Oh(s, t));
}
function d1(s, e = 0) {
  const t = setTimeout(s, e);
  return ze(() => clearTimeout(t));
}
class oo {
  constructor(e, t) {
    this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class Nu {
  constructor() {
    this._token = -1;
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    this._token !== -1 && (clearInterval(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    this.cancel(), this._token = setInterval(() => {
      e();
    }, t);
  }
}
class oi {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  dispose() {
    this.cancel(), this.runner = null;
  }
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    var e;
    (e = this.runner) === null || e === void 0 || e.call(this);
  }
}
let vf;
(function() {
  typeof requestIdleCallback != "function" || typeof cancelIdleCallback != "function" ? vf = (s) => {
    Nk(() => {
      if (e)
        return;
      const t = Date.now() + 15;
      s(Object.freeze({
        didTimeout: !0,
        timeRemaining() {
          return Math.max(0, t - Date.now());
        }
      }));
    });
    let e = !1;
    return {
      dispose() {
        e || (e = !0);
      }
    };
  } : vf = (s, e) => {
    const t = requestIdleCallback(s, typeof e == "number" ? { timeout: e } : void 0);
    let i = !1;
    return {
      dispose() {
        i || (i = !0, cancelIdleCallback(t));
      }
    };
  };
})();
class Fg {
  constructor(e) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = e();
      } catch (t) {
        this._error = t;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = vf(() => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class T2 {
  constructor() {
    this.rejected = !1, this.resolved = !1, this.p = new Promise((e, t) => {
      this.completeCallback = e, this.errorCallback = t;
    });
  }
  get isRejected() {
    return this.rejected;
  }
  get isSettled() {
    return this.rejected || this.resolved;
  }
  complete(e) {
    return new Promise((t) => {
      this.completeCallback(e), this.resolved = !0, t();
    });
  }
  cancel() {
    new Promise((e) => {
      this.errorCallback(new Du()), this.rejected = !0, e();
    });
  }
}
var f1;
(function(s) {
  function e(i) {
    return hn(this, void 0, void 0, function* () {
      let n;
      const r = yield Promise.all(i.map((o) => o.then((a) => a, (a) => {
        n || (n = a);
      })));
      if (typeof n < "u")
        throw n;
      return r;
    });
  }
  s.settled = e;
  function t(i) {
    return new Promise((n, r) => hn(this, void 0, void 0, function* () {
      try {
        yield i(n, r);
      } catch (o) {
        r(o);
      }
    }));
  }
  s.withAsyncBody = t;
})(f1 || (f1 = {}));
class Ai {
  constructor(e) {
    this._state = 0, this._results = [], this._error = null, this._onStateChanged = new A(), queueMicrotask(() => hn(this, void 0, void 0, function* () {
      const t = {
        emitOne: (i) => this.emitOne(i),
        emitMany: (i) => this.emitMany(i),
        reject: (i) => this.reject(i)
      };
      try {
        yield Promise.resolve(e(t)), this.resolve();
      } catch (i) {
        this.reject(i);
      } finally {
        t.emitOne = void 0, t.emitMany = void 0, t.reject = void 0;
      }
    }));
  }
  static fromArray(e) {
    return new Ai((t) => {
      t.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new Ai((t) => hn(this, void 0, void 0, function* () {
      t.emitMany(yield e);
    }));
  }
  static fromPromises(e) {
    return new Ai((t) => hn(this, void 0, void 0, function* () {
      yield Promise.all(e.map((i) => hn(this, void 0, void 0, function* () {
        return t.emitOne(yield i);
      })));
    }));
  }
  static merge(e) {
    return new Ai((t) => hn(this, void 0, void 0, function* () {
      yield Promise.all(e.map((i) => {
        var n, r;
        return hn(this, void 0, void 0, function* () {
          var o, a;
          try {
            for (n = Xu(i); r = yield n.next(), !r.done; ) {
              const l = r.value;
              t.emitOne(l);
            }
          } catch (l) {
            o = { error: l };
          } finally {
            try {
              r && !r.done && (a = n.return) && (yield a.call(n));
            } finally {
              if (o)
                throw o.error;
            }
          }
        });
      }));
    }));
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: () => hn(this, void 0, void 0, function* () {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          yield Q.toPromise(this._onStateChanged.event);
        } while (!0);
      })
    };
  }
  static map(e, t) {
    return new Ai((i) => hn(this, void 0, void 0, function* () {
      var n, r;
      try {
        for (var o = Xu(e), a; a = yield o.next(), !a.done; ) {
          const l = a.value;
          i.emitOne(t(l));
        }
      } catch (l) {
        n = { error: l };
      } finally {
        try {
          a && !a.done && (r = o.return) && (yield r.call(o));
        } finally {
          if (n)
            throw n.error;
        }
      }
    }));
  }
  map(e) {
    return Ai.map(this, e);
  }
  static filter(e, t) {
    return new Ai((i) => hn(this, void 0, void 0, function* () {
      var n, r;
      try {
        for (var o = Xu(e), a; a = yield o.next(), !a.done; ) {
          const l = a.value;
          t(l) && i.emitOne(l);
        }
      } catch (l) {
        n = { error: l };
      } finally {
        try {
          a && !a.done && (r = o.return) && (yield r.call(o));
        } finally {
          if (n)
            throw n.error;
        }
      }
    }));
  }
  filter(e) {
    return Ai.filter(this, e);
  }
  static coalesce(e) {
    return Ai.filter(e, (t) => !!t);
  }
  coalesce() {
    return Ai.coalesce(this);
  }
  static toPromise(e) {
    var t, i, n, r;
    return hn(this, void 0, void 0, function* () {
      const o = [];
      try {
        for (t = Xu(e); i = yield t.next(), !i.done; ) {
          const a = i.value;
          o.push(a);
        }
      } catch (a) {
        n = { error: a };
      } finally {
        try {
          i && !i.done && (r = t.return) && (yield r.call(t));
        } finally {
          if (n)
            throw n.error;
        }
      }
      return o;
    });
  }
  toPromise() {
    return Ai.toPromise(this);
  }
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
}
Ai.EMPTY = Ai.fromArray([]);
const H4 = "$initialize";
let hw = !1;
function g1(s) {
  !rc || (hw || (hw = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(s.message));
}
class z4 {
  constructor(e, t, i, n) {
    this.vsWorker = e, this.req = t, this.method = i, this.args = n, this.type = 0;
  }
}
class uw {
  constructor(e, t, i, n) {
    this.vsWorker = e, this.seq = t, this.res = i, this.err = n, this.type = 1;
  }
}
class U4 {
  constructor(e, t, i, n) {
    this.vsWorker = e, this.req = t, this.eventName = i, this.arg = n, this.type = 2;
  }
}
class $4 {
  constructor(e, t, i) {
    this.vsWorker = e, this.req = t, this.event = i, this.type = 3;
  }
}
class j4 {
  constructor(e, t) {
    this.vsWorker = e, this.req = t, this.type = 4;
  }
}
class K4 {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, t) {
    const i = String(++this._lastSentReq);
    return new Promise((n, r) => {
      this._pendingReplies[i] = {
        resolve: n,
        reject: r
      }, this._send(new z4(this._workerId, i, e, t));
    });
  }
  listen(e, t) {
    let i = null;
    const n = new A({
      onFirstListenerAdd: () => {
        i = String(++this._lastSentReq), this._pendingEmitters.set(i, n), this._send(new U4(this._workerId, i, e, t));
      },
      onLastListenerRemove: () => {
        this._pendingEmitters.delete(i), this._send(new j4(this._workerId, i)), i = null;
      }
    });
    return n.event;
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  _handleMessage(e) {
    switch (e.type) {
      case 1:
        return this._handleReplyMessage(e);
      case 0:
        return this._handleRequestMessage(e);
      case 2:
        return this._handleSubscribeEventMessage(e);
      case 3:
        return this._handleEventMessage(e);
      case 4:
        return this._handleUnsubscribeEventMessage(e);
    }
  }
  _handleReplyMessage(e) {
    if (!this._pendingReplies[e.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const t = this._pendingReplies[e.seq];
    if (delete this._pendingReplies[e.seq], e.err) {
      let i = e.err;
      e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), t.reject(i);
      return;
    }
    t.resolve(e.res);
  }
  _handleRequestMessage(e) {
    const t = e.req;
    this._handler.handleMessage(e.method, e.args).then((n) => {
      this._send(new uw(this._workerId, t, n, void 0));
    }, (n) => {
      n.detail instanceof Error && (n.detail = Ov(n.detail)), this._send(new uw(this._workerId, t, void 0, Ov(n)));
    });
  }
  _handleSubscribeEventMessage(e) {
    const t = e.req, i = this._handler.handleEvent(e.eventName, e.arg)((n) => {
      this._send(new $4(this._workerId, t, n));
    });
    this._pendingEvents.set(t, i);
  }
  _handleEventMessage(e) {
    if (!this._pendingEmitters.has(e.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(e.req).fire(e.event);
  }
  _handleUnsubscribeEventMessage(e) {
    if (!this._pendingEvents.has(e.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
  }
  _send(e) {
    const t = [];
    if (e.type === 0)
      for (let i = 0; i < e.args.length; i++)
        e.args[i] instanceof ArrayBuffer && t.push(e.args[i]);
    else
      e.type === 1 && e.res instanceof ArrayBuffer && t.push(e.res);
    this._handler.sendMessage(e, t);
  }
}
class q4 extends z {
  constructor(e, t, i) {
    super();
    let n = null;
    this._worker = this._register(e.create("vs/base/common/worker/simpleWorker", (c) => {
      this._protocol.handleMessage(c);
    }, (c) => {
      n == null || n(c);
    })), this._protocol = new K4({
      sendMessage: (c, h) => {
        this._worker.postMessage(c, h);
      },
      handleMessage: (c, h) => {
        if (typeof i[c] != "function")
          return Promise.reject(new Error("Missing method " + c + " on main thread host."));
        try {
          return Promise.resolve(i[c].apply(i, h));
        } catch (u) {
          return Promise.reject(u);
        }
      },
      handleEvent: (c, h) => {
        if (A2(c)) {
          const u = i[c].call(i, h);
          if (typeof u != "function")
            throw new Error(`Missing dynamic event ${c} on main thread host.`);
          return u;
        }
        if (M2(c)) {
          const u = i[c];
          if (typeof u != "function")
            throw new Error(`Missing event ${c} on main thread host.`);
          return u;
        }
        throw new Error(`Malformed event name ${c}`);
      }
    }), this._protocol.setWorkerId(this._worker.getId());
    let r = null;
    typeof it.require < "u" && typeof it.require.getConfig == "function" ? r = it.require.getConfig() : typeof it.requirejs < "u" && (r = it.requirejs.s.contexts._.config);
    const o = db(i);
    this._onModuleLoaded = this._protocol.sendMessage(H4, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(r)),
      t,
      o
    ]);
    const a = (c, h) => this._request(c, h), l = (c, h) => this._protocol.listen(c, h);
    this._lazyProxy = new Promise((c, h) => {
      n = h, this._onModuleLoaded.then((u) => {
        c(G4(u, a, l));
      }, (u) => {
        h(u), this._onError("Worker failed to load " + t, u);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(e, t) {
    return new Promise((i, n) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(e, t).then(i, n);
      }, n);
    });
  }
  _onError(e, t) {
    console.error(e), console.info(t);
  }
}
function M2(s) {
  return s[0] === "o" && s[1] === "n" && yr(s.charCodeAt(2));
}
function A2(s) {
  return /^onDynamic/.test(s) && yr(s.charCodeAt(9));
}
function G4(s, e, t) {
  const i = (o) => function() {
    const a = Array.prototype.slice.call(arguments, 0);
    return e(o, a);
  }, n = (o) => function(a) {
    return t(o, a);
  }, r = {};
  for (const o of s) {
    if (A2(o)) {
      r[o] = n(o);
      continue;
    }
    if (M2(o)) {
      r[o] = t(o, void 0);
      continue;
    }
    r[o] = i(o);
  }
  return r;
}
var Ym;
const dw = (Ym = window.trustedTypes) === null || Ym === void 0 ? void 0 : Ym.createPolicy("defaultWorkerFactory", { createScriptURL: (s) => s });
function Z4(s) {
  if (it.MonacoEnvironment) {
    if (typeof it.MonacoEnvironment.getWorker == "function")
      return it.MonacoEnvironment.getWorker("workerMain.js", s);
    if (typeof it.MonacoEnvironment.getWorkerUrl == "function") {
      const e = it.MonacoEnvironment.getWorkerUrl("workerMain.js", s);
      return new Worker(dw ? dw.createScriptURL(e) : e, { name: s });
    }
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function Y4(s) {
  return typeof s.then == "function";
}
class Q4 {
  constructor(e, t, i, n, r) {
    this.id = t;
    const o = Z4(i);
    Y4(o) ? this.worker = o : this.worker = Promise.resolve(o), this.postMessage(e, []), this.worker.then((a) => {
      a.onmessage = function(l) {
        n(l.data);
      }, a.onmessageerror = r, typeof a.addEventListener == "function" && a.addEventListener("error", r);
    });
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    var i;
    (i = this.worker) === null || i === void 0 || i.then((n) => n.postMessage(e, t));
  }
  dispose() {
    var e;
    (e = this.worker) === null || e === void 0 || e.then((t) => t.terminate()), this.worker = null;
  }
}
class Bg {
  constructor(e) {
    this._label = e, this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    const n = ++Bg.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new Q4(e, n, this._label || "anonymous" + n, t, (r) => {
      g1(r), this._webWorkerFailedBeforeError = r, i(r);
    });
  }
}
Bg.LAST_WORKER_ID = 0;
class br {
  constructor(e, t, i, n) {
    this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = n;
  }
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
function Fb(s, e) {
  switch (typeof s) {
    case "object":
      return s === null ? qs(349, e) : Array.isArray(s) ? J4(s, e) : e5(s, e);
    case "string":
      return Bb(s, e);
    case "boolean":
      return X4(s, e);
    case "number":
      return qs(s, e);
    case "undefined":
      return qs(937, e);
    default:
      return qs(617, e);
  }
}
function qs(s, e) {
  return (e << 5) - e + s | 0;
}
function X4(s, e) {
  return qs(s ? 433 : 863, e);
}
function Bb(s, e) {
  e = qs(149417, e);
  for (let t = 0, i = s.length; t < i; t++)
    e = qs(s.charCodeAt(t), e);
  return e;
}
function J4(s, e) {
  return e = qs(104579, e), s.reduce((t, i) => Fb(i, t), e);
}
function e5(s, e) {
  return e = qs(181387, e), Object.keys(s).sort().reduce((t, i) => (t = Bb(i, t), Fb(s[i], t)), e);
}
function Qm(s, e, t = 32) {
  const i = t - e, n = ~((1 << i) - 1);
  return (s << e | (n & s) >>> i) >>> 0;
}
function fw(s, e = 0, t = s.byteLength, i = 0) {
  for (let n = 0; n < t; n++)
    s[e + n] = i;
}
function t5(s, e, t = "0") {
  for (; s.length < e; )
    s = t + s;
  return s;
}
function Ic(s, e = 32) {
  return s instanceof ArrayBuffer ? Array.from(new Uint8Array(s)).map((t) => t.toString(16).padStart(2, "0")).join("") : t5((s >>> 0).toString(16), e / 4);
}
class Vg {
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(64 + 3), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const t = e.length;
    if (t === 0)
      return;
    const i = this._buff;
    let n = this._buffLen, r = this._leftoverHighSurrogate, o, a;
    for (r !== 0 ? (o = r, a = -1, r = 0) : (o = e.charCodeAt(0), a = 0); ; ) {
      let l = o;
      if (Lt(o))
        if (a + 1 < t) {
          const c = e.charCodeAt(a + 1);
          Rl(c) ? (a++, l = Lb(o, c)) : l = 65533;
        } else {
          r = o;
          break;
        }
      else
        Rl(o) && (l = 65533);
      if (n = this._push(i, n, l), a++, a < t)
        o = e.charCodeAt(a);
      else
        break;
    }
    this._buffLen = n, this._leftoverHighSurrogate = r;
  }
  _push(e, t, i) {
    return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64 + 0], e[1] = e[64 + 1], e[2] = e[64 + 2]), t;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(this._buff, this._buffLen, 65533)), this._totalLen += this._buffLen, this._wrapUp()), Ic(this._h0) + Ic(this._h1) + Ic(this._h2) + Ic(this._h3) + Ic(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, fw(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), fw(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = Vg._bigBlock32, t = this._buffDV;
    for (let u = 0; u < 64; u += 4)
      e.setUint32(u, t.getUint32(u, !1), !1);
    for (let u = 64; u < 320; u += 4)
      e.setUint32(u, Qm(e.getUint32(u - 12, !1) ^ e.getUint32(u - 32, !1) ^ e.getUint32(u - 56, !1) ^ e.getUint32(u - 64, !1), 1), !1);
    let i = this._h0, n = this._h1, r = this._h2, o = this._h3, a = this._h4, l, c, h;
    for (let u = 0; u < 80; u++)
      u < 20 ? (l = n & r | ~n & o, c = 1518500249) : u < 40 ? (l = n ^ r ^ o, c = 1859775393) : u < 60 ? (l = n & r | n & o | r & o, c = 2400959708) : (l = n ^ r ^ o, c = 3395469782), h = Qm(i, 5) + l + a + c + e.getUint32(u * 4, !1) & 4294967295, a = o, o = r, r = Qm(n, 30), n = i, i = h;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + n & 4294967295, this._h2 = this._h2 + r & 4294967295, this._h3 = this._h3 + o & 4294967295, this._h4 = this._h4 + a & 4294967295;
  }
}
Vg._bigBlock32 = new DataView(new ArrayBuffer(320));
class gw {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, t = new Int32Array(e.length);
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
}
function i5(s, e, t) {
  return new Us(new gw(s), new gw(e)).ComputeDiff(t).changes;
}
class Da {
  static Assert(e, t) {
    if (!e)
      throw new Error(t);
  }
}
class Ea {
  static Copy(e, t, i, n, r) {
    for (let o = 0; o < r; o++)
      i[n + o] = e[t + o];
  }
  static Copy2(e, t, i, n, r) {
    for (let o = 0; o < r; o++)
      i[n + o] = e[t + o];
  }
}
class mw {
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new br(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  AddOriginalElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
  }
  AddModifiedElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
  }
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class Us {
  constructor(e, t, i = null) {
    this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = t;
    const [n, r, o] = Us._getElements(e), [a, l, c] = Us._getElements(t);
    this._hasStrings = o && c, this._originalStringElements = n, this._originalElementsOrHash = r, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const t = e.getElements();
    if (Us._isStringArray(t)) {
      const i = new Int32Array(t.length);
      for (let n = 0, r = t.length; n < r; n++)
        i[n] = Bb(t[n], 0);
      return [t, i, !0];
    }
    return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
  }
  ElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ElementsAreStrictEqual(e, t) {
    if (!this.ElementsAreEqual(e, t))
      return !1;
    const i = Us._getStrictElement(this._originalSequence, e), n = Us._getStrictElement(this._modifiedSequence, t);
    return i === n;
  }
  static _getStrictElement(e, t) {
    return typeof e.getStrictElement == "function" ? e.getStrictElement(t) : null;
  }
  OriginalElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
  }
  ModifiedElementsAreEqual(e, t) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  _ComputeDiff(e, t, i, n, r) {
    const o = [!1];
    let a = this.ComputeDiffRecursive(e, t, i, n, o);
    return r && (a = this.PrettifyChanges(a)), {
      quitEarly: o[0],
      changes: a
    };
  }
  ComputeDiffRecursive(e, t, i, n, r) {
    for (r[0] = !1; e <= t && i <= n && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; t >= e && n >= i && this.ElementsAreEqual(t, n); )
      t--, n--;
    if (e > t || i > n) {
      let u;
      return i <= n ? (Da.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), u = [
        new br(e, 0, i, n - i + 1)
      ]) : e <= t ? (Da.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), u = [
        new br(e, t - e + 1, i, 0)
      ]) : (Da.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), Da.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), u = []), u;
    }
    const o = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, n, o, a, r), c = o[0], h = a[0];
    if (l !== null)
      return l;
    if (!r[0]) {
      const u = this.ComputeDiffRecursive(e, c, i, h, r);
      let d = [];
      return r[0] ? d = [
        new br(c + 1, t - (c + 1) + 1, h + 1, n - (h + 1) + 1)
      ] : d = this.ComputeDiffRecursive(c + 1, t, h + 1, n, r), this.ConcatenateChanges(u, d);
    }
    return [
      new br(e, t - e + 1, i, n - i + 1)
    ];
  }
  WALKTRACE(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, b, v, C) {
    let w = null, L = null, E = new mw(), k = t, y = i, S = f[0] - b[0] - n, D = -1073741824, T = this.m_forwardHistory.length - 1;
    do {
      const M = S + e;
      M === k || M < y && c[M - 1] < c[M + 1] ? (u = c[M + 1], m = u - S - n, u < D && E.MarkNextChange(), D = u, E.AddModifiedElement(u + 1, m), S = M + 1 - e) : (u = c[M - 1] + 1, m = u - S - n, u < D && E.MarkNextChange(), D = u - 1, E.AddOriginalElement(u, m + 1), S = M - 1 - e), T >= 0 && (c = this.m_forwardHistory[T], e = c[0], k = 1, y = c.length - 1);
    } while (--T >= -1);
    if (w = E.getReverseChanges(), C[0]) {
      let M = f[0] + 1, P = b[0] + 1;
      if (w !== null && w.length > 0) {
        const V = w[w.length - 1];
        M = Math.max(M, V.getOriginalEnd()), P = Math.max(P, V.getModifiedEnd());
      }
      L = [
        new br(M, d - M + 1, P, _ - P + 1)
      ];
    } else {
      E = new mw(), k = o, y = a, S = f[0] - b[0] - l, D = 1073741824, T = v ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const M = S + r;
        M === k || M < y && h[M - 1] >= h[M + 1] ? (u = h[M + 1] - 1, m = u - S - l, u > D && E.MarkNextChange(), D = u + 1, E.AddOriginalElement(u + 1, m + 1), S = M + 1 - r) : (u = h[M - 1], m = u - S - l, u > D && E.MarkNextChange(), D = u, E.AddModifiedElement(u + 1, m + 1), S = M - 1 - r), T >= 0 && (h = this.m_reverseHistory[T], r = h[0], k = 1, y = h.length - 1);
      } while (--T >= -1);
      L = E.getChanges();
    }
    return this.ConcatenateChanges(w, L);
  }
  ComputeRecursionPoint(e, t, i, n, r, o, a) {
    let l = 0, c = 0, h = 0, u = 0, d = 0, f = 0;
    e--, i--, r[0] = 0, o[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const m = t - e + (n - i), _ = m + 1, b = new Int32Array(_), v = new Int32Array(_), C = n - i, w = t - e, L = e - i, E = t - n, y = (w - C) % 2 === 0;
    b[C] = e, v[w] = t, a[0] = !1;
    for (let S = 1; S <= m / 2 + 1; S++) {
      let D = 0, T = 0;
      h = this.ClipDiagonalBound(C - S, S, C, _), u = this.ClipDiagonalBound(C + S, S, C, _);
      for (let P = h; P <= u; P += 2) {
        P === h || P < u && b[P - 1] < b[P + 1] ? l = b[P + 1] : l = b[P - 1] + 1, c = l - (P - C) - L;
        const V = l;
        for (; l < t && c < n && this.ElementsAreEqual(l + 1, c + 1); )
          l++, c++;
        if (b[P] = l, l + c > D + T && (D = l, T = c), !y && Math.abs(P - w) <= S - 1 && l >= v[P])
          return r[0] = l, o[0] = c, V <= v[P] && 1447 > 0 && S <= 1447 + 1 ? this.WALKTRACE(C, h, u, L, w, d, f, E, b, v, l, t, r, c, n, o, y, a) : null;
      }
      const M = (D - e + (T - i) - S) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(D, M))
        return a[0] = !0, r[0] = D, o[0] = T, M > 0 && 1447 > 0 && S <= 1447 + 1 ? this.WALKTRACE(C, h, u, L, w, d, f, E, b, v, l, t, r, c, n, o, y, a) : (e++, i++, [
          new br(e, t - e + 1, i, n - i + 1)
        ]);
      d = this.ClipDiagonalBound(w - S, S, w, _), f = this.ClipDiagonalBound(w + S, S, w, _);
      for (let P = d; P <= f; P += 2) {
        P === d || P < f && v[P - 1] >= v[P + 1] ? l = v[P + 1] - 1 : l = v[P - 1], c = l - (P - w) - E;
        const V = l;
        for (; l > e && c > i && this.ElementsAreEqual(l, c); )
          l--, c--;
        if (v[P] = l, y && Math.abs(P - C) <= S && l <= b[P])
          return r[0] = l, o[0] = c, V >= b[P] && 1447 > 0 && S <= 1447 + 1 ? this.WALKTRACE(C, h, u, L, w, d, f, E, b, v, l, t, r, c, n, o, y, a) : null;
      }
      if (S <= 1447) {
        let P = new Int32Array(u - h + 2);
        P[0] = C - h + 1, Ea.Copy2(b, h, P, 1, u - h + 1), this.m_forwardHistory.push(P), P = new Int32Array(f - d + 2), P[0] = w - d + 1, Ea.Copy2(v, d, P, 1, f - d + 1), this.m_reverseHistory.push(P);
      }
    }
    return this.WALKTRACE(C, h, u, L, w, d, f, E, b, v, l, t, r, c, n, o, y, a);
  }
  PrettifyChanges(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, r = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, o = i.originalLength > 0, a = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < n && i.modifiedStart + i.modifiedLength < r && (!o || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
        const c = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
        if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !c)
          break;
        i.originalStart++, i.modifiedStart++;
      }
      const l = [null];
      if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
        e[t] = l[0], e.splice(t + 1, 1), t--;
        continue;
      }
    }
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      let n = 0, r = 0;
      if (t > 0) {
        const u = e[t - 1];
        n = u.originalStart + u.originalLength, r = u.modifiedStart + u.modifiedLength;
      }
      const o = i.originalLength > 0, a = i.modifiedLength > 0;
      let l = 0, c = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let u = 1; ; u++) {
        const d = i.originalStart - u, f = i.modifiedStart - u;
        if (d < n || f < r || o && !this.OriginalElementsAreEqual(d, d + i.originalLength) || a && !this.ModifiedElementsAreEqual(f, f + i.modifiedLength))
          break;
        const _ = (d === n && f === r ? 5 : 0) + this._boundaryScore(d, i.originalLength, f, i.modifiedLength);
        _ > c && (c = _, l = u);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const h = [null];
      if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], h)) {
        e[t - 1] = h[0], e.splice(t, 1), t++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let t = 1, i = e.length; t < i; t++) {
        const n = e[t - 1], r = e[t], o = r.originalStart - n.originalStart - n.originalLength, a = n.originalStart, l = r.originalStart + r.originalLength, c = l - a, h = n.modifiedStart, u = r.modifiedStart + r.modifiedLength, d = u - h;
        if (o < 5 && c < 20 && d < 20) {
          const f = this._findBetterContiguousSequence(a, c, h, d, o);
          if (f) {
            const [m, _] = f;
            (m !== n.originalStart + n.originalLength || _ !== n.modifiedStart + n.modifiedLength) && (n.originalLength = m - n.originalStart, n.modifiedLength = _ - n.modifiedStart, r.originalStart = m + o, r.modifiedStart = _ + o, r.originalLength = l - r.originalStart, r.modifiedLength = u - r.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, t, i, n, r) {
    if (t < r || n < r)
      return null;
    const o = e + t - r + 1, a = i + n - r + 1;
    let l = 0, c = 0, h = 0;
    for (let u = e; u < o; u++)
      for (let d = i; d < a; d++) {
        const f = this._contiguousSequenceScore(u, d, r);
        f > 0 && f > l && (l = f, c = u, h = d);
      }
    return l > 0 ? [c, h] : null;
  }
  _contiguousSequenceScore(e, t, i) {
    let n = 0;
    for (let r = 0; r < i; r++) {
      if (!this.ElementsAreEqual(e + r, t + r))
        return 0;
      n += this._originalStringElements[e + r].length;
    }
    return n;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, t) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, t) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, t, i, n) {
    const r = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, o = this._ModifiedRegionIsBoundary(i, n) ? 1 : 0;
    return r + o;
  }
  ConcatenateChanges(e, t) {
    const i = [];
    if (e.length === 0 || t.length === 0)
      return t.length > 0 ? t : e;
    if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
      const n = new Array(e.length + t.length - 1);
      return Ea.Copy(e, 0, n, 0, e.length - 1), n[e.length - 1] = i[0], Ea.Copy(t, 1, n, e.length, t.length - 1), n;
    } else {
      const n = new Array(e.length + t.length);
      return Ea.Copy(e, 0, n, 0, e.length), Ea.Copy(t, 0, n, e.length, t.length), n;
    }
  }
  ChangesOverlap(e, t, i) {
    if (Da.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), Da.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
      const n = e.originalStart;
      let r = e.originalLength;
      const o = e.modifiedStart;
      let a = e.modifiedLength;
      return e.originalStart + e.originalLength >= t.originalStart && (r = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new br(n, r, o, a), !0;
    } else
      return i[0] = null, !1;
  }
  ClipDiagonalBound(e, t, i, n) {
    if (e >= 0 && e < n)
      return e;
    const r = i, o = n - i - 1, a = t % 2 === 0;
    if (e < 0) {
      const l = r % 2 === 0;
      return a === l ? 0 : 1;
    } else {
      const l = o % 2 === 0;
      return a === l ? n - 1 : n - 2;
    }
  }
}
const n5 = 3;
function R2(s, e, t, i) {
  return new Us(s, e, t).ComputeDiff(i);
}
class pw {
  constructor(e) {
    const t = [], i = [];
    for (let n = 0, r = e.length; n < r; n++)
      t[n] = m1(e[n], 1), i[n] = p1(e[n], 1);
    this.lines = e, this._startColumns = t, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let t = 0, i = this.lines.length; t < i; t++)
      e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
    return e;
  }
  getStrictElement(e) {
    return this.lines[e];
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, t, i) {
    const n = [], r = [], o = [];
    let a = 0;
    for (let l = t; l <= i; l++) {
      const c = this.lines[l], h = e ? this._startColumns[l] : 1, u = e ? this._endColumns[l] : c.length + 1;
      for (let d = h; d < u; d++)
        n[a] = c.charCodeAt(d - 1), r[a] = l + 1, o[a] = d, a++;
      !e && l < i && (n[a] = 10, r[a] = l + 1, o[a] = c.length + 1, a++);
    }
    return new s5(n, r, o);
  }
}
class s5 {
  constructor(e, t, i) {
    this._charCodes = e, this._lineNumbers = t, this._columns = i;
  }
  toString() {
    return "[" + this._charCodes.map((e, t) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[t]},${this._columns[t]})`).join(", ") + "]";
  }
  _assertIndex(e, t) {
    if (e < 0 || e >= t.length)
      throw new Error("Illegal index");
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
  }
  getEndLineNumber(e) {
    return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
  }
  getStartColumn(e) {
    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
  }
  getEndColumn(e) {
    return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
  }
}
class Fh {
  constructor(e, t, i, n, r, o, a, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = n, this.modifiedStartLineNumber = r, this.modifiedStartColumn = o, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, t, i) {
    const n = t.getStartLineNumber(e.originalStart), r = t.getStartColumn(e.originalStart), o = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1), l = i.getStartLineNumber(e.modifiedStart), c = i.getStartColumn(e.modifiedStart), h = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), u = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
    return new Fh(n, r, o, a, l, c, h, u);
  }
}
function r5(s) {
  if (s.length <= 1)
    return s;
  const e = [s[0]];
  let t = e[0];
  for (let i = 1, n = s.length; i < n; i++) {
    const r = s[i], o = r.originalStart - (t.originalStart + t.originalLength), a = r.modifiedStart - (t.modifiedStart + t.modifiedLength);
    Math.min(o, a) < n5 ? (t.originalLength = r.originalStart + r.originalLength - t.originalStart, t.modifiedLength = r.modifiedStart + r.modifiedLength - t.modifiedStart) : (e.push(r), t = r);
  }
  return e;
}
class ah {
  constructor(e, t, i, n, r) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = n, this.charChanges = r;
  }
  static createFromDiffResult(e, t, i, n, r, o, a) {
    let l, c, h, u, d;
    if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, c = 0) : (l = i.getStartLineNumber(t.originalStart), c = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (h = n.getStartLineNumber(t.modifiedStart) - 1, u = 0) : (h = n.getStartLineNumber(t.modifiedStart), u = n.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), o && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && r()) {
      const f = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), m = n.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
      if (f.getElements().length > 0 && m.getElements().length > 0) {
        let _ = R2(f, m, r, !0).changes;
        a && (_ = r5(_)), d = [];
        for (let b = 0, v = _.length; b < v; b++)
          d.push(Fh.createFromDiffChange(_[b], f, m));
      }
    }
    return new ah(l, c, h, u, d);
  }
}
class o5 {
  constructor(e, t, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new pw(e), this.modified = new pw(t), this.continueLineDiff = _w(i.maxComputationTime), this.continueCharDiff = _w(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    const e = R2(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const a = [];
      for (let l = 0, c = t.length; l < c; l++)
        a.push(ah.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: a
      };
    }
    const n = [];
    let r = 0, o = 0;
    for (let a = -1, l = t.length; a < l; a++) {
      const c = a + 1 < l ? t[a + 1] : null, h = c ? c.originalStart : this.originalLines.length, u = c ? c.modifiedStart : this.modifiedLines.length;
      for (; r < h && o < u; ) {
        const d = this.originalLines[r], f = this.modifiedLines[o];
        if (d !== f) {
          {
            let m = m1(d, 1), _ = m1(f, 1);
            for (; m > 1 && _ > 1; ) {
              const b = d.charCodeAt(m - 2), v = f.charCodeAt(_ - 2);
              if (b !== v)
                break;
              m--, _--;
            }
            (m > 1 || _ > 1) && this._pushTrimWhitespaceCharChange(n, r + 1, 1, m, o + 1, 1, _);
          }
          {
            let m = p1(d, 1), _ = p1(f, 1);
            const b = d.length + 1, v = f.length + 1;
            for (; m < b && _ < v; ) {
              const C = d.charCodeAt(m - 1), w = d.charCodeAt(_ - 1);
              if (C !== w)
                break;
              m++, _++;
            }
            (m < b || _ < v) && this._pushTrimWhitespaceCharChange(n, r + 1, m, b, o + 1, _, v);
          }
        }
        r++, o++;
      }
      c && (n.push(ah.createFromDiffResult(this.shouldIgnoreTrimWhitespace, c, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), r += c.originalLength, o += c.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: n
    };
  }
  _pushTrimWhitespaceCharChange(e, t, i, n, r, o, a) {
    if (this._mergeTrimWhitespaceCharChange(e, t, i, n, r, o, a))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new Fh(t, i, t, n, r, o, r, a)]), e.push(new ah(t, t, r, r, l));
  }
  _mergeTrimWhitespaceCharChange(e, t, i, n, r, o, a) {
    const l = e.length;
    if (l === 0)
      return !1;
    const c = e[l - 1];
    return c.originalEndLineNumber === 0 || c.modifiedEndLineNumber === 0 ? !1 : c.originalEndLineNumber + 1 === t && c.modifiedEndLineNumber + 1 === r ? (c.originalEndLineNumber = t, c.modifiedEndLineNumber = r, this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new Fh(t, i, t, n, r, o, r, a)), !0) : !1;
  }
}
function m1(s, e) {
  const t = Bi(s);
  return t === -1 ? e : t + 1;
}
function p1(s, e) {
  const t = cc(s);
  return t === -1 ? e : t + 2;
}
function _w(s) {
  if (s === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < s;
}
function wf(s) {
  return s < 0 ? 0 : s > 255 ? 255 : s | 0;
}
function xa(s) {
  return s < 0 ? 0 : s > 4294967295 ? 4294967295 : s | 0;
}
class a5 {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, t) {
    e = xa(e);
    const i = this.values, n = this.prefixSum, r = t.length;
    return r === 0 ? !1 : (this.values = new Uint32Array(i.length + r), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + r), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, t) {
    return e = xa(e), t = xa(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, t) {
    e = xa(e), t = xa(t);
    const i = this.values, n = this.prefixSum;
    if (e >= i.length)
      return !1;
    const r = i.length - e;
    return t >= r && (t = r), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = xa(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let t = this.prefixSumValidIndex[0] + 1;
    t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = t; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let t = 0, i = this.values.length - 1, n = 0, r = 0, o = 0;
    for (; t <= i; )
      if (n = t + (i - t) / 2 | 0, r = this.prefixSum[n], o = r - this.values[n], e < o)
        i = n - 1;
      else if (e >= r)
        t = n + 1;
      else
        break;
    return new P2(n, e - o);
  }
}
class l5 {
  constructor(e) {
    this._values = e, this._isValid = !1, this._validEndIndex = -1, this._prefixSum = [], this._indexBySum = [];
  }
  getTotalSum() {
    return this._ensureValid(), this._indexBySum.length;
  }
  getPrefixSum(e) {
    return this._ensureValid(), e === 0 ? 0 : this._prefixSum[e - 1];
  }
  getIndexOf(e) {
    this._ensureValid();
    const t = this._indexBySum[e], i = t > 0 ? this._prefixSum[t - 1] : 0;
    return new P2(t, e - i);
  }
  removeValues(e, t) {
    this._values.splice(e, t), this._invalidate(e);
  }
  insertValues(e, t) {
    this._values = kg(this._values, e, t), this._invalidate(e);
  }
  _invalidate(e) {
    this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
  }
  _ensureValid() {
    if (!this._isValid) {
      for (let e = this._validEndIndex + 1, t = this._values.length; e < t; e++) {
        const i = this._values[e], n = e > 0 ? this._prefixSum[e - 1] : 0;
        this._prefixSum[e] = n + i;
        for (let r = 0; r < i; r++)
          this._indexBySum[n + r] = e;
      }
      this._prefixSum.length = this._values.length, this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1], this._isValid = !0, this._validEndIndex = this._values.length - 1;
    }
  }
  setValue(e, t) {
    this._values[e] !== t && (this._values[e] = t, this._invalidate(e));
  }
}
class P2 {
  constructor(e, t) {
    this.index = e, this.remainder = t, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = t;
  }
}
class c5 {
  constructor(e, t, i, n) {
    this._uri = e, this._lines = t, this._eol = i, this._versionId = n, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const t = e.changes;
    for (const i of t)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new O(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
      for (let n = 0; n < t; n++)
        i[n] = this._lines[n].length + e;
      this._lineStarts = new a5(i);
    }
  }
  _setLineText(e, t) {
    this._lines[e] = t, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    if (t.length === 0)
      return;
    const i = xu(t);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    const n = new Uint32Array(i.length - 1);
    for (let r = 1; r < i.length; r++)
      this._lines.splice(e.lineNumber + r - 1, 0, i[r]), n[r - 1] = i[r].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, n);
  }
}
class Tu {
  constructor(e) {
    const t = wf(e);
    this._defaultValue = t, this._asciiMap = Tu._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const t = new Uint8Array(256);
    for (let i = 0; i < 256; i++)
      t[i] = e;
    return t;
  }
  set(e, t) {
    const i = wf(t);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
}
class h5 {
  constructor(e, t, i) {
    const n = new Uint8Array(e * t);
    for (let r = 0, o = e * t; r < o; r++)
      n[r] = i;
    this._data = n, this.rows = e, this.cols = t;
  }
  get(e, t) {
    return this._data[e * this.cols + t];
  }
  set(e, t, i) {
    this._data[e * this.cols + t] = i;
  }
}
class u5 {
  constructor(e) {
    let t = 0, i = 0;
    for (let r = 0, o = e.length; r < o; r++) {
      const [a, l, c] = e[r];
      l > t && (t = l), a > i && (i = a), c > i && (i = c);
    }
    t++, i++;
    const n = new h5(i, t, 0);
    for (let r = 0, o = e.length; r < o; r++) {
      const [a, l, c] = e[r];
      n.set(a, l, c);
    }
    this._states = n, this._maxCharCode = t;
  }
  nextState(e, t) {
    return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
  }
}
let Xm = null;
function d5() {
  return Xm === null && (Xm = new u5([
    [1, 104, 2],
    [1, 72, 2],
    [1, 102, 6],
    [1, 70, 6],
    [2, 116, 3],
    [2, 84, 3],
    [3, 116, 4],
    [3, 84, 4],
    [4, 112, 5],
    [4, 80, 5],
    [5, 115, 9],
    [5, 83, 9],
    [5, 58, 10],
    [6, 105, 7],
    [6, 73, 7],
    [7, 108, 8],
    [7, 76, 8],
    [8, 101, 9],
    [8, 69, 9],
    [9, 58, 10],
    [10, 47, 11],
    [11, 47, 12]
  ])), Xm;
}
let Nc = null;
function f5() {
  if (Nc === null) {
    Nc = new Tu(0);
    const s = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
    for (let t = 0; t < s.length; t++)
      Nc.set(s.charCodeAt(t), 1);
    const e = ".,;:";
    for (let t = 0; t < e.length; t++)
      Nc.set(e.charCodeAt(t), 2);
  }
  return Nc;
}
class Sf {
  static _createLink(e, t, i, n, r) {
    let o = r - 1;
    do {
      const a = t.charCodeAt(o);
      if (e.get(a) !== 2)
        break;
      o--;
    } while (o > n);
    if (n > 0) {
      const a = t.charCodeAt(n - 1), l = t.charCodeAt(o);
      (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && o--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: n + 1,
        endLineNumber: i,
        endColumn: o + 2
      },
      url: t.substring(n, o + 1)
    };
  }
  static computeLinks(e, t = d5()) {
    const i = f5(), n = [];
    for (let r = 1, o = e.getLineCount(); r <= o; r++) {
      const a = e.getLineContent(r), l = a.length;
      let c = 0, h = 0, u = 0, d = 1, f = !1, m = !1, _ = !1, b = !1;
      for (; c < l; ) {
        let v = !1;
        const C = a.charCodeAt(c);
        if (d === 13) {
          let w;
          switch (C) {
            case 40:
              f = !0, w = 0;
              break;
            case 41:
              w = f ? 0 : 1;
              break;
            case 91:
              _ = !0, m = !0, w = 0;
              break;
            case 93:
              _ = !1, w = m ? 0 : 1;
              break;
            case 123:
              b = !0, w = 0;
              break;
            case 125:
              w = b ? 0 : 1;
              break;
            case 39:
              w = u === 39 ? 1 : 0;
              break;
            case 34:
              w = u === 34 ? 1 : 0;
              break;
            case 96:
              w = u === 96 ? 1 : 0;
              break;
            case 42:
              w = u === 42 ? 1 : 0;
              break;
            case 124:
              w = u === 124 ? 1 : 0;
              break;
            case 32:
              w = _ ? 0 : 1;
              break;
            default:
              w = i.get(C);
          }
          w === 1 && (n.push(Sf._createLink(i, a, r, h, c)), v = !0);
        } else if (d === 12) {
          let w;
          C === 91 ? (m = !0, w = 0) : w = i.get(C), w === 1 ? v = !0 : d = 13;
        } else
          d = t.nextState(d, C), d === 0 && (v = !0);
        v && (d = 1, f = !1, m = !1, b = !1, h = c + 1, u = C), c++;
      }
      d === 13 && n.push(Sf._createLink(i, a, r, h, l));
    }
    return n;
  }
}
function g5(s) {
  return !s || typeof s.getLineCount != "function" || typeof s.getLineContent != "function" ? [] : Sf.computeLinks(s);
}
class _1 {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(e, t, i, n, r) {
    if (e && t) {
      const o = this.doNavigateValueSet(t, r);
      if (o)
        return {
          range: e,
          value: o
        };
    }
    if (i && n) {
      const o = this.doNavigateValueSet(n, r);
      if (o)
        return {
          range: i,
          value: o
        };
    }
    return null;
  }
  doNavigateValueSet(e, t) {
    const i = this.numberReplace(e, t);
    return i !== null ? i : this.textReplace(e, t);
  }
  numberReplace(e, t) {
    const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
    let n = Number(e);
    const r = parseFloat(e);
    return !isNaN(n) && !isNaN(r) && n === r ? n === 0 && !t ? null : (n = Math.floor(n * i), n += t ? i : -i, String(n / i)) : null;
  }
  textReplace(e, t) {
    return this.valueSetsReplace(this._defaultValueSet, e, t);
  }
  valueSetsReplace(e, t, i) {
    let n = null;
    for (let r = 0, o = e.length; n === null && r < o; r++)
      n = this.valueSetReplace(e[r], t, i);
    return n;
  }
  valueSetReplace(e, t, i) {
    let n = e.indexOf(t);
    return n >= 0 ? (n += i ? 1 : -1, n < 0 ? n = e.length - 1 : n %= e.length, e[n]) : null;
  }
}
_1.INSTANCE = new _1();
class m5 extends Tu {
  constructor(e) {
    super(0);
    for (let t = 0, i = e.length; t < i; t++)
      this.set(e.charCodeAt(t), 2);
    this.set(32, 1), this.set(9, 1);
  }
}
function p5(s) {
  const e = {};
  return (t) => (e.hasOwnProperty(t) || (e[t] = s(t)), e[t]);
}
const Bl = p5((s) => new m5(s)), _5 = 999;
class Ia {
  constructor(e, t, i, n) {
    this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = n;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = b5(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let t = null;
    try {
      t = s2(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!t)
      return null;
    let i = !this.isRegex && !e;
    return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new YT(t, this.wordSeparators ? Bl(this.wordSeparators) : null, i ? this.searchString : null);
  }
}
function b5(s) {
  if (!s || s.length === 0)
    return !1;
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i === 10)
      return !0;
    if (i === 92) {
      if (e++, e >= t)
        break;
      const n = s.charCodeAt(e);
      if (n === 110 || n === 114 || n === 87)
        return !0;
    }
  }
  return !1;
}
function yo(s, e, t) {
  if (!t)
    return new Ah(s, null);
  const i = [];
  for (let n = 0, r = e.length; n < r; n++)
    i[n] = e[n];
  return new Ah(s, i);
}
class bw {
  constructor(e) {
    const t = [];
    let i = 0;
    for (let n = 0, r = e.length; n < r; n++)
      e.charCodeAt(n) === 10 && (t[i++] = n);
    this._lineFeedsOffsets = t;
  }
  findLineFeedCountBeforeOffset(e) {
    const t = this._lineFeedsOffsets;
    let i = 0, n = t.length - 1;
    if (n === -1 || e <= t[0])
      return 0;
    for (; i < n; ) {
      const r = i + ((n - i) / 2 >> 0);
      t[r] >= e ? n = r - 1 : t[r + 1] >= e ? (i = r, n = r) : i = r + 1;
    }
    return i + 1;
  }
}
class Ju {
  static findMatches(e, t, i, n, r) {
    const o = t.parseSearchRequest();
    return o ? o.regex.multiline ? this._doFindMatchesMultiline(e, i, new Ga(o.wordSeparators, o.regex), n, r) : this._doFindMatchesLineByLine(e, i, o, n, r) : [];
  }
  static _getMultilineMatchRange(e, t, i, n, r, o) {
    let a, l = 0;
    n ? (l = n.findLineFeedCountBeforeOffset(r), a = t + r + l) : a = t + r;
    let c;
    if (n) {
      const f = n.findLineFeedCountBeforeOffset(r + o.length) - l;
      c = a + o.length + f;
    } else
      c = a + o.length;
    const h = e.getPositionAt(a), u = e.getPositionAt(c);
    return new N(h.lineNumber, h.column, u.lineNumber, u.column);
  }
  static _doFindMatchesMultiline(e, t, i, n, r) {
    const o = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(t, 1), l = e.getEOL() === `\r
` ? new bw(a) : null, c = [];
    let h = 0, u;
    for (i.reset(0); u = i.next(a); )
      if (c[h++] = yo(this._getMultilineMatchRange(e, o, a, l, u.index, u[0]), u, n), h >= r)
        return c;
    return c;
  }
  static _doFindMatchesLineByLine(e, t, i, n, r) {
    const o = [];
    let a = 0;
    if (t.startLineNumber === t.endLineNumber) {
      const c = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
      return a = this._findMatchesInLine(i, c, t.startLineNumber, t.startColumn - 1, a, o, n, r), o;
    }
    const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
    a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, o, n, r);
    for (let c = t.startLineNumber + 1; c < t.endLineNumber && a < r; c++)
      a = this._findMatchesInLine(i, e.getLineContent(c), c, 0, a, o, n, r);
    if (a < r) {
      const c = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
      a = this._findMatchesInLine(i, c, t.endLineNumber, 0, a, o, n, r);
    }
    return o;
  }
  static _findMatchesInLine(e, t, i, n, r, o, a, l) {
    const c = e.wordSeparators;
    if (!a && e.simpleSearch) {
      const d = e.simpleSearch, f = d.length, m = t.length;
      let _ = -f;
      for (; (_ = t.indexOf(d, _ + f)) !== -1; )
        if ((!c || Vb(c, t, m, _, f)) && (o[r++] = new Ah(new N(i, _ + 1 + n, i, _ + 1 + f + n), null), r >= l))
          return r;
      return r;
    }
    const h = new Ga(e.wordSeparators, e.regex);
    let u;
    h.reset(0);
    do
      if (u = h.next(t), u && (o[r++] = yo(new N(i, u.index + 1 + n, i, u.index + 1 + u[0].length + n), u, a), r >= l))
        return r;
    while (u);
    return r;
  }
  static findNextMatch(e, t, i, n) {
    const r = t.parseSearchRequest();
    if (!r)
      return null;
    const o = new Ga(r.wordSeparators, r.regex);
    return r.regex.multiline ? this._doFindNextMatchMultiline(e, i, o, n) : this._doFindNextMatchLineByLine(e, i, o, n);
  }
  static _doFindNextMatchMultiline(e, t, i, n) {
    const r = new O(t.lineNumber, 1), o = e.getOffsetAt(r), a = e.getLineCount(), l = e.getValueInRange(new N(r.lineNumber, r.column, a, e.getLineMaxColumn(a)), 1), c = e.getEOL() === `\r
` ? new bw(l) : null;
    i.reset(t.column - 1);
    const h = i.next(l);
    return h ? yo(this._getMultilineMatchRange(e, o, l, c, h.index, h[0]), h, n) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new O(1, 1), i, n) : null;
  }
  static _doFindNextMatchLineByLine(e, t, i, n) {
    const r = e.getLineCount(), o = t.lineNumber, a = e.getLineContent(o), l = this._findFirstMatchInLine(i, a, o, t.column, n);
    if (l)
      return l;
    for (let c = 1; c <= r; c++) {
      const h = (o + c - 1) % r, u = e.getLineContent(h + 1), d = this._findFirstMatchInLine(i, u, h + 1, 1, n);
      if (d)
        return d;
    }
    return null;
  }
  static _findFirstMatchInLine(e, t, i, n, r) {
    e.reset(n - 1);
    const o = e.next(t);
    return o ? yo(new N(i, o.index + 1, i, o.index + 1 + o[0].length), o, r) : null;
  }
  static findPreviousMatch(e, t, i, n) {
    const r = t.parseSearchRequest();
    if (!r)
      return null;
    const o = new Ga(r.wordSeparators, r.regex);
    return r.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, o, n) : this._doFindPreviousMatchLineByLine(e, i, o, n);
  }
  static _doFindPreviousMatchMultiline(e, t, i, n) {
    const r = this._doFindMatchesMultiline(e, new N(1, 1, t.lineNumber, t.column), i, n, 10 * _5);
    if (r.length > 0)
      return r[r.length - 1];
    const o = e.getLineCount();
    return t.lineNumber !== o || t.column !== e.getLineMaxColumn(o) ? this._doFindPreviousMatchMultiline(e, new O(o, e.getLineMaxColumn(o)), i, n) : null;
  }
  static _doFindPreviousMatchLineByLine(e, t, i, n) {
    const r = e.getLineCount(), o = t.lineNumber, a = e.getLineContent(o).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, o, n);
    if (l)
      return l;
    for (let c = 1; c <= r; c++) {
      const h = (r + o - c - 1) % r, u = e.getLineContent(h + 1), d = this._findLastMatchInLine(i, u, h + 1, n);
      if (d)
        return d;
    }
    return null;
  }
  static _findLastMatchInLine(e, t, i, n) {
    let r = null, o;
    for (e.reset(0); o = e.next(t); )
      r = yo(new N(i, o.index + 1, i, o.index + 1 + o[0].length), o, n);
    return r;
  }
}
function C5(s, e, t, i, n) {
  if (i === 0)
    return !0;
  const r = e.charCodeAt(i - 1);
  if (s.get(r) !== 0 || r === 13 || r === 10)
    return !0;
  if (n > 0) {
    const o = e.charCodeAt(i);
    if (s.get(o) !== 0)
      return !0;
  }
  return !1;
}
function v5(s, e, t, i, n) {
  if (i + n === t)
    return !0;
  const r = e.charCodeAt(i + n);
  if (s.get(r) !== 0 || r === 13 || r === 10)
    return !0;
  if (n > 0) {
    const o = e.charCodeAt(i + n - 1);
    if (s.get(o) !== 0)
      return !0;
  }
  return !1;
}
function Vb(s, e, t, i, n) {
  return C5(s, e, t, i, n) && v5(s, e, t, i, n);
}
class Ga {
  constructor(e, t) {
    this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const t = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
        return null;
      const n = i.index, r = i[0].length;
      if (n === this._prevMatchStartIndex && r === this._prevMatchLength) {
        if (r === 0) {
          gf(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = n, this._prevMatchLength = r, !this._wordSeparators || Vb(this._wordSeparators, e, t, n, r))
        return i;
    } while (i);
    return null;
  }
}
class w5 {
  static computeUnicodeHighlights(e, t, i) {
    const n = i ? i.startLineNumber : 1, r = i ? i.endLineNumber : e.getLineCount(), o = new Cw(t), a = o.getCandidateCodePoints();
    let l;
    a === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${S5(Array.from(a))}`, "g");
    const c = new Ga(null, l), h = [];
    let u = !1, d, f = 0, m = 0, _ = 0;
    e:
      for (let b = n, v = r; b <= v; b++) {
        const C = e.getLineContent(b), w = C.length;
        c.reset(0);
        do
          if (d = c.next(C), d) {
            let L = d.index, E = d.index + d[0].length;
            if (L > 0) {
              const D = C.charCodeAt(L - 1);
              Lt(D) && L--;
            }
            if (E + 1 < w) {
              const D = C.charCodeAt(E - 1);
              Lt(D) && E++;
            }
            const k = C.substring(L, E), y = xh(L + 1, ub, C, 0), S = o.shouldHighlightNonBasicASCII(k, y ? y.word : null);
            if (S !== 0) {
              S === 3 ? f++ : S === 2 ? m++ : S === 1 ? _++ : fb();
              const D = 1e3;
              if (h.length >= D) {
                u = !0;
                break e;
              }
              h.push(new N(b, L + 1, b, E + 1));
            }
          }
        while (d);
      }
    return {
      ranges: h,
      hasMore: u,
      ambiguousCharacterCount: f,
      invisibleCharacterCount: m,
      nonBasicAsciiCharacterCount: _
    };
  }
  static computeUnicodeHighlightReason(e, t) {
    const i = new Cw(t);
    switch (i.shouldHighlightNonBasicASCII(e, null)) {
      case 0:
        return null;
      case 2:
        return { kind: 1 };
      case 3: {
        const r = e.codePointAt(0), o = i.ambiguousCharacters.getPrimaryConfusable(r), a = _n.getLocales().filter((l) => !_n.getInstance(/* @__PURE__ */ new Set([...t.allowedLocales, l])).isAmbiguous(r));
        return { kind: 0, confusableWith: String.fromCodePoint(o), notAmbiguousInLocales: a };
      }
      case 1:
        return { kind: 2 };
    }
  }
}
function S5(s, e) {
  return `[${sr(s.map((i) => String.fromCodePoint(i)).join(""))}]`;
}
class Cw {
  constructor(e) {
    this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = _n.getInstance(new Set(e.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII)
      return "allNonBasicAscii";
    const e = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters)
      for (const t of $r.codePoints)
        vw(String.fromCodePoint(t)) || e.add(t);
    if (this.options.ambiguousCharacters)
      for (const t of this.ambiguousCharacters.getConfusableCodePoints())
        e.add(t);
    for (const t of this.allowedCodePoints)
      e.delete(t);
    return e;
  }
  shouldHighlightNonBasicASCII(e, t) {
    const i = e.codePointAt(0);
    if (this.allowedCodePoints.has(i))
      return 0;
    if (this.options.nonBasicASCII)
      return 1;
    let n = !1, r = !1;
    if (t)
      for (const o of t) {
        const a = o.codePointAt(0), l = Eb(o);
        n = n || l, !l && !this.ambiguousCharacters.isAmbiguous(a) && !$r.isInvisibleCharacter(a) && (r = !0);
      }
    return !n && r ? 0 : this.options.invisibleCharacters && !vw(e) && $r.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0;
  }
}
function vw(s) {
  return s === " " || s === `
` || s === "	";
}
var mo = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class y5 extends c5 {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, t) {
    const i = xh(e.column, Rk(t), this._lines[e.lineNumber - 1], 0);
    return i ? new N(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const t = this._lines, i = this._wordenize.bind(this);
    let n = 0, r = "", o = 0, a = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (o < a.length) {
            const l = r.substring(a[o].start, a[o].end);
            o += 1, yield l;
          } else if (n < t.length)
            r = t[n], a = i(r, e), o = 0, n += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, t) {
    const i = this._lines[e - 1], n = this._wordenize(i, t), r = [];
    for (const o of n)
      r.push({
        word: i.substring(o.start, o.end),
        startColumn: o.start + 1,
        endColumn: o.end + 1
      });
    return r;
  }
  _wordenize(e, t) {
    const i = [];
    let n;
    for (t.lastIndex = 0; (n = t.exec(e)) && n[0].length !== 0; )
      i.push({ start: n.index, end: n.index + n[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    const t = this._eol, i = e.startLineNumber - 1, n = e.endLineNumber - 1, r = [];
    r.push(this._lines[i].substring(e.startColumn - 1));
    for (let o = i + 1; o < n; o++)
      r.push(this._lines[o]);
    return r.push(this._lines[n].substring(0, e.endColumn - 1)), r.join(t);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
    return {
      lineNumber: 1 + t.index,
      column: 1 + Math.min(t.remainder, i)
    };
  }
  _validateRange(e) {
    const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: t.lineNumber,
      startColumn: t.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!O.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: t, column: i } = e, n = !1;
    if (t < 1)
      t = 1, i = 1, n = !0;
    else if (t > this._lines.length)
      t = this._lines.length, i = this._lines[t - 1].length + 1, n = !0;
    else {
      const r = this._lines[t - 1].length + 1;
      i < 1 ? (i = 1, n = !0) : i > r && (i = r, n = !0);
    }
    return n ? { lineNumber: t, column: i } : e;
  }
}
class Kr {
  constructor(e, t) {
    this._host = e, this._models = /* @__PURE__ */ Object.create(null), this._foreignModuleFactory = t, this._foreignModule = null;
  }
  dispose() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  _getModel(e) {
    return this._models[e];
  }
  _getModels() {
    const e = [];
    return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
  }
  acceptNewModel(e) {
    this._models[e.url] = new y5(Le.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  acceptModelChanged(e, t) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(t);
  }
  acceptRemovedModel(e) {
    !this._models[e] || delete this._models[e];
  }
  computeUnicodeHighlights(e, t, i) {
    return mo(this, void 0, void 0, function* () {
      const n = this._getModel(e);
      return n ? w5.computeUnicodeHighlights(n, t, i) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
    });
  }
  computeDiff(e, t, i, n) {
    return mo(this, void 0, void 0, function* () {
      const r = this._getModel(e), o = this._getModel(t);
      return !r || !o ? null : Kr.computeDiff(r, o, i, n);
    });
  }
  static computeDiff(e, t, i, n) {
    const r = e.getLinesContent(), o = t.getLinesContent(), l = new o5(r, o, {
      shouldComputeCharChanges: !0,
      shouldPostProcessCharChanges: !0,
      shouldIgnoreTrimWhitespace: i,
      shouldMakePrettyDiff: !0,
      maxComputationTime: n
    }).computeDiff(), c = l.changes.length > 0 ? !1 : this._modelsAreIdentical(e, t);
    return {
      quitEarly: l.quitEarly,
      identical: c,
      changes: l.changes
    };
  }
  static _modelsAreIdentical(e, t) {
    const i = e.getLineCount(), n = t.getLineCount();
    if (i !== n)
      return !1;
    for (let r = 1; r <= i; r++) {
      const o = e.getLineContent(r), a = t.getLineContent(r);
      if (o !== a)
        return !1;
    }
    return !0;
  }
  computeMoreMinimalEdits(e, t) {
    return mo(this, void 0, void 0, function* () {
      const i = this._getModel(e);
      if (!i)
        return t;
      const n = [];
      let r;
      t = t.slice(0).sort((o, a) => {
        if (o.range && a.range)
          return N.compareRangesUsingStarts(o.range, a.range);
        const l = o.range ? 0 : 1, c = a.range ? 0 : 1;
        return l - c;
      });
      for (let { range: o, text: a, eol: l } of t) {
        if (typeof l == "number" && (r = l), N.isEmpty(o) && !a)
          continue;
        const c = i.getValueInRange(o);
        if (a = a.replace(/\r\n|\n|\r/g, i.eol), c === a)
          continue;
        if (Math.max(a.length, c.length) > Kr._diffLimit) {
          n.push({ range: o, text: a });
          continue;
        }
        const h = i5(c, a, !1), u = i.offsetAt(N.lift(o).getStartPosition());
        for (const d of h) {
          const f = i.positionAt(u + d.originalStart), m = i.positionAt(u + d.originalStart + d.originalLength), _ = {
            text: a.substr(d.modifiedStart, d.modifiedLength),
            range: { startLineNumber: f.lineNumber, startColumn: f.column, endLineNumber: m.lineNumber, endColumn: m.column }
          };
          i.getValueInRange(_.range) !== _.text && n.push(_);
        }
      }
      return typeof r == "number" && n.push({ eol: r, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), n;
    });
  }
  computeLinks(e) {
    return mo(this, void 0, void 0, function* () {
      const t = this._getModel(e);
      return t ? g5(t) : null;
    });
  }
  textualSuggest(e, t, i, n) {
    return mo(this, void 0, void 0, function* () {
      const r = new aa(!0), o = new RegExp(i, n), a = /* @__PURE__ */ new Set();
      e:
        for (const l of e) {
          const c = this._getModel(l);
          if (!!c) {
            for (const h of c.words(o))
              if (!(h === t || !isNaN(Number(h))) && (a.add(h), a.size > Kr._suggestionsLimit))
                break e;
          }
        }
      return { words: Array.from(a), duration: r.elapsed() };
    });
  }
  computeWordRanges(e, t, i, n) {
    return mo(this, void 0, void 0, function* () {
      const r = this._getModel(e);
      if (!r)
        return /* @__PURE__ */ Object.create(null);
      const o = new RegExp(i, n), a = /* @__PURE__ */ Object.create(null);
      for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
        const c = r.getLineWords(l, o);
        for (const h of c) {
          if (!isNaN(Number(h.word)))
            continue;
          let u = a[h.word];
          u || (u = [], a[h.word] = u), u.push({
            startLineNumber: l,
            startColumn: h.startColumn,
            endLineNumber: l,
            endColumn: h.endColumn
          });
        }
      }
      return a;
    });
  }
  navigateValueSet(e, t, i, n, r) {
    return mo(this, void 0, void 0, function* () {
      const o = this._getModel(e);
      if (!o)
        return null;
      const a = new RegExp(n, r);
      t.startColumn === t.endColumn && (t = {
        startLineNumber: t.startLineNumber,
        startColumn: t.startColumn,
        endLineNumber: t.endLineNumber,
        endColumn: t.endColumn + 1
      });
      const l = o.getValueInRange(t), c = o.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
      if (!c)
        return null;
      const h = o.getValueInRange(c);
      return _1.INSTANCE.navigateValueSet(t, l, c, h, i);
    });
  }
  loadForeignModule(e, t, i) {
    const o = {
      host: QI(i, (a, l) => this._host.fhr(a, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(o, t), Promise.resolve(db(this._foreignModule))) : Promise.reject(new Error("Unexpected usage"));
  }
  fmr(e, t) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
Kr._diffLimit = 1e5;
Kr._suggestionsLimit = 1e4;
typeof importScripts == "function" && (it.monaco = t2());
const O2 = Se("textResourceConfigurationService"), F2 = Se("textResourcePropertiesService"), ao = Se("logService");
var Tn;
(function(s) {
  s[s.Trace = 0] = "Trace", s[s.Debug = 1] = "Debug", s[s.Info = 2] = "Info", s[s.Warning = 3] = "Warning", s[s.Error = 4] = "Error", s[s.Critical = 5] = "Critical", s[s.Off = 6] = "Off";
})(Tn || (Tn = {}));
const B2 = Tn.Info;
class L5 extends z {
  constructor() {
    super(...arguments), this.level = B2, this._onDidChangeLogLevel = this._register(new A());
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
}
class k5 extends L5 {
  constructor(e = B2) {
    super(), this.setLevel(e);
  }
  trace(e, ...t) {
    this.getLevel() <= Tn.Trace && console.log("%cTRACE", "color: #888", e, ...t);
  }
  debug(e, ...t) {
    this.getLevel() <= Tn.Debug && console.log("%cDEBUG", "background: #eee; color: #888", e, ...t);
  }
  info(e, ...t) {
    this.getLevel() <= Tn.Info && console.log("%c INFO", "color: #33f", e, ...t);
  }
  error(e, ...t) {
    this.getLevel() <= Tn.Error && console.log("%c  ERR", "color: #f33", e, ...t);
  }
  dispose() {
  }
}
class D5 extends z {
  constructor(e) {
    super(), this.logger = e, this._register(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
const De = Se("ILanguageFeaturesService");
var E5 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Tc = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, b1 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
const ww = 60 * 1e3, Sw = 5 * 60 * 1e3;
function Lo(s, e) {
  const t = s.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let C1 = class extends z {
  constructor(e, t, i, n, r) {
    super(), this._modelService = e, this._workerManager = this._register(new I5(this._modelService, n)), this._logService = i, this._register(r.linkProvider.register({ language: "*", hasAccessToAllModels: !0 }, {
      provideLinks: (o, a) => Lo(this._modelService, o.uri) ? this._workerManager.withWorker().then((l) => l.computeLinks(o.uri)).then((l) => l && { links: l }) : Promise.resolve({ links: [] })
    })), this._register(r.completionProvider.register("*", new x5(this._workerManager, t, this._modelService, n)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(e) {
    return Lo(this._modelService, e);
  }
  computedUnicodeHighlights(e, t, i) {
    return this._workerManager.withWorker().then((n) => n.computedUnicodeHighlights(e, t, i));
  }
  computeDiff(e, t, i, n) {
    return this._workerManager.withWorker().then((r) => r.computeDiff(e, t, i, n));
  }
  computeMoreMinimalEdits(e, t) {
    if (Lg(t)) {
      if (!Lo(this._modelService, e))
        return Promise.resolve(t);
      const i = aa.create(!0), n = this._workerManager.withWorker().then((r) => r.computeMoreMinimalEdits(e, t));
      return n.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), i.elapsed())), Promise.race([n, Oh(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return Lo(this._modelService, e);
  }
  navigateValueSet(e, t, i) {
    return this._workerManager.withWorker().then((n) => n.navigateValueSet(e, t, i));
  }
  canComputeWordRanges(e) {
    return Lo(this._modelService, e);
  }
  computeWordRanges(e, t) {
    return this._workerManager.withWorker().then((i) => i.computeWordRanges(e, t));
  }
};
C1 = E5([
  Tc(0, Kt),
  Tc(1, O2),
  Tc(2, ao),
  Tc(3, bs),
  Tc(4, De)
], C1);
class x5 {
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  provideCompletionItems(e, t) {
    return b1(this, void 0, void 0, function* () {
      const i = this._configurationService.getValue(e.uri, t, "editor");
      if (!i.wordBasedSuggestions)
        return;
      const n = [];
      if (i.wordBasedSuggestionsMode === "currentDocument")
        Lo(this._modelService, e.uri) && n.push(e.uri);
      else
        for (const u of this._modelService.getModels())
          !Lo(this._modelService, u.uri) || (u === e ? n.unshift(u.uri) : (i.wordBasedSuggestionsMode === "allDocuments" || u.getLanguageId() === e.getLanguageId()) && n.push(u.uri));
      if (n.length === 0)
        return;
      const r = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), o = e.getWordAtPosition(t), a = o ? new N(t.lineNumber, o.startColumn, t.lineNumber, o.endColumn) : N.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), h = yield (yield this._workerManager.withWorker()).textualSuggest(n, o == null ? void 0 : o.word, r);
      if (!!h)
        return {
          duration: h.duration,
          suggestions: h.words.map((u) => ({
            kind: 18,
            label: u,
            insertText: u,
            range: { insert: l, replace: a }
          }))
        };
    });
  }
}
class I5 extends z {
  constructor(e, t) {
    super(), this.languageConfigurationService = t, this._modelService = e, this._editorWorkerClient = null, this._lastWorkerUsedTime = new Date().getTime(), this._register(new Nu()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(Sw / 2)), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    new Date().getTime() - this._lastWorkerUsedTime > Sw && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = new Date().getTime(), this._editorWorkerClient || (this._editorWorkerClient = new V2(this._modelService, !1, "editorWorkerService", this.languageConfigurationService)), Promise.resolve(this._editorWorkerClient);
  }
}
class N5 extends z {
  constructor(e, t, i) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      const n = new Nu();
      n.cancelAndSet(() => this._checkStopModelSync(), Math.round(ww / 2)), this._register(n);
    }
  }
  dispose() {
    for (const e in this._syncedModels)
      je(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e, t) {
    for (const i of e) {
      const n = i.toString();
      this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = new Date().getTime());
    }
  }
  _checkStopModelSync() {
    const e = new Date().getTime(), t = [];
    for (const i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > ww && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e, t) {
    const i = this._modelService.getModel(e);
    if (!i || !t && i.isTooLargeForSyncing())
      return;
    const n = e.toString();
    this._proxy.acceptNewModel({
      url: i.uri.toString(),
      lines: i.getLinesContent(),
      EOL: i.getEOL(),
      versionId: i.getVersionId()
    });
    const r = new le();
    r.add(i.onDidChangeContent((o) => {
      this._proxy.acceptModelChanged(n.toString(), o);
    })), r.add(i.onWillDispose(() => {
      this._stopModelSync(n);
    })), r.add(ze(() => {
      this._proxy.acceptRemovedModel(n);
    })), this._syncedModels[n] = r;
  }
  _stopModelSync(e) {
    const t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], je(t);
  }
}
class yw {
  constructor(e) {
    this._instance = e, this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
}
class Jm {
  constructor(e) {
    this._workerClient = e;
  }
  fhr(e, t) {
    return this._workerClient.fhr(e, t);
  }
}
class V2 extends z {
  constructor(e, t, i, n) {
    super(), this.languageConfigurationService = n, this._disposed = !1, this._modelService = e, this._keepIdleModels = t, this._workerFactory = new Bg(i), this._worker = null, this._modelManager = null;
  }
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register(new q4(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new Jm(this)));
      } catch (e) {
        g1(e), this._worker = new yw(new Kr(new Jm(this), null));
      }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (e) => (g1(e), this._worker = new yw(new Kr(new Jm(this), null)), this._getOrCreateWorker().getProxyObject()));
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new N5(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  _withSyncedResources(e, t = !1) {
    return b1(this, void 0, void 0, function* () {
      return this._disposed ? Promise.reject(VN()) : this._getProxy().then((i) => (this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i));
    });
  }
  computedUnicodeHighlights(e, t, i) {
    return this._withSyncedResources([e]).then((n) => n.computeUnicodeHighlights(e.toString(), t, i));
  }
  computeDiff(e, t, i, n) {
    return this._withSyncedResources([e, t], !0).then((r) => r.computeDiff(e.toString(), t.toString(), i, n));
  }
  computeMoreMinimalEdits(e, t) {
    return this._withSyncedResources([e]).then((i) => i.computeMoreMinimalEdits(e.toString(), t));
  }
  computeLinks(e) {
    return this._withSyncedResources([e]).then((t) => t.computeLinks(e.toString()));
  }
  textualSuggest(e, t, i) {
    return b1(this, void 0, void 0, function* () {
      const n = yield this._withSyncedResources(e), r = i.source, o = Hm(i);
      return n.textualSuggest(e.map((a) => a.toString()), t, r, o);
    });
  }
  computeWordRanges(e, t) {
    return this._withSyncedResources([e]).then((i) => {
      const n = this._modelService.getModel(e);
      if (!n)
        return Promise.resolve(null);
      const r = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), o = r.source, a = Hm(r);
      return i.computeWordRanges(e.toString(), t, o, a);
    });
  }
  navigateValueSet(e, t, i) {
    return this._withSyncedResources([e]).then((n) => {
      const r = this._modelService.getModel(e);
      if (!r)
        return null;
      const o = this.languageConfigurationService.getLanguageConfiguration(r.getLanguageId()).getWordDefinition(), a = o.source, l = Hm(o);
      return n.navigateValueSet(e.toString(), t, i, a, l);
    });
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
}
function T5(s, e, t) {
  return new M5(s, e, t);
}
class M5 extends V2 {
  constructor(e, t, i) {
    super(e, i.keepIdleModels || !1, i.label, t), this._foreignModuleId = i.moduleId, this._foreignModuleCreateData = i.createData || null, this._foreignModuleHost = i.host || null, this._foreignProxy = null;
  }
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? db(this._foreignModuleHost) : [];
      return e.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const n = (a, l) => e.fmr(a, l), r = (a, l) => function() {
          const c = Array.prototype.slice.call(arguments, 0);
          return l(a, c);
        }, o = {};
        for (const a of i)
          o[a] = r(a, n);
        return o;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this._withSyncedResources(e).then((t) => this.getProxy());
  }
}
class ki {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e);
    const n = this.getFontStyle(e);
    return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), n = this.getFontStyle(e);
    let r = `color: ${t[i]};`;
    n & 1 && (r += "font-style: italic;"), n & 2 && (r += "font-weight: bold;");
    let o = "";
    return n & 4 && (o += " underline"), n & 8 && (o += " line-through"), o && (r += `text-decoration:${o};`), r;
  }
  static getPresentationFromMetadata(e) {
    const t = this.getForeground(e), i = this.getFontStyle(e);
    return {
      foreground: t,
      italic: Boolean(i & 1),
      bold: Boolean(i & 2),
      underline: Boolean(i & 4),
      strikethrough: Boolean(i & 8)
    };
  }
}
class Pt {
  constructor(e, t, i) {
    this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this._languageIdCodec = i;
  }
  static createEmpty(e, t) {
    const i = Pt.defaultTokenMetadata, n = new Uint32Array(2);
    return n[0] = e.length, n[1] = i, new Pt(n, e, t);
  }
  equals(e) {
    return e instanceof Pt ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const n = t << 1, r = n + (i << 1);
    for (let o = n; o < r; o++)
      if (this._tokens[o] !== e._tokens[o])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1], i = ki.getLanguageId(t);
    return this._languageIdCodec.decodeLanguageId(i);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return ki.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return ki.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return ki.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return ki.getInlineStyleFromMetadata(i, t);
  }
  getPresentation(e) {
    const t = this._tokens[(e << 1) + 1];
    return ki.getPresentationFromMetadata(t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  findTokenIndexAtOffset(e) {
    return Pt.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new Wb(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const n = (e.length >>> 1) - 1;
    for (let r = 0; r < n; r++)
      e[r << 1] = e[r + 1 << 1];
    e[n << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, n = (e.length >>> 1) - 1;
    for (; i < n; ) {
      const r = i + Math.floor((n - i) / 2), o = e[r << 1];
      if (o === t)
        return r + 1;
      o < t ? i = r + 1 : o > t && (n = r);
    }
    return i;
  }
  withInserted(e) {
    if (e.length === 0)
      return this;
    let t = 0, i = 0, n = "";
    const r = new Array();
    let o = 0;
    for (; ; ) {
      const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
      if (a !== -1 && (l === null || a <= l.offset)) {
        n += this._text.substring(o, a);
        const c = this._tokens[(t << 1) + 1];
        r.push(n.length, c), t++, o = a;
      } else if (l) {
        if (l.offset > o) {
          n += this._text.substring(o, l.offset);
          const c = this._tokens[(t << 1) + 1];
          r.push(n.length, c), o = l.offset;
        }
        n += l.text, r.push(n.length, l.tokenMetadata), i++;
      } else
        break;
    }
    return new Pt(new Uint32Array(r), n, this._languageIdCodec);
  }
}
Pt.defaultTokenMetadata = (0 << 11 | 1 << 15 | 2 << 24) >>> 0;
class Wb {
  constructor(e, t, i, n) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this._tokensCount = 0;
    for (let r = this._firstTokenIndex, o = e.getCount(); r < o && !(e.getStartOffset(r) >= i); r++)
      this._tokensCount++;
  }
  getMetadata(e) {
    return this._source.getMetadata(this._firstTokenIndex + e);
  }
  getLanguageId(e) {
    return this._source.getLanguageId(this._firstTokenIndex + e);
  }
  getLineContent() {
    return this._source.getLineContent().substring(this._startOffset, this._endOffset);
  }
  equals(e) {
    return e instanceof Wb ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  getPresentation(e) {
    return this._source.getPresentation(this._firstTokenIndex + e);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
}
class gn {
  constructor(e, t, i, n) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let r = 0; r < i; r++)
      if (!gn._equals(e[r], t[r]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const n = t + 1, r = i + 1, o = i - t, a = [];
    let l = 0;
    for (const c of e)
      c.endColumn <= n || c.startColumn >= r || (a[l++] = new gn(Math.max(1, c.startColumn - n + 1), Math.min(o + 1, c.endColumn - n + 1), c.className, c.type));
    return a;
  }
  static filter(e, t, i, n) {
    if (e.length === 0)
      return [];
    const r = [];
    let o = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], h = c.range;
      if (h.endLineNumber < t || h.startLineNumber > t || h.isEmpty() && (c.type === 0 || c.type === 3))
        continue;
      const u = h.startLineNumber === t ? h.startColumn : i, d = h.endLineNumber === t ? h.endColumn : n;
      r[o++] = new gn(u, d, c.inlineClassName, c.type);
    }
    return r;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn !== t.startColumn)
      return e.startColumn - t.startColumn;
    if (e.endColumn !== t.endColumn)
      return e.endColumn - t.endColumn;
    const i = gn._typeCompare(e.type, t.type);
    return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
  }
}
class Lw {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
  }
}
class yf {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, n = e.length; i < n; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let n = 0;
      for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; )
        n++;
      i.push(new Lw(t, this.stopOffsets[n], this.classNames.join(" "), yf._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
    }
    return this.count > 0 && t < e && (i.push(new Lw(t, e - 1, this.classNames.join(" "), yf._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let n = 0; n < this.count; n++)
        if (this.stopOffsets[n] >= e) {
          this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
          break;
        }
    this.count++;
  }
}
class A5 {
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    const i = [], n = new yf();
    let r = 0;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      let c = l.startColumn, h = l.endColumn;
      const u = l.className, d = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (c > 1) {
        const _ = e.charCodeAt(c - 2);
        Lt(_) && c--;
      }
      if (h > 1) {
        const _ = e.charCodeAt(h - 2);
        Lt(_) && h--;
      }
      const f = c - 1, m = h - 2;
      r = n.consumeLowerThan(f, r, i), n.count === 0 && (r = f), n.insert(m, u, d);
    }
    return n.consumeLowerThan(1073741824, r, i), i;
  }
}
class kt {
  constructor(e, t, i, n) {
    this.endIndex = e, this.type = t, this.metadata = i, this.containsRTL = n, this._linePartBrand = void 0;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
class R5 {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
}
class dc {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, b, v, C, w) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = r, this.containsRTL = o, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = c.sort(gn.compare), this.tabSize = h, this.startVisibleColumn = u, this.spaceWidth = d, this.stopRenderingLineAfter = _, this.renderWhitespace = b === "all" ? 4 : b === "boundary" ? 1 : b === "selection" ? 2 : b === "trailing" ? 3 : 0, this.renderControlCharacters = v, this.fontLigatures = C, this.selectionsOnLine = w && w.sort((k, y) => k.startOffset < y.startOffset ? -1 : 1);
    const L = Math.abs(m - d), E = Math.abs(f - d);
    L < E ? (this.renderSpaceWidth = m, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = f, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && gn.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class Hb {
  constructor(e, t) {
    this.partIndex = e, this.charIndex = t;
  }
}
class Qn {
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._horizontalOffset = new Uint32Array(this.length);
  }
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  setColumnInfo(e, t, i, n) {
    const r = (t << 16 | i << 0) >>> 0;
    this._data[e - 1] = r, this._horizontalOffset[e - 1] = n;
  }
  getHorizontalOffset(e) {
    return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[e - 1];
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  getDomPosition(e) {
    const t = this.charOffsetToPartData(e - 1), i = Qn.getPartIndex(t), n = Qn.getCharIndex(t);
    return new Hb(i, n);
  }
  getColumn(e, t) {
    return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    const n = (e << 16 | i << 0) >>> 0;
    let r = 0, o = this.length - 1;
    for (; r + 1 < o; ) {
      const _ = r + o >>> 1, b = this._data[_];
      if (b === n)
        return _;
      b > n ? o = _ : r = _;
    }
    if (r === o)
      return r;
    const a = this._data[r], l = this._data[o];
    if (a === n)
      return r;
    if (l === n)
      return o;
    const c = Qn.getPartIndex(a), h = Qn.getCharIndex(a), u = Qn.getPartIndex(l);
    let d;
    c !== u ? d = t : d = Qn.getCharIndex(l);
    const f = i - h, m = d - i;
    return f <= m ? r : o;
  }
}
class v1 {
  constructor(e, t, i) {
    this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function zb(s, e) {
  if (s.lineContent.length === 0) {
    if (s.lineDecorations.length > 0) {
      e.appendASCIIString("<span>");
      let t = 0, i = 0, n = 0;
      for (const o of s.lineDecorations)
        (o.type === 1 || o.type === 2) && (e.appendASCIIString('<span class="'), e.appendASCIIString(o.className), e.appendASCIIString('"></span>'), o.type === 1 && (n |= 1, t++), o.type === 2 && (n |= 2, i++));
      e.appendASCIIString("</span>");
      const r = new Qn(1, t + i);
      return r.setColumnInfo(1, t, 0, 0), new v1(r, !1, n);
    }
    return e.appendASCIIString("<span><span></span></span>"), new v1(new Qn(0, 0), !1, 0);
  }
  return U5(F5(s), e);
}
class P5 {
  constructor(e, t, i, n) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
  }
}
function Wg(s) {
  const e = Ol(1e4), t = zb(s, e);
  return new P5(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class O5 {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = r, this.parts = o, this.containsForeignElements = a, this.fauxIndentLength = l, this.tabSize = c, this.startVisibleColumn = h, this.containsRTL = u, this.spaceWidth = d, this.renderSpaceCharCode = f, this.renderWhitespace = m, this.renderControlCharacters = _;
  }
}
function F5(s) {
  const e = s.lineContent;
  let t, i;
  s.stopRenderingLineAfter !== -1 && s.stopRenderingLineAfter < e.length ? (t = !0, i = s.stopRenderingLineAfter) : (t = !1, i = e.length);
  let n = B5(e, s.containsRTL, s.lineTokens, s.fauxIndentLength, i);
  s.renderControlCharacters && !s.isBasicASCII && (n = W5(e, n)), (s.renderWhitespace === 4 || s.renderWhitespace === 1 || s.renderWhitespace === 2 && !!s.selectionsOnLine || s.renderWhitespace === 3) && (n = H5(s, e, i, n));
  let r = 0;
  if (s.lineDecorations.length > 0) {
    for (let o = 0, a = s.lineDecorations.length; o < a; o++) {
      const l = s.lineDecorations[o];
      l.type === 3 || l.type === 1 ? r |= 1 : l.type === 2 && (r |= 2);
    }
    n = z5(e, i, n, s.lineDecorations);
  }
  return s.containsRTL || (n = V5(e, n, !s.isBasicASCII || s.fontLigatures)), new O5(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, e, i, t, n, r, s.fauxIndentLength, s.tabSize, s.startVisibleColumn, s.containsRTL, s.spaceWidth, s.renderSpaceCharCode, s.renderWhitespace, s.renderControlCharacters);
}
function B5(s, e, t, i, n) {
  const r = [];
  let o = 0;
  i > 0 && (r[o++] = new kt(i, "", 0, !1));
  let a = i;
  for (let l = 0, c = t.getCount(); l < c; l++) {
    const h = t.getEndOffset(l);
    if (h <= i)
      continue;
    const u = t.getClassName(l);
    if (h >= n) {
      const f = e ? Th(s.substring(a, n)) : !1;
      r[o++] = new kt(n, u, 0, f);
      break;
    }
    const d = e ? Th(s.substring(a, h)) : !1;
    r[o++] = new kt(h, u, 0, d), a = h;
  }
  return r;
}
function V5(s, e, t) {
  let i = 0;
  const n = [];
  let r = 0;
  if (t)
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o], c = l.endIndex;
      if (i + 50 < c) {
        const h = l.type, u = l.metadata, d = l.containsRTL;
        let f = -1, m = i;
        for (let _ = i; _ < c; _++)
          s.charCodeAt(_) === 32 && (f = _), f !== -1 && _ - m >= 50 && (n[r++] = new kt(f + 1, h, u, d), m = f + 1, f = -1);
        m !== c && (n[r++] = new kt(c, h, u, d));
      } else
        n[r++] = l;
      i = c;
    }
  else
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o], c = l.endIndex, h = c - i;
      if (h > 50) {
        const u = l.type, d = l.metadata, f = l.containsRTL, m = Math.ceil(h / 50);
        for (let _ = 1; _ < m; _++) {
          const b = i + _ * 50;
          n[r++] = new kt(b, u, d, f);
        }
        n[r++] = new kt(c, u, d, f);
      } else
        n[r++] = l;
      i = c;
    }
  return n;
}
function W2(s) {
  return s < 32 ? s !== 9 : s === 127 || s >= 8234 && s <= 8238 || s >= 8294 && s <= 8297 || s >= 8206 && s <= 8207 || s === 1564;
}
function W5(s, e) {
  const t = [];
  let i = new kt(0, "", 0, !1), n = 0;
  for (const r of e) {
    const o = r.endIndex;
    for (; n < o; n++) {
      const a = s.charCodeAt(n);
      W2(a) && (n > i.endIndex && (i = new kt(n, r.type, r.metadata, r.containsRTL), t.push(i)), i = new kt(n + 1, "mtkcontrol", r.metadata, !1), t.push(i));
    }
    n > i.endIndex && (i = new kt(o, r.type, r.metadata, r.containsRTL), t.push(i));
  }
  return t;
}
function H5(s, e, t, i) {
  const n = s.continuesWithWrappedLine, r = s.fauxIndentLength, o = s.tabSize, a = s.startVisibleColumn, l = s.useMonospaceOptimizations, c = s.selectionsOnLine, h = s.renderWhitespace === 1, u = s.renderWhitespace === 3, d = s.renderSpaceWidth !== s.spaceWidth, f = [];
  let m = 0, _ = 0, b = i[_].type, v = i[_].containsRTL, C = i[_].endIndex;
  const w = i.length;
  let L = !1, E = Bi(e), k;
  E === -1 ? (L = !0, E = t, k = t) : k = cc(e);
  let y = !1, S = 0, D = c && c[S], T = a % o;
  for (let P = r; P < t; P++) {
    const V = e.charCodeAt(P);
    D && P >= D.endOffset && (S++, D = c && c[S]);
    let U;
    if (P < E || P > k)
      U = !0;
    else if (V === 9)
      U = !0;
    else if (V === 32)
      if (h)
        if (y)
          U = !0;
        else {
          const K = P + 1 < t ? e.charCodeAt(P + 1) : 0;
          U = K === 32 || K === 9;
        }
      else
        U = !0;
    else
      U = !1;
    if (U && c && (U = !!D && D.startOffset <= P && D.endOffset > P), U && u && (U = L || P > k), U && v && P >= E && P <= k && (U = !1), y) {
      if (!U || !l && T >= o) {
        if (d) {
          const K = m > 0 ? f[m - 1].endIndex : r;
          for (let J = K + 1; J <= P; J++)
            f[m++] = new kt(J, "mtkw", 1, !1);
        } else
          f[m++] = new kt(P, "mtkw", 1, !1);
        T = T % o;
      }
    } else
      (P === C || U && P > r) && (f[m++] = new kt(P, b, 0, v), T = T % o);
    for (V === 9 ? T = o : Jr(V) ? T += 2 : T++, y = U; P === C && (_++, _ < w); )
      b = i[_].type, v = i[_].containsRTL, C = i[_].endIndex;
  }
  let M = !1;
  if (y)
    if (n && h) {
      const P = t > 0 ? e.charCodeAt(t - 1) : 0, V = t > 1 ? e.charCodeAt(t - 2) : 0;
      P === 32 && V !== 32 && V !== 9 || (M = !0);
    } else
      M = !0;
  if (M)
    if (d) {
      const P = m > 0 ? f[m - 1].endIndex : r;
      for (let V = P + 1; V <= t; V++)
        f[m++] = new kt(V, "mtkw", 1, !1);
    } else
      f[m++] = new kt(t, "mtkw", 1, !1);
  else
    f[m++] = new kt(t, b, 0, v);
  return f;
}
function z5(s, e, t, i) {
  i.sort(gn.compare);
  const n = A5.normalize(s, i), r = n.length;
  let o = 0;
  const a = [];
  let l = 0, c = 0;
  for (let u = 0, d = t.length; u < d; u++) {
    const f = t[u], m = f.endIndex, _ = f.type, b = f.metadata, v = f.containsRTL;
    for (; o < r && n[o].startOffset < m; ) {
      const C = n[o];
      if (C.startOffset > c && (c = C.startOffset, a[l++] = new kt(c, _, b, v)), C.endOffset + 1 <= m)
        c = C.endOffset + 1, a[l++] = new kt(c, _ + " " + C.className, b | C.metadata, v), o++;
      else {
        c = m, a[l++] = new kt(c, _ + " " + C.className, b | C.metadata, v);
        break;
      }
    }
    m > c && (c = m, a[l++] = new kt(c, _, b, v));
  }
  const h = t[t.length - 1].endIndex;
  if (o < r && n[o].startOffset === h)
    for (; o < r && n[o].startOffset === h; ) {
      const u = n[o];
      a[l++] = new kt(c, u.className, u.metadata, !1), o++;
    }
  return a;
}
function U5(s, e) {
  const t = s.fontIsMonospace, i = s.canUseHalfwidthRightwardsArrow, n = s.containsForeignElements, r = s.lineContent, o = s.len, a = s.isOverflowing, l = s.parts, c = s.fauxIndentLength, h = s.tabSize, u = s.startVisibleColumn, d = s.containsRTL, f = s.spaceWidth, m = s.renderSpaceCharCode, _ = s.renderWhitespace, b = s.renderControlCharacters, v = new Qn(o + 1, l.length);
  let C = !1, w = 0, L = u, E = 0, k = 0, y = 0;
  d ? e.appendASCIIString('<span dir="ltr">') : e.appendASCIIString("<span>");
  for (let S = 0, D = l.length; S < D; S++) {
    const T = l[S], M = T.endIndex, P = T.type, V = T.containsRTL, U = _ !== 0 && T.isWhitespace(), K = U && !t && (P === "mtkw" || !n), J = w === M && T.isPseudoAfter();
    if (E = 0, e.appendASCIIString("<span "), V && e.appendASCIIString('style="unicode-bidi:isolate" '), e.appendASCIIString('class="'), e.appendASCIIString(K ? "mtkz" : P), e.appendASCII(34), U) {
      let ee = 0;
      {
        let ne = w, ue = L;
        for (; ne < M; ne++) {
          const Ue = (r.charCodeAt(ne) === 9 ? h - ue % h : 1) | 0;
          ee += Ue, ne >= c && (ue += Ue);
        }
      }
      for (K && (e.appendASCIIString(' style="width:'), e.appendASCIIString(String(f * ee)), e.appendASCIIString('px"')), e.appendASCII(62); w < M; w++) {
        v.setColumnInfo(w + 1, S - y, E, k), y = 0;
        const ne = r.charCodeAt(w);
        let ue, He;
        if (ne === 9) {
          ue = h - L % h | 0, He = ue, !i || He > 1 ? e.write1(8594) : e.write1(65515);
          for (let Ue = 2; Ue <= He; Ue++)
            e.write1(160);
        } else
          ue = 2, He = 1, e.write1(m), e.write1(8204);
        E += ue, k += He, w >= c && (L += He);
      }
    } else
      for (e.appendASCII(62); w < M; w++) {
        v.setColumnInfo(w + 1, S - y, E, k), y = 0;
        const ee = r.charCodeAt(w);
        let ne = 1, ue = 1;
        switch (ee) {
          case 9:
            ne = h - L % h, ue = ne;
            for (let He = 1; He <= ne; He++)
              e.write1(160);
            break;
          case 32:
            e.write1(160);
            break;
          case 60:
            e.appendASCIIString("&lt;");
            break;
          case 62:
            e.appendASCIIString("&gt;");
            break;
          case 38:
            e.appendASCIIString("&amp;");
            break;
          case 0:
            b ? e.write1(9216) : e.appendASCIIString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.write1(65533);
            break;
          default:
            Jr(ee) && ue++, b && ee < 32 ? e.write1(9216 + ee) : b && ee === 127 ? e.write1(9249) : b && W2(ee) ? (e.appendASCIIString("[U+"), e.appendASCIIString($5(ee)), e.appendASCIIString("]"), ne = 8, ue = ne) : e.write1(ee);
        }
        E += ne, k += ue, w >= c && (L += ue);
      }
    J ? y++ : y = 0, w >= o && !C && T.isPseudoAfter() && (C = !0, v.setColumnInfo(w + 1, S, E, k)), e.appendASCIIString("</span>");
  }
  return C || v.setColumnInfo(o + 1, l.length - 1, E, k), a && e.appendASCIIString("<span>&hellip;</span>"), e.appendASCIIString("</span>"), new v1(v, d, n);
}
function $5(s) {
  return s.toString(16).toUpperCase().padStart(4, "0");
}
class kw {
  constructor(e, t, i, n) {
    this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
  }
}
class j5 {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class Ub {
  constructor(e, t, i, n, r, o, a) {
    this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = r, this.tokens = o, this.inlineDecorations = a;
  }
}
class Wi {
  constructor(e, t, i, n, r, o, a, l, c, h) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = Wi.isBasicASCII(i, o), this.containsRTL = Wi.containsRTL(i, this.isBasicASCII, r), this.tokens = a, this.inlineDecorations = l, this.tabSize = c, this.startVisibleColumn = h;
  }
  static isBasicASCII(e, t) {
    return t ? Eb(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? Th(e) : !1;
  }
}
class lh {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class K5 {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
  }
  toInlineDecoration(e) {
    return new lh(new N(e, this.startOffset + 1, e, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 : 0);
  }
}
class H2 {
  constructor(e, t) {
    this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
  }
}
class z2 {
  constructor(e, t, i) {
    this.color = e, this.zIndex = t, this.data = i;
  }
  static cmp(e, t) {
    return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
  }
}
function q5(s) {
  return Array.isArray(s);
}
function G5(s) {
  return !q5(s);
}
function U2(s) {
  return typeof s == "string";
}
function Dw(s) {
  return !U2(s);
}
function Ba(s) {
  return !s;
}
function qr(s, e) {
  return s.ignoreCase && e ? e.toLowerCase() : e;
}
function Ew(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function Z5(s, e) {
  console.log(`${s.languageId}: ${e}`);
}
function Ae(s, e) {
  return new Error(`${s.languageId}: ${e}`);
}
function xr(s, e, t, i, n) {
  const r = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let o = null;
  return e.replace(r, function(a, l, c, h, u, d, f, m, _) {
    return Ba(c) ? Ba(h) ? !Ba(u) && u < i.length ? qr(s, i[u]) : !Ba(f) && s && typeof s[f] == "string" ? s[f] : (o === null && (o = n.split("."), o.unshift(n)), !Ba(d) && d < o.length ? qr(s, o[d]) : "") : qr(s, t) : "$";
  });
}
function ed(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = s.tokenizer[t];
    if (i)
      return i;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return null;
}
function Y5(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (s.stateNames[t])
      return !0;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return !1;
}
var Q5 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, X5 = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const $2 = 5;
class Bh {
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new gl(e, t);
    let i = gl.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let n = this._entries[i];
    return n || (n = new gl(e, t), this._entries[i] = n, n);
  }
}
Bh._INSTANCE = new Bh($2);
class gl {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return gl._equals(this, e);
  }
  push(e) {
    return Bh.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return Bh.create(this.parent, e);
  }
}
class Za {
  constructor(e, t) {
    this.languageId = e, this.state = t;
  }
  equals(e) {
    return this.languageId === e.languageId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new Za(this.languageId, this.state);
  }
}
class Ir {
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  create(e, t) {
    if (t !== null)
      return new ch(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new ch(e, t);
    const i = gl.getStackElementId(e);
    let n = this._entries[i];
    return n || (n = new ch(e, null), this._entries[i] = n, n);
  }
}
Ir._INSTANCE = new Ir($2);
class ch {
  constructor(e, t) {
    this.stack = e, this.embeddedLanguageData = t;
  }
  clone() {
    return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : Ir.create(this.stack, this.embeddedLanguageData);
  }
  equals(e) {
    return !(e instanceof ch) || !this.stack.equals(e.stack) ? !1 : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? !0 : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? !1 : this.embeddedLanguageData.equals(e.embeddedLanguageData);
  }
}
class J5 {
  constructor() {
    this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterLanguage(e) {
    this._languageId = e;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new Nh(e, t, this._languageId)));
  }
  nestedLanguageTokenize(e, t, i, n) {
    const r = i.languageId, o = i.state, a = at.get(r);
    if (!a)
      return this.enterLanguage(r), this.emit(n, ""), o;
    const l = a.tokenize(e, t, o);
    if (n !== 0)
      for (const c of l.tokens)
        this._tokens.push(new Nh(c.offset + n, c.type, c.language));
    else
      this._tokens = this._tokens.concat(l.tokens);
    return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
  }
  finalize(e) {
    return new vb(this._tokens, e);
  }
}
class Lf {
  constructor(e, t) {
    this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterLanguage(e) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
  }
  emit(e, t) {
    const i = this._theme.match(this._currentLanguageId, t);
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    const n = e !== null ? e.length : 0, r = t.length, o = i !== null ? i.length : 0;
    if (n === 0 && r === 0 && o === 0)
      return new Uint32Array(0);
    if (n === 0 && r === 0)
      return i;
    if (r === 0 && o === 0)
      return e;
    const a = new Uint32Array(n + r + o);
    e !== null && a.set(e);
    for (let l = 0; l < r; l++)
      a[n + l] = t[l];
    return i !== null && a.set(i, n + r), a;
  }
  nestedLanguageTokenize(e, t, i, n) {
    const r = i.languageId, o = i.state, a = at.get(r);
    if (!a)
      return this.enterLanguage(r), this.emit(n, ""), o;
    const l = a.tokenizeEncoded(e, t, o);
    if (n !== 0)
      for (let c = 0, h = l.tokens.length; c < h; c += 2)
        l.tokens[c] += n;
    return this._prependTokens = Lf._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new Ig(Lf._merge(this._prependTokens, this._tokens, null), e);
  }
}
let Vh = class j2 {
  constructor(e, t, i, n, r) {
    this._configurationService = r, this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let o = !1;
    this._tokenizationRegistryListener = at.onDidChange((a) => {
      if (o)
        return;
      let l = !1;
      for (let c = 0, h = a.changedLanguages.length; c < h; c++) {
        const u = a.changedLanguages[c];
        if (this._embeddedLanguages[u]) {
          l = !0;
          break;
        }
      }
      l && (o = !0, at.fire([this._languageId]), o = !1);
    }), this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    }), this._configurationService.onDidChangeConfiguration((a) => {
      a.affectsConfiguration("editor.maxTokenizationLineLength") && (this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
        overrideIdentifier: this._languageId
      }));
    });
  }
  dispose() {
    this._tokenizationRegistryListener.dispose();
  }
  getLoadStatus() {
    const e = [];
    for (const t in this._embeddedLanguages) {
      const i = at.get(t);
      if (i) {
        if (i instanceof j2) {
          const n = i.getLoadStatus();
          n.loaded === !1 && e.push(n.promise);
        }
        continue;
      }
      at.isResolved(t) || e.push(at.getOrCreate(t));
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    const e = Bh.create(null, this._lexer.start);
    return Ir.create(e, null);
  }
  tokenize(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return E2(this._languageId, i);
    const n = new J5(), r = this._tokenize(e, t, i, n);
    return n.finalize(r);
  }
  tokenizeEncoded(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return x2(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), i);
    const n = new Lf(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), r = this._tokenize(e, t, i, n);
    return n.finalize(r);
  }
  _tokenize(e, t, i, n) {
    return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
  }
  _findLeavingNestedLanguageOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = ed(this._lexer, t.stack.state), !i))
      throw Ae(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let n = -1, r = !1;
    for (const o of i) {
      if (!Dw(o.action) || o.action.nextEmbedded !== "@pop")
        continue;
      r = !0;
      let a = o.regex;
      const l = o.regex.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        const h = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), h);
      }
      const c = e.search(a);
      c === -1 || c !== 0 && o.matchOnlyAtLineStart || (n === -1 || c < n) && (n = c);
    }
    if (!r)
      throw Ae(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return n;
  }
  _nestedTokenize(e, t, i, n, r) {
    const o = this._findLeavingNestedLanguageOffset(e, i);
    if (o === -1) {
      const c = r.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
      return Ir.create(i.stack, new Za(i.embeddedLanguageData.languageId, c));
    }
    const a = e.substring(0, o);
    a.length > 0 && r.nestedLanguageTokenize(a, !1, i.embeddedLanguageData, n);
    const l = e.substring(o);
    return this._myTokenize(l, t, i, n + o, r);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, n, r) {
    r.enterLanguage(this._languageId);
    const o = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let c = i.embeddedLanguageData, h = i.stack, u = 0, d = null, f = !0;
    for (; f || u < l; ) {
      const m = u, _ = h.depth, b = d ? d.groups.length : 0, v = h.state;
      let C = null, w = null, L = null, E = null, k = null;
      if (d) {
        C = d.matches;
        const D = d.groups.shift();
        w = D.matched, L = D.action, E = d.rule, d.groups.length === 0 && (d = null);
      } else {
        if (!f && u >= l)
          break;
        f = !1;
        let D = this._lexer.tokenizer[v];
        if (!D && (D = ed(this._lexer, v), !D))
          throw Ae(this._lexer, "tokenizer state is not defined: " + v);
        const T = a.substr(u);
        for (const M of D)
          if ((u === 0 || !M.matchOnlyAtLineStart) && (C = T.match(M.regex), C)) {
            w = C[0], L = M.action;
            break;
          }
      }
      if (C || (C = [""], w = ""), L || (u < l && (C = [a.charAt(u)], w = C[0]), L = this._lexer.defaultToken), w === null)
        break;
      for (u += w.length; G5(L) && Dw(L) && L.test; )
        L = L.test(w, C, v, u === l);
      let y = null;
      if (typeof L == "string" || Array.isArray(L))
        y = L;
      else if (L.group)
        y = L.group;
      else if (L.token !== null && L.token !== void 0) {
        if (L.tokenSubst ? y = xr(this._lexer, L.token, w, C, v) : y = L.token, L.nextEmbedded)
          if (L.nextEmbedded === "@pop") {
            if (!c)
              throw Ae(this._lexer, "cannot pop embedded language if not inside one");
            c = null;
          } else {
            if (c)
              throw Ae(this._lexer, "cannot enter embedded language from within an embedded language");
            k = xr(this._lexer, L.nextEmbedded, w, C, v);
          }
        if (L.goBack && (u = Math.max(0, u - L.goBack)), L.switchTo && typeof L.switchTo == "string") {
          let D = xr(this._lexer, L.switchTo, w, C, v);
          if (D[0] === "@" && (D = D.substr(1)), ed(this._lexer, D))
            h = h.switchTo(D);
          else
            throw Ae(this._lexer, "trying to switch to a state '" + D + "' that is undefined in rule: " + this._safeRuleName(E));
        } else {
          if (L.transform && typeof L.transform == "function")
            throw Ae(this._lexer, "action.transform not supported");
          if (L.next)
            if (L.next === "@push") {
              if (h.depth >= this._lexer.maxStack)
                throw Ae(this._lexer, "maximum tokenizer stack size reached: [" + h.state + "," + h.parent.state + ",...]");
              h = h.push(v);
            } else if (L.next === "@pop") {
              if (h.depth <= 1)
                throw Ae(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(E));
              h = h.pop();
            } else if (L.next === "@popall")
              h = h.popall();
            else {
              let D = xr(this._lexer, L.next, w, C, v);
              if (D[0] === "@" && (D = D.substr(1)), ed(this._lexer, D))
                h = h.push(D);
              else
                throw Ae(this._lexer, "trying to set a next state '" + D + "' that is undefined in rule: " + this._safeRuleName(E));
            }
        }
        L.log && typeof L.log == "string" && Z5(this._lexer, this._lexer.languageId + ": " + xr(this._lexer, L.log, w, C, v));
      }
      if (y === null)
        throw Ae(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(E));
      const S = (D) => {
        const T = this._languageService.getLanguageIdByLanguageName(D) || this._languageService.getLanguageIdByMimeType(D) || D, M = this._getNestedEmbeddedLanguageData(T);
        if (u < l) {
          const P = e.substr(u);
          return this._nestedTokenize(P, t, Ir.create(h, M), n + u, r);
        } else
          return Ir.create(h, M);
      };
      if (Array.isArray(y)) {
        if (d && d.groups.length > 0)
          throw Ae(this._lexer, "groups cannot be nested: " + this._safeRuleName(E));
        if (C.length !== y.length + 1)
          throw Ae(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(E));
        let D = 0;
        for (let T = 1; T < C.length; T++)
          D += C[T].length;
        if (D !== w.length)
          throw Ae(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(E));
        d = {
          rule: E,
          matches: C,
          groups: []
        };
        for (let T = 0; T < y.length; T++)
          d.groups[T] = {
            action: y[T],
            matched: C[T + 1]
          };
        u -= w.length;
        continue;
      } else {
        if (y === "@rematch" && (u -= w.length, w = "", C = null, y = "", k !== null))
          return S(k);
        if (w.length === 0) {
          if (l === 0 || _ !== h.depth || v !== h.state || (d ? d.groups.length : 0) !== b)
            continue;
          throw Ae(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(E));
        }
        let D = null;
        if (U2(y) && y.indexOf("@brackets") === 0) {
          const T = y.substr(9), M = eM(this._lexer, w);
          if (!M)
            throw Ae(this._lexer, "@brackets token returned but no bracket defined as: " + w);
          D = Ew(M.token + T);
        } else {
          const T = y === "" ? "" : y + this._lexer.tokenPostfix;
          D = Ew(T);
        }
        m < o && r.emit(m + n, D);
      }
      if (k !== null)
        return S(k);
    }
    return Ir.create(h, c);
  }
  _getNestedEmbeddedLanguageData(e) {
    if (!this._languageService.isRegisteredLanguageId(e))
      return new Za(e, Cf);
    e !== this._languageId && (at.getOrCreate(e), this._embeddedLanguages[e] = !0);
    const t = at.get(e);
    return t ? new Za(e, t.getInitialState()) : new Za(e, Cf);
  }
};
Vh = Q5([
  X5(4, gt)
], Vh);
function eM(s, e) {
  if (!e)
    return null;
  e = qr(s, e);
  const t = s.brackets;
  for (const i of t) {
    if (i.open === e)
      return { token: i.token, bracketType: 1 };
    if (i.close === e)
      return { token: i.token, bracketType: -1 };
  }
  return null;
}
var tM = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
}, ep;
const tp = (ep = window.trustedTypes) === null || ep === void 0 ? void 0 : ep.createPolicy("standaloneColorizer", { createHTML: (s) => s });
class $b {
  static colorizeElement(e, t, i, n) {
    n = n || {};
    const r = n.theme || "vs", o = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!o)
      return console.error("Mode not detected"), Promise.resolve();
    const a = t.getLanguageIdByMimeType(o) || o;
    e.setTheme(r);
    const l = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + r;
    const c = (h) => {
      var u;
      const d = (u = tp == null ? void 0 : tp.createHTML(h)) !== null && u !== void 0 ? u : h;
      i.innerHTML = d;
    };
    return this.colorize(t, l || "", a, n).then(c, (h) => console.error(h));
  }
  static colorize(e, t, i, n) {
    return tM(this, void 0, void 0, function* () {
      const r = e.languageIdCodec;
      let o = 4;
      n && typeof n.tabSize == "number" && (o = n.tabSize), Ib(t) && (t = t.substr(1));
      const a = xu(t);
      if (!e.isRegisteredLanguageId(i))
        return xw(a, o, r);
      const l = yield at.getOrCreate(i);
      return l ? iM(a, o, l, r) : xw(a, o, r);
    });
  }
  static colorizeLine(e, t, i, n, r = 4) {
    const o = Wi.isBasicASCII(e, t), a = Wi.containsRTL(e, o, i);
    return Wg(new dc(!1, !0, e, !1, o, a, 0, n, [], r, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    const n = e.getLineContent(t);
    e.tokenization.forceTokenization(t);
    const o = e.tokenization.getLineTokens(t).inflate();
    return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), o, i);
  }
}
function iM(s, e, t, i) {
  return new Promise((n, r) => {
    const o = () => {
      const a = nM(s, e, t, i);
      if (t instanceof Vh) {
        const l = t.getLoadStatus();
        if (l.loaded === !1) {
          l.promise.then(o, r);
          return;
        }
      }
      n(a);
    };
    o();
  });
}
function xw(s, e, t) {
  let i = [];
  const r = new Uint32Array(2);
  r[0] = 0, r[1] = 33587200;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o];
    r[0] = l.length;
    const c = new Pt(r, l, t), h = Wi.isBasicASCII(l, !0), u = Wi.containsRTL(l, h, !0), d = Wg(new dc(!1, !0, l, !1, h, u, 0, c, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(d.html), i.push("<br/>");
  }
  return i.join("");
}
function nM(s, e, t, i) {
  let n = [], r = t.getInitialState();
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], c = t.tokenizeEncoded(l, !0, r);
    Pt.convertToEndOffset(c.tokens, l.length);
    const h = new Pt(c.tokens, l, i), u = Wi.isBasicASCII(l, !0), d = Wi.containsRTL(l, u, !0), f = Wg(new dc(!1, !0, l, !1, u, d, 0, h.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    n = n.concat(f.html), n.push("<br/>"), r = c.endState;
  }
  return n.join("");
}
const K2 = {
  clipboard: {
    writeText: sh || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: sh || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  keyboard: (() => sh || u2() ? 0 : navigator.keyboard || rr ? 1 : 2)(),
  touch: "ontouchstart" in window || navigator.maxTouchPoints > 0,
  pointerEvents: window.PointerEvent && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0)
};
function w1(s, e) {
  if (s === 0)
    return null;
  const t = (s & 65535) >>> 0, i = (s & 4294901760) >>> 16;
  return i !== 0 ? new kf([
    ip(t, e),
    ip(i, e)
  ]) : new kf([ip(t, e)]);
}
function ip(s, e) {
  const t = !!(s & 2048), i = !!(s & 256), n = e === 2 ? i : t, r = !!(s & 1024), o = !!(s & 512), a = e === 2 ? t : i, l = s & 255;
  return new Wh(n, r, o, a, l);
}
class Wh {
  constructor(e, t, i, n, r) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = r;
  }
  equals(e) {
    return this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  toChord() {
    return new kf([this]);
  }
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class kf {
  constructor(e) {
    if (e.length === 0)
      throw gb("parts");
    this.parts = e;
  }
}
class sM {
  constructor(e, t, i, n, r, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = r, this.keyAriaLabel = o;
  }
}
class rM {
}
function oM(s) {
  if (s.charCode) {
    const t = String.fromCharCode(s.charCode).toUpperCase();
    return Mo.fromString(t);
  }
  const e = s.keyCode;
  if (e === 3)
    return 7;
  if (sn) {
    if (e === 59)
      return 80;
    if (e === 107)
      return 81;
    if (e === 109)
      return 83;
    if (Ie && e === 224)
      return 57;
  } else if (jr) {
    if (e === 91)
      return 57;
    if (Ie && e === 93)
      return 57;
    if (!Ie && e === 92)
      return 57;
  }
  return qk[e] || 0;
}
const aM = Ie ? 256 : 2048, lM = 512, cM = 1024, hM = Ie ? 2048 : 256;
class nt {
  constructor(e) {
    this._standardKeyboardEventBrand = !0;
    const t = e;
    this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.keyCode = oM(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeybinding() {
    return this._asRuntimeKeybinding;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= aM), this.altKey && (t |= lM), this.shiftKey && (t |= cM), this.metaKey && (t |= hM), t |= e, t;
  }
  _computeRuntimeKeybinding() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new Wh(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
let Iw = !1, Mc = null;
function uM(s) {
  if (!s.parent || s.parent === s)
    return null;
  try {
    const e = s.location, t = s.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin)
      return Iw = !0, null;
  } catch {
    return Iw = !0, null;
  }
  return s.parent;
}
class dM {
  static getSameOriginWindowChain() {
    if (!Mc) {
      Mc = [];
      let e = window, t;
      do
        t = uM(e), t ? Mc.push({
          window: e,
          iframeElement: e.frameElement || null
        }) : Mc.push({
          window: e,
          iframeElement: null
        }), e = t;
      while (e);
    }
    return Mc.slice(0);
  }
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let i = 0, n = 0;
    const r = this.getSameOriginWindowChain();
    for (const o of r) {
      if (i += o.window.scrollY, n += o.window.scrollX, o.window === t || !o.iframeElement)
        break;
      const a = o.iframeElement.getBoundingClientRect();
      i += a.top, n += a.left;
    }
    return {
      top: i,
      left: n
    };
  }
}
class Gs {
  constructor(e) {
    this.timestamp = Date.now(), this.browserEvent = e, this.leftButton = e.button === 0, this.middleButton = e.button === 1, this.rightButton = e.button === 2, this.buttons = e.buttons, this.target = e.target, this.detail = e.detail || 1, e.type === "dblclick" && (this.detail = 2), this.ctrlKey = e.ctrlKey, this.shiftKey = e.shiftKey, this.altKey = e.altKey, this.metaKey = e.metaKey, typeof e.pageX == "number" ? (this.posx = e.pageX, this.posy = e.pageY) : (this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop);
    const t = dM.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
    this.posx -= t.left, this.posy -= t.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class Vl {
  constructor(e, t = 0, i = 0) {
    if (this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t, e) {
      const n = e, r = e;
      if (typeof n.wheelDeltaY < "u")
        this.deltaY = n.wheelDeltaY / 120;
      else if (typeof r.VERTICAL_AXIS < "u" && r.axis === r.VERTICAL_AXIS)
        this.deltaY = -r.detail / 3;
      else if (e.type === "wheel") {
        const o = e;
        o.deltaMode === o.DOM_DELTA_LINE ? sn && !Ie ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof n.wheelDeltaX < "u")
        rr && Vi ? this.deltaX = -(n.wheelDeltaX / 120) : this.deltaX = n.wheelDeltaX / 120;
      else if (typeof r.HORIZONTAL_AXIS < "u" && r.axis === r.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const o = e;
        o.deltaMode === o.DOM_DELTA_LINE ? sn && !Ie ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation();
  }
}
/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */
function fM(s) {
  if (Array.isArray(s)) {
    for (var e = 0, t = Array(s.length); e < s.length; e++)
      t[e] = s[e];
    return t;
  } else
    return Array.from(s);
}
var gM = Object.hasOwnProperty, Nw = Object.setPrototypeOf, mM = Object.isFrozen, pM = Object.getPrototypeOf, _M = Object.getOwnPropertyDescriptor, Ni = Object.freeze, or = Object.seal, bM = Object.create, q2 = typeof Reflect < "u" && Reflect, Df = q2.apply, S1 = q2.construct;
Df || (Df = function(e, t, i) {
  return e.apply(t, i);
});
Ni || (Ni = function(e) {
  return e;
});
or || (or = function(e) {
  return e;
});
S1 || (S1 = function(e, t) {
  return new (Function.prototype.bind.apply(e, [null].concat(fM(t))))();
});
var CM = Fn(Array.prototype.forEach), Tw = Fn(Array.prototype.pop), Ac = Fn(Array.prototype.push), vo = Fn(String.prototype.toLowerCase), Mw = Fn(String.prototype.match), dr = Fn(String.prototype.replace), vM = Fn(String.prototype.indexOf), wM = Fn(String.prototype.trim), Ds = Fn(RegExp.prototype.test), Aw = SM(TypeError);
function Fn(s) {
  return function(e) {
    for (var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      i[n - 1] = arguments[n];
    return Df(s, e, i);
  };
}
function SM(s) {
  return function() {
    for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return S1(s, t);
  };
}
function xe(s, e) {
  Nw && Nw(s, null);
  for (var t = e.length; t--; ) {
    var i = e[t];
    if (typeof i == "string") {
      var n = vo(i);
      n !== i && (mM(e) || (e[t] = n), i = n);
    }
    s[i] = !0;
  }
  return s;
}
function po(s) {
  var e = bM(null), t = void 0;
  for (t in s)
    Df(gM, s, [t]) && (e[t] = s[t]);
  return e;
}
function td(s, e) {
  for (; s !== null; ) {
    var t = _M(s, e);
    if (t) {
      if (t.get)
        return Fn(t.get);
      if (typeof t.value == "function")
        return Fn(t.value);
    }
    s = pM(s);
  }
  function i(n) {
    return console.warn("fallback value for", n), null;
  }
  return i;
}
var Rw = Ni(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), np = Ni(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), sp = Ni(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), yM = Ni(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), rp = Ni(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), LM = Ni(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Pw = Ni(["#text"]), Ow = Ni(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), op = Ni(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Fw = Ni(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), id = Ni(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), kM = or(/\{\{[\s\S]*|[\s\S]*\}\}/gm), DM = or(/<%[\s\S]*|[\s\S]*%>/gm), EM = or(/^data-[\-\w.\u00B7-\uFFFF]/), xM = or(/^aria-[\-\w]+$/), IM = or(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), NM = or(/^(?:\w+script|data):/i), TM = or(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), $c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
  return typeof s;
} : function(s) {
  return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
};
function $n(s) {
  if (Array.isArray(s)) {
    for (var e = 0, t = Array(s.length); e < s.length; e++)
      t[e] = s[e];
    return t;
  } else
    return Array.from(s);
}
var MM = function() {
  return typeof window > "u" ? null : window;
}, AM = function(e, t) {
  if ((typeof e > "u" ? "undefined" : $c(e)) !== "object" || typeof e.createPolicy != "function")
    return null;
  var i = null, n = "data-tt-policy-suffix";
  t.currentScript && t.currentScript.hasAttribute(n) && (i = t.currentScript.getAttribute(n));
  var r = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(r, {
      createHTML: function(a) {
        return a;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + r + " could not be created."), null;
  }
};
function G2() {
  var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MM(), e = function(B) {
    return G2(B);
  };
  if (e.version = "2.3.1", e.removed = [], !s || !s.document || s.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var t = s.document, i = s.document, n = s.DocumentFragment, r = s.HTMLTemplateElement, o = s.Node, a = s.Element, l = s.NodeFilter, c = s.NamedNodeMap, h = c === void 0 ? s.NamedNodeMap || s.MozNamedAttrMap : c, u = s.Text, d = s.Comment, f = s.DOMParser, m = s.trustedTypes, _ = a.prototype, b = td(_, "cloneNode"), v = td(_, "nextSibling"), C = td(_, "childNodes"), w = td(_, "parentNode");
  if (typeof r == "function") {
    var L = i.createElement("template");
    L.content && L.content.ownerDocument && (i = L.content.ownerDocument);
  }
  var E = AM(m, t), k = E && $u ? E.createHTML("") : "", y = i, S = y.implementation, D = y.createNodeIterator, T = y.createDocumentFragment, M = y.getElementsByTagName, P = t.importNode, V = {};
  try {
    V = po(i).documentMode ? i.documentMode : {};
  } catch {
  }
  var U = {};
  e.isSupported = typeof w == "function" && S && typeof S.createHTMLDocument < "u" && V !== 9;
  var K = kM, J = DM, ee = EM, ne = xM, ue = NM, He = TM, Ue = IM, rt = null, bi = xe({}, [].concat($n(Rw), $n(np), $n(sp), $n(rp), $n(Pw))), Be = null, qt = xe({}, [].concat($n(Ow), $n(op), $n(Fw), $n(id))), lr = null, _a = null, Sc = !0, fo = !0, fv = !1, ba = !1, Ca = !1, Im = !1, Nm = !1, va = !1, Uu = !1, gv = !0, $u = !1, mv = !0, Tm = !0, yc = !1, wa = {}, Sa = null, pv = xe({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), _v = null, bv = xe({}, ["audio", "video", "img", "source", "image", "track"]), Mm = null, Cv = xe({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Am = "http://www.w3.org/1998/Math/MathML", Rm = "http://www.w3.org/2000/svg", cr = "http://www.w3.org/1999/xhtml", ju = cr, Pm = !1, ya = null, pI = i.createElement("form"), Om = function(B) {
    ya && ya === B || ((!B || (typeof B > "u" ? "undefined" : $c(B)) !== "object") && (B = {}), B = po(B), rt = "ALLOWED_TAGS" in B ? xe({}, B.ALLOWED_TAGS) : bi, Be = "ALLOWED_ATTR" in B ? xe({}, B.ALLOWED_ATTR) : qt, Mm = "ADD_URI_SAFE_ATTR" in B ? xe(po(Cv), B.ADD_URI_SAFE_ATTR) : Cv, _v = "ADD_DATA_URI_TAGS" in B ? xe(po(bv), B.ADD_DATA_URI_TAGS) : bv, Sa = "FORBID_CONTENTS" in B ? xe({}, B.FORBID_CONTENTS) : pv, lr = "FORBID_TAGS" in B ? xe({}, B.FORBID_TAGS) : {}, _a = "FORBID_ATTR" in B ? xe({}, B.FORBID_ATTR) : {}, wa = "USE_PROFILES" in B ? B.USE_PROFILES : !1, Sc = B.ALLOW_ARIA_ATTR !== !1, fo = B.ALLOW_DATA_ATTR !== !1, fv = B.ALLOW_UNKNOWN_PROTOCOLS || !1, ba = B.SAFE_FOR_TEMPLATES || !1, Ca = B.WHOLE_DOCUMENT || !1, va = B.RETURN_DOM || !1, Uu = B.RETURN_DOM_FRAGMENT || !1, gv = B.RETURN_DOM_IMPORT !== !1, $u = B.RETURN_TRUSTED_TYPE || !1, Nm = B.FORCE_BODY || !1, mv = B.SANITIZE_DOM !== !1, Tm = B.KEEP_CONTENT !== !1, yc = B.IN_PLACE || !1, Ue = B.ALLOWED_URI_REGEXP || Ue, ju = B.NAMESPACE || cr, ba && (fo = !1), Uu && (va = !0), wa && (rt = xe({}, [].concat($n(Pw))), Be = [], wa.html === !0 && (xe(rt, Rw), xe(Be, Ow)), wa.svg === !0 && (xe(rt, np), xe(Be, op), xe(Be, id)), wa.svgFilters === !0 && (xe(rt, sp), xe(Be, op), xe(Be, id)), wa.mathMl === !0 && (xe(rt, rp), xe(Be, Fw), xe(Be, id))), B.ADD_TAGS && (rt === bi && (rt = po(rt)), xe(rt, B.ADD_TAGS)), B.ADD_ATTR && (Be === qt && (Be = po(Be)), xe(Be, B.ADD_ATTR)), B.ADD_URI_SAFE_ATTR && xe(Mm, B.ADD_URI_SAFE_ATTR), B.FORBID_CONTENTS && (Sa === pv && (Sa = po(Sa)), xe(Sa, B.FORBID_CONTENTS)), Tm && (rt["#text"] = !0), Ca && xe(rt, ["html", "head", "body"]), rt.table && (xe(rt, ["tbody"]), delete lr.tbody), Ni && Ni(B), ya = B);
  }, vv = xe({}, ["mi", "mo", "mn", "ms", "mtext"]), wv = xe({}, ["foreignobject", "desc", "title", "annotation-xml"]), Ku = xe({}, np);
  xe(Ku, sp), xe(Ku, yM);
  var Fm = xe({}, rp);
  xe(Fm, LM);
  var _I = function(B) {
    var q = w(B);
    (!q || !q.tagName) && (q = {
      namespaceURI: cr,
      tagName: "template"
    });
    var re = vo(B.tagName), Ke = vo(q.tagName);
    if (B.namespaceURI === Rm)
      return q.namespaceURI === cr ? re === "svg" : q.namespaceURI === Am ? re === "svg" && (Ke === "annotation-xml" || vv[Ke]) : Boolean(Ku[re]);
    if (B.namespaceURI === Am)
      return q.namespaceURI === cr ? re === "math" : q.namespaceURI === Rm ? re === "math" && wv[Ke] : Boolean(Fm[re]);
    if (B.namespaceURI === cr) {
      if (q.namespaceURI === Rm && !wv[Ke] || q.namespaceURI === Am && !vv[Ke])
        return !1;
      var li = xe({}, ["title", "style", "font", "a", "script"]);
      return !Fm[re] && (li[re] || !Ku[re]);
    }
    return !1;
  }, ys = function(B) {
    Ac(e.removed, { element: B });
    try {
      B.parentNode.removeChild(B);
    } catch {
      try {
        B.outerHTML = k;
      } catch {
        B.remove();
      }
    }
  }, Sv = function(B, q) {
    try {
      Ac(e.removed, {
        attribute: q.getAttributeNode(B),
        from: q
      });
    } catch {
      Ac(e.removed, {
        attribute: null,
        from: q
      });
    }
    if (q.removeAttribute(B), B === "is" && !Be[B])
      if (va || Uu)
        try {
          ys(q);
        } catch {
        }
      else
        try {
          q.setAttribute(B, "");
        } catch {
        }
  }, yv = function(B) {
    var q = void 0, re = void 0;
    if (Nm)
      B = "<remove></remove>" + B;
    else {
      var Ke = Mw(B, /^[\r\n\t ]+/);
      re = Ke && Ke[0];
    }
    var li = E ? E.createHTML(B) : B;
    if (ju === cr)
      try {
        q = new f().parseFromString(li, "text/html");
      } catch {
      }
    if (!q || !q.documentElement) {
      q = S.createDocument(ju, "template", null);
      try {
        q.documentElement.innerHTML = Pm ? "" : li;
      } catch {
      }
    }
    var ci = q.body || q.documentElement;
    return B && re && ci.insertBefore(i.createTextNode(re), ci.childNodes[0] || null), ju === cr ? M.call(q, Ca ? "html" : "body")[0] : Ca ? q.documentElement : ci;
  }, Lv = function(B) {
    return D.call(B.ownerDocument || B, B, l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT, null, !1);
  }, bI = function(B) {
    return B instanceof u || B instanceof d ? !1 : typeof B.nodeName != "string" || typeof B.textContent != "string" || typeof B.removeChild != "function" || !(B.attributes instanceof h) || typeof B.removeAttribute != "function" || typeof B.setAttribute != "function" || typeof B.namespaceURI != "string" || typeof B.insertBefore != "function";
  }, Lc = function(B) {
    return (typeof o > "u" ? "undefined" : $c(o)) === "object" ? B instanceof o : B && (typeof B > "u" ? "undefined" : $c(B)) === "object" && typeof B.nodeType == "number" && typeof B.nodeName == "string";
  }, Ls = function(B, q, re) {
    !U[B] || CM(U[B], function(Ke) {
      Ke.call(e, q, re, ya);
    });
  }, kv = function(B) {
    var q = void 0;
    if (Ls("beforeSanitizeElements", B, null), bI(B) || Mw(B.nodeName, /[\u0080-\uFFFF]/))
      return ys(B), !0;
    var re = vo(B.nodeName);
    if (Ls("uponSanitizeElement", B, {
      tagName: re,
      allowedTags: rt
    }), !Lc(B.firstElementChild) && (!Lc(B.content) || !Lc(B.content.firstElementChild)) && Ds(/<[/\w]/g, B.innerHTML) && Ds(/<[/\w]/g, B.textContent) || re === "select" && Ds(/<template/i, B.innerHTML))
      return ys(B), !0;
    if (!rt[re] || lr[re]) {
      if (Tm && !Sa[re]) {
        var Ke = w(B) || B.parentNode, li = C(B) || B.childNodes;
        if (li && Ke)
          for (var ci = li.length, hi = ci - 1; hi >= 0; --hi)
            Ke.insertBefore(b(li[hi], !0), v(B));
      }
      return ys(B), !0;
    }
    return B instanceof a && !_I(B) || (re === "noscript" || re === "noembed") && Ds(/<\/no(script|embed)/i, B.innerHTML) ? (ys(B), !0) : (ba && B.nodeType === 3 && (q = B.textContent, q = dr(q, K, " "), q = dr(q, J, " "), B.textContent !== q && (Ac(e.removed, { element: B.cloneNode() }), B.textContent = q)), Ls("afterSanitizeElements", B, null), !1);
  }, Dv = function(B, q, re) {
    if (mv && (q === "id" || q === "name") && (re in i || re in pI))
      return !1;
    if (!(fo && !_a[q] && Ds(ee, q))) {
      if (!(Sc && Ds(ne, q))) {
        if (!Be[q] || _a[q])
          return !1;
        if (!Mm[q]) {
          if (!Ds(Ue, dr(re, He, ""))) {
            if (!((q === "src" || q === "xlink:href" || q === "href") && B !== "script" && vM(re, "data:") === 0 && _v[B])) {
              if (!(fv && !Ds(ue, dr(re, He, "")))) {
                if (re)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Ev = function(B) {
    var q = void 0, re = void 0, Ke = void 0, li = void 0;
    Ls("beforeSanitizeAttributes", B, null);
    var ci = B.attributes;
    if (!!ci) {
      var hi = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Be
      };
      for (li = ci.length; li--; ) {
        q = ci[li];
        var ks = q, kc = ks.name, xv = ks.namespaceURI;
        if (re = wM(q.value), Ke = vo(kc), hi.attrName = Ke, hi.attrValue = re, hi.keepAttr = !0, hi.forceKeepAttr = void 0, Ls("uponSanitizeAttribute", B, hi), re = hi.attrValue, !hi.forceKeepAttr && (Sv(kc, B), !!hi.keepAttr)) {
          if (Ds(/\/>/i, re)) {
            Sv(kc, B);
            continue;
          }
          ba && (re = dr(re, K, " "), re = dr(re, J, " "));
          var vI = B.nodeName.toLowerCase();
          if (!!Dv(vI, Ke, re))
            try {
              xv ? B.setAttributeNS(xv, kc, re) : B.setAttribute(kc, re), Tw(e.removed);
            } catch {
            }
        }
      }
      Ls("afterSanitizeAttributes", B, null);
    }
  }, CI = function ce(B) {
    var q = void 0, re = Lv(B);
    for (Ls("beforeSanitizeShadowDOM", B, null); q = re.nextNode(); )
      Ls("uponSanitizeShadowNode", q, null), !kv(q) && (q.content instanceof n && ce(q.content), Ev(q));
    Ls("afterSanitizeShadowDOM", B, null);
  };
  return e.sanitize = function(ce, B) {
    var q = void 0, re = void 0, Ke = void 0, li = void 0, ci = void 0;
    if (Pm = !ce, Pm && (ce = "<!-->"), typeof ce != "string" && !Lc(ce)) {
      if (typeof ce.toString != "function")
        throw Aw("toString is not a function");
      if (ce = ce.toString(), typeof ce != "string")
        throw Aw("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if ($c(s.toStaticHTML) === "object" || typeof s.toStaticHTML == "function") {
        if (typeof ce == "string")
          return s.toStaticHTML(ce);
        if (Lc(ce))
          return s.toStaticHTML(ce.outerHTML);
      }
      return ce;
    }
    if (Im || Om(B), e.removed = [], typeof ce == "string" && (yc = !1), !yc)
      if (ce instanceof o)
        q = yv("<!---->"), re = q.ownerDocument.importNode(ce, !0), re.nodeType === 1 && re.nodeName === "BODY" || re.nodeName === "HTML" ? q = re : q.appendChild(re);
      else {
        if (!va && !ba && !Ca && ce.indexOf("<") === -1)
          return E && $u ? E.createHTML(ce) : ce;
        if (q = yv(ce), !q)
          return va ? null : k;
      }
    q && Nm && ys(q.firstChild);
    for (var hi = Lv(yc ? ce : q); Ke = hi.nextNode(); )
      Ke.nodeType === 3 && Ke === li || kv(Ke) || (Ke.content instanceof n && CI(Ke.content), Ev(Ke), li = Ke);
    if (li = null, yc)
      return ce;
    if (va) {
      if (Uu)
        for (ci = T.call(q.ownerDocument); q.firstChild; )
          ci.appendChild(q.firstChild);
      else
        ci = q;
      return gv && (ci = P.call(t, ci, !0)), ci;
    }
    var ks = Ca ? q.outerHTML : q.innerHTML;
    return ba && (ks = dr(ks, K, " "), ks = dr(ks, J, " ")), E && $u ? E.createHTML(ks) : ks;
  }, e.setConfig = function(ce) {
    Om(ce), Im = !0;
  }, e.clearConfig = function() {
    ya = null, Im = !1;
  }, e.isValidAttribute = function(ce, B, q) {
    ya || Om({});
    var re = vo(ce), Ke = vo(B);
    return Dv(re, Ke, q);
  }, e.addHook = function(ce, B) {
    typeof B == "function" && (U[ce] = U[ce] || [], Ac(U[ce], B));
  }, e.removeHook = function(ce) {
    U[ce] && Tw(U[ce]);
  }, e.removeHooks = function(ce) {
    U[ce] && (U[ce] = []);
  }, e.removeAllHooks = function() {
    U = {};
  }, e;
}
var Cs = G2();
Cs.version;
Cs.isSupported;
Cs.sanitize;
Cs.setConfig;
Cs.clearConfig;
Cs.isValidAttribute;
Cs.addHook;
Cs.removeHook;
Cs.removeHooks;
Cs.removeAllHooks;
var we;
(function(s) {
  s.inMemory = "inmemory", s.vscode = "vscode", s.internal = "private", s.walkThrough = "walkThrough", s.walkThroughSnippet = "walkThroughSnippet", s.http = "http", s.https = "https", s.file = "file", s.mailto = "mailto", s.untitled = "untitled", s.data = "data", s.command = "command", s.vscodeRemote = "vscode-remote", s.vscodeRemoteResource = "vscode-remote-resource", s.vscodeUserData = "vscode-userdata", s.vscodeCustomEditor = "vscode-custom-editor", s.vscodeNotebook = "vscode-notebook", s.vscodeNotebookCell = "vscode-notebook-cell", s.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", s.vscodeNotebookCellOutput = "vscode-notebook-cell-output", s.vscodeInteractive = "vscode-interactive", s.vscodeInteractiveInput = "vscode-interactive-input", s.vscodeSettings = "vscode-settings", s.vscodeWorkspaceTrust = "vscode-workspace-trust", s.vscodeTerminal = "vscode-terminal", s.webviewPanel = "webview-panel", s.vscodeWebview = "vscode-webview", s.extension = "extension", s.vscodeFileResource = "vscode-file", s.tmp = "tmp", s.vsls = "vsls", s.vscodeSourceControl = "vscode-scm";
})(we || (we = {}));
const RM = "tkn";
class PM {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._remoteResourcesPath = `/${we.vscodeRemoteResource}`;
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  rewrite(e) {
    if (this._delegate)
      return this._delegate(e);
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && (i = `[${i}]`);
    const n = this._ports[t], r = this._connectionTokens[t];
    let o = `path=${encodeURIComponent(e.path)}`;
    return typeof r == "string" && (o += `&${RM}=${encodeURIComponent(r)}`), Le.from({
      scheme: rc ? this._preferredWebSchema : we.vscodeRemoteResource,
      authority: `${i}:${n}`,
      path: this._remoteResourcesPath,
      query: o
    });
  }
}
const Z2 = new PM();
class Hh {
  asBrowserUri(e, t) {
    const i = this.toUri(e, t);
    return i.scheme === we.vscodeRemote ? Z2.rewrite(i) : i.scheme === we.file && (sh || xI && it.origin === `${we.vscodeFileResource}://${Hh.FALLBACK_AUTHORITY}`) ? i.with({
      scheme: we.vscodeFileResource,
      authority: i.authority || Hh.FALLBACK_AUTHORITY,
      query: null,
      fragment: null
    }) : i;
  }
  toUri(e, t) {
    return Le.isUri(e) ? e : Le.parse(t.toUrl(e));
  }
}
Hh.FALLBACK_AUTHORITY = "vscode-app";
const OM = new Hh();
function rn(s) {
  for (; s.firstChild; )
    s.firstChild.remove();
}
function Y2(s) {
  var e;
  return (e = s == null ? void 0 : s.isConnected) !== null && e !== void 0 ? e : !1;
}
class Q2 {
  constructor(e, t, i, n) {
    this._node = e, this._type = t, this._handler = i, this._options = n || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    !this._handler || (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function H(s, e, t, i) {
  return new Q2(s, e, t, i);
}
function FM(s) {
  return function(e) {
    return s(new Gs(e));
  };
}
function BM(s) {
  return function(e) {
    return s(new nt(e));
  };
}
const pi = function(e, t, i, n) {
  let r = i;
  return t === "click" || t === "mousedown" ? r = FM(i) : (t === "keydown" || t === "keypress" || t === "keyup") && (r = BM(i)), H(e, t, r, n);
};
function wn(s, e, t) {
  let i = null;
  const n = (l) => a.fire(l), r = () => {
    i || (i = new Q2(s, e, n, t));
  }, o = () => {
    i && (i.dispose(), i = null);
  }, a = new A({ onFirstListenerAdd: r, onLastListenerRemove: o });
  return a;
}
let ap = null;
function VM(s) {
  if (!ap) {
    const e = (t) => setTimeout(() => t(new Date().getTime()), 0);
    ap = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || e;
  }
  return ap.call(self, s);
}
let X2, Bn;
class lp {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        ct(e);
      }
  }
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  let s = [], e = null, t = !1, i = !1;
  const n = () => {
    for (t = !1, e = s, s = [], i = !0; e.length > 0; )
      e.sort(lp.sort), e.shift().execute();
    i = !1;
  };
  Bn = (r, o = 0) => {
    const a = new lp(r, o);
    return s.push(a), t || (t = !0, VM(n)), a;
  }, X2 = (r, o) => {
    if (i) {
      const a = new lp(r, o);
      return e.push(a), a;
    } else
      return Bn(r, o);
  };
})();
function jb(s) {
  return document.defaultView.getComputedStyle(s, null);
}
function J2(s) {
  if (s !== document.body)
    return new Gi(s.clientWidth, s.clientHeight);
  if (Ml && window.visualViewport)
    return new Gi(window.visualViewport.width, window.visualViewport.height);
  if (window.innerWidth && window.innerHeight)
    return new Gi(window.innerWidth, window.innerHeight);
  if (document.body && document.body.clientWidth && document.body.clientHeight)
    return new Gi(document.body.clientWidth, document.body.clientHeight);
  if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight)
    return new Gi(document.documentElement.clientWidth, document.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class Ye {
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    const n = jb(e);
    let r = "0";
    return n && (n.getPropertyValue ? r = n.getPropertyValue(t) : r = n.getAttribute(i)), Ye.convertToPixels(e, r);
  }
  static getBorderLeftWidth(e) {
    return Ye.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return Ye.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return Ye.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return Ye.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return Ye.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return Ye.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return Ye.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return Ye.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return Ye.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return Ye.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return Ye.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return Ye.getDimension(e, "margin-bottom", "marginBottom");
  }
}
class Gi {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new Gi(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof Gi ? e : new Gi(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
}
Gi.None = new Gi(0, 0);
function WM(s) {
  let e = s.offsetParent, t = s.offsetTop, i = s.offsetLeft;
  for (; (s = s.parentNode) !== null && s !== document.body && s !== document.documentElement; ) {
    t -= s.scrollTop;
    const n = tD(s) ? null : jb(s);
    n && (i -= n.direction !== "rtl" ? s.scrollLeft : -s.scrollLeft), s === e && (i += Ye.getBorderLeftWidth(s), t += Ye.getBorderTopWidth(s), t += s.offsetTop, i += s.offsetLeft, e = s.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function is(s) {
  const e = s.getBoundingClientRect();
  return {
    left: e.left + tr.scrollX,
    top: e.top + tr.scrollY,
    width: e.width,
    height: e.height
  };
}
function HM(s) {
  let e = s, t = 1;
  do {
    const i = jb(e).zoom;
    i != null && i !== "1" && (t *= i), e = e.parentElement;
  } while (e !== null && e !== document.documentElement);
  return t;
}
const tr = new class {
  get scrollX() {
    return typeof window.scrollX == "number" ? window.scrollX : document.body.scrollLeft + document.documentElement.scrollLeft;
  }
  get scrollY() {
    return typeof window.scrollY == "number" ? window.scrollY : document.body.scrollTop + document.documentElement.scrollTop;
  }
}();
function y1(s) {
  const e = Ye.getMarginLeft(s) + Ye.getMarginRight(s);
  return s.offsetWidth + e;
}
function cp(s) {
  const e = Ye.getBorderLeftWidth(s) + Ye.getBorderRightWidth(s), t = Ye.getPaddingLeft(s) + Ye.getPaddingRight(s);
  return s.offsetWidth - e - t;
}
function zM(s) {
  const e = Ye.getBorderTopWidth(s) + Ye.getBorderBottomWidth(s), t = Ye.getPaddingTop(s) + Ye.getPaddingBottom(s);
  return s.offsetHeight - e - t;
}
function L1(s) {
  const e = Ye.getMarginTop(s) + Ye.getMarginBottom(s);
  return s.offsetHeight + e;
}
function ir(s, e) {
  for (; s; ) {
    if (s === e)
      return !0;
    s = s.parentNode;
  }
  return !1;
}
function eD(s, e, t) {
  for (; s && s.nodeType === s.ELEMENT_NODE; ) {
    if (s.classList.contains(e))
      return s;
    if (t) {
      if (typeof t == "string") {
        if (s.classList.contains(t))
          return null;
      } else if (s === t)
        return null;
    }
    s = s.parentNode;
  }
  return null;
}
function hp(s, e, t) {
  return !!eD(s, e, t);
}
function tD(s) {
  return s && !!s.host && !!s.mode;
}
function k1(s) {
  return !!Wl(s);
}
function Wl(s) {
  for (; s.parentNode; ) {
    if (s === document.body)
      return null;
    s = s.parentNode;
  }
  return tD(s) ? s : null;
}
function ml() {
  let s = document.activeElement;
  for (; s != null && s.shadowRoot; )
    s = s.shadowRoot.activeElement;
  return s;
}
function Vn(s = document.getElementsByTagName("head")[0]) {
  const e = document.createElement("style");
  return e.type = "text/css", e.media = "screen", s.appendChild(e), e;
}
let up = null;
function UM() {
  return up || (up = Vn()), up;
}
function Bw(s, e, t = UM()) {
  !t || !e || t.sheet.insertRule(s + "{" + e + "}", 0);
}
function iD(s) {
  return typeof HTMLElement == "object" ? s instanceof HTMLElement : s && typeof s == "object" && s.nodeType === 1 && typeof s.nodeName == "string";
}
const $ = {
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  POINTER_LEAVE: "pointerleave",
  CONTEXT_MENU: "contextmenu",
  WHEEL: "wheel",
  KEY_DOWN: "keydown",
  KEY_PRESS: "keypress",
  KEY_UP: "keyup",
  LOAD: "load",
  BEFORE_UNLOAD: "beforeunload",
  UNLOAD: "unload",
  PAGE_SHOW: "pageshow",
  PAGE_HIDE: "pagehide",
  ABORT: "abort",
  ERROR: "error",
  RESIZE: "resize",
  SCROLL: "scroll",
  FULLSCREEN_CHANGE: "fullscreenchange",
  WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
  SELECT: "select",
  CHANGE: "change",
  SUBMIT: "submit",
  RESET: "reset",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  STORAGE: "storage",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend",
  ANIMATION_START: jr ? "webkitAnimationStart" : "animationstart",
  ANIMATION_END: jr ? "webkitAnimationEnd" : "animationend",
  ANIMATION_ITERATION: jr ? "webkitAnimationIteration" : "animationiteration"
}, Oe = {
  stop: function(s, e) {
    s.preventDefault ? s.preventDefault() : s.returnValue = !1, e && (s.stopPropagation ? s.stopPropagation() : s.cancelBubble = !0);
  }
};
function $M(s) {
  const e = [];
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    e[t] = s.scrollTop, s = s.parentNode;
  return e;
}
function jM(s, e) {
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    s.scrollTop !== e[t] && (s.scrollTop = e[t]), s = s.parentNode;
}
class Ef extends z {
  constructor(e) {
    super(), this._onDidFocus = this._register(new A()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new A()), this.onDidBlur = this._onDidBlur.event;
    let t = Ef.hasFocusWithin(e), i = !1;
    const n = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, r = () => {
      t && (i = !0, window.setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      Ef.hasFocusWithin(e) !== t && (t ? r() : n());
    }, this._register(H(e, $.FOCUS, n, !0)), this._register(H(e, $.BLUR, r, !0)), this._register(H(e, $.FOCUS_IN, () => this._refreshStateHandler())), this._register(H(e, $.FOCUS_OUT, () => this._refreshStateHandler()));
  }
  static hasFocusWithin(e) {
    const t = Wl(e), i = t ? t.activeElement : document.activeElement;
    return ir(i, e);
  }
}
function Hg(s) {
  return new Ef(s);
}
function Y(s, ...e) {
  if (s.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function zg(s, ...e) {
  s.innerText = "", Y(s, ...e);
}
const KM = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var zh;
(function(s) {
  s.HTML = "http://www.w3.org/1999/xhtml", s.SVG = "http://www.w3.org/2000/svg";
})(zh || (zh = {}));
function nD(s, e, t, ...i) {
  const n = KM.exec(e);
  if (!n)
    throw new Error("Bad use of emmet");
  t = Object.assign({}, t || {});
  const r = n[1] || "div";
  let o;
  return s !== zh.HTML ? o = document.createElementNS(s, r) : o = document.createElement(r), n[3] && (o.id = n[3]), n[4] && (o.className = n[4].replace(/\./g, " ").trim()), Object.keys(t).forEach((a) => {
    const l = t[a];
    typeof l > "u" || (/^on\w+$/.test(a) ? o[a] = l : a === "selected" ? l && o.setAttribute(a, "true") : o.setAttribute(a, l));
  }), o.append(...i), o;
}
function ae(s, e, ...t) {
  return nD(zh.HTML, s, e, ...t);
}
ae.SVG = function(s, e, ...t) {
  return nD(zh.SVG, s, e, ...t);
};
function sD(...s) {
  for (const e of s)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function Vw(...s) {
  for (const e of s)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function qM(s) {
  return Array.prototype.slice.call(document.getElementsByTagName(s), 0);
}
function Ww(s) {
  const e = window.devicePixelRatio * s;
  return Math.max(1, Math.floor(e)) / window.devicePixelRatio;
}
function rD(s) {
  window.open(s, "_blank", "noopener");
}
function GM(s) {
  const e = () => {
    s(), t = Bn(e);
  };
  let t = Bn(e);
  return ze(() => t.dispose());
}
Z2.setPreferredWebSchema(/^https:/.test(window.location.href) ? "https" : "http");
function D1(s) {
  return s ? `url('${OM.asBrowserUri(s).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function Hw(s) {
  return `'${s.replace(/'/g, "%27")}'`;
}
class Ya extends A {
  constructor() {
    super(), this._subscriptions = new le(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(H(window, "keydown", (e) => {
      if (e.defaultPrevented)
        return;
      const t = new nt(e);
      if (!(t.keyCode === 6 && e.repeat)) {
        if (e.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (e.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (e.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (e.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (t.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = e, this.fire(this._keyStatus));
      }
    }, !0)), this._subscriptions.add(H(window, "keyup", (e) => {
      e.defaultPrevented || (!e.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !e.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !e.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !e.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = e, this.fire(this._keyStatus)));
    }, !0)), this._subscriptions.add(H(document.body, "mousedown", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), this._subscriptions.add(H(document.body, "mouseup", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), this._subscriptions.add(H(document.body, "mousemove", (e) => {
      e.buttons && (this._keyStatus.lastKeyPressed = void 0);
    }, !0)), this._subscriptions.add(H(window, "blur", () => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return Ya.instance || (Ya.instance = new Ya()), Ya.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
class ZM extends z {
  constructor(e, t) {
    super(), this.element = e, this.callbacks = t, this.counter = 0, this.dragStartTime = 0, this.registerListeners();
  }
  registerListeners() {
    this._register(H(this.element, $.DRAG_ENTER, (e) => {
      this.counter++, this.dragStartTime = e.timeStamp, this.callbacks.onDragEnter(e);
    })), this._register(H(this.element, $.DRAG_OVER, (e) => {
      var t, i;
      e.preventDefault(), (i = (t = this.callbacks).onDragOver) === null || i === void 0 || i.call(t, e, e.timeStamp - this.dragStartTime);
    })), this._register(H(this.element, $.DRAG_LEAVE, (e) => {
      this.counter--, this.counter === 0 && (this.dragStartTime = 0, this.callbacks.onDragLeave(e));
    })), this._register(H(this.element, $.DRAG_END, (e) => {
      this.counter = 0, this.dragStartTime = 0, this.callbacks.onDragEnd(e);
    })), this._register(H(this.element, $.DROP, (e) => {
      this.counter = 0, this.dragStartTime = 0, this.callbacks.onDrop(e);
    }));
  }
}
const zw = 2e4;
let ko, Kd, E1, qd, x1;
function YM(s) {
  ko = document.createElement("div"), ko.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), ko.appendChild(i), i;
  };
  Kd = e(), E1 = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("role", "complementary"), i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), ko.appendChild(i), i;
  };
  qd = t(), x1 = t(), s.appendChild(ko);
}
function Kb(s) {
  !ko || (Kd.textContent !== s ? (rn(E1), xf(Kd, s)) : (rn(Kd), xf(E1, s)));
}
function QM(s) {
  !ko || (Ie ? Kb(s) : qd.textContent !== s ? (rn(x1), xf(qd, s)) : (rn(qd), xf(x1, s)));
}
function xf(s, e) {
  rn(s), e.length > zw && (e = e.substr(0, zw)), s.textContent = e, s.style.visibility = "hidden", s.style.visibility = "visible";
}
const oD = Se("markerDecorationsService"), Ug = Se("textModelService");
var Uh = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class as extends z {
  constructor(e, t = "", i = "", n = !0, r) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = r;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  run(e, t) {
    return Uh(this, void 0, void 0, function* () {
      this._actionCallback && (yield this._actionCallback(e));
    });
  }
}
class qb extends z {
  constructor() {
    super(...arguments), this._onBeforeRun = this._register(new A()), this.onBeforeRun = this._onBeforeRun.event, this._onDidRun = this._register(new A()), this.onDidRun = this._onDidRun.event;
  }
  run(e, t) {
    return Uh(this, void 0, void 0, function* () {
      if (!e.enabled)
        return;
      this._onBeforeRun.fire({ action: e });
      let i;
      try {
        yield this.runAction(e, t);
      } catch (n) {
        i = n;
      }
      this._onDidRun.fire({ action: e, error: i });
    });
  }
  runAction(e, t) {
    return Uh(this, void 0, void 0, function* () {
      yield e.run(t);
    });
  }
}
class ls extends as {
  constructor(e) {
    super(ls.ID, e, e ? "separator text" : "separator"), this.checked = !1, this.enabled = !1;
  }
}
ls.ID = "vs.actions.separator";
class aD {
  constructor(e, t, i, n) {
    this.tooltip = "", this.enabled = !0, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
  }
  get actions() {
    return this._actions;
  }
  dispose() {
  }
  run() {
    return Uh(this, void 0, void 0, function* () {
    });
  }
}
class $g extends as {
  constructor() {
    super($g.ID, p("submenu.empty", "(empty)"), void 0, !1);
  }
}
$g.ID = "vs.actions.empty";
function Uw(s) {
  var e, t;
  return {
    id: s.id,
    label: s.label,
    class: void 0,
    enabled: (e = s.enabled) !== null && e !== void 0 ? e : !0,
    checked: (t = s.checked) !== null && t !== void 0 ? t : !1,
    run: () => Uh(this, void 0, void 0, function* () {
      return s.run();
    }),
    tooltip: s.label,
    dispose: () => {
    }
  };
}
const an = Se("commandService"), Bt = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new A(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(s, e) {
    if (!s)
      throw new Error("invalid command");
    if (typeof s == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: s, handler: e });
    }
    if (s.description) {
      const o = [];
      for (const l of s.description.args)
        o.push(l.constraint);
      const a = s.handler;
      s.handler = function(l, ...c) {
        return GI(c, o), a(l, ...c);
      };
    }
    const { id: t } = s;
    let i = this._commands.get(t);
    i || (i = new Ei(), this._commands.set(t, i));
    const n = i.unshift(s), r = ze(() => {
      n();
      const o = this._commands.get(t);
      o != null && o.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), r;
  }
  registerCommandAlias(s, e) {
    return Bt.registerCommand(s, (t, ...i) => t.get(an).executeCommand(e, ...i));
  }
  getCommand(s) {
    const e = this._commands.get(s);
    if (!(!e || e.isEmpty()))
      return ge.first(e);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && s.set(e, t);
    }
    return s;
  }
}();
Bt.registerCommand("noop", () => {
});
const jt = /* @__PURE__ */ new Map();
jt.set("false", !1);
jt.set("true", !0);
jt.set("isMac", Ie);
jt.set("isLinux", _i);
jt.set("isWindows", Vi);
jt.set("isWeb", rc);
jt.set("isMacNative", Ie && !rc);
jt.set("isEdge", MI);
jt.set("isFirefox", NI);
jt.set("isChrome", Mk);
jt.set("isSafari", TI);
const XM = Object.prototype.hasOwnProperty;
class Ut {
  static has(e) {
    return eo.create(e);
  }
  static equals(e, t) {
    return Hl.create(e, t);
  }
  static regex(e, t) {
    return If.create(e, t);
  }
  static not(e) {
    return Xo.create(e);
  }
  static and(...e) {
    return Rr.create(e, null);
  }
  static or(...e) {
    return Zs.create(e, null, !0);
  }
  static deserialize(e, t = !1) {
    if (!!e)
      return this._deserializeOrExpression(e, t);
  }
  static _deserializeOrExpression(e, t) {
    const i = e.split("||");
    return Zs.create(i.map((n) => this._deserializeAndExpression(n, t)), null, !0);
  }
  static _deserializeAndExpression(e, t) {
    const i = e.split("&&");
    return Rr.create(i.map((n) => this._deserializeOne(n, t)), null);
  }
  static _deserializeOne(e, t) {
    if (e = e.trim(), e.indexOf("!=") >= 0) {
      const i = e.split("!=");
      return qg.create(i[0].trim(), this._deserializeValue(i[1], t));
    }
    if (e.indexOf("==") >= 0) {
      const i = e.split("==");
      return Hl.create(i[0].trim(), this._deserializeValue(i[1], t));
    }
    if (e.indexOf("=~") >= 0) {
      const i = e.split("=~");
      return If.create(i[0].trim(), this._deserializeRegexValue(i[1], t));
    }
    if (e.indexOf(" not in ") >= 0) {
      const i = e.split(" not in ");
      return Kg.create(i[0].trim(), i[1].trim());
    }
    if (e.indexOf(" in ") >= 0) {
      const i = e.split(" in ");
      return jg.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+>=[^<=>]+$/.test(e)) {
      const i = e.split(">=");
      return Yg.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+>[^<=>]+$/.test(e)) {
      const i = e.split(">");
      return Zg.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+<=[^<=>]+$/.test(e)) {
      const i = e.split("<=");
      return Xg.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+<[^<=>]+$/.test(e)) {
      const i = e.split("<");
      return Qg.create(i[0].trim(), i[1].trim());
    }
    return /^\!\s*/.test(e) ? Xo.create(e.substr(1).trim()) : eo.create(e);
  }
  static _deserializeValue(e, t) {
    if (e = e.trim(), e === "true")
      return !0;
    if (e === "false")
      return !1;
    const i = /^'([^']*)'$/.exec(e);
    return i ? i[1].trim() : e;
  }
  static _deserializeRegexValue(e, t) {
    if (wT(e)) {
      if (t)
        throw new Error("missing regexp-value for =~-expression");
      return console.warn("missing regexp-value for =~-expression"), null;
    }
    const i = e.indexOf("/"), n = e.lastIndexOf("/");
    if (i === n || i < 0) {
      if (t)
        throw new Error(`bad regexp-value '${e}', missing /-enclosure`);
      return console.warn(`bad regexp-value '${e}', missing /-enclosure`), null;
    }
    const r = e.slice(i + 1, n), o = e[n + 1] === "i" ? "i" : "";
    try {
      return new RegExp(r, o);
    } catch (a) {
      if (t)
        throw new Error(`bad regexp-value '${e}', parse error: ${a}`);
      return console.warn(`bad regexp-value '${e}', parse error: ${a}`), null;
    }
  }
}
function JM(s, e) {
  const t = s ? s.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
  return !t && !i ? !0 : !t || !i ? !1 : t.equals(i);
}
function pl(s, e) {
  return s.cmp(e);
}
class Hi {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return on.INSTANCE;
  }
}
Hi.INSTANCE = new Hi();
class on {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return Hi.INSTANCE;
  }
}
on.INSTANCE = new on();
class eo {
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 2;
  }
  static create(e, t = null) {
    const i = jt.get(e);
    return typeof i == "boolean" ? i ? on.INSTANCE : Hi.INSTANCE : new eo(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : cD(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = jt.get(this.key);
    return typeof e == "boolean" ? e ? on.INSTANCE : Hi.INSTANCE : this;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Xo.create(this.key, this)), this.negated;
  }
}
class Hl {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 4;
  }
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? eo.create(e, i) : Xo.create(e, i);
    const n = jt.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? on.INSTANCE : Hi.INSTANCE : new Hl(e, t, i);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = jt.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? on.INSTANCE : Hi.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = qg.create(this.key, this.value, this)), this.negated;
  }
}
class jg {
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
  }
  static create(e, t) {
    return new jg(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.includes(i) : typeof i == "string" && typeof t == "object" && t !== null ? XM.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return this.negated || (this.negated = Kg.create(this.key, this.valueKey)), this.negated;
  }
}
class Kg {
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 11, this._negated = jg.create(e, t);
  }
  static create(e, t) {
    return new Kg(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
  }
  equals(e) {
    return e.type === this.type ? this._negated.equals(e._negated) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._negated.evaluate(e);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  negate() {
    return this._negated;
  }
}
class qg {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 5;
  }
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Xo.create(e, i) : eo.create(e, i);
    const n = jt.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? Hi.INSTANCE : on.INSTANCE : new qg(e, t, i);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = jt.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? Hi.INSTANCE : on.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Hl.create(this.key, this.value, this)), this.negated;
  }
}
class Xo {
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 3;
  }
  static create(e, t = null) {
    const i = jt.get(e);
    return typeof i == "boolean" ? i ? Hi.INSTANCE : on.INSTANCE : new Xo(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : cD(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = jt.get(this.key);
    return typeof e == "boolean" ? e ? Hi.INSTANCE : on.INSTANCE : this;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = eo.create(this.key, this)), this.negated;
  }
}
function Gg(s, e) {
  if (typeof s == "string") {
    const t = parseFloat(s);
    isNaN(t) || (s = t);
  }
  return typeof s == "string" || typeof s == "number" ? e(s) : Hi.INSTANCE;
}
class Zg {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 12;
  }
  static create(e, t, i = null) {
    return Gg(t, (n) => new Zg(e, n, i));
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Xg.create(this.key, this.value, this)), this.negated;
  }
}
class Yg {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 13;
  }
  static create(e, t, i = null) {
    return Gg(t, (n) => new Yg(e, n, i));
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Qg.create(this.key, this.value, this)), this.negated;
  }
}
class Qg {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 14;
  }
  static create(e, t, i = null) {
    return Gg(t, (n) => new Qg(e, n, i));
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Yg.create(this.key, this.value, this)), this.negated;
  }
}
class Xg {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 15;
  }
  static create(e, t, i = null) {
    return Gg(t, (n) => new Xg(e, n, i));
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : ca(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Zg.create(this.key, this.value, this)), this.negated;
  }
}
class If {
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7, this.negated = null;
  }
  static create(e, t) {
    return new If(e, t);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? "i" : ""}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Gb.create(this)), this.negated;
  }
}
class Gb {
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  static create(e) {
    return new Gb(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
function lD(s) {
  let e = null;
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t].substituteConstants();
    if (s[t] !== n && e === null) {
      e = [];
      for (let r = 0; r < t; r++)
        e[r] = s[r];
    }
    e !== null && (e[t] = n);
  }
  return e === null ? s : e;
}
class Rr {
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 6;
  }
  static create(e, t) {
    return Rr._normalizeArr(e, t);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = pl(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = lD(this.expr);
    return e === this.expr ? this : Rr.create(e, this.negated);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e, t) {
    const i = [];
    let n = !1;
    for (const r of e)
      if (!!r) {
        if (r.type === 1) {
          n = !0;
          continue;
        }
        if (r.type === 0)
          return Hi.INSTANCE;
        if (r.type === 6) {
          i.push(...r.expr);
          continue;
        }
        i.push(r);
      }
    if (i.length === 0 && n)
      return on.INSTANCE;
    if (i.length !== 0) {
      if (i.length === 1)
        return i[0];
      i.sort(pl);
      for (let r = 1; r < i.length; r++)
        i[r - 1].equals(i[r]) && (i.splice(r, 1), r--);
      if (i.length === 1)
        return i[0];
      for (; i.length > 1; ) {
        const r = i[i.length - 1];
        if (r.type !== 9)
          break;
        i.pop();
        const o = i.pop(), a = i.length === 0, l = Zs.create(r.expr.map((c) => Rr.create([c, o], null)), null, a);
        l && (i.push(l), i.sort(pl));
      }
      return i.length === 1 ? i[0] : new Rr(i, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      this.negated = Zs.create(e, this, !0);
    }
    return this.negated;
  }
}
class Zs {
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 9;
  }
  static create(e, t, i) {
    return Zs._normalizeArr(e, t, i);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = pl(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = lD(this.expr);
    return e === this.expr ? this : Zs.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e, t, i) {
    let n = [], r = !1;
    if (e) {
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        if (!!l) {
          if (l.type === 0) {
            r = !0;
            continue;
          }
          if (l.type === 1)
            return on.INSTANCE;
          if (l.type === 9) {
            n = n.concat(l.expr);
            continue;
          }
          n.push(l);
        }
      }
      if (n.length === 0 && r)
        return Hi.INSTANCE;
      n.sort(pl);
    }
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      for (let o = 1; o < n.length; o++)
        n[o - 1].equals(n[o]) && (n.splice(o, 1), o--);
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let o = 0; o < n.length; o++)
          for (let a = o + 1; a < n.length; a++)
            hD(n[o], n[a]) && (n.splice(a, 1), a--);
        if (n.length === 1)
          return n[0];
      }
      return new Zs(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      for (; e.length > 1; ) {
        const t = e.shift(), i = e.shift(), n = [];
        for (const o of Nf(t))
          for (const a of Nf(i))
            n.push(Rr.create([o, a], null));
        const r = e.length === 0;
        e.unshift(Zs.create(n, null, r));
      }
      this.negated = e[0];
    }
    return this.negated;
  }
}
class ie extends eo {
  constructor(e, t, i) {
    super(e, null), this._defaultValue = t, typeof i == "object" ? ie._info.push(Object.assign(Object.assign({}, i), { key: e })) : i !== !0 && ie._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  static all() {
    return ie._info.values();
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(e) {
    return Hl.create(this.key, e);
  }
}
ie._info = [];
const Qe = Se("contextKeyService"), eA = "setContext";
function cD(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function ca(s, e, t, i) {
  return s < t ? -1 : s > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
function hD(s, e) {
  if (e.type === 6 && s.type !== 9 && s.type !== 6) {
    for (const n of e.expr)
      if (s.equals(n))
        return !0;
  }
  const t = s.negate(), i = Nf(t).concat(Nf(e));
  i.sort(pl);
  for (let n = 0; n < i.length; n++) {
    const o = i[n].negate();
    for (let a = n + 1; a < i.length; a++) {
      const l = i[a];
      if (o.equals(l))
        return !0;
    }
  }
  return !1;
}
function Nf(s) {
  return s.type === 9 ? s.expr : [s];
}
var Qi;
(function(s) {
  s.DARK = "dark", s.LIGHT = "light", s.HIGH_CONTRAST_DARK = "hcDark", s.HIGH_CONTRAST_LIGHT = "hcLight";
})(Qi || (Qi = {}));
function cs(s) {
  return s === Qi.HIGH_CONTRAST_DARK || s === Qi.HIGH_CONTRAST_LIGHT;
}
function tA(s) {
  return s === Qi.DARK || s === Qi.HIGH_CONTRAST_DARK;
}
const vt = Se("themeService");
var I1;
(function(s) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  s.isThemeColor = e;
})(I1 || (I1 = {}));
function Va(s) {
  return { id: s };
}
var ri;
(function(s) {
  function e(c) {
    return c && typeof c == "object" && typeof c.id == "string" && (typeof c.color > "u" || I1.isThemeColor(c.color));
  }
  s.isThemeIcon = e;
  const t = new RegExp(`^\\$\\((${Di.iconNameExpression}(?:${Di.iconModifierExpression})?)\\)$`);
  function i(c) {
    const h = t.exec(c);
    if (!h)
      return;
    const [, u] = h;
    return { id: u };
  }
  s.fromString = i;
  function n(c) {
    return { id: c };
  }
  s.fromId = n;
  function r(c, h) {
    let u = c.id;
    const d = u.lastIndexOf("~");
    return d !== -1 && (u = u.substring(0, d)), h && (u = `${u}~${h}`), { id: u };
  }
  s.modify = r;
  function o(c) {
    const h = c.id.lastIndexOf("~");
    if (h !== -1)
      return c.id.substring(h + 1);
  }
  s.getModifier = o;
  function a(c, h) {
    var u, d;
    return c.id === h.id && ((u = c.color) === null || u === void 0 ? void 0 : u.id) === ((d = h.color) === null || d === void 0 ? void 0 : d.id);
  }
  s.isEqual = a;
  function l(c, h) {
    return { id: c.id, color: h ? Va(h) : void 0 };
  }
  s.asThemeIcon = l, s.asClassNameArray = Di.asClassNameArray, s.asClassName = Di.asClassName, s.asCSSSelector = Di.asCSSSelector;
})(ri || (ri = {}));
function Tf(s) {
  switch (s) {
    case Qi.DARK:
      return "vs-dark";
    case Qi.HIGH_CONTRAST_DARK:
      return "hc-black";
    case Qi.HIGH_CONTRAST_LIGHT:
      return "hc-light";
    default:
      return "vs";
  }
}
const uD = {
  ThemingContribution: "base.contributions.theming"
};
class iA {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new A();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), ze(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
const dD = new iA();
Ft.add(uD.ThemingContribution, dD);
function zi(s) {
  return dD.onColorThemeChange(s);
}
class nA extends z {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
var sA = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, $w = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function jc(s) {
  return s.command !== void 0;
}
class I {
  constructor(e) {
    if (I._instances.has(e))
      throw new TypeError(`MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`);
    I._instances.set(e, this), this.id = e;
  }
}
I._instances = /* @__PURE__ */ new Map();
I.CommandPalette = new I("CommandPalette");
I.DebugBreakpointsContext = new I("DebugBreakpointsContext");
I.DebugCallStackContext = new I("DebugCallStackContext");
I.DebugConsoleContext = new I("DebugConsoleContext");
I.DebugVariablesContext = new I("DebugVariablesContext");
I.DebugWatchContext = new I("DebugWatchContext");
I.DebugToolBar = new I("DebugToolBar");
I.DebugToolBarStop = new I("DebugToolBarStop");
I.EditorContext = new I("EditorContext");
I.SimpleEditorContext = new I("SimpleEditorContext");
I.EditorContextCopy = new I("EditorContextCopy");
I.EditorContextPeek = new I("EditorContextPeek");
I.EditorContextShare = new I("EditorContextShare");
I.EditorTitle = new I("EditorTitle");
I.EditorTitleRun = new I("EditorTitleRun");
I.EditorTitleContext = new I("EditorTitleContext");
I.EmptyEditorGroup = new I("EmptyEditorGroup");
I.EmptyEditorGroupContext = new I("EmptyEditorGroupContext");
I.ExplorerContext = new I("ExplorerContext");
I.ExtensionContext = new I("ExtensionContext");
I.GlobalActivity = new I("GlobalActivity");
I.CommandCenter = new I("CommandCenter");
I.LayoutControlMenuSubmenu = new I("LayoutControlMenuSubmenu");
I.LayoutControlMenu = new I("LayoutControlMenu");
I.MenubarMainMenu = new I("MenubarMainMenu");
I.MenubarAppearanceMenu = new I("MenubarAppearanceMenu");
I.MenubarDebugMenu = new I("MenubarDebugMenu");
I.MenubarEditMenu = new I("MenubarEditMenu");
I.MenubarCopy = new I("MenubarCopy");
I.MenubarFileMenu = new I("MenubarFileMenu");
I.MenubarGoMenu = new I("MenubarGoMenu");
I.MenubarHelpMenu = new I("MenubarHelpMenu");
I.MenubarLayoutMenu = new I("MenubarLayoutMenu");
I.MenubarNewBreakpointMenu = new I("MenubarNewBreakpointMenu");
I.MenubarPanelAlignmentMenu = new I("MenubarPanelAlignmentMenu");
I.MenubarPanelPositionMenu = new I("MenubarPanelPositionMenu");
I.MenubarPreferencesMenu = new I("MenubarPreferencesMenu");
I.MenubarRecentMenu = new I("MenubarRecentMenu");
I.MenubarSelectionMenu = new I("MenubarSelectionMenu");
I.MenubarShare = new I("MenubarShare");
I.MenubarSwitchEditorMenu = new I("MenubarSwitchEditorMenu");
I.MenubarSwitchGroupMenu = new I("MenubarSwitchGroupMenu");
I.MenubarTerminalMenu = new I("MenubarTerminalMenu");
I.MenubarViewMenu = new I("MenubarViewMenu");
I.MenubarHomeMenu = new I("MenubarHomeMenu");
I.OpenEditorsContext = new I("OpenEditorsContext");
I.ProblemsPanelContext = new I("ProblemsPanelContext");
I.SCMChangeContext = new I("SCMChangeContext");
I.SCMResourceContext = new I("SCMResourceContext");
I.SCMResourceFolderContext = new I("SCMResourceFolderContext");
I.SCMResourceGroupContext = new I("SCMResourceGroupContext");
I.SCMSourceControl = new I("SCMSourceControl");
I.SCMTitle = new I("SCMTitle");
I.SearchContext = new I("SearchContext");
I.StatusBarWindowIndicatorMenu = new I("StatusBarWindowIndicatorMenu");
I.StatusBarRemoteIndicatorMenu = new I("StatusBarRemoteIndicatorMenu");
I.TestItem = new I("TestItem");
I.TestItemGutter = new I("TestItemGutter");
I.TestPeekElement = new I("TestPeekElement");
I.TestPeekTitle = new I("TestPeekTitle");
I.TouchBarContext = new I("TouchBarContext");
I.TitleBarContext = new I("TitleBarContext");
I.TitleBarTitleContext = new I("TitleBarTitleContext");
I.TunnelContext = new I("TunnelContext");
I.TunnelPrivacy = new I("TunnelPrivacy");
I.TunnelProtocol = new I("TunnelProtocol");
I.TunnelPortInline = new I("TunnelInline");
I.TunnelTitle = new I("TunnelTitle");
I.TunnelLocalAddressInline = new I("TunnelLocalAddressInline");
I.TunnelOriginInline = new I("TunnelOriginInline");
I.ViewItemContext = new I("ViewItemContext");
I.ViewContainerTitle = new I("ViewContainerTitle");
I.ViewContainerTitleContext = new I("ViewContainerTitleContext");
I.ViewTitle = new I("ViewTitle");
I.ViewTitleContext = new I("ViewTitleContext");
I.CommentThreadTitle = new I("CommentThreadTitle");
I.CommentThreadActions = new I("CommentThreadActions");
I.CommentTitle = new I("CommentTitle");
I.CommentActions = new I("CommentActions");
I.InteractiveToolbar = new I("InteractiveToolbar");
I.InteractiveCellTitle = new I("InteractiveCellTitle");
I.InteractiveCellDelete = new I("InteractiveCellDelete");
I.InteractiveCellExecute = new I("InteractiveCellExecute");
I.InteractiveInputExecute = new I("InteractiveInputExecute");
I.NotebookToolbar = new I("NotebookToolbar");
I.NotebookCellTitle = new I("NotebookCellTitle");
I.NotebookCellDelete = new I("NotebookCellDelete");
I.NotebookCellInsert = new I("NotebookCellInsert");
I.NotebookCellBetween = new I("NotebookCellBetween");
I.NotebookCellListTop = new I("NotebookCellTop");
I.NotebookCellExecute = new I("NotebookCellExecute");
I.NotebookCellExecutePrimary = new I("NotebookCellExecutePrimary");
I.NotebookDiffCellInputTitle = new I("NotebookDiffCellInputTitle");
I.NotebookDiffCellMetadataTitle = new I("NotebookDiffCellMetadataTitle");
I.NotebookDiffCellOutputsTitle = new I("NotebookDiffCellOutputsTitle");
I.NotebookOutputToolbar = new I("NotebookOutputToolbar");
I.NotebookEditorLayoutConfigure = new I("NotebookEditorLayoutConfigure");
I.NotebookKernelSource = new I("NotebookKernelSource");
I.BulkEditTitle = new I("BulkEditTitle");
I.BulkEditContext = new I("BulkEditContext");
I.TimelineItemContext = new I("TimelineItemContext");
I.TimelineTitle = new I("TimelineTitle");
I.TimelineTitleContext = new I("TimelineTitleContext");
I.TimelineFilterSubMenu = new I("TimelineFilterSubMenu");
I.AccountsContext = new I("AccountsContext");
I.PanelTitle = new I("PanelTitle");
I.AuxiliaryBarTitle = new I("AuxiliaryBarTitle");
I.TerminalInstanceContext = new I("TerminalInstanceContext");
I.TerminalEditorInstanceContext = new I("TerminalEditorInstanceContext");
I.TerminalNewDropdownContext = new I("TerminalNewDropdownContext");
I.TerminalTabContext = new I("TerminalTabContext");
I.TerminalTabEmptyAreaContext = new I("TerminalTabEmptyAreaContext");
I.TerminalInlineTabContext = new I("TerminalInlineTabContext");
I.WebviewContext = new I("WebviewContext");
I.InlineCompletionsActions = new I("InlineCompletionsActions");
I.NewFile = new I("NewFile");
I.MergeToolbar = new I("MergeToolbar");
I.MergeInput1Toolbar = new I("MergeToolbar1Toolbar");
I.MergeInput2Toolbar = new I("MergeToolbar2Toolbar");
const fD = Se("menuService"), _l = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new A(), this.onDidChangeMenu = this._onDidChangeMenu.event, this._commandPaletteChangeEvent = {
      has: (s) => s === I.CommandPalette
    };
  }
  addCommand(s) {
    return this.addCommands(ge.single(s));
  }
  addCommands(s) {
    for (const e of s)
      this._commands.set(e.id, e);
    return this._onDidChangeMenu.fire(this._commandPaletteChangeEvent), ze(() => {
      let e = !1;
      for (const t of s)
        e = this._commands.delete(t.id) || e;
      e && this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
    });
  }
  getCommand(s) {
    return this._commands.get(s);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => s.set(t, e)), s;
  }
  appendMenuItem(s, e) {
    return this.appendMenuItems(ge.single({ id: s, item: e }));
  }
  appendMenuItems(s) {
    const e = /* @__PURE__ */ new Set(), t = new Ei();
    for (const { id: i, item: n } of s) {
      let r = this._menuItems.get(i);
      r || (r = new Ei(), this._menuItems.set(i, r)), t.push(r.push(n)), e.add(i);
    }
    return this._onDidChangeMenu.fire(e), ze(() => {
      if (t.size > 0) {
        for (const i of t)
          i();
        this._onDidChangeMenu.fire(e), t.clear();
      }
    });
  }
  getMenuItems(s) {
    let e;
    return this._menuItems.has(s) ? e = [...this._menuItems.get(s)] : e = [], s === I.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(s) {
    const e = /* @__PURE__ */ new Set();
    for (const t of s)
      jc(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || s.push({ command: t });
    });
  }
}();
class rA extends aD {
  constructor(e, t, i, n) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, [], "submenu"), this.item = e, this._menuService = t, this._contextKeyService = i, this._options = n;
  }
  get actions() {
    const e = [], t = this._menuService.createMenu(this.item.submenu, this._contextKeyService), i = t.getActions(this._options);
    t.dispose();
    for (const [, n] of i)
      n.length > 0 && (e.push(...n), e.push(new ls()));
    return e.length && e.pop(), e;
  }
}
let N1 = class gD {
  constructor(e, t, i, n, r, o) {
    var a, l;
    if (this.hideActions = n, this._commandService = o, this.id = e.id, this.label = (i == null ? void 0 : i.renderShortTitle) && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value, this.tooltip = (l = typeof e.tooltip == "string" ? e.tooltip : (a = e.tooltip) === null || a === void 0 ? void 0 : a.value) !== null && l !== void 0 ? l : "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = void 0, e.toggled) {
      const c = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = r.contextMatchesRules(c.condition), this.checked && c.tooltip && (this.tooltip = typeof c.tooltip == "string" ? c.tooltip : c.tooltip.value), c.title && (this.label = typeof c.title == "string" ? c.title : c.title.value);
    }
    this.item = e, this.alt = t ? new gD(t, void 0, i, n, r, o) : void 0, this._options = i, ri.isThemeIcon(e.icon) && (this.class = Di.asClassName(e.icon));
  }
  dispose() {
  }
  run(...e) {
    var t, i;
    let n = [];
    return !((t = this._options) === null || t === void 0) && t.arg && (n = [...n, this._options.arg]), !((i = this._options) === null || i === void 0) && i.shouldForwardArgs && (n = [...n, ...e]), this._commandService.executeCommand(this.id, ...n);
  }
};
N1 = sA([
  $w(4, Qe),
  $w(5, an)
], N1);
class Mf {
  constructor() {
    this._coreKeybindings = [], this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  static bindToCurrentPlatform(e) {
    if (dn === 1) {
      if (e && e.win)
        return e.win;
    } else if (dn === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = Mf.bindToCurrentPlatform(e);
    if (t && t.primary) {
      const i = w1(t.primary, dn);
      i && this._registerDefaultKeybinding(i, e.id, e.args, e.weight, 0, e.when);
    }
    if (t && Array.isArray(t.secondary))
      for (let i = 0, n = t.secondary.length; i < n; i++) {
        const r = t.secondary[i], o = w1(r, dn);
        o && this._registerDefaultKeybinding(o, e.id, e.args, e.weight, -i - 1, e.when);
      }
  }
  registerCommandAndKeybindingRule(e) {
    this.registerKeybindingRule(e), Bt.registerCommand(e);
  }
  static _mightProduceChar(e) {
    return e >= 21 && e <= 30 || e >= 31 && e <= 56 ? !0 : e === 80 || e === 81 || e === 82 || e === 83 || e === 84 || e === 85 || e === 86 || e === 110 || e === 111 || e === 87 || e === 88 || e === 89 || e === 90 || e === 91 || e === 92;
  }
  _assertNoCtrlAlt(e, t) {
    e.ctrlKey && e.altKey && !e.metaKey && Mf._mightProduceChar(e.keyCode) && console.warn("Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", e, " for ", t);
  }
  _registerDefaultKeybinding(e, t, i, n, r, o) {
    dn === 1 && this._assertNoCtrlAlt(e.parts[0], t), this._coreKeybindings.push({
      keybinding: e.parts,
      command: t,
      commandArgs: i,
      when: o,
      weight1: n,
      weight2: r,
      extensionId: null,
      isBuiltinExtension: !1
    }), this._cachedMergedKeybindings = null;
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(aA)), this._cachedMergedKeybindings.slice(0);
  }
}
const Jg = new Mf(), oA = {
  EditorModes: "platform.keybindingsRegistry"
};
Ft.add(oA.EditorModes, Jg);
function aA(s, e) {
  if (s.weight1 !== e.weight1)
    return s.weight1 - e.weight1;
  if (s.command && e.command) {
    if (s.command < e.command)
      return -1;
    if (s.command > e.command)
      return 1;
  }
  return s.weight2 - e.weight2;
}
const Mu = Se("telemetryService");
class em {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this._description = e.description;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = Ut.and(i, this.precondition) : i = this.precondition);
        const n = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        Jg.registerKeybindingRule(n);
      }
    }
    Bt.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      description: this._description
    });
  }
  _registerMenuItem(e) {
    _l.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
}
class Zb extends em {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  addImplementation(e, t, i) {
    return this._implementations.push({ priority: e, name: t, implementation: i }), this._implementations.sort((n, r) => r.priority - n.priority), {
      dispose: () => {
        for (let n = 0; n < this._implementations.length; n++)
          if (this._implementations[n].implementation === i) {
            this._implementations.splice(n, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(ao);
    i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
    for (const n of this._implementations) {
      const r = n.implementation(e, t);
      if (r)
        return i.trace(`Command '${this.id}' was handled by '${n.name}'.`), typeof r == "boolean" ? void 0 : r;
    }
    i.trace(`The Command '${this.id}' was not handled by any implementation.`);
  }
}
class mD extends em {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class to extends em {
  static bindToContribution(e) {
    return class extends to {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, n, r) {
        const o = e(n);
        o && this._callback(o, r);
      }
    };
  }
  static runEditorCommand(e, t, i, n) {
    const r = e.get(Ct), o = r.getFocusedCodeEditor() || r.getActiveCodeEditor();
    if (!!o)
      return o.invokeWithinContext((a) => {
        if (!!a.get(Qe).contextMatchesRules(Er(i)))
          return n(a, o, t);
      });
  }
  runCommand(e, t) {
    return to.runEditorCommand(e, t, this.precondition, (i, n, r) => this.runEditorCommand(i, n, r));
  }
}
class tm extends to {
  constructor(e) {
    super(tm.convertOptions(e)), this.label = e.label, this.alias = e.alias;
  }
  static convertOptions(e) {
    let t;
    Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
    function i(n) {
      return n.menuId || (n.menuId = I.EditorContext), n.title || (n.title = e.label), n.when = Ut.and(e.precondition, n.when), n;
    }
    return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
  }
  runEditorCommand(e, t, i) {
    return this.reportTelemetry(e, t), this.run(e, t, i || {});
  }
  reportTelemetry(e, t) {
    e.get(Mu).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
}
function se(s) {
  return In.INSTANCE.registerEditorCommand(s), s;
}
function pD(s) {
  const e = new s();
  return In.INSTANCE.registerEditorAction(e), e;
}
function _D(s, e) {
  In.INSTANCE.registerEditorContribution(s, e);
}
var bl;
(function(s) {
  function e(o) {
    return In.INSTANCE.getEditorCommand(o);
  }
  s.getEditorCommand = e;
  function t() {
    return In.INSTANCE.getEditorActions();
  }
  s.getEditorActions = t;
  function i() {
    return In.INSTANCE.getEditorContributions();
  }
  s.getEditorContributions = i;
  function n(o) {
    return In.INSTANCE.getEditorContributions().filter((a) => o.indexOf(a.id) >= 0);
  }
  s.getSomeEditorContributions = n;
  function r() {
    return In.INSTANCE.getDiffEditorContributions();
  }
  s.getDiffEditorContributions = r;
})(bl || (bl = {}));
const lA = {
  EditorCommonContributions: "editor.contributions"
};
class In {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t) {
    this.editorContributions.push({ id: e, ctor: t });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions.slice(0);
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
}
In.INSTANCE = new In();
Ft.add(lA.EditorCommonContributions, In.INSTANCE);
function Au(s) {
  return s.register(), s;
}
const bD = Au(new Zb({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
  },
  menuOpts: [{
    menuId: I.MenubarEditMenu,
    group: "1_do",
    title: p({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: I.CommandPalette,
    group: "",
    title: p("undo", "Undo"),
    order: 1
  }]
}));
Au(new mD(bD, { id: "default:undo", precondition: void 0 }));
const CD = Au(new Zb({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [3128],
    mac: { primary: 3128 }
  },
  menuOpts: [{
    menuId: I.MenubarEditMenu,
    group: "1_do",
    title: p({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: I.CommandPalette,
    group: "",
    title: p("redo", "Redo"),
    order: 1
  }]
}));
Au(new mD(CD, { id: "default:redo", precondition: void 0 }));
const cA = Au(new Zb({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
  },
  menuOpts: [{
    menuId: I.MenubarSelectionMenu,
    group: "1_basic",
    title: p({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: I.CommandPalette,
    group: "",
    title: p("selectAll", "Select All"),
    order: 1
  }]
}));
var hA = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, uA = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let $h = class {
  constructor(e, t) {
  }
  dispose() {
  }
};
$h.ID = "editor.contrib.markerDecorations";
$h = hA([
  uA(1, oD)
], $h);
_D($h.ID, $h);
class vD extends z {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  startObserving() {
    !this._resizeObserver && this._referenceDomElement && (this._resizeObserver = new ResizeObserver((e) => {
      e && e[0] && e[0].contentRect ? this.observe({ width: e[0].contentRect.width, height: e[0].contentRect.height }) : this.observe();
    }), this._resizeObserver.observe(this._referenceDomElement));
  }
  stopObserving() {
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, n = 0;
    t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
  }
}
class Gr {
  constructor(e, t) {
    this.key = e, this.migrate = t;
  }
  apply(e) {
    const t = Gr._read(e, this.key), i = (r) => Gr._read(e, r), n = (r, o) => Gr._write(e, r, o);
    this.migrate(t, i, n);
  }
  static _read(e, t) {
    if (typeof e > "u")
      return;
    const i = t.indexOf(".");
    if (i >= 0) {
      const n = t.substring(0, i);
      return this._read(e[n], t.substring(i + 1));
    }
    return e[t];
  }
  static _write(e, t, i) {
    const n = t.indexOf(".");
    if (n >= 0) {
      const r = t.substring(0, n);
      e[r] = e[r] || {}, this._write(e[r], t.substring(n + 1), i);
      return;
    }
    e[t] = i;
  }
}
Gr.items = [];
function fc(s, e) {
  Gr.items.push(new Gr(s, e));
}
function zn(s, e) {
  fc(s, (t, i, n) => {
    if (typeof t < "u") {
      for (const [r, o] of e)
        if (t === r) {
          n(s, o);
          return;
        }
    }
  });
}
function dA(s) {
  Gr.items.forEach((e) => e.apply(s));
}
zn("wordWrap", [[!0, "on"], [!1, "off"]]);
zn("lineNumbers", [[!0, "on"], [!1, "off"]]);
zn("cursorBlinking", [["visible", "solid"]]);
zn("renderWhitespace", [[!0, "boundary"], [!1, "none"]]);
zn("renderLineHighlight", [[!0, "line"], [!1, "none"]]);
zn("acceptSuggestionOnEnter", [[!0, "on"], [!1, "off"]]);
zn("tabCompletion", [[!1, "off"], [!0, "onlySnippets"]]);
zn("hover", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
zn("parameterHints", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
zn("autoIndent", [[!1, "advanced"], [!0, "full"]]);
zn("matchBrackets", [[!0, "always"], [!1, "never"]]);
fc("autoClosingBrackets", (s, e, t) => {
  s === !1 && (t("autoClosingBrackets", "never"), typeof e("autoClosingQuotes") > "u" && t("autoClosingQuotes", "never"), typeof e("autoSurround") > "u" && t("autoSurround", "never"));
});
fc("renderIndentGuides", (s, e, t) => {
  typeof s < "u" && (t("renderIndentGuides", void 0), typeof e("guides.indentation") > "u" && t("guides.indentation", !!s));
});
fc("highlightActiveIndentGuide", (s, e, t) => {
  typeof s < "u" && (t("highlightActiveIndentGuide", void 0), typeof e("guides.highlightActiveIndentation") > "u" && t("guides.highlightActiveIndentation", !!s));
});
const fA = {
  method: "showMethods",
  function: "showFunctions",
  constructor: "showConstructors",
  deprecated: "showDeprecated",
  field: "showFields",
  variable: "showVariables",
  class: "showClasses",
  struct: "showStructs",
  interface: "showInterfaces",
  module: "showModules",
  property: "showProperties",
  event: "showEvents",
  operator: "showOperators",
  unit: "showUnits",
  value: "showValues",
  constant: "showConstants",
  enum: "showEnums",
  enumMember: "showEnumMembers",
  keyword: "showKeywords",
  text: "showWords",
  color: "showColors",
  file: "showFiles",
  reference: "showReferences",
  folder: "showFolders",
  typeParameter: "showTypeParameters",
  snippet: "showSnippets"
};
fc("suggest.filteredTypes", (s, e, t) => {
  if (s && typeof s == "object") {
    for (const i of Object.entries(fA))
      s[i[0]] === !1 && typeof e(`suggest.${i[1]}`) > "u" && t(`suggest.${i[1]}`, !1);
    t("suggest.filteredTypes", void 0);
  }
});
fc("quickSuggestions", (s, e, t) => {
  if (typeof s == "boolean") {
    const i = s ? "on" : "off";
    t("quickSuggestions", { comments: i, strings: i, other: i });
  }
});
class gA {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new A(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(e) {
    this._tabFocus !== e && (this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus));
  }
}
const jw = new gA(), ha = Se("accessibilityService"), mA = new ie("accessibilityModeEnabled", !1);
var pA = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, _A = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let T1 = class extends z {
  constructor(e, t, i, n) {
    super(), this._accessibilityService = n, this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new A()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = !1, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._computeOptionsMemory = new zk(), this.isSimpleWidget = e, this._containerObserver = this._register(new vD(i, t.dimension)), this._rawOptions = Kw(t), this._validatedOptions = Nr.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(10) && this._containerObserver.startObserving(), this._register(pf.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(jw.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(a1.onDidChange(() => this._recomputeOptions())), this._register(Mh.onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
  }
  _recomputeOptions() {
    const e = this._computeOptions(), t = Nr.checkEquals(this.options, e);
    t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
  }
  _computeOptions() {
    const e = this._readEnvConfiguration(), t = $o.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight - this._reservedHeight,
      fontInfo: i,
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: jw.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport
    };
    return Nr.computeOptions(this._validatedOptions, n);
  }
  _readEnvConfiguration() {
    return {
      extraEditorClassName: CA(),
      outerWidth: this._containerObserver.getWidth(),
      outerHeight: this._containerObserver.getHeight(),
      emptySelectionClipboard: jr || sn,
      pixelRatio: Mh.value,
      accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
    };
  }
  _readFontInfo(e) {
    return a1.readFontInfo(e);
  }
  getRawOptions() {
    return this._rawOptions;
  }
  updateOptions(e) {
    const t = Kw(e);
    !Nr.applyUpdate(this._rawOptions, t) || (this._validatedOptions = Nr.validateOptions(this._rawOptions), this._recomputeOptions());
  }
  observeContainer(e) {
    this._containerObserver.observe(e);
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
  }
  setModelLineCount(e) {
    const t = bA(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  setReservedHeight(e) {
    this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
  }
};
T1 = pA([
  _A(3, ha)
], T1);
function bA(s) {
  let e = 0;
  for (; s; )
    s = Math.floor(s / 10), e++;
  return e || 1;
}
function CA() {
  let s = "";
  return !rr && !Mb && (s += "no-user-select "), rr && (s += "no-minimap-shadow ", s += "enable-user-select "), Ie && (s += "mac "), s;
}
class vA {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class wA {
  constructor() {
    this._values = [];
  }
  _read(e) {
    if (e >= this._values.length)
      throw new Error("Cannot read uninitialized value");
    return this._values[e];
  }
  get(e) {
    return this._read(e);
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class Nr {
  static validateOptions(e) {
    const t = new vA();
    for (const i of $a) {
      const n = i.name === "_never_" ? void 0 : e[i.name];
      t._write(i.id, i.validate(n));
    }
    return t;
  }
  static computeOptions(e, t) {
    const i = new wA();
    for (const n of $a)
      i._write(n.id, n.compute(t, i, e._read(n.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object" || !e || !t)
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? rs(e, t) : !1;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const i in e)
      if (!Nr._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let n = !1;
    for (const r of $a) {
      const o = !Nr._deepEquals(e._read(r.id), t._read(r.id));
      i[r.id] = o, o && (n = !0);
    }
    return n ? new Hk(i) : null;
  }
  static applyUpdate(e, t) {
    let i = !1;
    for (const n of $a)
      if (t.hasOwnProperty(n.name)) {
        const r = n.applyUpdate(e[n.name], t[n.name]);
        e[n.name] = r.newValue, i = i || r.didChange;
      }
    return i;
  }
}
function Kw(s) {
  const e = Sr(s);
  return dA(e), e;
}
function dt(s, e, t) {
  let i = null, n = null;
  if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n)
    throw new Error("not supported");
  const r = `$memoize$${e}`;
  t[i] = function(...o) {
    return this.hasOwnProperty(r) || Object.defineProperty(this, r, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: n.apply(this, o)
    }), this[r];
  };
}
var SA = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, We;
(function(s) {
  s.Tap = "-monaco-gesturetap", s.Change = "-monaco-gesturechange", s.Start = "-monaco-gesturestart", s.End = "-monaco-gesturesend", s.Contextmenu = "-monaco-gesturecontextmenu";
})(We || (We = {}));
class Ne extends z {
  constructor() {
    super(), this.dispatched = !1, this.activeTouches = {}, this.handle = null, this.targets = [], this.ignoreTargets = [], this._lastSetTapCountTime = 0, this._register(H(document, "touchstart", (e) => this.onTouchStart(e), { passive: !1 })), this._register(H(document, "touchend", (e) => this.onTouchEnd(e))), this._register(H(document, "touchmove", (e) => this.onTouchMove(e), { passive: !1 }));
  }
  static addTarget(e) {
    return Ne.isTouchDevice() ? (Ne.INSTANCE || (Ne.INSTANCE = new Ne()), Ne.INSTANCE.targets.push(e), {
      dispose: () => {
        Ne.INSTANCE.targets = Ne.INSTANCE.targets.filter((t) => t !== e);
      }
    }) : z.None;
  }
  static ignoreTarget(e) {
    return Ne.isTouchDevice() ? (Ne.INSTANCE || (Ne.INSTANCE = new Ne()), Ne.INSTANCE.ignoreTargets.push(e), {
      dispose: () => {
        Ne.INSTANCE.ignoreTargets = Ne.INSTANCE.ignoreTargets.filter((t) => t !== e);
      }
    }) : z.None;
  }
  static isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    const t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, n = e.targetTouches.length; i < n; i++) {
      const r = e.targetTouches.item(i);
      this.activeTouches[r.identifier] = {
        id: r.identifier,
        initialTarget: r.target,
        initialTimeStamp: t,
        initialPageX: r.pageX,
        initialPageY: r.pageY,
        rollingTimestamps: [t],
        rollingPageX: [r.pageX],
        rollingPageY: [r.pageY]
      };
      const o = this.newGestureEvent(We.Start, r.target);
      o.pageX = r.pageX, o.pageY = r.pageY, this.dispatchEvent(o);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e) {
    const t = Date.now(), i = Object.keys(this.activeTouches).length;
    for (let n = 0, r = e.changedTouches.length; n < r; n++) {
      const o = e.changedTouches.item(n);
      if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
        console.warn("move of an UNKNOWN touch", o);
        continue;
      }
      const a = this.activeTouches[o.identifier], l = Date.now() - a.initialTimeStamp;
      if (l < Ne.HOLD_DELAY && Math.abs(a.initialPageX - $i(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - $i(a.rollingPageY)) < 30) {
        const c = this.newGestureEvent(We.Tap, a.initialTarget);
        c.pageX = $i(a.rollingPageX), c.pageY = $i(a.rollingPageY), this.dispatchEvent(c);
      } else if (l >= Ne.HOLD_DELAY && Math.abs(a.initialPageX - $i(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - $i(a.rollingPageY)) < 30) {
        const c = this.newGestureEvent(We.Contextmenu, a.initialTarget);
        c.pageX = $i(a.rollingPageX), c.pageY = $i(a.rollingPageY), this.dispatchEvent(c);
      } else if (i === 1) {
        const c = $i(a.rollingPageX), h = $i(a.rollingPageY), u = $i(a.rollingTimestamps) - a.rollingTimestamps[0], d = c - a.rollingPageX[0], f = h - a.rollingPageY[0], m = this.targets.filter((_) => a.initialTarget instanceof Node && _.contains(a.initialTarget));
        this.inertia(
          m,
          t,
          Math.abs(d) / u,
          d > 0 ? 1 : -1,
          c,
          Math.abs(f) / u,
          f > 0 ? 1 : -1,
          h
        );
      }
      this.dispatchEvent(this.newGestureEvent(We.End, a.initialTarget)), delete this.activeTouches[o.identifier];
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    const i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === We.Tap) {
      const t = new Date().getTime();
      let i = 0;
      t - this._lastSetTapCountTime > Ne.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else
      (e.type === We.Change || e.type === We.Contextmenu) && (this._lastSetTapCountTime = 0);
    for (let t = 0; t < this.ignoreTargets.length; t++)
      if (e.initialTarget instanceof Node && this.ignoreTargets[t].contains(e.initialTarget))
        return;
    this.targets.forEach((t) => {
      e.initialTarget instanceof Node && t.contains(e.initialTarget) && (t.dispatchEvent(e), this.dispatched = !0);
    });
  }
  inertia(e, t, i, n, r, o, a, l) {
    this.handle = Bn(() => {
      const c = Date.now(), h = c - t;
      let u = 0, d = 0, f = !0;
      i += Ne.SCROLL_FRICTION * h, o += Ne.SCROLL_FRICTION * h, i > 0 && (f = !1, u = n * i * h), o > 0 && (f = !1, d = a * o * h);
      const m = this.newGestureEvent(We.Change);
      m.translationX = u, m.translationY = d, e.forEach((_) => _.dispatchEvent(m)), f || this.inertia(e, c, i, n, r + u, o, a, l + d);
    });
  }
  onTouchMove(e) {
    const t = Date.now();
    for (let i = 0, n = e.changedTouches.length; i < n; i++) {
      const r = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(r.identifier))) {
        console.warn("end of an UNKNOWN touch", r);
        continue;
      }
      const o = this.activeTouches[r.identifier], a = this.newGestureEvent(We.Change, o.initialTarget);
      a.translationX = r.pageX - $i(o.rollingPageX), a.translationY = r.pageY - $i(o.rollingPageY), a.pageX = r.pageX, a.pageY = r.pageY, this.dispatchEvent(a), o.rollingPageX.length > 3 && (o.rollingPageX.shift(), o.rollingPageY.shift(), o.rollingTimestamps.shift()), o.rollingPageX.push(r.pageX), o.rollingPageY.push(r.pageY), o.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
}
Ne.SCROLL_FRICTION = -5e-3;
Ne.HOLD_DELAY = 700;
Ne.CLEAR_TAP_COUNT_TIME = 400;
SA([
  dt
], Ne, "isTouchDevice", null);
class im {
  constructor() {
    this._hooks = new le(), this._pointerMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._pointerMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(e, t, i, n, r) {
    this.isMonitoring() && this.stopMonitoring(!1), this._pointerMoveCallback = n, this._onStopCallback = r;
    let o = e;
    try {
      e.setPointerCapture(t), this._hooks.add(ze(() => {
        e.releasePointerCapture(t);
      }));
    } catch {
      o = window;
    }
    this._hooks.add(H(o, $.POINTER_MOVE, (a) => {
      if (a.buttons !== i) {
        this.stopMonitoring(!0);
        return;
      }
      a.preventDefault(), this._pointerMoveCallback(a);
    })), this._hooks.add(H(o, $.POINTER_UP, (a) => this.stopMonitoring(!0)));
  }
}
function Zr(s, e) {
  const t = Math.pow(10, e);
  return Math.round(s * t) / t;
}
class _e {
  constructor(e, t, i, n = 1) {
    this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = Zr(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
  }
}
class En {
  constructor(e, t, i, n) {
    this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Zr(Math.max(Math.min(1, t), 0), 3), this.l = Zr(Math.max(Math.min(1, i), 0), 3), this.a = Zr(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
  }
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, r = e.a, o = Math.max(t, i, n), a = Math.min(t, i, n);
    let l = 0, c = 0;
    const h = (a + o) / 2, u = o - a;
    if (u > 0) {
      switch (c = Math.min(h <= 0.5 ? u / (2 * h) : u / (2 - 2 * h), 1), o) {
        case t:
          l = (i - n) / u + (i < n ? 6 : 0);
          break;
        case i:
          l = (n - t) / u + 2;
          break;
        case n:
          l = (t - i) / u + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new En(l, c, h, r);
  }
  static _hue2rgb(e, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
  }
  static toRGBA(e) {
    const t = e.h / 360, { s: i, l: n, a: r } = e;
    let o, a, l;
    if (i === 0)
      o = a = l = n;
    else {
      const c = n < 0.5 ? n * (1 + i) : n + i - n * i, h = 2 * n - c;
      o = En._hue2rgb(h, c, t + 1 / 3), a = En._hue2rgb(h, c, t), l = En._hue2rgb(h, c, t - 1 / 3);
    }
    return new _e(Math.round(o * 255), Math.round(a * 255), Math.round(l * 255), r);
  }
}
class Qa {
  constructor(e, t, i, n) {
    this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Zr(Math.max(Math.min(1, t), 0), 3), this.v = Zr(Math.max(Math.min(1, i), 0), 3), this.a = Zr(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
  }
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, r = Math.max(t, i, n), o = Math.min(t, i, n), a = r - o, l = r === 0 ? 0 : a / r;
    let c;
    return a === 0 ? c = 0 : r === t ? c = ((i - n) / a % 6 + 6) % 6 : r === i ? c = (n - t) / a + 2 : c = (t - i) / a + 4, new Qa(Math.round(c * 60), l, r, e.a);
  }
  static toRGBA(e) {
    const { h: t, s: i, v: n, a: r } = e, o = n * i, a = o * (1 - Math.abs(t / 60 % 2 - 1)), l = n - o;
    let [c, h, u] = [0, 0, 0];
    return t < 60 ? (c = o, h = a) : t < 120 ? (c = a, h = o) : t < 180 ? (h = o, u = a) : t < 240 ? (h = a, u = o) : t < 300 ? (c = a, u = o) : t <= 360 && (c = o, u = a), c = Math.round((c + l) * 255), h = Math.round((h + l) * 255), u = Math.round((u + l) * 255), new _e(c, h, u, r);
  }
}
class R {
  constructor(e) {
    if (e)
      if (e instanceof _e)
        this.rgba = e;
      else if (e instanceof En)
        this._hsla = e, this.rgba = En.toRGBA(e);
      else if (e instanceof Qa)
        this._hsva = e, this.rgba = Qa.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else
      throw new Error("Color needs a value");
  }
  static fromHex(e) {
    return R.Format.CSS.parseHex(e) || R.red;
  }
  get hsla() {
    return this._hsla ? this._hsla : En.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : Qa.fromRGBA(this.rgba);
  }
  equals(e) {
    return !!e && _e.equals(this.rgba, e.rgba) && En.equals(this.hsla, e.hsla) && Qa.equals(this.hsva, e.hsva);
  }
  getRelativeLuminance() {
    const e = R._relativeLuminanceForComponent(this.rgba.r), t = R._relativeLuminanceForComponent(this.rgba.g), i = R._relativeLuminanceForComponent(this.rgba.b), n = 0.2126 * e + 0.7152 * t + 0.0722 * i;
    return Zr(n, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t > i;
  }
  isDarkerThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t < i;
  }
  lighten(e) {
    return new R(new En(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new R(new En(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: t, g: i, b: n, a: r } = this.rgba;
    return new R(new _e(t, i, n, r * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new R(new _e(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  toString() {
    return this._toString || (this._toString = R.Format.CSS.format(this)), this._toString;
  }
  static getLighterColor(e, t, i) {
    if (e.isLighterThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), r = t.getRelativeLuminance();
    return i = i * (r - n) / r, e.lighten(i);
  }
  static getDarkerColor(e, t, i) {
    if (e.isDarkerThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), r = t.getRelativeLuminance();
    return i = i * (n - r) / n, e.darken(i);
  }
}
R.white = new R(new _e(255, 255, 255, 1));
R.black = new R(new _e(0, 0, 0, 1));
R.red = new R(new _e(255, 0, 0, 1));
R.blue = new R(new _e(0, 0, 255, 1));
R.green = new R(new _e(0, 255, 0, 1));
R.cyan = new R(new _e(0, 255, 255, 1));
R.lightgrey = new R(new _e(211, 211, 211, 1));
R.transparent = new R(new _e(0, 0, 0, 0));
(function(s) {
  (function(e) {
    (function(t) {
      function i(f) {
        return f.rgba.a === 1 ? `rgb(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b})` : s.Format.CSS.formatRGBA(f);
      }
      t.formatRGB = i;
      function n(f) {
        return `rgba(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b}, ${+f.rgba.a.toFixed(2)})`;
      }
      t.formatRGBA = n;
      function r(f) {
        return f.hsla.a === 1 ? `hsl(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%)` : s.Format.CSS.formatHSLA(f);
      }
      t.formatHSL = r;
      function o(f) {
        return `hsla(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%, ${f.hsla.a.toFixed(2)})`;
      }
      t.formatHSLA = o;
      function a(f) {
        const m = f.toString(16);
        return m.length !== 2 ? "0" + m : m;
      }
      function l(f) {
        return `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}`;
      }
      t.formatHex = l;
      function c(f, m = !1) {
        return m && f.rgba.a === 1 ? s.Format.CSS.formatHex(f) : `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}${a(Math.round(f.rgba.a * 255))}`;
      }
      t.formatHexA = c;
      function h(f) {
        return f.isOpaque() ? s.Format.CSS.formatHex(f) : s.Format.CSS.formatRGBA(f);
      }
      t.format = h;
      function u(f) {
        const m = f.length;
        if (m === 0 || f.charCodeAt(0) !== 35)
          return null;
        if (m === 7) {
          const _ = 16 * d(f.charCodeAt(1)) + d(f.charCodeAt(2)), b = 16 * d(f.charCodeAt(3)) + d(f.charCodeAt(4)), v = 16 * d(f.charCodeAt(5)) + d(f.charCodeAt(6));
          return new s(new _e(_, b, v, 1));
        }
        if (m === 9) {
          const _ = 16 * d(f.charCodeAt(1)) + d(f.charCodeAt(2)), b = 16 * d(f.charCodeAt(3)) + d(f.charCodeAt(4)), v = 16 * d(f.charCodeAt(5)) + d(f.charCodeAt(6)), C = 16 * d(f.charCodeAt(7)) + d(f.charCodeAt(8));
          return new s(new _e(_, b, v, C / 255));
        }
        if (m === 4) {
          const _ = d(f.charCodeAt(1)), b = d(f.charCodeAt(2)), v = d(f.charCodeAt(3));
          return new s(new _e(16 * _ + _, 16 * b + b, 16 * v + v));
        }
        if (m === 5) {
          const _ = d(f.charCodeAt(1)), b = d(f.charCodeAt(2)), v = d(f.charCodeAt(3)), C = d(f.charCodeAt(4));
          return new s(new _e(16 * _ + _, 16 * b + b, 16 * v + v, (16 * C + C) / 255));
        }
        return null;
      }
      t.parseHex = u;
      function d(f) {
        switch (f) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(s.Format || (s.Format = {}));
})(R || (R = {}));
function yA(s) {
  return `--vscode-${s.replace(/\./g, "-")}`;
}
const wD = {
  ColorContribution: "base.contributions.colors"
};
class LA {
  constructor() {
    this._onDidChangeSchema = new A(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, n = !1, r) {
    const o = { id: e, description: i, defaults: t, needsTransparency: n, deprecationMessage: r };
    this.colorsById[e] = o;
    const a = { type: "string", description: i, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return r && (a.deprecationMessage = r), this.colorSchema.properties[e] = a, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  getColors() {
    return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i && i.defaults) {
      const n = i.defaults[t.type];
      return Rs(n, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    const e = (t, i) => {
      const n = t.indexOf(".") === -1 ? 0 : 1, r = i.indexOf(".") === -1 ? 0 : 1;
      return n !== r ? n - r : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const nm = new LA();
Ft.add(wD.ColorContribution, nm);
function kA(s) {
  return s === null || typeof s.hcLight > "u" && (s.hcDark === null || typeof s.hcDark == "string" ? s.hcLight = s.hcDark : s.hcLight = s.light), s;
}
function x(s, e, t, i, n) {
  return nm.registerColor(s, kA(e), t, i, n);
}
const fe = x("foreground", { dark: "#CCCCCC", light: "#616161", hcDark: "#FFFFFF", hcLight: "#292929" }, p("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
x("disabledForeground", { dark: "#CCCCCC80", light: "#61616180", hcDark: "#A5A5A5", hcLight: "#7F7F7F" }, p("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
x("errorForeground", { dark: "#F48771", light: "#A1260D", hcDark: "#F48771", hcLight: "#B5200D" }, p("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
x("descriptionForeground", { light: "#717171", dark: Z(fe, 0.7), hcDark: Z(fe, 0.7), hcLight: Z(fe, 0.7) }, p("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
x("icon.foreground", { dark: "#C5C5C5", light: "#424242", hcDark: "#FFFFFF", hcLight: "#292929" }, p("iconForeground", "The default color for icons in the workbench."));
const mn = x("focusBorder", { dark: "#007FD4", light: "#0090F1", hcDark: "#F38518", hcLight: "#0F4A85" }, p("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), ve = x("contrastBorder", { light: null, dark: null, hcDark: "#6FC3DF", hcLight: "#0F4A85" }, p("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), ht = x("contrastActiveBorder", { light: null, dark: null, hcDark: mn, hcLight: mn }, p("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
x("selection.background", { light: null, dark: null, hcDark: null, hcLight: null }, p("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
x("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hcDark: R.black, hcLight: "#292929" }, p("textSeparatorForeground", "Color for text separators."));
x("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hcDark: "#3794FF", hcLight: "#0F4A85" }, p("textLinkForeground", "Foreground color for links in text."));
x("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hcDark: "#3794FF", hcLight: "#0F4A85" }, p("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
x("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hcDark: "#D7BA7D", hcLight: "#292929" }, p("textPreformatForeground", "Foreground color for preformatted text segments."));
x("textBlockQuote.background", { light: "#7f7f7f1a", dark: "#7f7f7f1a", hcDark: null, hcLight: "#F2F2F2" }, p("textBlockQuoteBackground", "Background color for block quotes in text."));
x("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hcDark: R.white, hcLight: "#292929" }, p("textBlockQuoteBorder", "Border color for block quotes in text."));
x("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hcDark: R.black, hcLight: "#F2F2F2" }, p("textCodeBlockBackground", "Background color for code blocks in text."));
const Ao = x("widget.shadow", { dark: Z(R.black, 0.36), light: Z(R.black, 0.16), hcDark: null, hcLight: null }, p("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), SD = x("input.background", { dark: "#3C3C3C", light: R.white, hcDark: R.black, hcLight: R.white }, p("inputBoxBackground", "Input box background.")), yD = x("input.foreground", { dark: fe, light: fe, hcDark: fe, hcLight: fe }, p("inputBoxForeground", "Input box foreground.")), LD = x("input.border", { dark: null, light: null, hcDark: ve, hcLight: ve }, p("inputBoxBorder", "Input box border.")), DA = x("inputOption.activeBorder", { dark: "#007ACC00", light: "#007ACC00", hcDark: ve, hcLight: ve }, p("inputBoxActiveOptionBorder", "Border color of activated options in input fields."));
x("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hcDark: null, hcLight: null }, p("inputOption.hoverBackground", "Background color of activated options in input fields."));
const EA = x("inputOption.activeBackground", { dark: Z(mn, 0.4), light: Z(mn, 0.2), hcDark: R.transparent, hcLight: R.transparent }, p("inputOption.activeBackground", "Background hover color of options in input fields.")), xA = x("inputOption.activeForeground", { dark: R.white, light: R.black, hcDark: null, hcLight: fe }, p("inputOption.activeForeground", "Foreground color of activated options in input fields."));
x("input.placeholderForeground", { light: Z(fe, 0.5), dark: Z(fe, 0.5), hcDark: Z(fe, 0.7), hcLight: Z(fe, 0.7) }, p("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
const kD = x("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hcDark: R.black, hcLight: R.white }, p("inputValidationInfoBackground", "Input validation background color for information severity.")), DD = x("inputValidation.infoForeground", { dark: null, light: null, hcDark: null, hcLight: fe }, p("inputValidationInfoForeground", "Input validation foreground color for information severity.")), ED = x("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hcDark: ve, hcLight: ve }, p("inputValidationInfoBorder", "Input validation border color for information severity.")), xD = x("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hcDark: R.black, hcLight: R.white }, p("inputValidationWarningBackground", "Input validation background color for warning severity.")), ID = x("inputValidation.warningForeground", { dark: null, light: null, hcDark: null, hcLight: fe }, p("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), ND = x("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hcDark: ve, hcLight: ve }, p("inputValidationWarningBorder", "Input validation border color for warning severity.")), TD = x("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hcDark: R.black, hcLight: R.white }, p("inputValidationErrorBackground", "Input validation background color for error severity.")), MD = x("inputValidation.errorForeground", { dark: null, light: null, hcDark: null, hcLight: fe }, p("inputValidationErrorForeground", "Input validation foreground color for error severity.")), AD = x("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hcDark: ve, hcLight: ve }, p("inputValidationErrorBorder", "Input validation border color for error severity.")), Ys = x("dropdown.background", { dark: "#3C3C3C", light: R.white, hcDark: R.black, hcLight: R.white }, p("dropdownBackground", "Dropdown background."));
x("dropdown.listBackground", { dark: null, light: null, hcDark: R.black, hcLight: R.white }, p("dropdownListBackground", "Dropdown list background."));
const Ro = x("dropdown.foreground", { dark: "#F0F0F0", light: null, hcDark: R.white, hcLight: fe }, p("dropdownForeground", "Dropdown foreground.")), nd = x("dropdown.border", { dark: Ys, light: "#CECECE", hcDark: ve, hcLight: ve }, p("dropdownBorder", "Dropdown border."));
x("checkbox.background", { dark: Ys, light: Ys, hcDark: Ys, hcLight: Ys }, p("checkbox.background", "Background color of checkbox widget."));
x("checkbox.foreground", { dark: Ro, light: Ro, hcDark: Ro, hcLight: Ro }, p("checkbox.foreground", "Foreground color of checkbox widget."));
x("checkbox.border", { dark: nd, light: nd, hcDark: nd, hcLight: nd }, p("checkbox.border", "Border color of checkbox widget."));
const Kc = x("button.foreground", { dark: R.white, light: R.white, hcDark: R.white, hcLight: R.white }, p("buttonForeground", "Button foreground color."));
x("button.separator", { dark: Z(Kc, 0.4), light: Z(Kc, 0.4), hcDark: Z(Kc, 0.4), hcLight: Z(Kc, 0.4) }, p("buttonSeparator", "Button separator color."));
const M1 = x("button.background", { dark: "#0E639C", light: "#007ACC", hcDark: null, hcLight: "#0F4A85" }, p("buttonBackground", "Button background color.")), IA = x("button.hoverBackground", { dark: On(M1, 0.2), light: ua(M1, 0.2), hcDark: null, hcLight: null }, p("buttonHoverBackground", "Button background color when hovering."));
x("button.border", { dark: ve, light: ve, hcDark: ve, hcLight: ve }, p("buttonBorder", "Button border color."));
x("button.secondaryForeground", { dark: R.white, light: R.white, hcDark: R.white, hcLight: fe }, p("buttonSecondaryForeground", "Secondary button foreground color."));
const qw = x("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hcDark: null, hcLight: R.white }, p("buttonSecondaryBackground", "Secondary button background color."));
x("button.secondaryHoverBackground", { dark: On(qw, 0.2), light: ua(qw, 0.2), hcDark: null, hcLight: null }, p("buttonSecondaryHoverBackground", "Secondary button background color when hovering."));
const qc = x("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hcDark: R.black, hcLight: "#0F4A85" }, p("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), Gc = x("badge.foreground", { dark: R.white, light: "#333", hcDark: R.white, hcLight: R.white }, p("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), gc = x("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hcDark: null, hcLight: null }, p("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), Po = x("scrollbarSlider.background", { dark: R.fromHex("#797979").transparent(0.4), light: R.fromHex("#646464").transparent(0.4), hcDark: Z(ve, 0.6), hcLight: Z(ve, 0.4) }, p("scrollbarSliderBackground", "Scrollbar slider background color.")), Oo = x("scrollbarSlider.hoverBackground", { dark: R.fromHex("#646464").transparent(0.7), light: R.fromHex("#646464").transparent(0.7), hcDark: Z(ve, 0.8), hcLight: Z(ve, 0.8) }, p("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), Fo = x("scrollbarSlider.activeBackground", { dark: R.fromHex("#BFBFBF").transparent(0.4), light: R.fromHex("#000000").transparent(0.6), hcDark: ve, hcLight: ve }, p("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), NA = x("progressBar.background", { dark: R.fromHex("#0E70C0"), light: R.fromHex("#0E70C0"), hcDark: ve, hcLight: ve }, p("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), TA = x("editorError.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Qs = x("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hcDark: "#F48771", hcLight: "#B5200D" }, p("editorError.foreground", "Foreground color of error squigglies in the editor.")), MA = x("editorError.border", { dark: null, light: null, hcDark: R.fromHex("#E47777").transparent(0.8), hcLight: "#B5200D" }, p("errorBorder", "Border color of error boxes in the editor.")), AA = x("editorWarning.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Xi = x("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hcDark: "#FFD37", hcLight: "#895503" }, p("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), jh = x("editorWarning.border", { dark: null, light: null, hcDark: R.fromHex("#FFCC00").transparent(0.8), hcLight: "#" }, p("warningBorder", "Border color of warning boxes in the editor.")), RA = x("editorInfo.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Mn = x("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hcDark: "#3794FF", hcLight: "#1a85ff" }, p("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), A1 = x("editorInfo.border", { dark: null, light: null, hcDark: R.fromHex("#3794FF").transparent(0.8), hcLight: "#292929" }, p("infoBorder", "Border color of info boxes in the editor.")), PA = x("editorHint.foreground", { dark: R.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hcDark: null, hcLight: null }, p("editorHint.foreground", "Foreground color of hint squigglies in the editor.")), OA = x("editorHint.border", { dark: null, light: null, hcDark: R.fromHex("#eeeeee").transparent(0.8), hcLight: "#292929" }, p("hintBorder", "Border color of hint boxes in the editor."));
x("sash.hoverBorder", { dark: mn, light: mn, hcDark: mn, hcLight: mn }, p("sashActiveBorder", "Border color of active sashes."));
const $t = x("editor.background", { light: "#ffffff", dark: "#1E1E1E", hcDark: R.black, hcLight: R.white }, p("editorBackground", "Editor background color.")), mc = x("editor.foreground", { light: "#333333", dark: "#BBBBBB", hcDark: R.white, hcLight: fe }, p("editorForeground", "Editor default foreground color."));
x("editorStickyScroll.background", { light: $t, dark: $t, hcDark: $t, hcLight: $t }, p("editorStickyScrollBackground", "Sticky scroll background color for the editor"));
x("editorStickyScrollHover.background", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: R.fromHex("#0F4A85").transparent(0.1) }, p("editorStickyScrollHoverBackground", "Sticky scroll on hover background color for the editor"));
const Qt = x("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hcDark: "#0C141F", hcLight: R.white }, p("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), Pr = x("editorWidget.foreground", { dark: fe, light: fe, hcDark: fe, hcLight: fe }, p("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), sd = x("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hcDark: ve, hcLight: ve }, p("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
x("editorWidget.resizeBorder", { light: null, dark: null, hcDark: null, hcLight: null }, p("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
const Gw = x("quickInput.background", { dark: Qt, light: Qt, hcDark: Qt, hcLight: Qt }, p("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), FA = x("quickInput.foreground", { dark: Pr, light: Pr, hcDark: Pr, hcLight: Pr }, p("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), BA = x("quickInputTitle.background", { dark: new R(new _e(255, 255, 255, 0.105)), light: new R(new _e(0, 0, 0, 0.06)), hcDark: "#000000", hcLight: R.white }, p("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), VA = x("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hcDark: R.white, hcLight: "#0F4A85" }, p("pickerGroupForeground", "Quick picker color for grouping labels.")), WA = x("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hcDark: R.white, hcLight: "#0F4A85" }, p("pickerGroupBorder", "Quick picker color for grouping borders.")), HA = x("keybindingLabel.background", { dark: new R(new _e(128, 128, 128, 0.17)), light: new R(new _e(221, 221, 221, 0.4)), hcDark: R.transparent, hcLight: R.transparent }, p("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), zA = x("keybindingLabel.foreground", { dark: R.fromHex("#CCCCCC"), light: R.fromHex("#555555"), hcDark: R.white, hcLight: fe }, p("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), UA = x("keybindingLabel.border", { dark: new R(new _e(51, 51, 51, 0.6)), light: new R(new _e(204, 204, 204, 0.4)), hcDark: new R(new _e(111, 195, 223)), hcLight: ve }, p("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), $A = x("keybindingLabel.bottomBorder", { dark: new R(new _e(68, 68, 68, 0.6)), light: new R(new _e(187, 187, 187, 0.4)), hcDark: new R(new _e(111, 195, 223)), hcLight: fe }, p("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), Bo = x("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hcDark: "#f3f518", hcLight: "#0F4A85" }, p("editorSelectionBackground", "Color of the editor selection.")), jA = x("editor.selectionForeground", { light: null, dark: null, hcDark: "#000000", hcLight: R.white }, p("editorSelectionForeground", "Color of the selected text for high contrast.")), Yb = x("editor.inactiveSelectionBackground", { light: Z(Bo, 0.5), dark: Z(Bo, 0.5), hcDark: Z(Bo, 0.7), hcLight: Z(Bo, 0.5) }, p("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), RD = x("editor.selectionHighlightBackground", { light: nS(Bo, $t, 0.3, 0.6), dark: nS(Bo, $t, 0.3, 0.6), hcDark: null, hcLight: null }, p("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0);
x("editor.selectionHighlightBorder", { light: null, dark: null, hcDark: ht, hcLight: ht }, p("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
x("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hcDark: null, hcLight: null }, p("editorFindMatch", "Color of the current search match."));
const Or = x("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hcDark: null, hcLight: null }, p("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0);
x("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hcDark: null, hcLight: null }, p("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
x("editor.findMatchBorder", { light: null, dark: null, hcDark: ht, hcLight: ht }, p("editorFindMatchBorder", "Border color of the current search match."));
const Xa = x("editor.findMatchHighlightBorder", { light: null, dark: null, hcDark: ht, hcLight: ht }, p("findMatchHighlightBorder", "Border color of the other search matches."));
x("editor.findRangeHighlightBorder", { dark: null, light: null, hcDark: Z(ht, 0.4), hcLight: Z(ht, 0.4) }, p("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
x("searchEditor.findMatchBackground", { light: Z(Or, 0.66), dark: Z(Or, 0.66), hcDark: Or, hcLight: Or }, p("searchEditor.queryMatch", "Color of the Search Editor query matches."));
x("searchEditor.findMatchBorder", { light: Z(Xa, 0.66), dark: Z(Xa, 0.66), hcDark: Xa, hcLight: Xa }, p("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
x("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hcDark: "#ADD6FF26", hcLight: null }, p("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0);
const Zw = x("editorHoverWidget.background", { light: Qt, dark: Qt, hcDark: Qt, hcLight: Qt }, p("hoverBackground", "Background color of the editor hover."));
x("editorHoverWidget.foreground", { light: Pr, dark: Pr, hcDark: Pr, hcLight: Pr }, p("hoverForeground", "Foreground color of the editor hover."));
x("editorHoverWidget.border", { light: sd, dark: sd, hcDark: sd, hcLight: sd }, p("hoverBorder", "Border color of the editor hover."));
x("editorHoverWidget.statusBarBackground", { dark: On(Zw, 0.2), light: ua(Zw, 0.05), hcDark: Qt, hcLight: Qt }, p("statusBarBackground", "Background color of the editor hover status bar."));
x("editorLink.activeForeground", { dark: "#4E94CE", light: R.blue, hcDark: R.cyan, hcLight: "#292929" }, p("activeLinkForeground", "Color of active links."));
const Fr = x("editorInlayHint.foreground", { dark: Z(Gc, 0.8), light: Z(Gc, 0.8), hcDark: Gc, hcLight: Gc }, p("editorInlayHintForeground", "Foreground color of inline hints")), Br = x("editorInlayHint.background", { dark: Z(qc, 0.6), light: Z(qc, 0.3), hcDark: qc, hcLight: qc }, p("editorInlayHintBackground", "Background color of inline hints"));
x("editorInlayHint.typeForeground", { dark: Fr, light: Fr, hcDark: Fr, hcLight: Fr }, p("editorInlayHintForegroundTypes", "Foreground color of inline hints for types"));
x("editorInlayHint.typeBackground", { dark: Br, light: Br, hcDark: Br, hcLight: Br }, p("editorInlayHintBackgroundTypes", "Background color of inline hints for types"));
x("editorInlayHint.parameterForeground", { dark: Fr, light: Fr, hcDark: Fr, hcLight: Fr }, p("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters"));
x("editorInlayHint.parameterBackground", { dark: Br, light: Br, hcDark: Br, hcLight: Br }, p("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters"));
x("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hcDark: "#FFCC00", hcLight: "#007ACC" }, p("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
x("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hcDark: "#75BEFF", hcLight: "#007ACC" }, p("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
const R1 = new R(new _e(155, 185, 85, 0.2)), P1 = new R(new _e(255, 0, 0, 0.2)), PD = x("diffEditor.insertedTextBackground", { dark: "#9ccc2c33", light: "#9ccc2c66", hcDark: null, hcLight: null }, p("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), OD = x("diffEditor.removedTextBackground", { dark: "#ff000066", light: "#ff00004d", hcDark: null, hcLight: null }, p("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0), KA = x("diffEditor.insertedLineBackground", { dark: R1, light: R1, hcDark: null, hcLight: null }, p("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), qA = x("diffEditor.removedLineBackground", { dark: P1, light: P1, hcDark: null, hcLight: null }, p("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), !0), GA = x("diffEditorGutter.insertedLineBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted.")), ZA = x("diffEditorGutter.removedLineBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed.")), YA = x("diffEditorOverview.insertedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), QA = x("diffEditorOverview.removedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content.")), XA = x("diffEditor.insertedTextBorder", { dark: null, light: null, hcDark: "#33ff2eff", hcLight: "#374E06" }, p("diffEditorInsertedOutline", "Outline color for the text that got inserted.")), JA = x("diffEditor.removedTextBorder", { dark: null, light: null, hcDark: "#FF008F", hcLight: "#AD0707" }, p("diffEditorRemovedOutline", "Outline color for text that got removed.")), e7 = x("diffEditor.border", { dark: null, light: null, hcDark: ve, hcLight: ve }, p("diffEditorBorder", "Border color between the two text editors.")), t7 = x("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hcDark: null, hcLight: null }, p("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.")), i7 = x("list.focusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), n7 = x("list.focusForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), s7 = x("list.focusOutline", { dark: mn, light: mn, hcDark: ht, hcLight: ht }, p("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), r7 = x("list.focusAndSelectionOutline", { dark: null, light: null, hcDark: null, hcLight: null }, p("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.")), Xs = x("list.activeSelectionBackground", { dark: "#04395E", light: "#0060C0", hcDark: null, hcLight: R.fromHex("#0F4A85").transparent(0.1) }, p("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), ns = x("list.activeSelectionForeground", { dark: R.white, light: R.white, hcDark: null, hcLight: null }, p("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Zc = x("list.activeSelectionIconForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), o7 = x("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hcDark: null, hcLight: R.fromHex("#0F4A85").transparent(0.1) }, p("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), a7 = x("list.inactiveSelectionForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), l7 = x("list.inactiveSelectionIconForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), c7 = x("list.inactiveFocusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), h7 = x("list.inactiveFocusOutline", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), u7 = x("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: R.fromHex("#0F4A85").transparent(0.1) }, p("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), d7 = x("list.hoverForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), f7 = x("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hcDark: null, hcLight: null }, p("listDropBackground", "List/Tree drag and drop background when moving items around using the mouse.")), rd = x("list.highlightForeground", { dark: "#2AAAFF", light: "#0066BF", hcDark: mn, hcLight: mn }, p("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
x("list.focusHighlightForeground", { dark: rd, light: V7(Xs, rd, "#BBE7FF"), hcDark: rd, hcLight: rd }, p("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
x("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hcDark: "#B89500", hcLight: "#B5200D" }, p("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
x("list.errorForeground", { dark: "#F88070", light: "#B01011", hcDark: null, hcLight: null }, p("listErrorForeground", "Foreground color of list items containing errors."));
x("list.warningForeground", { dark: "#CCA700", light: "#855F00", hcDark: null, hcLight: null }, p("listWarningForeground", "Foreground color of list items containing warnings."));
const g7 = x("listFilterWidget.background", { light: ua(Qt, 0), dark: On(Qt, 0), hcDark: Qt, hcLight: Qt }, p("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), m7 = x("listFilterWidget.outline", { dark: R.transparent, light: R.transparent, hcDark: "#f38518", hcLight: "#007ACC" }, p("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), p7 = x("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hcDark: ve, hcLight: ve }, p("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), _7 = x("listFilterWidget.shadow", { dark: Ao, light: Ao, hcDark: Ao, hcLight: Ao }, p("listFilterWidgetShadow", "Shadown color of the type filter widget in lists and trees."));
x("list.filterMatchBackground", { dark: Or, light: Or, hcDark: null, hcLight: null }, p("listFilterMatchHighlight", "Background color of the filtered match."));
x("list.filterMatchBorder", { dark: Xa, light: Xa, hcDark: ve, hcLight: ht }, p("listFilterMatchHighlightBorder", "Border color of the filtered match."));
const b7 = x("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hcDark: "#a9a9a9", hcLight: "#a5a5a5" }, p("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), C7 = x("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hcDark: null, hcLight: null }, p("tableColumnsBorder", "Table border color between columns.")), v7 = x("tree.tableOddRowsBackground", { dark: Z(fe, 0.04), light: Z(fe, 0.04), hcDark: null, hcLight: null }, p("tableOddRowsBackgroundColor", "Background color for odd table rows."));
x("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hcDark: "#A7A8A9", hcLight: "#666666" }, p("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized. "));
const Yw = x("quickInput.list.focusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, "", void 0, p("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), w7 = x("quickInputList.focusForeground", { dark: ns, light: ns, hcDark: ns, hcLight: ns }, p("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), S7 = x("quickInputList.focusIconForeground", { dark: Zc, light: Zc, hcDark: Zc, hcLight: Zc }, p("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), y7 = x("quickInputList.focusBackground", { dark: iS(Yw, Xs), light: iS(Yw, Xs), hcDark: null, hcLight: null }, p("quickInput.listFocusBackground", "Quick picker background color for the focused item.")), L7 = x("menu.border", { dark: null, light: null, hcDark: ve, hcLight: ve }, p("menuBorder", "Border color of menus.")), k7 = x("menu.foreground", { dark: Ro, light: fe, hcDark: Ro, hcLight: Ro }, p("menuForeground", "Foreground color of menu items.")), D7 = x("menu.background", { dark: Ys, light: Ys, hcDark: Ys, hcLight: Ys }, p("menuBackground", "Background color of menu items.")), E7 = x("menu.selectionForeground", { dark: ns, light: ns, hcDark: ns, hcLight: ns }, p("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), x7 = x("menu.selectionBackground", { dark: Xs, light: Xs, hcDark: Xs, hcLight: Xs }, p("menuSelectionBackground", "Background color of the selected menu item in menus.")), I7 = x("menu.selectionBorder", { dark: null, light: null, hcDark: ht, hcLight: ht }, p("menuSelectionBorder", "Border color of the selected menu item in menus.")), N7 = x("menu.separatorBackground", { dark: "#606060", light: "#D4D4D4", hcDark: ve, hcLight: ve }, p("menuSeparatorBackground", "Color of a separator menu item in menus.")), Qw = x("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hcDark: null, hcLight: null }, p("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
x("toolbar.hoverOutline", { dark: null, light: null, hcDark: ht, hcLight: ht }, p("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
x("toolbar.activeBackground", { dark: On(Qw, 0.1), light: ua(Qw, 0.1), hcDark: null, hcLight: null }, p("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
x("editor.snippetTabstopHighlightBackground", { dark: new R(new _e(124, 124, 124, 0.3)), light: new R(new _e(10, 50, 100, 0.2)), hcDark: new R(new _e(124, 124, 124, 0.3)), hcLight: new R(new _e(10, 50, 100, 0.2)) }, p("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
x("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hcDark: null, hcLight: null }, p("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
x("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
x("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new R(new _e(10, 50, 100, 0.5)), hcDark: "#525252", hcLight: "#292929" }, p("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
x("breadcrumb.foreground", { light: Z(fe, 0.8), dark: Z(fe, 0.8), hcDark: Z(fe, 0.8), hcLight: Z(fe, 0.8) }, p("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
x("breadcrumb.background", { light: $t, dark: $t, hcDark: $t, hcLight: $t }, p("breadcrumbsBackground", "Background color of breadcrumb items."));
x("breadcrumb.focusForeground", { light: ua(fe, 0.2), dark: On(fe, 0.1), hcDark: On(fe, 0.1), hcLight: On(fe, 0.1) }, p("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
x("breadcrumb.activeSelectionForeground", { light: ua(fe, 0.2), dark: On(fe, 0.1), hcDark: On(fe, 0.1), hcLight: On(fe, 0.1) }, p("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
x("breadcrumbPicker.background", { light: Qt, dark: Qt, hcDark: Qt, hcLight: Qt }, p("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
const FD = 0.5, Xw = R.fromHex("#40C8AE").transparent(FD), Jw = R.fromHex("#40A6FF").transparent(FD), eS = R.fromHex("#606060").transparent(0.4), pn = 0.4, zl = 1, Ja = x("merge.currentHeaderBackground", { dark: Xw, light: Xw, hcDark: null, hcLight: null }, p("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
x("merge.currentContentBackground", { dark: Z(Ja, pn), light: Z(Ja, pn), hcDark: Z(Ja, pn), hcLight: Z(Ja, pn) }, p("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const el = x("merge.incomingHeaderBackground", { dark: Jw, light: Jw, hcDark: null, hcLight: null }, p("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
x("merge.incomingContentBackground", { dark: Z(el, pn), light: Z(el, pn), hcDark: Z(el, pn), hcLight: Z(el, pn) }, p("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const tl = x("merge.commonHeaderBackground", { dark: eS, light: eS, hcDark: null, hcLight: null }, p("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
x("merge.commonContentBackground", { dark: Z(tl, pn), light: Z(tl, pn), hcDark: Z(tl, pn), hcLight: Z(tl, pn) }, p("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const Ul = x("merge.border", { dark: null, light: null, hcDark: "#C3DF6F", hcLight: "#007ACC" }, p("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
x("editorOverviewRuler.currentContentForeground", { dark: Z(Ja, zl), light: Z(Ja, zl), hcDark: Ul, hcLight: Ul }, p("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
x("editorOverviewRuler.incomingContentForeground", { dark: Z(el, zl), light: Z(el, zl), hcDark: Ul, hcLight: Ul }, p("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
x("editorOverviewRuler.commonContentForeground", { dark: Z(tl, zl), light: Z(tl, zl), hcDark: Ul, hcLight: Ul }, p("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
x("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hcDark: "#AB5A00", hcLight: "" }, p("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0);
x("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, p("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const od = x("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hcDark: "#AB5A00", hcLight: "#0F4A85" }, p("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0);
x("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hcDark: "#ffffff", hcLight: "#0F4A85" }, p("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), !0);
const tS = x("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hcDark: "#ffffff", hcLight: "#0F4A85" }, p("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), T7 = x("minimap.errorHighlight", { dark: new R(new _e(255, 18, 18, 0.7)), light: new R(new _e(255, 18, 18, 0.7)), hcDark: new R(new _e(255, 50, 50, 1)), hcLight: "#B5200D" }, p("minimapError", "Minimap marker color for errors.")), M7 = x("minimap.warningHighlight", { dark: Xi, light: Xi, hcDark: jh, hcLight: jh }, p("overviewRuleWarning", "Minimap marker color for warnings.")), A7 = x("minimap.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("minimapBackground", "Minimap background color.")), R7 = x("minimap.foregroundOpacity", { dark: R.fromHex("#000f"), light: R.fromHex("#000f"), hcDark: R.fromHex("#000f"), hcLight: R.fromHex("#000f") }, p("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.')), P7 = x("minimapSlider.background", { light: Z(Po, 0.5), dark: Z(Po, 0.5), hcDark: Z(Po, 0.5), hcLight: Z(Po, 0.5) }, p("minimapSliderBackground", "Minimap slider background color.")), O7 = x("minimapSlider.hoverBackground", { light: Z(Oo, 0.5), dark: Z(Oo, 0.5), hcDark: Z(Oo, 0.5), hcLight: Z(Oo, 0.5) }, p("minimapSliderHoverBackground", "Minimap slider background color when hovering.")), F7 = x("minimapSlider.activeBackground", { light: Z(Fo, 0.5), dark: Z(Fo, 0.5), hcDark: Z(Fo, 0.5), hcLight: Z(Fo, 0.5) }, p("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
x("problemsErrorIcon.foreground", { dark: Qs, light: Qs, hcDark: Qs, hcLight: Qs }, p("problemsErrorIconForeground", "The color used for the problems error icon."));
x("problemsWarningIcon.foreground", { dark: Xi, light: Xi, hcDark: Xi, hcLight: Xi }, p("problemsWarningIconForeground", "The color used for the problems warning icon."));
x("problemsInfoIcon.foreground", { dark: Mn, light: Mn, hcDark: Mn, hcLight: Mn }, p("problemsInfoIconForeground", "The color used for the problems info icon."));
x("charts.foreground", { dark: fe, light: fe, hcDark: fe, hcLight: fe }, p("chartsForeground", "The foreground color used in charts."));
x("charts.lines", { dark: Z(fe, 0.5), light: Z(fe, 0.5), hcDark: Z(fe, 0.5), hcLight: Z(fe, 0.5) }, p("chartsLines", "The color used for horizontal lines in charts."));
x("charts.red", { dark: Qs, light: Qs, hcDark: Qs, hcLight: Qs }, p("chartsRed", "The red color used in chart visualizations."));
x("charts.blue", { dark: Mn, light: Mn, hcDark: Mn, hcLight: Mn }, p("chartsBlue", "The blue color used in chart visualizations."));
x("charts.yellow", { dark: Xi, light: Xi, hcDark: Xi, hcLight: Xi }, p("chartsYellow", "The yellow color used in chart visualizations."));
x("charts.orange", { dark: od, light: od, hcDark: od, hcLight: od }, p("chartsOrange", "The orange color used in chart visualizations."));
x("charts.green", { dark: "#89D185", light: "#388A34", hcDark: "#89D185", hcLight: "#374e06" }, p("chartsGreen", "The green color used in chart visualizations."));
x("charts.purple", { dark: "#B180D7", light: "#652D90", hcDark: "#B180D7", hcLight: "#652D90" }, p("chartsPurple", "The purple color used in chart visualizations."));
function B7(s, e) {
  var t, i, n;
  switch (s.op) {
    case 0:
      return (t = Rs(s.value, e)) === null || t === void 0 ? void 0 : t.darken(s.factor);
    case 1:
      return (i = Rs(s.value, e)) === null || i === void 0 ? void 0 : i.lighten(s.factor);
    case 2:
      return (n = Rs(s.value, e)) === null || n === void 0 ? void 0 : n.transparent(s.factor);
    case 3:
      for (const r of s.values) {
        const o = Rs(r, e);
        if (o)
          return o;
      }
      return;
    case 5:
      return Rs(e.defines(s.if) ? s.then : s.else, e);
    case 4: {
      const r = Rs(s.value, e);
      if (!r)
        return;
      const o = Rs(s.background, e);
      return o ? r.isDarkerThan(o) ? R.getLighterColor(r, o, s.factor).transparent(s.transparency) : R.getDarkerColor(r, o, s.factor).transparent(s.transparency) : r.transparent(s.factor * s.transparency);
    }
    default:
      throw fb();
  }
}
function ua(s, e) {
  return { op: 0, value: s, factor: e };
}
function On(s, e) {
  return { op: 1, value: s, factor: e };
}
function Z(s, e) {
  return { op: 2, value: s, factor: e };
}
function iS(...s) {
  return { op: 3, values: s };
}
function V7(s, e, t) {
  return { op: 5, if: s, then: e, else: t };
}
function nS(s, e, t, i) {
  return { op: 4, value: s, background: e, factor: t, transparency: i };
}
function Rs(s, e) {
  if (s !== null) {
    if (typeof s == "string")
      return s[0] === "#" ? R.fromHex(s) : e.getColor(s);
    if (s instanceof R)
      return s;
    if (typeof s == "object")
      return B7(s, e);
  }
}
const BD = "vscode://schemas/workbench-colors", VD = Ft.as(Pg.JSONContribution);
VD.registerSchema(BD, nm.getColorSchema());
const sS = new oi(() => VD.notifySchemaChanged(BD), 200);
nm.onDidChangeSchema(() => {
  sS.isScheduled() || sS.schedule();
});
class Qb {
  constructor(e, t) {
    this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
  }
  toClientCoordinates() {
    return new WD(this.x - tr.scrollX, this.y - tr.scrollY);
  }
}
class WD {
  constructor(e, t) {
    this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
  }
  toPageCoordinates() {
    return new Qb(this.clientX + tr.scrollX, this.clientY + tr.scrollY);
  }
}
class W7 {
  constructor(e, t, i, n) {
    this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
  }
}
class H7 {
  constructor(e, t) {
    this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
  }
}
function HD(s) {
  const e = is(s);
  return new W7(e.left, e.top, e.width, e.height);
}
function zD(s, e, t) {
  const i = e.width / s.offsetWidth, n = e.height / s.offsetHeight, r = (t.x - e.x) / i, o = (t.y - e.y) / n;
  return new H7(r, o);
}
class io extends Gs {
  constructor(e, t, i) {
    super(e), this._editorMouseEventBrand = void 0, this.isFromPointerCapture = t, this.pos = new Qb(this.posx, this.posy), this.editorPos = HD(i), this.relativePos = zD(i, this.editorPos, this.pos);
  }
}
class z7 {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new io(e, !1, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return H(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return H(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return H(e, $.MOUSE_DOWN, (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return H(e, $.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onMouseLeave(e, t) {
    return H(e, $.MOUSE_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onMouseMove(e, t) {
    return H(e, "mousemove", (i) => t(this._create(i)));
  }
}
class U7 {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new io(e, !1, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return H(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return H(e, $.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onPointerLeave(e, t) {
    return H(e, $.POINTER_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onPointerMove(e, t) {
    return H(e, "pointermove", (i) => t(this._create(i)));
  }
}
class $7 extends z {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalPointerMoveMonitor = this._register(new im()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, n, r) {
    this._keydownListener = pi(document, "keydown", (o) => {
      o.toKeybinding().isModifierKey() || this._globalPointerMoveMonitor.stopMonitoring(!0, o.browserEvent);
    }, !0), this._globalPointerMoveMonitor.startMonitoring(e, t, i, (o) => {
      n(new io(o, !0, this._editorViewDomNode));
    }, (o) => {
      this._keydownListener.dispose(), r(o);
    });
  }
  stopMonitoring() {
    this._globalPointerMoveMonitor.stopMonitoring(!0);
  }
}
class Ru extends z {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  handleEvents(e) {
    let t = !1;
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      switch (r.type) {
        case 0:
          this.onCompositionStart(r) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(r) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(r) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(r) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(r) && (t = !0);
          break;
        case 5:
          this.onFlushed(r) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(r) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(r) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(r) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(r) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(r) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(r) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(r) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(r) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(r) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(r) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(r) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(r) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(r);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class Ui extends Ru {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class fs {
  static write(e, t) {
    e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    const i = [];
    let n = 0;
    for (; e && e !== document.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
    const r = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      r[o] = i[n - o - 1];
    return r;
  }
}
class j7 {
  constructor(e, t) {
    this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class K7 extends j7 {
  constructor(e, t, i) {
    super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class q7 {
  constructor(e, t, i) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i;
  }
}
class sm {
  constructor(e, t) {
    this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
  }
  static from(e) {
    const t = new Array(e.length);
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      t[i] = new sm(r.left, r.width);
    }
    return t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class Cl {
  constructor(e, t) {
    this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class G7 {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
  }
}
class Z7 {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class dp {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, n, r) {
    const o = this._createRange();
    try {
      return o.setStart(e, t), o.setEnd(i, n), o.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(o, r);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return e;
    e.sort(Cl.compare);
    const t = [];
    let i = 0, n = e[0];
    for (let r = 1, o = e.length; r < o; r++) {
      const a = e[r];
      n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
    }
    return t[i++] = n, t;
  }
  static _createHorizontalRangesFromClientRects(e, t, i) {
    if (!e || e.length === 0)
      return null;
    const n = [];
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r];
      n[r] = new Cl(Math.max(0, (a.left - t) / i), a.width / i);
    }
    return this._mergeAdjacentRanges(n);
  }
  static readHorizontalRanges(e, t, i, n, r, o, a, l) {
    const h = e.children.length - 1;
    if (0 > h)
      return null;
    if (t = Math.min(h, Math.max(0, t)), n = Math.min(h, Math.max(0, n)), t === n && i === r && i === 0 && !e.children[t].firstChild) {
      const m = e.children[t].getClientRects();
      return this._createHorizontalRangesFromClientRects(m, o, a);
    }
    t !== n && n > 0 && r === 0 && (n--, r = 1073741824);
    let u = e.children[t].firstChild, d = e.children[n].firstChild;
    if ((!u || !d) && (!u && i === 0 && t > 0 && (u = e.children[t - 1].firstChild, i = 1073741824), !d && r === 0 && n > 0 && (d = e.children[n - 1].firstChild, r = 1073741824)), !u || !d)
      return null;
    i = Math.min(u.textContent.length, Math.max(0, i)), r = Math.min(d.textContent.length, Math.max(0, r));
    const f = this._readClientRects(u, i, d, r, l);
    return this._createHorizontalRangesFromClientRects(f, o, a);
  }
}
const Y7 = function() {
  return sh ? !0 : !(_i || sn || rr);
}();
let vl = !0;
class rS {
  constructor(e, t) {
    this._domNode = e, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = !1, this.endNode = t;
  }
  readClientRect() {
    if (!this._clientRectRead) {
      this._clientRectRead = !0;
      const e = this._domNode.getBoundingClientRect();
      this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
    }
  }
  get clientRectDeltaLeft() {
    return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
  }
  get clientRectScale() {
    return this._clientRectRead || this.readClientRect(), this._clientRectScale;
  }
}
class oS {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, n = i.get(46);
    this.renderWhitespace = i.get(90), this.renderControlCharacters = i.get(85), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(29), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(61), this.stopRenderingLineAfter = i.get(107), this.fontLigatures = i.get(47);
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
class Jn {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = me(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return cs(this._options.themeType) || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, n) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const r = i.getViewLineRenderingData(e), o = this._options, a = gn.filter(r.inlineDecorations, e, r.minColumn, r.maxColumn);
    let l = null;
    if (cs(o.themeType) || this._options.renderWhitespace === "selection") {
      const d = i.selections;
      for (const f of d) {
        if (f.endLineNumber < e || f.startLineNumber > e)
          continue;
        const m = f.startLineNumber === e ? f.startColumn : r.minColumn, _ = f.endLineNumber === e ? f.endColumn : r.maxColumn;
        m < _ && (cs(o.themeType) || this._options.renderWhitespace !== "selection" ? a.push(new gn(m, _, "inline-selected-text", 0)) : (l || (l = []), l.push(new R5(m - 1, _ - 1))));
      }
    }
    const c = new dc(o.useMonospaceOptimizations, o.canUseHalfwidthRightwardsArrow, r.content, r.continuesWithWrappedLine, r.isBasicASCII, r.containsRTL, r.minColumn - 1, r.tokens, a, r.tabSize, r.startVisibleColumn, o.spaceWidth, o.middotWidth, o.wsmiddotWidth, o.stopRenderingLineAfter, o.renderWhitespace, o.renderControlCharacters, o.fontLigatures !== qi.OFF, l);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(c))
      return !1;
    n.appendASCIIString('<div style="top:'), n.appendASCIIString(String(t)), n.appendASCIIString("px;height:"), n.appendASCIIString(String(this._options.lineHeight)), n.appendASCIIString('px;" class="'), n.appendASCIIString(Jn.CLASS_NAME), n.appendASCIIString('">');
    const h = zb(c, n);
    n.appendASCIIString("</div>");
    let u = null;
    return vl && Y7 && r.isBasicASCII && o.useMonospaceOptimizations && h.containsForeignElements === 0 && r.content.length < 300 && c.lineTokens.getCount() < 100 && (u = new ad(this._renderedViewLine ? this._renderedViewLine.domNode : null, c, h.characterMapping)), u || (u = $D(this._renderedViewLine ? this._renderedViewLine.domNode : null, c, h.characterMapping, h.containsRTL, h.containsForeignElements)), this._renderedViewLine = u, !0;
  }
  layoutLine(e, t) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(this._options.lineHeight));
  }
  getWidth() {
    return this._renderedViewLine ? this._renderedViewLine.getWidth() : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof ad : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof ad ? this._renderedViewLine.monospaceAssumptionsAreValid() : vl;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof ad && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i, n) {
    if (!this._renderedViewLine)
      return null;
    t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
    const r = this._renderedViewLine.input.stopRenderingLineAfter;
    let o = !1;
    r !== -1 && t > r + 1 && i > r + 1 && (o = !0), r !== -1 && t > r + 1 && (t = r + 1), r !== -1 && i > r + 1 && (i = r + 1);
    const a = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
    return a && a.length > 0 ? new Z7(o, a) : null;
  }
  getColumnOfNodeOffset(e, t, i) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t, i) : 1;
  }
}
Jn.CLASS_NAME = "view-line";
class ad {
  constructor(e, t, i) {
    this.domNode = e, this.input = t, this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth() {
    return Math.round(this._getCharPosition(this._characterMapping.length));
  }
  getWidthIsFast() {
    return !0;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return vl;
    const e = this.getWidth(), t = this.domNode.domNode.firstChild.offsetWidth;
    return Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), vl = !1), vl;
  }
  toSlowRenderedLine() {
    return $D(this.domNode, this.input, this._characterMapping, !1, 0);
  }
  getVisibleRangesForRange(e, t, i, n) {
    const r = this._getCharPosition(t), o = this._getCharPosition(i);
    return [new Cl(r, o - r)];
  }
  _getCharPosition(e) {
    const t = this._characterMapping.getHorizontalOffset(e);
    return this._charWidth * t;
  }
  getColumnOfNodeOffset(e, t, i) {
    const n = t.textContent.length;
    let r = -1;
    for (; t; )
      t = t.previousSibling, r++;
    return this._characterMapping.getColumn(new Hb(r, i), n);
  }
}
class UD {
  constructor(e, t, i, n, r) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = r, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
      for (let o = 0, a = this._characterMapping.length; o <= a; o++)
        this._pixelOffsetCache[o] = -1;
    }
  }
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  getWidth() {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  getVisibleRangesForRange(e, t, i, n) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const r = this._readPixelOffset(this.domNode, e, t, n);
      if (r === -1)
        return null;
      const o = this._readPixelOffset(this.domNode, e, i, n);
      return o === -1 ? null : [new Cl(r, o - r)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
  }
  _readVisibleRangesForRange(e, t, i, n, r) {
    if (i === n) {
      const o = this._readPixelOffset(e, t, i, r);
      return o === -1 ? null : [new Cl(o, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, i, n, r);
  }
  _readPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth();
      const r = this._getReadingTarget(e);
      return r.firstChild ? r.firstChild.offsetWidth : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const r = this._pixelOffsetCache[i];
      if (r !== -1)
        return r;
      const o = this._actualReadPixelOffset(e, t, i, n);
      return this._pixelOffsetCache[i] = o, o;
    }
    return this._actualReadPixelOffset(e, t, i, n);
  }
  _actualReadPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      const l = dp.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n.clientRectDeltaLeft, n.clientRectScale, n.endNode);
      return !l || l.length === 0 ? -1 : l[0].left;
    }
    if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth();
    const r = this._characterMapping.getDomPosition(i), o = dp.readHorizontalRanges(this._getReadingTarget(e), r.partIndex, r.charIndex, r.partIndex, r.charIndex, n.clientRectDeltaLeft, n.clientRectScale, n.endNode);
    if (!o || o.length === 0)
      return -1;
    const a = o[0].left;
    if (this.input.isBasicASCII) {
      const l = this._characterMapping.getHorizontalOffset(i), c = Math.round(this.input.spaceWidth * l);
      if (Math.abs(c - a) <= 1)
        return c;
    }
    return a;
  }
  _readRawVisibleRangesForRange(e, t, i, n) {
    if (t === 1 && i === this._characterMapping.length)
      return [new Cl(0, this.getWidth())];
    const r = this._characterMapping.getDomPosition(t), o = this._characterMapping.getDomPosition(i);
    return dp.readHorizontalRanges(this._getReadingTarget(e), r.partIndex, r.charIndex, o.partIndex, o.charIndex, n.clientRectDeltaLeft, n.clientRectScale, n.endNode);
  }
  getColumnOfNodeOffset(e, t, i) {
    const n = t.textContent.length;
    let r = -1;
    for (; t; )
      t = t.previousSibling, r++;
    return this._characterMapping.getColumn(new Hb(r, i), n);
  }
}
class Q7 extends UD {
  _readVisibleRangesForRange(e, t, i, n, r) {
    const o = super._readVisibleRangesForRange(e, t, i, n, r);
    if (!o || o.length === 0 || i === n || i === 1 && n === this._characterMapping.length)
      return o;
    if (!this.input.containsRTL) {
      const a = this._readPixelOffset(e, t, n, r);
      if (a !== -1) {
        const l = o[o.length - 1];
        l.left < a && (l.width = a - l.left);
      }
    }
    return o;
  }
}
const $D = function() {
  return jr ? X7 : J7;
}();
function X7(s, e, t, i, n) {
  return new Q7(s, e, t, i, n);
}
function J7(s, e, t, i, n) {
  return new UD(s, e, t, i, n);
}
class _t {
  static _nextVisibleColumn(e, t, i) {
    return e === 9 ? _t.nextRenderTabStop(t, i) : Jr(e) || xb(e) ? t + 2 : t + 1;
  }
  static visibleColumnFromColumn(e, t, i) {
    const n = Math.min(t - 1, e.length), r = e.substring(0, n), o = new mf(r);
    let a = 0;
    for (; !o.eol(); ) {
      const l = gf(r, n, o.offset);
      o.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
    }
    return a;
  }
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const n = e.length, r = new mf(e);
    let o = 0, a = 1;
    for (; !r.eol(); ) {
      const l = gf(e, n, r.offset);
      r.nextGraphemeLength();
      const c = this._nextVisibleColumn(l, o, i), h = r.offset + 1;
      if (c >= t) {
        const u = t - o;
        return c - t < u ? h : a;
      }
      o = c, a = h;
    }
    return n + 1;
  }
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
class Kh {
  static whitespaceVisibleColumn(e, t, i) {
    const n = e.length;
    let r = 0, o = -1, a = -1;
    for (let l = 0; l < n; l++) {
      if (l === t)
        return [o, a, r];
      switch (r % i === 0 && (o = l, a = r), e.charCodeAt(l)) {
        case 32:
          r += 1;
          break;
        case 9:
          r = _t.nextRenderTabStop(r, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === n ? [o, a, r] : [-1, -1, -1];
  }
  static atomicPosition(e, t, i, n) {
    const r = e.length, [o, a, l] = Kh.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let c;
    switch (n) {
      case 0:
        c = !0;
        break;
      case 1:
        c = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        c = l % i <= i / 2;
        break;
    }
    if (c) {
      if (o === -1)
        return -1;
      let d = a;
      for (let f = o; f < r; ++f) {
        if (d === a + i)
          return o;
        switch (e.charCodeAt(f)) {
          case 32:
            d += 1;
            break;
          case 9:
            d = _t.nextRenderTabStop(d, i);
            break;
          default:
            return -1;
        }
      }
      return d === a + i ? o : -1;
    }
    const h = _t.nextRenderTabStop(l, i);
    let u = l;
    for (let d = t; d < r; d++) {
      if (u === h)
        return d;
      switch (e.charCodeAt(d)) {
        case 32:
          u += 1;
          break;
        case 9:
          u = _t.nextRenderTabStop(u, i);
          break;
        default:
          return -1;
      }
    }
    return u === h ? r : -1;
  }
}
class Cr {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class O1 {
  constructor(e, t, i) {
    this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
  }
}
var Do;
(function(s) {
  function e(t, i, n) {
    const r = t.getPositionFromDOMInfo(i, n);
    return r ? new O1(r, i, null) : new Cr(i);
  }
  s.createFromDOMInfo = e;
})(Do || (Do = {}));
class eR {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class fi {
  static _deduceRage(e, t = null) {
    return !t && e ? new N(e.lineNumber, e.column, e.lineNumber, e.column) : t != null ? t : null;
  }
  static createUnknown(e, t, i) {
    return { type: 0, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createTextarea(e, t) {
    return { type: 1, element: e, mouseColumn: t, position: null, range: null };
  }
  static createMargin(e, t, i, n, r, o) {
    return { type: e, element: t, mouseColumn: i, position: n, range: r, detail: o };
  }
  static createViewZone(e, t, i, n, r) {
    return { type: e, element: t, mouseColumn: i, position: n, range: this._deduceRage(n), detail: r };
  }
  static createContentText(e, t, i, n, r) {
    return { type: 6, element: e, mouseColumn: t, position: i, range: this._deduceRage(i, n), detail: r };
  }
  static createContentEmpty(e, t, i, n) {
    return { type: 7, element: e, mouseColumn: t, position: i, range: this._deduceRage(i), detail: n };
  }
  static createContentWidget(e, t, i) {
    return { type: 9, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createScrollbar(e, t, i) {
    return { type: 11, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createOverlayWidget(e, t, i) {
    return { type: 12, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createOutsideEditor(e, t) {
    return { type: 13, element: null, mouseColumn: e, position: t, range: this._deduceRage(t) };
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
  }
}
class ln {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 7;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 7;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 5;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 8;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
}
class $l {
  constructor(e, t, i) {
    this.viewModel = e.viewModel;
    const n = e.configuration.options;
    this.layoutInfo = n.get(133), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(61), this.stickyTabStops = n.get(106), this.typicalHalfwidthCharacterWidth = n.get(46).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return $l.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const n = i.verticalOffset + i.height / 2, r = e.viewModel.getLineCount();
      let o = null, a, l = null;
      return i.afterLineNumber !== r && (l = new O(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (o = new O(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = o : o === null ? a = l : t < n ? a = o : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: o,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const n = this._context.viewModel.getLineCount(), r = this._context.viewModel.getLineMaxColumn(n);
      return {
        range: new N(n, r, n, r),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
    return {
      range: new N(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return $l._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== document.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class tR {
  constructor(e, t, i, n) {
    this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, Wt._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class Xb extends tR {
  constructor(e, t, i, n, r) {
    super(e, t, i, n), this._ctx = e, r ? (this.target = r, this.targetPath = fs.collect(r, e.viewDomNode)) : (this.target = null, this.targetPath = new Uint8Array(0));
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  _getMouseColumn(e = null) {
    return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? _t.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
  }
  fulfillUnknown(e = null) {
    return fi.createUnknown(this.target, this._getMouseColumn(e), e);
  }
  fulfillTextarea() {
    return fi.createTextarea(this.target, this._getMouseColumn());
  }
  fulfillMargin(e, t, i, n) {
    return fi.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
  }
  fulfillViewZone(e, t, i) {
    return fi.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
  }
  fulfillContentText(e, t, i) {
    return fi.createContentText(this.target, this._getMouseColumn(e), e, t, i);
  }
  fulfillContentEmpty(e, t) {
    return fi.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
  }
  fulfillContentWidget(e) {
    return fi.createContentWidget(this.target, this._getMouseColumn(), e);
  }
  fulfillScrollbar(e) {
    return fi.createScrollbar(this.target, this._getMouseColumn(e), e);
  }
  fulfillOverlayWidget(e) {
    return fi.createOverlayWidget(this.target, this._getMouseColumn(), e);
  }
  withTarget(e) {
    return new Xb(this._ctx, this.editorPos, this.pos, this.relativePos, e);
  }
}
const aS = { isAfterLines: !0 };
function fp(s) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: s
  };
}
class Wt {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = fs.collect(t, this._viewHelper.viewDomNode);
    return !!(ln.isChildOfContentWidgets(i) || ln.isChildOfOverflowingContentWidgets(i) || ln.isChildOfOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, n, r) {
    const o = new $l(this._context, this._viewHelper, e), a = new Xb(o, t, i, n, r);
    try {
      return Wt._createMouseTarget(o, a, !1);
    } catch {
      return a.fulfillUnknown();
    }
  }
  static _createMouseTarget(e, t, i) {
    if (t.target === null) {
      if (i)
        return t.fulfillUnknown();
      const o = Wt._doHitTest(e, t);
      return o.type === 1 ? Wt.createMouseTargetFromHitTestPosition(e, t, o.spanNode, o.position, o.injectedText) : this._createMouseTarget(e, t.withTarget(o.hitTarget), !0);
    }
    const n = t;
    let r = null;
    return r = r || Wt._hitTestContentWidget(e, n), r = r || Wt._hitTestOverlayWidget(e, n), r = r || Wt._hitTestMinimap(e, n), r = r || Wt._hitTestScrollbarSlider(e, n), r = r || Wt._hitTestViewZone(e, n), r = r || Wt._hitTestMargin(e, n), r = r || Wt._hitTestViewCursor(e, n), r = r || Wt._hitTestTextArea(e, n), r = r || Wt._hitTestViewLines(e, n, i), r = r || Wt._hitTestScrollbar(e, n), r || t.fulfillUnknown();
  }
  static _hitTestContentWidget(e, t) {
    if (ln.isChildOfContentWidgets(t.targetPath) || ln.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (ln.isChildOfOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const n of i)
        if (t.target === n.domNode)
          return t.fulfillContentText(n.position, null, { mightBeForeignElement: !1, injectedText: null });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, r = t.mouseVerticalOffset;
      for (const o of i) {
        if (n < o.contentLeft || n > o.contentLeft + o.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(o.position.lineNumber);
        if (a <= r && r <= a + o.height)
          return t.fulfillContentText(o.position, null, { mightBeForeignElement: !1, injectedText: null });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const n = t.isInContentArea ? 8 : 5;
      return t.fulfillViewZone(n, i.position, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return ln.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1, injectedText: null }) : t.fulfillTextarea() : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
      let r = Math.abs(t.relativePos.x);
      const o = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: r
      };
      return r -= e.layoutInfo.glyphMarginLeft, r <= e.layoutInfo.glyphMarginWidth ? t.fulfillMargin(2, n, i.range, o) : (r -= e.layoutInfo.glyphMarginWidth, r <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, o) : (r -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, o)));
    }
    return null;
  }
  static _hitTestViewLines(e, t, i) {
    if (!ln.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfillContentEmpty(new O(1, 1), aS);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const r = e.viewModel.getLineCount(), o = e.viewModel.getLineMaxColumn(r);
      return t.fulfillContentEmpty(new O(r, o), aS);
    }
    if (i) {
      if (ln.isStrictChildOfViewLines(t.targetPath)) {
        const r = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
        if (e.viewModel.getLineLength(r) === 0) {
          const a = e.getLineWidth(r), l = fp(t.mouseContentHorizontalOffset - a);
          return t.fulfillContentEmpty(new O(r, 1), l);
        }
        const o = e.getLineWidth(r);
        if (t.mouseContentHorizontalOffset >= o) {
          const a = fp(t.mouseContentHorizontalOffset - o), l = new O(r, e.viewModel.getLineMaxColumn(r));
          return t.fulfillContentEmpty(l, a);
        }
      }
      return t.fulfillUnknown();
    }
    const n = Wt._doHitTest(e, t);
    return n.type === 1 ? Wt.createMouseTargetFromHitTestPosition(e, t, n.spanNode, n.position, n.injectedText) : this._createMouseTarget(e, t.withTarget(n.hitTarget), !0);
  }
  static _hitTestMinimap(e, t) {
    if (ln.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new O(i, n));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (ln.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), r = e.viewModel.getLineMaxColumn(n);
        return t.fulfillScrollbar(new O(n, r));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (ln.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new O(i, n));
    }
    return null;
  }
  getMouseColumn(e) {
    const t = this._context.configuration.options, i = t.get(133), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
    return Wt._getMouseColumn(n, t.get(46).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, n, r) {
    const o = n.lineNumber, a = n.column, l = e.getLineWidth(o);
    if (t.mouseContentHorizontalOffset > l) {
      const b = fp(t.mouseContentHorizontalOffset - l);
      return t.fulfillContentEmpty(n, b);
    }
    const c = e.visibleRangeForPosition(o, a);
    if (!c)
      return t.fulfillUnknown(n);
    const h = c.left;
    if (t.mouseContentHorizontalOffset === h)
      return t.fulfillContentText(n, null, { mightBeForeignElement: !!r, injectedText: r });
    const u = [];
    if (u.push({ offset: c.left, column: a }), a > 1) {
      const b = e.visibleRangeForPosition(o, a - 1);
      b && u.push({ offset: b.left, column: a - 1 });
    }
    const d = e.viewModel.getLineMaxColumn(o);
    if (a < d) {
      const b = e.visibleRangeForPosition(o, a + 1);
      b && u.push({ offset: b.left, column: a + 1 });
    }
    u.sort((b, v) => b.offset - v.offset);
    const f = t.pos.toClientCoordinates(), m = i.getBoundingClientRect(), _ = m.left <= f.clientX && f.clientX <= m.right;
    for (let b = 1; b < u.length; b++) {
      const v = u[b - 1], C = u[b];
      if (v.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= C.offset) {
        const w = new N(o, v.column, o, C.column), L = Math.abs(v.offset - t.mouseContentHorizontalOffset), E = Math.abs(C.offset - t.mouseContentHorizontalOffset), k = L < E ? new O(o, v.column) : new O(o, C.column);
        return t.fulfillContentText(k, w, { mightBeForeignElement: !_ || !!r, injectedText: r });
      }
    }
    return t.fulfillContentText(n, null, { mightBeForeignElement: !_ || !!r, injectedText: r });
  }
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), r = e.getVerticalOffsetForLineNumber(i) + Math.floor(e.lineHeight / 2);
    let o = t.pos.y + (r - t.mouseVerticalOffset);
    o <= t.editorPos.y && (o = t.editorPos.y + 1), o >= t.editorPos.y + t.editorPos.height && (o = t.editorPos.y + t.editorPos.height - 1);
    const a = new Qb(t.pos.x, o), l = this._actualDoHitTestWithCaretRangeFromPoint(e, a.toClientCoordinates());
    return l.type === 1 ? l : this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates());
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = Wl(e.viewDomNode);
    let n;
    if (i ? typeof i.caretRangeFromPoint > "u" ? n = iR(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = document.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer)
      return new Cr();
    const r = n.startContainer;
    if (r.nodeType === r.TEXT_NODE) {
      const o = r.parentNode, a = o ? o.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Jn.CLASS_NAME ? Do.createFromDOMInfo(e, o, n.startOffset) : new Cr(r.parentNode);
    } else if (r.nodeType === r.ELEMENT_NODE) {
      const o = r.parentNode, a = o ? o.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Jn.CLASS_NAME ? Do.createFromDOMInfo(e, r, r.textContent.length) : new Cr(r);
    }
    return new Cr();
  }
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = document.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const n = i.offsetNode.parentNode, r = n ? n.parentNode : null, o = r ? r.parentNode : null;
      return (o && o.nodeType === o.ELEMENT_NODE ? o.className : null) === Jn.CLASS_NAME ? Do.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new Cr(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const n = i.offsetNode.parentNode, r = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, o = n ? n.parentNode : null, a = o && o.nodeType === o.ELEMENT_NODE ? o.className : null;
      if (r === Jn.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return Do.createFromDOMInfo(e, l, 0);
      } else if (a === Jn.CLASS_NAME)
        return Do.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new Cr(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), r = Kh.atomicPosition(i, e.column - 1, n, 2);
    return r !== -1 ? new O(e.lineNumber, r + 1) : e;
  }
  static _doHitTest(e, t) {
    let i = new Cr();
    if (typeof document.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : document.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates())), i.type === 1) {
      const n = e.viewModel.getInjectedTextAt(i.position), r = e.viewModel.normalizePosition(i.position, 2);
      (n || !r.equals(i.position)) && (i = new O1(r, i.spanNode, n));
    }
    return i.type === 1 && e.stickyTabStops && (i = new O1(this._snapToSoftTabBoundary(i.position, e.viewModel), i.spanNode, i.injectedText)), i;
  }
}
function iR(s, e, t) {
  const i = document.createRange();
  let n = s.elementFromPoint(e, t);
  if (n !== null) {
    for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; )
      n = n.lastChild;
    const r = n.getBoundingClientRect(), o = window.getComputedStyle(n, null).getPropertyValue("font"), a = n.innerText;
    let l = r.left, c = 0, h;
    if (e > r.left + r.width)
      c = a.length;
    else {
      const u = Vo.getInstance();
      for (let d = 0; d < a.length + 1; d++) {
        if (h = u.getCharWidth(a.charAt(d), o) / 2, l += h, e < l) {
          c = d;
          break;
        }
        l += h;
      }
    }
    i.setStart(n.firstChild, c), i.setEnd(n.firstChild, c);
  }
  return i;
}
class Vo {
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  static getInstance() {
    return Vo._INSTANCE || (Vo._INSTANCE = new Vo()), Vo._INSTANCE;
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const n = this._canvas.getContext("2d");
    n.font = t;
    const o = n.measureText(e).width;
    return this._cache[i] = o, o;
  }
}
Vo._INSTANCE = null;
class Jb extends Ru {
  constructor(e, t, i) {
    super(), this._mouseLeaveMonitor = null, this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new Wt(this._context, i), this._mouseDownOperation = this._register(new nR(this._context, this.viewController, this.viewHelper, (a, l) => this._createMouseTarget(a, l), (a) => this._getMouseColumn(a))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(133).height;
    const n = new z7(this.viewHelper.viewDomNode);
    this._register(n.onContextMenu(this.viewHelper.viewDomNode, (a) => this._onContextMenu(a, !0))), this._register(n.onMouseMove(this.viewHelper.viewDomNode, (a) => {
      this._onMouseMove(a), this._mouseLeaveMonitor || (this._mouseLeaveMonitor = H(document, "mousemove", (l) => {
        this.viewHelper.viewDomNode.contains(l.target) || this._onMouseLeave(new io(l, !1, this.viewHelper.viewDomNode));
      }));
    })), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (a) => this._onMouseUp(a))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (a) => this._onMouseLeave(a)));
    let r = 0;
    this._register(n.onPointerDown(this.viewHelper.viewDomNode, (a, l) => {
      r = l;
    })), this._register(H(this.viewHelper.viewDomNode, $.POINTER_UP, (a) => {
      this._mouseDownOperation.onPointerUp();
    })), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (a) => this._onMouseDown(a, r)));
    const o = (a) => {
      if (this.viewController.emitMouseWheel(a), !this._context.configuration.options.get(70))
        return;
      const l = new Vl(a);
      if (Ie ? (a.metaKey || a.ctrlKey) && !a.shiftKey && !a.altKey : a.ctrlKey && !a.metaKey && !a.shiftKey && !a.altKey) {
        const h = pf.getZoomLevel(), u = l.deltaY > 0 ? 1 : -1;
        pf.setZoomLevel(h + u), l.preventDefault(), l.stopPropagation();
      }
    };
    this._register(H(this.viewHelper.viewDomNode, $.MOUSE_WHEEL, o, { capture: !0, passive: !1 })), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), super.dispose();
  }
  onConfigurationChanged(e) {
    if (e.hasChanged(133)) {
      const t = this._context.configuration.options.get(133).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onScrollChanged(e) {
    return this._mouseDownOperation.onScrollChanged(), !1;
  }
  getTargetAtClientPoint(e, t) {
    const n = new WD(e, t).toPageCoordinates(), r = HD(this.viewHelper.viewDomNode);
    if (n.y < r.y || n.y > r.y + r.height || n.x < r.x || n.x > r.x + r.width)
      return null;
    const o = zD(this.viewHelper.viewDomNode, r, n);
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), r, n, o, null);
  }
  _createMouseTarget(e, t) {
    let i = e.target;
    if (!this.viewHelper.viewDomNode.contains(i)) {
      const n = Wl(this.viewHelper.viewDomNode);
      n && (i = n.elementsFromPoint(e.posx, e.posy).find((r) => this.viewHelper.viewDomNode.contains(r)));
    }
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.relativePos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault(), !(this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime) && this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), this.lastMouseLeaveTime = new Date().getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e, t) {
    const i = this._createMouseTarget(e, !0), n = i.type === 6 || i.type === 7, r = i.type === 2 || i.type === 3 || i.type === 4, o = i.type === 3, a = this._context.configuration.options.get(100), l = i.type === 8 || i.type === 5, c = i.type === 9;
    let h = e.leftButton || e.middleButton;
    Ie && e.leftButton && e.ctrlKey && (h = !1);
    const u = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (h && (n || o && a))
      u(), this._mouseDownOperation.start(i.type, e, t);
    else if (r)
      e.preventDefault();
    else if (l) {
      const d = i.detail;
      h && this.viewHelper.shouldSuppressMouseDownOnViewZone(d.viewZoneId) && (u(), this._mouseDownOperation.start(i.type, e, t), e.preventDefault());
    } else
      c && this.viewHelper.shouldSuppressMouseDownOnWidget(i.detail) && (u(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: i
    });
  }
}
class nR extends z {
  constructor(e, t, i, n, r) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._createMouseTarget = n, this._getMouseColumn = r, this._mouseMoveMonitor = this._register(new $7(this._viewHelper.viewDomNode)), this._onScrollTimeout = this._register(new oo()), this._mouseState = new rm(), this._currentSelection = new Ce(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !1);
    !t || (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : this._dispatchMouse(t, !0));
  }
  start(e, t, i) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(e === 3), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const n = this._findMousePosition(t, !0);
    if (!n || !n.position)
      return;
    this._mouseState.trySetCount(t.detail, n.position), t.detail = this._mouseState.count;
    const r = this._context.configuration.options;
    if (!r.get(83) && r.get(31) && !r.get(18) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && n.type === 6 && n.position && this._currentSelection.containsPosition(n.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (o) => this._onMouseDownThenMove(o), (o) => {
        const a = this._findMousePosition(this._lastMouseEvent, !1);
        o && o instanceof KeyboardEvent ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: a ? this._createMouseTarget(this._lastMouseEvent, !0) : null
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(n, t.shiftKey), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (o) => this._onMouseDownThenMove(o), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._onScrollTimeout.cancel();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onPointerUp() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onScrollChanged() {
    !this._isActive || this._onScrollTimeout.setIfNotSet(() => {
      if (!this._lastMouseEvent)
        return;
      const e = this._findMousePosition(this._lastMouseEvent, !1);
      !e || this._mouseState.isDragAndDrop || this._dispatchMouse(e, !0);
    }, 10);
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, r = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = Math.max(n.getCurrentScrollTop() - (t.y - e.posy), 0), l = $l.getZoneAtCoord(this._context, a);
      if (l) {
        const h = this._helpPositionJumpOverViewZone(l);
        if (h)
          return fi.createOutsideEditor(r, h);
      }
      const c = n.getLineNumberAtVerticalOffset(a);
      return fi.createOutsideEditor(r, new O(c, 1));
    }
    if (e.posy > t.y + t.height) {
      const a = n.getCurrentScrollTop() + e.relativePos.y, l = $l.getZoneAtCoord(this._context, a);
      if (l) {
        const h = this._helpPositionJumpOverViewZone(l);
        if (h)
          return fi.createOutsideEditor(r, h);
      }
      const c = n.getLineNumberAtVerticalOffset(a);
      return fi.createOutsideEditor(r, new O(c, i.getLineMaxColumn(c)));
    }
    const o = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
    return e.posx < t.x ? fi.createOutsideEditor(r, new O(o, 1)) : e.posx > t.x + t.width ? fi.createOutsideEditor(r, new O(o, i.getLineMaxColumn(o))) : null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const n = this._createMouseTarget(e, t);
    if (!n.position)
      return null;
    if (n.type === 8 || n.type === 5) {
      const o = this._helpPositionJumpOverViewZone(n.detail);
      if (o)
        return fi.createViewZone(n.type, n.element, n.mouseColumn, o, n.detail);
    }
    return n;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new O(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
    return i && n ? i.isBefore(t) ? i : n : null;
  }
  _dispatchMouse(e, t) {
    !e.position || this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton,
      onInjectedText: e.type === 6 && e.detail.injectedText !== null
    });
  }
}
class rm {
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = new Date().getTime();
    i - this._lastSetMouseDownCountTime > rm.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
}
rm.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
class Mt {
  constructor(e, t, i, n, r) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selectionStartPosition = n, this.selectionEndPosition = r;
  }
  toString() {
    return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
  }
  static readFromTextArea(e) {
    return new Mt(e.getValue(), e.getSelectionStart(), e.getSelectionEnd(), null, null);
  }
  collapseSelection() {
    return new Mt(this.value, this.value.length, this.value.length, null, null);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    if (e <= this.selectionStart) {
      const n = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition(this.selectionStartPosition, n, -1);
    }
    if (e >= this.selectionEnd) {
      const n = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition(this.selectionEndPosition, n, 1);
    }
    const t = this.value.substring(this.selectionStart, e);
    if (t.indexOf(String.fromCharCode(8230)) === -1)
      return this._finishDeduceEditorPosition(this.selectionStartPosition, t, 1);
    const i = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition(this.selectionEndPosition, i, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let n = 0, r = -1;
    for (; (r = t.indexOf(`
`, r + 1)) !== -1; )
      n++;
    return [e, i * t.length, n];
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    const n = Math.min(i1(e.value, t.value), e.selectionStart, t.selectionStart), r = Math.min(n1(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
    e.value.substring(n, e.value.length - r);
    const o = t.value.substring(n, t.value.length - r), a = e.selectionStart - n, l = e.selectionEnd - n, c = t.selectionStart - n, h = t.selectionEnd - n;
    if (c === h) {
      const d = e.selectionStart - n;
      return {
        text: o,
        replacePrevCharCnt: d,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const u = l - a;
    return {
      text: o,
      replacePrevCharCnt: u,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(i1(e.value, t.value), e.selectionEnd), n = Math.min(n1(e.value, t.value), e.value.length - e.selectionEnd), r = e.value.substring(i, e.value.length - n), o = t.value.substring(i, t.value.length - n);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: o,
      replacePrevCharCnt: a,
      replaceNextCharCnt: r.length - a,
      positionDelta: l - o.length
    };
  }
}
Mt.EMPTY = new Mt("", 0, 0, null, null);
class il {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, n = i + 1, r = i + t;
    return new N(n, 1, r + 1, 1);
  }
  static fromEditorSelection(e, t, i, n, r) {
    const o = il._getPageOfLine(i.startLineNumber, n), a = il._getRangeForPage(o, n), l = il._getPageOfLine(i.endLineNumber, n), c = il._getRangeForPage(l, n), h = a.intersectRanges(new N(1, 1, i.startLineNumber, i.startColumn));
    let u = t.getValueInRange(h, 1);
    const d = t.getLineCount(), f = t.getLineMaxColumn(d), m = c.intersectRanges(new N(i.endLineNumber, i.endColumn, d, f));
    let _ = t.getValueInRange(m, 1), b;
    if (o === l || o + 1 === l)
      b = t.getValueInRange(i, 1);
    else {
      const v = a.intersectRanges(i), C = c.intersectRanges(i);
      b = t.getValueInRange(v, 1) + String.fromCharCode(8230) + t.getValueInRange(C, 1);
    }
    return r && (u.length > 500 && (u = u.substring(u.length - 500, u.length)), _.length > 500 && (_ = _.substring(0, 500)), b.length > 2 * 500 && (b = b.substring(0, 500) + String.fromCharCode(8230) + b.substring(b.length - 500, b.length))), new Mt(u + b + _, u.length, u.length + b.length, new O(i.startLineNumber, i.startColumn), new O(i.endLineNumber, i.endColumn));
  }
}
var Af;
(function(s) {
  s.Tap = "-monaco-textarea-synthetic-tap";
})(Af || (Af = {}));
class Rf {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
}
Rf.INSTANCE = new Rf();
class sR {
  constructor() {
    this._lastTypeTextLength = 0;
  }
  handleCompositionUpdate(e) {
    e = e || "";
    const t = {
      text: e,
      replacePrevCharCnt: this._lastTypeTextLength,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
    return this._lastTypeTextLength = e.length, t;
  }
}
class rR extends z {
  constructor(e, t, i, n) {
    super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._onFocus = this._register(new A()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new A()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new A()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new A()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new A()), this.onCut = this._onCut.event, this._onPaste = this._register(new A()), this.onPaste = this._onPaste.event, this._onType = this._register(new A()), this.onType = this._onType.event, this._onCompositionStart = this._register(new A()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new A()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new A()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new A()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncTriggerCut = this._register(new oi(() => this._onCut.fire(), 0)), this._asyncFocusGainWriteScreenReaderContent = this._register(new oi(() => this.writeScreenReaderContent("asyncFocusGain"), 0)), this._textAreaState = Mt.EMPTY, this._selectionChangeListener = null, this.writeScreenReaderContent("ctor"), this._hasFocus = !1, this._currentComposition = null;
    let r = null;
    this._register(this._textArea.onKeyDown((o) => {
      const a = new nt(o);
      (a.keyCode === 109 || this._currentComposition && a.keyCode === 1) && a.stopPropagation(), a.equals(9) && a.preventDefault(), r = a, this._onKeyDown.fire(a);
    })), this._register(this._textArea.onKeyUp((o) => {
      const a = new nt(o);
      this._onKeyUp.fire(a);
    })), this._register(this._textArea.onCompositionStart((o) => {
      const a = new sR();
      if (this._currentComposition) {
        this._currentComposition = a;
        return;
      }
      if (this._currentComposition = a, this._OS === 2 && r && r.equals(109) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === o.data && (r.code === "ArrowRight" || r.code === "ArrowLeft")) {
        a.handleCompositionUpdate("x"), this._onCompositionStart.fire({ data: o.data });
        return;
      }
      if (this._browser.isAndroid) {
        this._onCompositionStart.fire({ data: o.data });
        return;
      }
      this._onCompositionStart.fire({ data: o.data });
    })), this._register(this._textArea.onCompositionUpdate((o) => {
      const a = this._currentComposition;
      if (!a)
        return;
      if (this._browser.isAndroid) {
        const c = Mt.readFromTextArea(this._textArea), h = Mt.deduceAndroidCompositionInput(this._textAreaState, c);
        this._textAreaState = c, this._onType.fire(h), this._onCompositionUpdate.fire(o);
        return;
      }
      const l = a.handleCompositionUpdate(o.data);
      this._textAreaState = Mt.readFromTextArea(this._textArea), this._onType.fire(l), this._onCompositionUpdate.fire(o);
    })), this._register(this._textArea.onCompositionEnd((o) => {
      const a = this._currentComposition;
      if (!a)
        return;
      if (this._currentComposition = null, this._browser.isAndroid) {
        const c = Mt.readFromTextArea(this._textArea), h = Mt.deduceAndroidCompositionInput(this._textAreaState, c);
        this._textAreaState = c, this._onType.fire(h), this._onCompositionEnd.fire();
        return;
      }
      const l = a.handleCompositionUpdate(o.data);
      this._textAreaState = Mt.readFromTextArea(this._textArea), this._onType.fire(l), this._onCompositionEnd.fire();
    })), this._register(this._textArea.onInput((o) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition)
        return;
      const a = Mt.readFromTextArea(this._textArea), l = Mt.deduceInput(this._textAreaState, a, this._OS === 2);
      l.replacePrevCharCnt === 0 && l.text.length === 1 && Lt(l.text.charCodeAt(0)) || (this._textAreaState = a, (l.text !== "" || l.replacePrevCharCnt !== 0 || l.replaceNextCharCnt !== 0 || l.positionDelta !== 0) && this._onType.fire(l));
    })), this._register(this._textArea.onCut((o) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(o), this._asyncTriggerCut.schedule();
    })), this._register(this._textArea.onCopy((o) => {
      this._ensureClipboardGetsEditorSelection(o);
    })), this._register(this._textArea.onPaste((o) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), o.preventDefault(), !o.clipboardData)
        return;
      let [a, l] = lS.getTextData(o.clipboardData);
      !a || (l = l || Rf.INSTANCE.get(a), this._onPaste.fire({
        text: a,
        metadata: l
      }));
    })), this._register(this._textArea.onFocus(() => {
      const o = this._hasFocus;
      this._setHasFocus(!0), this._browser.isSafari && !o && this._hasFocus && this._asyncFocusGainWriteScreenReaderContent.schedule();
    })), this._register(this._textArea.onBlur(() => {
      this._currentComposition && (this._currentComposition = null, this.writeScreenReaderContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(this._textArea.onSyntheticTap(() => {
      this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeScreenReaderContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return H(document, "selectionchange", (t) => {
      if (!this._hasFocus || this._currentComposition || !this._browser.isChrome)
        return;
      const i = Date.now(), n = i - e;
      if (e = i, n < 5)
        return;
      const r = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), r < 100 || !this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition)
        return;
      const o = this._textArea.getValue();
      if (this._textAreaState.value !== o)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const c = this._textAreaState.deduceEditorPosition(a), h = this._host.deduceModelPosition(c[0], c[1], c[2]), u = this._textAreaState.deduceEditorPosition(l), d = this._host.deduceModelPosition(u[0], u[1], u[2]), f = new Ce(h.lineNumber, h.column, d.lineNumber, d.column);
      this._onSelectionChangeRequest.fire(f);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    this._setHasFocus(this._textArea.hasFocus());
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeScreenReaderContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeScreenReaderContent(e) {
    this._currentComposition || this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent(this._textAreaState));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    Rf.INSTANCE.set(
      this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), e.preventDefault(), e.clipboardData && lS.setTextData(e.clipboardData, t.text, t.html, i);
  }
}
class lS {
  static getTextData(e) {
    const t = e.getData(zs.text);
    let i = null;
    const n = e.getData("vscode-editor-data");
    if (typeof n == "string")
      try {
        i = JSON.parse(n), i.version !== 1 && (i = null);
      } catch {
      }
    return t.length === 0 && i === null && e.files.length > 0 ? [Array.prototype.slice.call(e.files, 0).map((o) => o.name).join(`
`), null] : [t, i];
  }
  static setTextData(e, t, i, n) {
    e.setData(zs.text, t), typeof i == "string" && e.setData("text/html", i), e.setData("vscode-editor-data", JSON.stringify(n));
  }
}
class oR extends z {
  constructor(e) {
    super(), this._actual = e, this.onKeyDown = this._register(wn(this._actual, "keydown")).event, this.onKeyUp = this._register(wn(this._actual, "keyup")).event, this.onCompositionStart = this._register(wn(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(wn(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(wn(this._actual, "compositionend")).event, this.onInput = this._register(wn(this._actual, "input")).event, this.onCut = this._register(wn(this._actual, "cut")).event, this.onCopy = this._register(wn(this._actual, "copy")).event, this.onPaste = this._register(wn(this._actual, "paste")).event, this.onFocus = this._register(wn(this._actual, "focus")).event, this.onBlur = this._register(wn(this._actual, "blur")).event, this._onSyntheticTap = this._register(new A()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(H(this._actual, Af.Tap, () => this._onSyntheticTap.fire()));
  }
  hasFocus() {
    const e = Wl(this._actual);
    return e ? e.activeElement === this._actual : Y2(this._actual) ? document.activeElement === this._actual : !1;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.value;
  }
  setValue(e, t) {
    const i = this._actual;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const n = this._actual;
    let r = null;
    const o = Wl(n);
    o ? r = o.activeElement : r = document.activeElement;
    const a = r === n, l = n.selectionStart, c = n.selectionEnd;
    if (a && l === t && c === i) {
      sn && window.parent !== window && n.focus();
      return;
    }
    if (a) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), sn && window.parent !== window && n.focus();
      return;
    }
    try {
      const h = $M(n);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), jM(n, h);
    } catch {
    }
  }
}
class aR extends Jb {
  constructor(e, t, i) {
    super(e, t, i), this._register(Ne.addTarget(this.viewHelper.linesContentDomNode)), this._register(H(this.viewHelper.linesContentDomNode, We.Tap, (r) => this.onTap(r))), this._register(H(this.viewHelper.linesContentDomNode, We.Change, (r) => this.onChange(r))), this._register(H(this.viewHelper.linesContentDomNode, We.Contextmenu, (r) => this._onContextMenu(new io(r, !1, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(H(this.viewHelper.linesContentDomNode, "pointerdown", (r) => {
      const o = r.pointerType;
      if (o === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else
        o === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const n = new U7(this.viewHelper.viewDomNode);
    this._register(n.onPointerMove(this.viewHelper.viewDomNode, (r) => this._onMouseMove(r))), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (r) => this._onMouseUp(r))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (r) => this._onMouseLeave(r))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (r, o) => this._onMouseDown(r, o)));
  }
  onTap(e) {
    if (!e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget))
      return;
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new io(e, !1, this.viewHelper.viewDomNode), !1);
    t.position && this.viewController.dispatchMouse({
      position: t.position,
      mouseColumn: t.position.column,
      startedOnLineNumbers: !1,
      mouseDownCount: e.tapCount,
      inSelectionMode: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1,
      onInjectedText: t.type === 6 && t.detail.injectedText !== null
    });
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
  }
  _onMouseDown(e, t) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e, t);
  }
}
class lR extends Jb {
  constructor(e, t, i) {
    super(e, t, i), this._register(Ne.addTarget(this.viewHelper.linesContentDomNode)), this._register(H(this.viewHelper.linesContentDomNode, We.Tap, (n) => this.onTap(n))), this._register(H(this.viewHelper.linesContentDomNode, We.Change, (n) => this.onChange(n))), this._register(H(this.viewHelper.linesContentDomNode, We.Contextmenu, (n) => this._onContextMenu(new io(n, !1, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new io(e, !1, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(Af.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(t.position);
    }
  }
  onChange(e) {
    this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class cR extends z {
  constructor(e, t, i) {
    super(), Ml && K2.pointerEvents ? this.handler = this._register(new aR(e, t, i)) : window.TouchEvent ? this.handler = this._register(new lR(e, t, i)) : this.handler = this._register(new Jb(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class pc extends Ru {
}
const jD = x("editor.lineHighlightBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("lineHighlight", "Background color for the highlight of line at the cursor position.")), cS = x("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hcDark: "#f38518", hcLight: ve }, p("lineHighlightBorderBox", "Background color for the border around the line at the cursor position.")), hR = x("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hcDark: null, hcLight: null }, p("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0), uR = x("editor.rangeHighlightBorder", { dark: null, light: null, hcDark: ht, hcLight: ht }, p("rangeHighlightBorder", "Background color of the border around highlighted ranges."), !0), dR = x("editor.symbolHighlightBackground", { dark: Or, light: Or, hcDark: null, hcLight: null }, p("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0), fR = x("editor.symbolHighlightBorder", { dark: null, light: null, hcDark: ht, hcLight: ht }, p("symbolHighlightBorder", "Background color of the border around highlighted symbols."), !0), KD = x("editorCursor.foreground", { dark: "#AEAFAD", light: R.black, hcDark: R.white, hcLight: "#0F4A85" }, p("caret", "Color of the editor cursor.")), gR = x("editorCursor.background", null, p("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), Js = x("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hcDark: "#e3e4e229", hcLight: "#CCCCCC" }, p("editorWhitespaces", "Color of whitespace characters in the editor.")), Pu = x("editorIndentGuide.background", { dark: Js, light: Js, hcDark: Js, hcLight: Js }, p("editorIndentGuides", "Color of the editor indentation guides.")), Ou = x("editorIndentGuide.activeBackground", { dark: Js, light: Js, hcDark: Js, hcLight: Js }, p("editorActiveIndentGuide", "Color of the active editor indentation guides.")), qD = x("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hcDark: R.white, hcLight: "#292929" }, p("editorLineNumbers", "Color of editor line numbers.")), ld = x("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hcDark: ht, hcLight: ht }, p("editorActiveLineNumber", "Color of editor active line number"), !1, p("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead.")), mR = x("editorLineNumber.activeForeground", { dark: ld, light: ld, hcDark: ld, hcLight: ld }, p("editorActiveLineNumber", "Color of editor active line number")), pR = x("editorRuler.foreground", { dark: "#5A5A5A", light: R.lightgrey, hcDark: R.white, hcLight: "#292929" }, p("editorRuler", "Color of the editor rulers."));
x("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hcDark: "#999999", hcLight: "#292929" }, p("editorCodeLensForeground", "Foreground color of editor CodeLens"));
x("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hcDark: "#0064001a", hcLight: "#0000" }, p("editorBracketMatchBackground", "Background color behind matching brackets"));
x("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hcDark: ve, hcLight: ve }, p("editorBracketMatchBorder", "Color for matching brackets boxes"));
const _R = x("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hcDark: "#7f7f7f4d", hcLight: "#666666" }, p("editorOverviewRulerBorder", "Color of the overview ruler border.")), bR = x("editorOverviewRuler.background", null, p("editorOverviewRulerBackground", "Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.")), CR = x("editorGutter.background", { dark: $t, light: $t, hcDark: $t, hcLight: $t }, p("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.")), vR = x("editorUnnecessaryCode.border", { dark: null, light: null, hcDark: R.fromHex("#fff").transparent(0.8), hcLight: ve }, p("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor.")), wR = x("editorUnnecessaryCode.opacity", { dark: R.fromHex("#000a"), light: R.fromHex("#0007"), hcDark: null, hcLight: null }, p("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
x("editorGhostText.border", { dark: null, light: null, hcDark: R.fromHex("#fff").transparent(0.8), hcLight: R.fromHex("#292929").transparent(0.8) }, p("editorGhostTextBorder", "Border color of ghost text in the editor."));
x("editorGhostText.foreground", { dark: R.fromHex("#ffffff56"), light: R.fromHex("#0007"), hcDark: null, hcLight: null }, p("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
x("editorGhostText.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorGhostTextBackground", "Background color of the ghost text in the editor."));
const cd = new R(new _e(0, 122, 204, 0.6));
x("editorOverviewRuler.rangeHighlightForeground", { dark: cd, light: cd, hcDark: cd, hcLight: cd }, p("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const SR = x("editorOverviewRuler.errorForeground", { dark: new R(new _e(255, 18, 18, 0.7)), light: new R(new _e(255, 18, 18, 0.7)), hcDark: new R(new _e(255, 50, 50, 1)), hcLight: "#B5200D" }, p("overviewRuleError", "Overview ruler marker color for errors.")), yR = x("editorOverviewRuler.warningForeground", { dark: Xi, light: Xi, hcDark: jh, hcLight: jh }, p("overviewRuleWarning", "Overview ruler marker color for warnings.")), LR = x("editorOverviewRuler.infoForeground", { dark: Mn, light: Mn, hcDark: A1, hcLight: A1 }, p("overviewRuleInfo", "Overview ruler marker color for infos.")), GD = x("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hcDark: "#FFD700", hcLight: "#0431FAFF" }, p("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), ZD = x("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hcDark: "#DA70D6", hcLight: "#319331FF" }, p("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), YD = x("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hcDark: "#87CEFA", hcLight: "#7B3814FF" }, p("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), QD = x("editorBracketHighlight.foreground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), XD = x("editorBracketHighlight.foreground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), JD = x("editorBracketHighlight.foreground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), kR = x("editorBracketHighlight.unexpectedBracket.foreground", { dark: new R(new _e(255, 18, 18, 0.8)), light: new R(new _e(255, 18, 18, 0.8)), hcDark: new R(new _e(255, 50, 50, 1)), hcLight: "" }, p("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), DR = x("editorBracketPairGuide.background1", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), ER = x("editorBracketPairGuide.background2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), xR = x("editorBracketPairGuide.background3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), IR = x("editorBracketPairGuide.background4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), NR = x("editorBracketPairGuide.background5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), TR = x("editorBracketPairGuide.background6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), MR = x("editorBracketPairGuide.activeBackground1", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), AR = x("editorBracketPairGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), RR = x("editorBracketPairGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), PR = x("editorBracketPairGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), OR = x("editorBracketPairGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), FR = x("editorBracketPairGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
x("editorUnicodeHighlight.border", { dark: "#BD9B03", light: "#CEA33D", hcDark: "#ff0000", hcLight: "" }, p("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
x("editorUnicodeHighlight.background", { dark: "#bd9b0326", light: "#cea33d14", hcDark: "#00000000", hcLight: "" }, p("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
zi((s, e) => {
  const t = s.getColor($t);
  t && e.addRule(`.monaco-editor, .monaco-editor-background { background-color: ${t}; }`);
  const i = s.getColor(jD), n = i && !i.isTransparent() ? i : t;
  n && e.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${n}; }`);
  const r = s.getColor(mc);
  r && e.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${r}; }`);
  const o = s.getColor(CR);
  o && e.addRule(`.monaco-editor .margin { background-color: ${o}; }`);
  const a = s.getColor(hR);
  a && e.addRule(`.monaco-editor .rangeHighlight { background-color: ${a}; }`);
  const l = s.getColor(uR);
  l && e.addRule(`.monaco-editor .rangeHighlight { border: 1px ${cs(s.type) ? "dotted" : "solid"} ${l}; }`);
  const c = s.getColor(dR);
  c && e.addRule(`.monaco-editor .symbolHighlight { background-color: ${c}; }`);
  const h = s.getColor(fR);
  h && e.addRule(`.monaco-editor .symbolHighlight { border: 1px ${cs(s.type) ? "dotted" : "solid"} ${h}; }`);
  const u = s.getColor(Js);
  u && (e.addRule(`.monaco-editor .mtkw { color: ${u} !important; }`), e.addRule(`.monaco-editor .mtkz { color: ${u} !important; }`));
});
class jl extends pc {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new O(1, 1), this._lastCursorViewPosition = new O(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(61);
    const t = e.get(62);
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(86);
    const i = e.get(133);
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorViewPosition = t, this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  _getLineRenderLineNumber(e) {
    const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new O(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    return this._renderCustomLineNumbers ? this._renderCustomLineNumbers(i) : this._renderLineNumbers === 3 ? this._lastCursorModelPosition.lineNumber === i || i % 10 === 0 ? String(i) : "" : String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = _i ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, r = '<div class="' + jl.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">';
    let o = null;
    if (this._renderLineNumbers === 2) {
      o = new Array(n - i + 1), this._lastCursorViewPosition.lineNumber >= i && this._lastCursorViewPosition.lineNumber <= n && (o[this._lastCursorViewPosition.lineNumber - i] = this._lastCursorModelPosition.lineNumber);
      {
        let c = 0;
        for (let h = this._lastCursorViewPosition.lineNumber + 1; h <= n; h++) {
          const d = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new O(h, 1)).column !== 1;
          d || c++, h >= i && (o[h - i] = d ? 0 : c);
        }
      }
      {
        let c = 0;
        for (let h = this._lastCursorViewPosition.lineNumber - 1; h >= i; h--) {
          const d = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new O(h, 1)).column !== 1;
          d || c++, h <= n && (o[h - i] = d ? 0 : c);
        }
      }
    }
    const a = this._context.viewModel.getLineCount(), l = [];
    for (let c = i; c <= n; c++) {
      const h = c - i;
      if (!this._renderFinalNewline && c === a && this._context.viewModel.getLineLength(c) === 0) {
        l[h] = "";
        continue;
      }
      let u;
      if (o) {
        const d = o[h];
        this._lastCursorViewPosition.lineNumber === c ? u = `<span class="relative-current-line-number">${d}</span>` : d ? u = String(d) : u = "";
      } else
        u = this._getLineRenderLineNumber(c);
      u ? c === this._activeLineNumber ? l[h] = '<div class="active-line-number ' + jl.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">' + u + "</div>" : l[h] = r + u + "</div>" : l[h] = "";
    }
    this._renderResult = l;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
jl.CLASS_NAME = "line-numbers";
zi((s, e) => {
  const t = s.getColor(qD);
  t && e.addRule(`.monaco-editor .line-numbers { color: ${t}; }`);
  const i = s.getColor(mR);
  i && e.addRule(`.monaco-editor .line-numbers.active-line-number { color: ${i}; }`);
});
class Jo extends Ui {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(133);
    this._canUseLayerHinting = !t.get(28), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = me(document.createElement("div")), this._domNode.setClassName(Jo.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = me(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(Jo.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(133);
    return this._canUseLayerHinting = !t.get(28), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
}
Jo.CLASS_NAME = "glyph-margin";
Jo.OUTER_CLASS_NAME = "margin";
const Ko = "monaco-mouse-cursor-text";
class BR {
  constructor(e, t, i, n, r) {
    this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = r, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
  }
  prepareRender(e) {
    const t = new O(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new O(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
    this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
  }
  definePresentation(e) {
    return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
      foreground: 1,
      italic: !1,
      bold: !1,
      underline: !1,
      strikethrough: !1
    }), this._previousPresentation;
  }
}
const Rc = sn;
class VR extends Ui {
  constructor(e, t, i) {
    super(e), this._primaryCursorPosition = new O(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
    const n = this._context.configuration.options, r = n.get(133);
    this._setAccessibilityOptions(n), this._contentLeft = r.contentLeft, this._contentWidth = r.contentWidth, this._contentHeight = r.height, this._fontInfo = n.get(46), this._lineHeight = n.get(61), this._emptySelectionClipboard = n.get(33), this._copyWithSyntaxHighlighting = n.get(21), this._visibleTextArea = null, this._selections = [new Ce(1, 1, 1, 1)], this._modelSelections = [new Ce(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = me(document.createElement("textarea")), fs.write(this.textArea, 6), this.textArea.setClassName(`inputarea ${Ko}`), this.textArea.setAttribute("wrap", "off"), this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(n)), this.textArea.setAttribute("tabindex", String(n.get(114))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", p("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), n.get(30) && n.get(83) && this.textArea.setAttribute("readonly", "true"), this.textAreaCover = me(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const o = {
      getLineCount: () => this._context.viewModel.getLineCount(),
      getLineMaxColumn: (c) => this._context.viewModel.getLineMaxColumn(c),
      getValueInRange: (c, h) => this._context.viewModel.getValueInRange(c, h)
    }, a = {
      getDataToCopy: () => {
        const c = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, Vi), h = this._context.viewModel.model.getEOL(), u = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), d = Array.isArray(c) ? c : null, f = Array.isArray(c) ? c.join(h) : c;
        let m, _ = null;
        if (this._copyWithSyntaxHighlighting && f.length < 65536) {
          const b = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          b && (m = b.html, _ = b.mode);
        }
        return {
          isFromEmptySelection: u,
          multicursorText: d,
          text: f,
          html: m,
          mode: _
        };
      },
      getScreenReaderContent: (c) => {
        if (this._accessibilitySupport === 1) {
          const h = this._selections[0];
          if (Ie && h.isEmpty()) {
            const u = h.getStartPosition();
            let d = this._getWordBeforePosition(u);
            if (d.length === 0 && (d = this._getCharacterBeforePosition(u)), d.length > 0)
              return new Mt(d, d.length, d.length, u, u);
          }
          if (rr && !h.isEmpty()) {
            const u = "vscode-placeholder";
            return new Mt(u, 0, u.length, null, null);
          }
          return Mt.EMPTY;
        }
        if (h2) {
          const h = this._selections[0];
          if (h.isEmpty()) {
            const u = h.getStartPosition(), [d, f] = this._getAndroidWordAtPosition(u);
            if (d.length > 0)
              return new Mt(d, f, f, u, u);
          }
          return Mt.EMPTY;
        }
        return il.fromEditorSelection(c, o, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0);
      },
      deduceModelPosition: (c, h, u) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(c, h, u)
    }, l = this._register(new oR(this.textArea.domNode));
    this._textAreaInput = this._register(new rR(a, l, dn, WT)), this._register(this._textAreaInput.onKeyDown((c) => {
      this._viewController.emitKeyDown(c);
    })), this._register(this._textAreaInput.onKeyUp((c) => {
      this._viewController.emitKeyUp(c);
    })), this._register(this._textAreaInput.onPaste((c) => {
      let h = !1, u = null, d = null;
      c.metadata && (h = this._emptySelectionClipboard && !!c.metadata.isFromEmptySelection, u = typeof c.metadata.multicursorText < "u" ? c.metadata.multicursorText : null, d = c.metadata.mode), this._viewController.paste(c.text, h, u, d);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((c) => {
      c.replacePrevCharCnt || c.replaceNextCharCnt || c.positionDelta ? this._viewController.compositionType(c.text, c.replacePrevCharCnt, c.replaceNextCharCnt, c.positionDelta) : this._viewController.type(c.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((c) => {
      this._viewController.setSelection(c);
    })), this._register(this._textAreaInput.onCompositionStart((c) => {
      const h = this.textArea.domNode, u = this._modelSelections[0], { distanceToModelLineStart: d, widthOfHiddenTextBefore: f } = (() => {
        const _ = h.value.substring(0, Math.min(h.selectionStart, h.selectionEnd)), b = _.lastIndexOf(`
`), v = _.substring(b + 1), C = v.lastIndexOf("	"), w = v.length - C - 1, L = u.getStartPosition(), E = Math.min(L.column - 1, w), k = L.column - 1 - E, y = v.substring(0, v.length - E), S = WR(y, this._fontInfo);
        return { distanceToModelLineStart: k, widthOfHiddenTextBefore: S };
      })(), { distanceToModelLineEnd: m } = (() => {
        const _ = h.value.substring(Math.max(h.selectionStart, h.selectionEnd)), b = _.indexOf(`
`), v = b === -1 ? _ : _.substring(0, b), C = v.indexOf("	"), w = C === -1 ? v.length : v.length - C - 1, L = u.getEndPosition(), E = Math.min(this._context.viewModel.model.getLineMaxColumn(L.lineNumber) - L.column, w);
        return { distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(L.lineNumber) - L.column - E };
      })();
      this._context.viewModel.revealRange("keyboard", !0, N.fromPositions(this._selections[0].getStartPosition()), 0, 1), this._visibleTextArea = new BR(this._context, u.startLineNumber, d, f, m), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${Ko} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((c) => {
      !this._visibleTextArea || (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this._render(), this.textArea.setClassName(`inputarea ${Ko}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.viewModel.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.viewModel.setHasFocus(!1);
    }));
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = Bl(t);
    let r = !0, o = e.column, a = !0, l = e.column, c = 0;
    for (; c < 50 && (r || a); ) {
      if (r && o <= 1 && (r = !1), r) {
        const h = i.charCodeAt(o - 2);
        n.get(h) !== 0 ? r = !1 : o--;
      }
      if (a && l > i.length && (a = !1), a) {
        const h = i.charCodeAt(l - 1);
        n.get(h) !== 0 ? a = !1 : l++;
      }
      c++;
    }
    return [i.substring(o - 1, l - 1), e.column - o];
  }
  _getWordBeforePosition(e) {
    const t = this._context.viewModel.getLineContent(e.lineNumber), i = Bl(this._context.configuration.options.get(119));
    let n = e.column, r = 0;
    for (; n > 1; ) {
      const o = t.charCodeAt(n - 2);
      if (i.get(o) !== 0 || r > 50)
        return t.substring(n - 1, e.column - 1);
      r++, n--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!Lt(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    return e.get(2) === 1 ? p("accessibilityOffAriaLabel", "The editor is not accessible at this time. Press {0} for options.", _i ? "Shift+Alt+F1" : "Alt+F1") : e.get(4);
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(2);
    const t = e.get(3);
    this._accessibilitySupport === 2 && t === oa.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(133);
    return this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(46), this._lineHeight = t.get(61), this._emptySelectionClipboard = t.get(33), this._copyWithSyntaxHighlighting = t.get(21), this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("tabindex", String(t.get(114))), (e.hasChanged(30) || e.hasChanged(83)) && (t.get(30) && t.get(83) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly")), e.hasChanged(2) && this._textAreaInput.writeScreenReaderContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeScreenReaderContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  prepareRender(e) {
    var t;
    this._primaryCursorPosition = new O(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), (t = this._visibleTextArea) === null || t === void 0 || t.prepareRender(e);
  }
  render(e) {
    this._textAreaInput.writeScreenReaderContent("render"), this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      const i = this._visibleTextArea.visibleTextareaStart, n = this._visibleTextArea.visibleTextareaEnd, r = this._visibleTextArea.startPosition, o = this._visibleTextArea.endPosition;
      if (r && o && i && n && n.left >= this._scrollLeft && i.left <= this._scrollLeft + this._contentWidth) {
        const a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, l = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
        let c = this._visibleTextArea.widthOfHiddenLineTextBefore, h = this._contentLeft + i.left - this._scrollLeft, u = n.left - i.left + 1;
        if (h < this._contentLeft) {
          const v = this._contentLeft - h;
          h += v, c += v, u -= v;
        }
        u > this._contentWidth && (u = this._contentWidth);
        const d = this._context.viewModel.getViewLineData(r.lineNumber), f = d.tokens.findTokenIndexAtOffset(r.column - 1), m = d.tokens.findTokenIndexAtOffset(o.column - 1), _ = f === m, b = this._visibleTextArea.definePresentation(_ ? d.tokens.getPresentation(f) : null);
        this.textArea.domNode.scrollTop = l * this._lineHeight, this.textArea.domNode.scrollLeft = c, this._doRender({
          lastRenderPosition: null,
          top: a,
          left: h,
          width: u,
          height: this._lineHeight,
          useCover: !1,
          color: (at.getColorMap() || [])[b.foreground],
          italic: b.italic,
          bold: b.bold,
          underline: b.underline,
          strikethrough: b.strikethrough
        });
      }
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (t < 0 || t > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (Ie) {
      this._doRender({
        lastRenderPosition: this._primaryCursorPosition,
        top: t,
        left: e,
        width: Rc ? 0 : 1,
        height: this._lineHeight,
        useCover: !1
      }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
      const i = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
      this.textArea.domNode.scrollTop = i * this._lineHeight;
      return;
    }
    this._doRender({
      lastRenderPosition: this._primaryCursorPosition,
      top: t,
      left: e,
      width: Rc ? 0 : 1,
      height: Rc ? 0 : 1,
      useCover: !1
    });
  }
  _newlinecount(e) {
    let t = 0, i = -1;
    do {
      if (i = e.indexOf(`
`, i + 1), i === -1)
        break;
      t++;
    } while (!0);
    return t;
  }
  _renderAtTopLeft() {
    this._doRender({
      lastRenderPosition: null,
      top: 0,
      left: 0,
      width: Rc ? 0 : 1,
      height: Rc ? 0 : 1,
      useCover: !0
    });
  }
  _doRender(e) {
    this._lastRenderPosition = e.lastRenderPosition;
    const t = this.textArea, i = this.textAreaCover;
    mi(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? R.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
    const n = this._context.configuration.options;
    n.get(52) ? i.setClassName("monaco-editor-background textAreaCover " + Jo.OUTER_CLASS_NAME) : n.get(62).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + jl.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
  }
}
function WR(s, e) {
  if (s.length === 0)
    return 0;
  const t = document.createElement("div");
  t.style.position = "absolute", t.style.top = "-50000px", t.style.width = "50000px";
  const i = document.createElement("span");
  mi(i, e), i.style.whiteSpace = "pre", i.append(s), t.appendChild(i), document.body.appendChild(t);
  const n = i.offsetWidth;
  return document.body.removeChild(t), n;
}
function HR(s, e, t) {
  let i = 0;
  for (let r = 0; r < s.length; r++)
    s.charAt(r) === "	" ? i = _t.nextIndentTabStop(i, e) : i++;
  let n = "";
  if (!t) {
    const r = Math.floor(i / e);
    i = i % e;
    for (let o = 0; o < r; o++)
      n += "	";
  }
  for (let r = 0; r < i; r++)
    n += " ";
  return n;
}
function eE(s, e, t) {
  let i = Bi(s);
  return i === -1 && (i = s.length), HR(s.substring(0, i), e, t) + s.substring(i);
}
const zR = () => !0, UR = () => !1, $R = (s) => s === " " || s === "	";
class Na {
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
    const r = i.options, o = r.get(133);
    this.readOnly = r.get(83), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = r.get(106), this.lineHeight = r.get(61), this.pageSize = Math.max(1, Math.floor(o.height / this.lineHeight) - 2), this.useTabStops = r.get(118), this.wordSeparators = r.get(119), this.emptySelectionClipboard = r.get(33), this.copyWithSyntaxHighlighting = r.get(21), this.multiCursorMergeOverlapping = r.get(71), this.multiCursorPaste = r.get(73), this.autoClosingBrackets = r.get(5), this.autoClosingQuotes = r.get(8), this.autoClosingDelete = r.get(6), this.autoClosingOvertype = r.get(7), this.autoSurround = r.get(11), this.autoIndent = r.get(9), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: this._getShouldAutoClose(e, this.autoClosingQuotes),
      bracket: this._getShouldAutoClose(e, this.autoClosingBrackets)
    }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
    const a = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
    if (a)
      for (const l of a)
        this.surroundingPairs[l.open] = l.close;
  }
  static shouldRecreate(e) {
    return e.hasChanged(133) || e.hasChanged(119) || e.hasChanged(33) || e.hasChanged(71) || e.hasChanged(73) || e.hasChanged(5) || e.hasChanged(8) || e.hasChanged(6) || e.hasChanged(7) || e.hasChanged(11) || e.hasChanged(118) || e.hasChanged(61) || e.hasChanged(83);
  }
  get electricChars() {
    var e;
    if (!this._electricChars) {
      this._electricChars = {};
      const t = (e = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || e === void 0 ? void 0 : e.getElectricCharacters();
      if (t)
        for (const i of t)
          this._electricChars[i] = !0;
    }
    return this._electricChars;
  }
  onElectricCharacter(e, t, i) {
    const n = Ng(t, i - 1), r = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
    return r ? r.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
  }
  normalizeIndentation(e) {
    return eE(e, this.indentSize, this.insertSpaces);
  }
  _getShouldAutoClose(e, t) {
    switch (t) {
      case "beforeWhitespace":
        return $R;
      case "languageDefined":
        return this._getLanguageDefinedShouldAutoClose(e);
      case "always":
        return zR;
      case "never":
        return UR;
    }
  }
  _getLanguageDefinedShouldAutoClose(e) {
    const t = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet();
    return (i) => t.indexOf(i) !== -1;
  }
  visibleColumnFromColumn(e, t) {
    return _t.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
  }
  columnFromVisibleColumn(e, t, i) {
    const n = _t.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), r = e.getLineMinColumn(t);
    if (n < r)
      return r;
    const o = e.getLineMaxColumn(t);
    return n > o ? o : n;
  }
}
class he {
  constructor(e, t) {
    this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
  }
  static fromModelState(e) {
    return new jR(e);
  }
  static fromViewState(e) {
    return new KR(e);
  }
  static fromModelSelection(e) {
    const t = Ce.liftSelection(e), i = new Dt(N.fromPositions(t.getSelectionStart()), 0, t.getPosition(), 0);
    return he.fromModelState(i);
  }
  static fromModelSelections(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
}
class jR {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class KR {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class Dt {
  constructor(e, t, i, n) {
    this._singleCursorStateBrand = void 0, this.selectionStart = e, this.selectionStartLeftoverVisibleColumns = t, this.position = i, this.leftoverVisibleColumns = n, this.selection = Dt._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, n) {
    return e ? new Dt(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new O(t, i), n) : new Dt(new N(t, i, t, i), n, new O(t, i), n);
  }
  static _computeSelection(e, t) {
    return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? Ce.fromPositions(e.getStartPosition(), t) : Ce.fromPositions(e.getEndPosition(), t);
  }
}
class ui {
  constructor(e, t, i) {
    this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
function vr(s) {
  return s === "'" || s === '"' || s === "`";
}
class Eo {
  static columnSelect(e, t, i, n, r, o) {
    const a = Math.abs(r - i) + 1, l = i > r, c = n > o, h = n < o, u = [];
    for (let d = 0; d < a; d++) {
      const f = i + (l ? -d : d), m = e.columnFromVisibleColumn(t, f, n), _ = e.columnFromVisibleColumn(t, f, o), b = e.visibleColumnFromColumn(t, new O(f, m)), v = e.visibleColumnFromColumn(t, new O(f, _));
      h && (b > o || v < n) || c && (v > n || b < o) || u.push(new Dt(new N(f, m, f, m), 0, new O(f, _), 0));
    }
    if (u.length === 0)
      for (let d = 0; d < a; d++) {
        const f = i + (l ? -d : d), m = t.getLineMaxColumn(f);
        u.push(new Dt(new N(f, m, f, m), 0, new O(f, m), 0));
      }
    return {
      viewStates: u,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: n,
      toLineNumber: r,
      toVisualColumn: o
    };
  }
  static columnSelectLeft(e, t, i) {
    let n = i.toViewVisualColumn;
    return n > 0 && n--, Eo.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
  }
  static columnSelectRight(e, t, i) {
    let n = 0;
    const r = Math.min(i.fromViewLineNumber, i.toViewLineNumber), o = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = r; l <= o; l++) {
      const c = t.getLineMaxColumn(l), h = e.visibleColumnFromColumn(t, new O(l, c));
      n = Math.max(n, h);
    }
    let a = i.toViewVisualColumn;
    return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, n) {
    const r = n ? e.pageSize : 1, o = Math.max(1, i.toViewLineNumber - r);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, o, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, n) {
    const r = n ? e.pageSize : 1, o = Math.min(t.getLineCount(), i.toViewLineNumber + r);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, o, i.toViewVisualColumn);
  }
}
class vi {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ce.fromPositions(n.getEndPosition());
  }
}
class hd {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ce.fromPositions(n.getStartPosition());
  }
}
class Gd {
  constructor(e, t, i, n, r = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = r;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ce.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
  }
}
class qR {
  constructor(e, t, i, n = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class gp {
  constructor(e, t, i) {
    this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class ke {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -r2(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new O(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const n = e.getLineMinColumn(t.lineNumber), r = e.getLineContent(t.lineNumber), o = Kh.atomicPosition(r, t.column - 1, i, 0);
      if (o !== -1 && o + 1 >= n)
        return new O(t.lineNumber, o + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const n = e.stickyTabStops ? ke.leftPositionAtomicSoftTabs(t, i, e.tabSize) : ke.leftPosition(t, i);
    return new gp(n.lineNumber, n.column, 0);
  }
  static moveLeft(e, t, i, n, r) {
    let o, a;
    if (i.hasSelection() && !n)
      o = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(r - 1)), c = t.normalizePosition(ke.clipPositionColumn(l, t), 0), h = ke.left(e, t, c);
      o = h.lineNumber, a = h.column;
    }
    return i.move(n, o, a, 0);
  }
  static clipPositionColumn(e, t) {
    return new O(e.lineNumber, ke.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + Db(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new O(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, n, r) {
    if (i < e.getLineIndentColumn(t)) {
      const o = e.getLineContent(t), a = Kh.atomicPosition(o, i - 1, n, 1);
      if (a !== -1)
        return new O(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const n = e.stickyTabStops ? ke.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : ke.rightPosition(t, i.lineNumber, i.column);
    return new gp(n.lineNumber, n.column, 0);
  }
  static moveRight(e, t, i, n, r) {
    let o, a;
    if (i.hasSelection() && !n)
      o = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, r - 1), c = t.normalizePosition(ke.clipPositionColumn(l, t), 1), h = ke.right(e, t, c);
      o = h.lineNumber, a = h.column;
    }
    return i.move(n, o, a, 0);
  }
  static vertical(e, t, i, n, r, o, a, l) {
    const c = _t.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + r, h = t.getLineCount(), u = i === 1 && n === 1, d = i === h && n === t.getLineMaxColumn(i), f = o < i ? u : d;
    if (i = o, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > h ? (i = h, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, c), f ? r = 0 : r = c - _t.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
      const m = new O(i, n), _ = t.normalizePosition(m, l);
      r = r + (n - _.column), i = _.lineNumber, n = _.column;
    }
    return new gp(i, n, r);
  }
  static down(e, t, i, n, r, o, a) {
    return this.vertical(e, t, i, n, r, i + o, a, 4);
  }
  static moveDown(e, t, i, n, r) {
    let o, a;
    i.hasSelection() && !n ? (o = i.selection.endLineNumber, a = i.selection.endColumn) : (o = i.position.lineNumber, a = i.position.column);
    const l = ke.down(e, t, o, a, i.leftoverVisibleColumns, r, !0);
    return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    const n = i.selection, r = ke.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), o = ke.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Dt(new N(r.lineNumber, r.column, r.lineNumber, r.column), r.leftoverVisibleColumns, new O(o.lineNumber, o.column), o.leftoverVisibleColumns);
  }
  static up(e, t, i, n, r, o, a) {
    return this.vertical(e, t, i, n, r, i - o, a, 3);
  }
  static moveUp(e, t, i, n, r) {
    let o, a;
    i.hasSelection() && !n ? (o = i.selection.startLineNumber, a = i.selection.startColumn) : (o = i.position.lineNumber, a = i.position.column);
    const l = ke.up(e, t, o, a, i.leftoverVisibleColumns, r, !0);
    return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    const n = i.selection, r = ke.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), o = ke.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Dt(new N(r.lineNumber, r.column, r.lineNumber, r.column), r.leftoverVisibleColumns, new O(o.lineNumber, o.column), o.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, n) {
    let r = i.position.lineNumber;
    for (; r > 1 && this._isBlankLine(t, r); )
      r--;
    for (; r > 1 && !this._isBlankLine(t, r); )
      r--;
    return i.move(n, r, t.getLineMinColumn(r), 0);
  }
  static moveToNextBlankLine(e, t, i, n) {
    const r = t.getLineCount();
    let o = i.position.lineNumber;
    for (; o < r && this._isBlankLine(t, o); )
      o++;
    for (; o < r && !this._isBlankLine(t, o); )
      o++;
    return i.move(n, o, t.getLineMinColumn(o), 0);
  }
  static moveToBeginningOfLine(e, t, i, n) {
    const r = i.position.lineNumber, o = t.getLineMinColumn(r), a = t.getLineFirstNonWhitespaceColumn(r) || o;
    let l;
    return i.position.column === a ? l = o : l = a, i.move(n, r, l, 0);
  }
  static moveToEndOfLine(e, t, i, n, r) {
    const o = i.position.lineNumber, a = t.getLineMaxColumn(o);
    return i.move(n, o, a, r ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, n) {
    return i.move(n, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, n) {
    const r = t.getLineCount(), o = t.getLineMaxColumn(r);
    return i.move(n, r, o, 0);
  }
}
class ea {
  static deleteRight(e, t, i, n) {
    const r = [];
    let o = e !== 3;
    for (let a = 0, l = n.length; a < l; a++) {
      const c = n[a];
      let h = c;
      if (h.isEmpty()) {
        const u = c.getPosition(), d = ke.right(t, i, u);
        h = new N(d.lineNumber, d.column, u.lineNumber, u.column);
      }
      if (h.isEmpty()) {
        r[a] = null;
        continue;
      }
      h.startLineNumber !== h.endLineNumber && (o = !0), r[a] = new vi(h, "");
    }
    return [o, r];
  }
  static isAutoClosingPairDelete(e, t, i, n, r, o, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, c = o.length; l < c; l++) {
      const h = o[l], u = h.getPosition();
      if (!h.isEmpty())
        return !1;
      const d = r.getLineContent(u.lineNumber);
      if (u.column < 2 || u.column >= d.length + 1)
        return !1;
      const f = d.charAt(u.column - 2), m = n.get(f);
      if (!m)
        return !1;
      if (vr(f)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const _ = d.charAt(u.column - 1);
      let b = !1;
      for (const v of m)
        v.open === f && v.close === _ && (b = !0);
      if (!b)
        return !1;
      if (e === "auto") {
        let v = !1;
        for (let C = 0, w = a.length; C < w; C++) {
          const L = a[C];
          if (u.lineNumber === L.startLineNumber && u.column === L.startColumn) {
            v = !0;
            break;
          }
        }
        if (!v)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    const n = [];
    for (let r = 0, o = i.length; r < o; r++) {
      const a = i[r].getPosition(), l = new N(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      n[r] = new vi(l, "");
    }
    return [!0, n];
  }
  static deleteLeft(e, t, i, n, r) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, r))
      return this._runAutoClosingPairDelete(t, i, n);
    const o = [];
    let a = e !== 2;
    for (let l = 0, c = n.length; l < c; l++) {
      const h = ea.getDeleteRange(n[l], i, t);
      if (h.isEmpty()) {
        o[l] = null;
        continue;
      }
      h.startLineNumber !== h.endLineNumber && (a = !0), o[l] = new vi(h, "");
    }
    return [a, o];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const n = e.getPosition();
    if (i.useTabStops && n.column > 1) {
      const r = t.getLineContent(n.lineNumber), o = Bi(r), a = o === -1 ? r.length + 1 : o + 1;
      if (n.column <= a) {
        const l = i.visibleColumnFromColumn(t, n), c = _t.prevIndentTabStop(l, i.indentSize), h = i.columnFromVisibleColumn(t, n.lineNumber, c);
        return new N(n.lineNumber, h, n.lineNumber, n.column);
      }
    }
    return N.fromPositions(ea.getPositionAfterDeleteLeft(n, t), n);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = AT(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new O(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    const n = [];
    let r = null;
    i.sort((o, a) => O.compare(o.getStartPosition(), a.getEndPosition()));
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      if (l.isEmpty())
        if (e.emptySelectionClipboard) {
          const c = l.getPosition();
          let h, u, d, f;
          c.lineNumber < t.getLineCount() ? (h = c.lineNumber, u = 1, d = c.lineNumber + 1, f = 1) : c.lineNumber > 1 && (r == null ? void 0 : r.endLineNumber) !== c.lineNumber ? (h = c.lineNumber - 1, u = t.getLineMaxColumn(c.lineNumber - 1), d = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber)) : (h = c.lineNumber, u = 1, d = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber));
          const m = new N(h, u, d, f);
          r = m, m.isEmpty() ? n[o] = null : n[o] = new vi(m, "");
        } else
          n[o] = null;
      else
        n[o] = new vi(l, "");
    }
    return new ui(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class et {
  static _createWord(e, t, i, n, r) {
    return { start: n, end: r, wordType: t, nextCharClass: i };
  }
  static _findPreviousWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(n, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let n = 0;
    for (let r = i.column - 2; r >= 0; r--) {
      const o = e.charCodeAt(r), a = t.get(o);
      if (a === 0) {
        if (n === 2)
          return this._createWord(e, n, a, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 1;
      } else if (a === 2) {
        if (n === 1)
          return this._createWord(e, n, a, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 2;
      } else if (a === 1 && n !== 0)
        return this._createWord(e, n, a, r + 1, this._findEndOfWord(e, t, n, r + 1));
    }
    return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
  }
  static _findEndOfWord(e, t, i, n) {
    const r = e.length;
    for (let o = n; o < r; o++) {
      const a = e.charCodeAt(o), l = t.get(a);
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return o;
    }
    return r;
  }
  static _findNextWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(n, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let n = 0;
    const r = e.length;
    for (let o = i.column - 1; o < r; o++) {
      const a = e.charCodeAt(o), l = t.get(a);
      if (l === 0) {
        if (n === 2)
          return this._createWord(e, n, l, this._findStartOfWord(e, t, n, o - 1), o);
        n = 1;
      } else if (l === 2) {
        if (n === 1)
          return this._createWord(e, n, l, this._findStartOfWord(e, t, n, o - 1), o);
        n = 2;
      } else if (l === 1 && n !== 0)
        return this._createWord(e, n, l, this._findStartOfWord(e, t, n, o - 1), o);
    }
    return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, r - 1), r) : null;
  }
  static _findStartOfWord(e, t, i, n) {
    for (let r = n; r >= 0; r--) {
      const o = e.charCodeAt(r), a = t.get(o);
      if (a === 1 || i === 1 && a === 2 || i === 2 && a === 0)
        return r + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, n) {
    let r = i.lineNumber, o = i.column;
    o === 1 && r > 1 && (r = r - 1, o = t.getLineMaxColumn(r));
    let a = et._findPreviousWordOnLine(e, t, new O(r, o));
    if (n === 0)
      return new O(r, a ? a.start + 1 : 1);
    if (n === 1)
      return a && a.wordType === 2 && a.end - a.start === 1 && a.nextCharClass === 0 && (a = et._findPreviousWordOnLine(e, t, new O(r, a.start + 1))), new O(r, a ? a.start + 1 : 1);
    if (n === 3) {
      for (; a && a.wordType === 2; )
        a = et._findPreviousWordOnLine(e, t, new O(r, a.start + 1));
      return new O(r, a ? a.start + 1 : 1);
    }
    return a && o <= a.end + 1 && (a = et._findPreviousWordOnLine(e, t, new O(r, a.start + 1))), new O(r, a ? a.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new O(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const r = e.getLineContent(i);
    for (let o = t.column - 1; o > 1; o--) {
      const a = r.charCodeAt(o - 2), l = r.charCodeAt(o - 1);
      if (a === 95 && l !== 95)
        return new O(i, o);
      if ((ja(a) || Yu(a)) && yr(l))
        return new O(i, o);
      if (yr(a) && yr(l) && o + 1 < n) {
        const c = r.charCodeAt(o);
        if (ja(c) || Yu(c))
          return new O(i, o);
      }
    }
    return new O(i, 1);
  }
  static moveWordRight(e, t, i, n) {
    let r = i.lineNumber, o = i.column, a = !1;
    o === t.getLineMaxColumn(r) && r < t.getLineCount() && (a = !0, r = r + 1, o = 1);
    let l = et._findNextWordOnLine(e, t, new O(r, o));
    if (n === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = et._findNextWordOnLine(e, t, new O(r, l.end + 1))), l ? o = l.end + 1 : o = t.getLineMaxColumn(r);
    else if (n === 3) {
      for (a && (o = 0); l && (l.wordType === 2 || l.start + 1 <= o); )
        l = et._findNextWordOnLine(e, t, new O(r, l.end + 1));
      l ? o = l.start + 1 : o = t.getLineMaxColumn(r);
    } else
      l && !a && o >= l.start + 1 && (l = et._findNextWordOnLine(e, t, new O(r, l.end + 1))), l ? o = l.start + 1 : o = t.getLineMaxColumn(r);
    return new O(r, o);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === n)
      return i < e.getLineCount() ? new O(i + 1, 1) : t;
    const r = e.getLineContent(i);
    for (let o = t.column + 1; o < n; o++) {
      const a = r.charCodeAt(o - 2), l = r.charCodeAt(o - 1);
      if (a !== 95 && l === 95)
        return new O(i, o);
      if ((ja(a) || Yu(a)) && yr(l))
        return new O(i, o);
      if (yr(a) && yr(l) && o + 1 < n) {
        const c = r.charCodeAt(o);
        if (ja(c) || Yu(c))
          return new O(i, o);
      }
    }
    return new O(i, n);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 2, r = cc(i, n);
    return r + 1 < n ? new N(t.lineNumber, r + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, n = e.model, r = e.selection, o = e.whitespaceHeuristics;
    if (!r.isEmpty())
      return r;
    if (ea.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const u = e.selection.getPosition();
      return new N(u.lineNumber, u.column - 1, u.lineNumber, u.column + 1);
    }
    const a = new O(r.positionLineNumber, r.positionColumn);
    let l = a.lineNumber, c = a.column;
    if (l === 1 && c === 1)
      return null;
    if (o) {
      const u = this._deleteWordLeftWhitespace(n, a);
      if (u)
        return u;
    }
    let h = et._findPreviousWordOnLine(i, n, a);
    return t === 0 ? h ? c = h.start + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l)) : (h && c <= h.end + 1 && (h = et._findPreviousWordOnLine(i, n, new O(l, h.start + 1))), h ? c = h.end + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l))), new N(l, c, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const n = new O(i.positionLineNumber, i.positionColumn), r = this._deleteInsideWordWhitespace(t, n);
    return r || this._deleteInsideWordDetermineDeleteRange(e, t, n);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = i.length;
    if (n === 0)
      return null;
    let r = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, r))
      return null;
    let o = Math.min(t.column - 1, n - 1);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    for (; r > 0 && this._charAtIsWhitespace(i, r - 1); )
      r--;
    for (; o + 1 < n && this._charAtIsWhitespace(i, o + 1); )
      o++;
    return new N(t.lineNumber, r + 1, t.lineNumber, o + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const n = t.getLineContent(i.lineNumber), r = n.length;
    if (r === 0)
      return i.lineNumber > 1 ? new N(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new N(i.lineNumber, 1, i.lineNumber + 1, 1) : new N(i.lineNumber, 1, i.lineNumber, 1);
    const o = (u) => u.start + 1 <= i.column && i.column <= u.end + 1, a = (u, d) => (u = Math.min(u, i.column), d = Math.max(d, i.column), new N(i.lineNumber, u, i.lineNumber, d)), l = (u) => {
      let d = u.start + 1, f = u.end + 1, m = !1;
      for (; f - 1 < r && this._charAtIsWhitespace(n, f - 1); )
        m = !0, f++;
      if (!m)
        for (; d > 1 && this._charAtIsWhitespace(n, d - 2); )
          d--;
      return a(d, f);
    }, c = et._findPreviousWordOnLine(e, t, i);
    if (c && o(c))
      return l(c);
    const h = et._findNextWordOnLine(e, t, i);
    return h && o(h) ? l(h) : c && h ? a(c.end + 1, h.start + 1) : c ? a(c.start + 1, c.end + 1) : h ? a(h.start + 1, h.end + 1) : a(1, r + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = et._moveWordPartLeft(e, i);
    return new N(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    const i = e.length;
    for (let n = t; n < i; n++) {
      const r = e.charAt(n);
      if (r !== " " && r !== "	")
        return n;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 1, r = this._findFirstNonWhitespaceChar(i, n);
    return n + 1 < r ? new N(t.lineNumber, t.column, t.lineNumber, r + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, n = e.model, r = e.selection, o = e.whitespaceHeuristics;
    if (!r.isEmpty())
      return r;
    const a = new O(r.positionLineNumber, r.positionColumn);
    let l = a.lineNumber, c = a.column;
    const h = n.getLineCount(), u = n.getLineMaxColumn(l);
    if (l === h && c === u)
      return null;
    if (o) {
      const f = this._deleteWordRightWhitespace(n, a);
      if (f)
        return f;
    }
    let d = et._findNextWordOnLine(i, n, a);
    return t === 2 ? d ? c = d.end + 1 : c < u || l === h ? c = u : (l++, d = et._findNextWordOnLine(i, n, new O(l, 1)), d ? c = d.start + 1 : c = n.getLineMaxColumn(l)) : (d && c >= d.start + 1 && (d = et._findNextWordOnLine(i, n, new O(l, d.end + 1))), d ? c = d.start + 1 : c < u || l === h ? c = u : (l++, d = et._findNextWordOnLine(i, n, new O(l, 1)), d ? c = d.start + 1 : c = n.getLineMaxColumn(l))), new N(l, c, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = et._moveWordPartRight(e, i);
    return new N(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _createWordAtPosition(e, t, i) {
    const n = new N(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(n),
      startColumn: n.startColumn,
      endColumn: n.endColumn
    };
  }
  static getWordAtPosition(e, t, i) {
    const n = Bl(t), r = et._findPreviousWordOnLine(n, e, i);
    if (r && r.wordType === 1 && r.start <= i.column - 1 && i.column - 1 <= r.end)
      return et._createWordAtPosition(e, i.lineNumber, r);
    const o = et._findNextWordOnLine(n, e, i);
    return o && o.wordType === 1 && o.start <= i.column - 1 && i.column - 1 <= o.end ? et._createWordAtPosition(e, i.lineNumber, o) : null;
  }
  static word(e, t, i, n, r) {
    const o = Bl(e.wordSeparators), a = et._findPreviousWordOnLine(o, t, r), l = et._findNextWordOnLine(o, t, r);
    if (!n) {
      let f, m;
      return a && a.wordType === 1 && a.start <= r.column - 1 && r.column - 1 <= a.end ? (f = a.start + 1, m = a.end + 1) : l && l.wordType === 1 && l.start <= r.column - 1 && r.column - 1 <= l.end ? (f = l.start + 1, m = l.end + 1) : (a ? f = a.end + 1 : f = 1, l ? m = l.start + 1 : m = t.getLineMaxColumn(r.lineNumber)), new Dt(new N(r.lineNumber, f, r.lineNumber, m), 0, new O(r.lineNumber, m), 0);
    }
    let c, h;
    a && a.wordType === 1 && a.start < r.column - 1 && r.column - 1 < a.end ? (c = a.start + 1, h = a.end + 1) : l && l.wordType === 1 && l.start < r.column - 1 && r.column - 1 < l.end ? (c = l.start + 1, h = l.end + 1) : (c = r.column, h = r.column);
    const u = r.lineNumber;
    let d;
    if (i.selectionStart.containsPosition(r))
      d = i.selectionStart.endColumn;
    else if (r.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      d = c;
      const f = new O(u, d);
      i.selectionStart.containsPosition(f) && (d = i.selectionStart.endColumn);
    } else {
      d = h;
      const f = new O(u, d);
      i.selectionStart.containsPosition(f) && (d = i.selectionStart.startColumn);
    }
    return i.move(!0, u, d, 0);
  }
}
class Gt {
  static addCursorDown(e, t, i) {
    const n = [];
    let r = 0;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      n[r++] = new he(l.modelState, l.viewState), i ? n[r++] = he.fromModelState(ke.translateDown(e.cursorConfig, e.model, l.modelState)) : n[r++] = he.fromViewState(ke.translateDown(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static addCursorUp(e, t, i) {
    const n = [];
    let r = 0;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      n[r++] = new he(l.modelState, l.viewState), i ? n[r++] = he.fromModelState(ke.translateUp(e.cursorConfig, e.model, l.modelState)) : n[r++] = he.fromViewState(ke.translateUp(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static moveToBeginningOfLine(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r];
      n[r] = this._moveToLineStart(e, a, i);
    }
    return n;
  }
  static _moveToLineStart(e, t, i) {
    const n = t.viewState.position.column, r = t.modelState.position.column, o = n === r, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !o && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return he.fromViewState(ke.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return he.fromModelState(ke.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, n) {
    const r = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      r[o] = this._moveToLineEnd(e, l, i, n);
    }
    return r;
  }
  static _moveToLineEnd(e, t, i, n) {
    const r = t.viewState.position, o = e.getLineMaxColumn(r.lineNumber), a = r.column === o, l = t.modelState.position, c = e.model.getLineMaxColumn(l.lineNumber), h = o - r.column === c - l.column;
    return a || h ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
  }
  static _moveToLineEndByView(e, t, i, n) {
    return he.fromViewState(ke.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
  }
  static _moveToLineEndByModel(e, t, i, n) {
    return he.fromModelState(ke.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
  }
  static expandLineSelection(e, t) {
    const i = [];
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n], a = o.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let c = o.modelState.selection.endLineNumber, h;
      c === l ? h = e.model.getLineMaxColumn(l) : (c++, h = 1), i[n] = he.fromModelState(new Dt(new N(a, 1, a, 1), 0, new O(c, h), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r];
      n[r] = he.fromModelState(ke.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static moveToEndOfBuffer(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r];
      n[r] = he.fromModelState(ke.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
    return he.fromModelState(new Dt(new N(1, 1, 1, 1), 0, new O(i, n), 0));
  }
  static line(e, t, i, n, r) {
    const o = e.model.validatePosition(n), a = r ? e.coordinatesConverter.validateViewPosition(new O(r.lineNumber, r.column), o) : e.coordinatesConverter.convertModelPositionToViewPosition(o);
    if (!i || !t.modelState.hasSelection()) {
      const c = e.model.getLineCount();
      let h = o.lineNumber + 1, u = 1;
      return h > c && (h = c, u = e.model.getLineMaxColumn(h)), he.fromModelState(new Dt(new N(o.lineNumber, 1, h, u), 0, new O(h, u), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (o.lineNumber < l)
      return he.fromViewState(t.viewState.move(t.modelState.hasSelection(), a.lineNumber, 1, 0));
    if (o.lineNumber > l) {
      const c = e.getLineCount();
      let h = a.lineNumber + 1, u = 1;
      return h > c && (h = c, u = e.getLineMaxColumn(h)), he.fromViewState(t.viewState.move(t.modelState.hasSelection(), h, u, 0));
    } else {
      const c = t.modelState.selectionStart.getEndPosition();
      return he.fromModelState(t.modelState.move(t.modelState.hasSelection(), c.lineNumber, c.column, 0));
    }
  }
  static word(e, t, i, n) {
    const r = e.model.validatePosition(n);
    return he.fromModelState(et.word(e.cursorConfig, e.model, t.modelState, i, r));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new he(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
    return he.fromViewState(new Dt(new N(i, n, i, n), 0, new O(i, n), 0));
  }
  static moveTo(e, t, i, n, r) {
    const o = e.model.validatePosition(n), a = r ? e.coordinatesConverter.validateViewPosition(new O(r.lineNumber, r.column), o) : e.coordinatesConverter.convertModelPositionToViewPosition(o);
    return he.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, n, r, o) {
    switch (i) {
      case 0:
        return o === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, r);
      case 1:
        return o === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, r);
      case 2:
        return o === 2 ? this._moveUpByViewLines(e, t, n, r) : this._moveUpByModelLines(e, t, n, r);
      case 3:
        return o === 2 ? this._moveDownByViewLines(e, t, n, r) : this._moveDownByModelLines(e, t, n, r);
      case 4:
        return o === 2 ? t.map((a) => he.fromViewState(ke.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => he.fromModelState(ke.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 5:
        return o === 2 ? t.map((a) => he.fromViewState(ke.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => he.fromModelState(ke.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 6:
        return this._moveToViewMinColumn(e, t, n);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
      case 8:
        return this._moveToViewCenterColumn(e, t, n);
      case 9:
        return this._moveToViewMaxColumn(e, t, n);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, n);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, n, r) {
    const o = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(o);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, r), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, r), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 14: {
        const l = [];
        for (let c = 0, h = t.length; c < h; c++) {
          const u = t[c];
          l[c] = this.findPositionInViewportIfOutside(e, u, o, n);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, n) {
    const r = t.viewState.position.lineNumber;
    if (i.startLineNumber <= r && r <= i.endLineNumber - 1)
      return new he(t.modelState, t.viewState);
    {
      let o;
      r > i.endLineNumber - 1 ? o = i.endLineNumber - 1 : r < i.startLineNumber ? o = i.startLineNumber : o = r;
      const a = ke.vertical(e.cursorConfig, e, r, t.viewState.position.column, t.viewState.leftoverVisibleColumns, o, !1);
      return he.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
    }
  }
  static _firstLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
  }
  static _lastLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, n) {
    return t.map((r) => he.fromViewState(ke.moveLeft(e.cursorConfig, e, r.viewState, i, n)));
  }
  static _moveHalfLineLeft(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = Math.round(e.getLineContent(l).length / 2);
      n[r] = he.fromViewState(ke.moveLeft(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveRight(e, t, i, n) {
    return t.map((r) => he.fromViewState(ke.moveRight(e.cursorConfig, e, r.viewState, i, n)));
  }
  static _moveHalfLineRight(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = Math.round(e.getLineContent(l).length / 2);
      n[r] = he.fromViewState(ke.moveRight(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveDownByViewLines(e, t, i, n) {
    const r = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      r[o] = he.fromViewState(ke.moveDown(e.cursorConfig, e, l.viewState, i, n));
    }
    return r;
  }
  static _moveDownByModelLines(e, t, i, n) {
    const r = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      r[o] = he.fromModelState(ke.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return r;
  }
  static _moveUpByViewLines(e, t, i, n) {
    const r = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      r[o] = he.fromViewState(ke.moveUp(e.cursorConfig, e, l.viewState, i, n));
    }
    return r;
  }
  static _moveUpByModelLines(e, t, i, n) {
    const r = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      r[o] = he.fromModelState(ke.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return r;
  }
  static _moveToViewPosition(e, t, i, n, r) {
    return he.fromViewState(t.viewState.move(i, n, r, 0));
  }
  static _moveToModelPosition(e, t, i, n, r) {
    return he.fromModelState(t.modelState.move(i, n, r, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = e.getLineMinColumn(l);
      n[r] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = e.getLineFirstNonWhitespaceColumn(l);
      n[r] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewCenterColumn(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      n[r] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewMaxColumn(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = e.getLineMaxColumn(l);
      n[r] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.viewState.position.lineNumber, c = e.getLineLastNonWhitespaceColumn(l);
      n[r] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
}
var Pf;
(function(s) {
  const e = function(i) {
    if (!Pi(i))
      return !1;
    const n = i;
    return !(!Fi(n.to) || !Rn(n.select) && !Vk(n.select) || !Rn(n.by) && !Fi(n.by) || !Rn(n.value) && !oc(n.value));
  };
  s.description = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let n;
    switch (i.to) {
      case s.RawDirection.Left:
        n = 0;
        break;
      case s.RawDirection.Right:
        n = 1;
        break;
      case s.RawDirection.Up:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.PrevBlankLine:
        n = 4;
        break;
      case s.RawDirection.NextBlankLine:
        n = 5;
        break;
      case s.RawDirection.WrappedLineStart:
        n = 6;
        break;
      case s.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        n = 7;
        break;
      case s.RawDirection.WrappedLineColumnCenter:
        n = 8;
        break;
      case s.RawDirection.WrappedLineEnd:
        n = 9;
        break;
      case s.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        n = 10;
        break;
      case s.RawDirection.ViewPortTop:
        n = 11;
        break;
      case s.RawDirection.ViewPortBottom:
        n = 13;
        break;
      case s.RawDirection.ViewPortCenter:
        n = 12;
        break;
      case s.RawDirection.ViewPortIfOutside:
        n = 14;
        break;
      default:
        return null;
    }
    let r = 0;
    switch (i.by) {
      case s.RawUnit.Line:
        r = 1;
        break;
      case s.RawUnit.WrappedLine:
        r = 2;
        break;
      case s.RawUnit.Character:
        r = 3;
        break;
      case s.RawUnit.HalfLine:
        r = 4;
        break;
    }
    return {
      direction: n,
      unit: r,
      select: !!i.select,
      value: i.value || 1
    };
  }
  s.parse = t;
})(Pf || (Pf = {}));
function F1(s, e, t, i) {
  const n = fl(e, t.startLineNumber, t.startColumn), r = i.getLanguageConfiguration(n.languageId);
  if (!r)
    return null;
  const o = n.getLineContent(), a = o.substr(0, t.startColumn - 1 - n.firstCharOffset);
  let l;
  t.isEmpty() ? l = o.substr(t.startColumn - 1 - n.firstCharOffset) : l = fl(e, t.endLineNumber, t.endColumn).getLineContent().substr(t.endColumn - 1 - n.firstCharOffset);
  let c = "";
  if (t.startLineNumber > 1 && n.firstCharOffset === 0) {
    const _ = fl(e, t.startLineNumber - 1);
    _.languageId === n.languageId && (c = _.getLineContent());
  }
  const h = r.onEnter(s, c, a, l);
  if (!h)
    return null;
  const u = h.indentAction;
  let d = h.appendText;
  const f = h.removeText || 0;
  d ? u === ni.Indent && (d = "	" + d) : u === ni.Indent || u === ni.IndentOutdent ? d = "	" : d = "";
  let m = k2(e, t.startLineNumber, t.startColumn);
  return f && (m = m.substring(0, m.length - f)), {
    indentAction: u,
    appendText: d,
    removeText: f,
    indentation: m
  };
}
var GR = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, ZR = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const mp = /* @__PURE__ */ Object.create(null);
function _o(s, e) {
  if (e <= 0)
    return "";
  mp[s] || (mp[s] = ["", s]);
  const t = mp[s];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + s;
  return t[e];
}
let xo = class B1 {
  constructor(e, t, i) {
    this._languageConfigurationService = i, this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  static unshiftIndent(e, t, i, n, r) {
    const o = _t.visibleColumnFromColumn(e, t, i);
    if (r) {
      const a = _o(" ", n), c = _t.prevIndentTabStop(o, n) / n;
      return _o(a, c);
    } else {
      const a = "	", c = _t.prevRenderTabStop(o, i) / i;
      return _o(a, c);
    }
  }
  static shiftIndent(e, t, i, n, r) {
    const o = _t.visibleColumnFromColumn(e, t, i);
    if (r) {
      const a = _o(" ", n), c = _t.nextIndentTabStop(o, n) / n;
      return _o(a, c);
    } else {
      const a = "	", c = _t.nextRenderTabStop(o, i) / i;
      return _o(a, c);
    }
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let n = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== n && (n = n - 1);
    const { tabSize: r, indentSize: o, insertSpaces: a } = this._opts, l = i === n;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let c = 0, h = 0;
      for (let u = i; u <= n; u++, c = h) {
        h = 0;
        const d = e.getLineContent(u);
        let f = Bi(d);
        if (this._opts.isUnshift && (d.length === 0 || f === 0) || !l && !this._opts.isUnshift && d.length === 0)
          continue;
        if (f === -1 && (f = d.length), u > 1 && _t.visibleColumnFromColumn(d, f + 1, r) % o !== 0 && e.tokenization.isCheapToTokenize(u - 1)) {
          const b = F1(this._opts.autoIndent, e, new N(u - 1, e.getLineMaxColumn(u - 1), u - 1, e.getLineMaxColumn(u - 1)), this._languageConfigurationService);
          if (b) {
            if (h = c, b.appendText)
              for (let v = 0, C = b.appendText.length; v < C && h < o && b.appendText.charCodeAt(v) === 32; v++)
                h++;
            b.removeText && (h = Math.max(0, h - b.removeText));
            for (let v = 0; v < h && !(f === 0 || d.charCodeAt(f - 1) !== 32); v++)
              f--;
          }
        }
        if (this._opts.isUnshift && f === 0)
          continue;
        let m;
        this._opts.isUnshift ? m = B1.unshiftIndent(d, f + 1, r, o, a) : m = B1.shiftIndent(d, f + 1, r, o, a), this._addEditOperation(t, new N(u, 1, u, f + 1), m), u === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= f + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const c = a ? _o(" ", o) : "	";
      for (let h = i; h <= n; h++) {
        const u = e.getLineContent(h);
        let d = Bi(u);
        if (!(this._opts.isUnshift && (u.length === 0 || d === 0)) && !(!l && !this._opts.isUnshift && u.length === 0) && (d === -1 && (d = u.length), !(this._opts.isUnshift && d === 0)))
          if (this._opts.isUnshift) {
            d = Math.min(d, o);
            for (let f = 0; f < d; f++)
              if (u.charCodeAt(f) === 9) {
                d = f + 1;
                break;
              }
            this._addEditOperation(t, new N(h, 1, h, d + 1), "");
          } else
            this._addEditOperation(t, new N(h, 1, h, 1), c), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      const n = t.getInverseEditOperations()[0];
      return new Ce(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      const n = this._selection.startColumn;
      return i.startColumn <= n ? i : i.getDirection() === 0 ? new Ce(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new Ce(i.endLineNumber, i.endColumn, i.startLineNumber, n);
    }
    return i;
  }
};
xo = GR([
  ZR(2, bs)
], xo);
class YR {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new N(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new N(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations(), n = i[0].range, r = i[1].range;
    return new Ce(n.endLineNumber, n.endColumn, r.endLineNumber, r.endColumn - this._charAfterSelection.length);
  }
}
class QR {
  constructor(e, t, i) {
    this._position = e, this._text = t, this._charAfter = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new N(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return new Ce(n.endLineNumber, n.startColumn, n.endLineNumber, n.endColumn - this._charAfter.length);
  }
}
function XR(s, e, t) {
  const i = s.tokenization.getLanguageIdAtPosition(e, 0);
  if (e > 1) {
    let n, r = -1;
    for (n = e - 1; n >= 1; n--) {
      if (s.tokenization.getLanguageIdAtPosition(n, 0) !== i)
        return r;
      const o = s.getLineContent(n);
      if (t.shouldIgnore(o) || /^\s+$/.test(o) || o === "") {
        r = n;
        continue;
      }
      return n;
    }
  }
  return -1;
}
function eC(s, e, t, i = !0, n) {
  if (s < 4)
    return null;
  const r = n.getLanguageConfiguration(e.tokenization.getLanguageId()).indentRulesSupport;
  if (!r)
    return null;
  if (t <= 1)
    return {
      indentation: "",
      action: null
    };
  const o = XR(e, t, r);
  if (o < 0)
    return null;
  if (o < 1)
    return {
      indentation: "",
      action: null
    };
  const a = e.getLineContent(o);
  if (r.shouldIncrease(a) || r.shouldIndentNextLine(a))
    return {
      indentation: wi(a),
      action: ni.Indent,
      line: o
    };
  if (r.shouldDecrease(a))
    return {
      indentation: wi(a),
      action: null,
      line: o
    };
  {
    if (o === 1)
      return {
        indentation: wi(e.getLineContent(o)),
        action: null,
        line: o
      };
    const l = o - 1, c = r.getIndentMetadata(e.getLineContent(l));
    if (!(c & 3) && c & 4) {
      let h = 0;
      for (let u = l - 1; u > 0; u--)
        if (!r.shouldIndentNextLine(e.getLineContent(u))) {
          h = u;
          break;
        }
      return {
        indentation: wi(e.getLineContent(h + 1)),
        action: null,
        line: h + 1
      };
    }
    if (i)
      return {
        indentation: wi(e.getLineContent(o)),
        action: null,
        line: o
      };
    for (let h = o; h > 0; h--) {
      const u = e.getLineContent(h);
      if (r.shouldIncrease(u))
        return {
          indentation: wi(u),
          action: ni.Indent,
          line: h
        };
      if (r.shouldIndentNextLine(u)) {
        let d = 0;
        for (let f = h - 1; f > 0; f--)
          if (!r.shouldIndentNextLine(e.getLineContent(h))) {
            d = f;
            break;
          }
        return {
          indentation: wi(e.getLineContent(d + 1)),
          action: null,
          line: d + 1
        };
      } else if (r.shouldDecrease(u))
        return {
          indentation: wi(u),
          action: null,
          line: h
        };
    }
    return {
      indentation: wi(e.getLineContent(1)),
      action: null,
      line: 1
    };
  }
}
function JR(s, e, t, i, n) {
  if (s < 4)
    return null;
  e.tokenization.forceTokenization(t.startLineNumber);
  const r = e.tokenization.getLineTokens(t.startLineNumber), o = Ng(r, t.startColumn - 1), a = o.getLineContent();
  let l = !1, c;
  o.firstCharOffset > 0 && r.getLanguageId(0) !== o.languageId ? (l = !0, c = a.substr(0, t.startColumn - 1 - o.firstCharOffset)) : c = r.getLineContent().substring(0, t.startColumn - 1);
  let h;
  t.isEmpty() ? h = a.substr(t.startColumn - 1 - o.firstCharOffset) : h = fl(e, t.endLineNumber, t.endColumn).getLineContent().substr(t.endColumn - 1 - o.firstCharOffset);
  const u = n.getLanguageConfiguration(o.languageId).indentRulesSupport;
  if (!u)
    return null;
  const d = c, f = wi(c), m = {
    tokenization: {
      getLineTokens: (C) => e.tokenization.getLineTokens(C),
      getLanguageId: () => e.getLanguageId(),
      getLanguageIdAtPosition: (C, w) => e.getLanguageIdAtPosition(C, w)
    },
    getLineContent: (C) => C === t.startLineNumber ? d : e.getLineContent(C)
  }, _ = wi(r.getLineContent()), b = eC(s, m, t.startLineNumber + 1, void 0, n);
  if (!b) {
    const C = l ? _ : f;
    return {
      beforeEnter: C,
      afterEnter: C
    };
  }
  let v = l ? _ : b.indentation;
  return b.action === ni.Indent && (v = i.shiftIndent(v)), u.shouldDecrease(h) && (v = i.unshiftIndent(v)), {
    beforeEnter: l ? _ : f,
    afterEnter: v
  };
}
function e9(s, e, t, i, n, r) {
  if (s < 4)
    return null;
  const o = fl(e, t.startLineNumber, t.startColumn);
  if (o.firstCharOffset)
    return null;
  const a = r.getLanguageConfiguration(o.languageId).indentRulesSupport;
  if (!a)
    return null;
  const l = o.getLineContent(), c = l.substr(0, t.startColumn - 1 - o.firstCharOffset);
  let h;
  if (t.isEmpty() ? h = l.substr(t.startColumn - 1 - o.firstCharOffset) : h = fl(e, t.endLineNumber, t.endColumn).getLineContent().substr(t.endColumn - 1 - o.firstCharOffset), !a.shouldDecrease(c + h) && a.shouldDecrease(c + i + h)) {
    const u = eC(s, e, t.startLineNumber, !1, r);
    if (!u)
      return null;
    let d = u.indentation;
    return u.action !== ni.Indent && (d = n.unshiftIndent(d)), d;
  }
  return null;
}
class Ge {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let r = 0, o = i.length; r < o; r++)
      n[r] = new xo(i[r], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static outdent(e, t, i) {
    const n = [];
    for (let r = 0, o = i.length; r < o; r++)
      n[r] = new xo(i[r], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static shiftIndent(e, t, i) {
    return i = i || 1, xo.shiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static unshiftIndent(e, t, i) {
    return i = i || 1, xo.unshiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static _distributedPaste(e, t, i, n) {
    const r = [];
    for (let o = 0, a = i.length; o < a; o++)
      r[o] = new vi(i[o], n[o]);
    return new ui(0, r, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, n, r) {
    const o = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], h = c.getPosition();
      if (r && !c.isEmpty() && (r = !1), r && n.indexOf(`
`) !== n.length - 1 && (r = !1), r) {
        const u = new N(h.lineNumber, 1, h.lineNumber, 1);
        o[a] = new qR(u, n, c, !0);
      } else
        o[a] = new vi(c, n);
    }
    return new ui(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _distributePasteToCursors(e, t, i, n, r) {
    if (n || t.length === 1)
      return null;
    if (r && r.length === t.length)
      return r;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substr(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substr(0, i.length - 1));
      const o = xu(i);
      if (o.length === t.length)
        return o;
    }
    return null;
  }
  static paste(e, t, i, n, r, o) {
    const a = this._distributePasteToCursors(e, i, n, r, o);
    return a ? (i = i.sort(N.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, r);
  }
  static _goodIndentForLine(e, t, i) {
    let n = null, r = "";
    const o = eC(e.autoIndent, t, i, !1, e.languageConfigurationService);
    if (o)
      n = o.action, r = o.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const h = t.getLineContent(a);
        if (cc(h) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), c = F1(e.autoIndent, t, new N(a, l, a, l), e.languageConfigurationService);
      c && (r = c.indentation + c.appendText);
    }
    return n && (n === ni.Indent && (r = Ge.shiftIndent(e, r)), n === ni.Outdent && (r = Ge.unshiftIndent(e, r)), r = e.normalizeIndentation(r)), r || null;
  }
  static _replaceJumpToNextIndent(e, t, i, n) {
    let r = "";
    const o = i.getStartPosition();
    if (e.insertSpaces) {
      const a = e.visibleColumnFromColumn(t, o), l = e.indentSize, c = l - a % l;
      for (let h = 0; h < c; h++)
        r += " ";
    } else
      r = "	";
    return new vi(i, r, n);
  }
  static tab(e, t, i) {
    const n = [];
    for (let r = 0, o = i.length; r < o; r++) {
      const a = i[r];
      if (a.isEmpty()) {
        const l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.tokenization.isCheapToTokenize(a.startLineNumber)) {
          let c = this._goodIndentForLine(e, t, a.startLineNumber);
          c = c || "	";
          const h = e.normalizeIndentation(c);
          if (!l.startsWith(h)) {
            n[r] = new vi(new N(a.startLineNumber, 1, a.startLineNumber, l.length + 1), h, !0);
            continue;
          }
        }
        n[r] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          const l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            n[r] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        n[r] = new xo(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        }, e.languageConfigurationService);
      }
    }
    return n;
  }
  static compositionType(e, t, i, n, r, o, a, l) {
    const c = n.map((h) => this._compositionType(i, h, r, o, a, l));
    return new ui(4, c, {
      shouldPushStackElementBefore: ud(e, 4),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, n, r, o) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - n), c = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + r), h = new N(a.lineNumber, l, a.lineNumber, c);
    return e.getValueInRange(h) === i && o === 0 ? null : new Gd(h, i, 0, o);
  }
  static _typeCommand(e, t, i) {
    return i ? new hd(e, t, !0) : new vi(e, t, !0);
  }
  static _enter(e, t, i, n) {
    if (e.autoIndent === 0)
      return Ge._typeCommand(n, `
`, i);
    if (!t.tokenization.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
      const l = t.getLineContent(n.startLineNumber), c = wi(l).substring(0, n.startColumn - 1);
      return Ge._typeCommand(n, `
` + e.normalizeIndentation(c), i);
    }
    const r = F1(e.autoIndent, t, n, e.languageConfigurationService);
    if (r) {
      if (r.indentAction === ni.None)
        return Ge._typeCommand(n, `
` + e.normalizeIndentation(r.indentation + r.appendText), i);
      if (r.indentAction === ni.Indent)
        return Ge._typeCommand(n, `
` + e.normalizeIndentation(r.indentation + r.appendText), i);
      if (r.indentAction === ni.IndentOutdent) {
        const l = e.normalizeIndentation(r.indentation), c = e.normalizeIndentation(r.indentation + r.appendText), h = `
` + c + `
` + l;
        return i ? new hd(n, h, !0) : new Gd(n, h, -1, c.length - l.length, !0);
      } else if (r.indentAction === ni.Outdent) {
        const l = Ge.unshiftIndent(e, r.indentation);
        return Ge._typeCommand(n, `
` + e.normalizeIndentation(l + r.appendText), i);
      }
    }
    const o = t.getLineContent(n.startLineNumber), a = wi(o).substring(0, n.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = JR(e.autoIndent, t, n, {
        unshiftIndent: (c) => Ge.unshiftIndent(e, c),
        shiftIndent: (c) => Ge.shiftIndent(e, c),
        normalizeIndentation: (c) => e.normalizeIndentation(c)
      }, e.languageConfigurationService);
      if (l) {
        let c = e.visibleColumnFromColumn(t, n.getEndPosition());
        const h = n.endColumn, u = t.getLineContent(n.endLineNumber), d = Bi(u);
        if (d >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, d + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i)
          return new hd(n, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let f = 0;
          return h <= d + 1 && (e.insertSpaces || (c = Math.ceil(c / e.indentSize)), f = Math.min(c + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new Gd(n, `
` + e.normalizeIndentation(l.afterEnter), 0, f, !0);
        }
      }
    }
    return Ge._typeCommand(n, `
` + e.normalizeIndentation(a), i);
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let n = 0, r = i.length; n < r; n++)
      if (!t.tokenization.isCheapToTokenize(i[n].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _runAutoIndentType(e, t, i, n) {
    const r = k2(t, i.startLineNumber, i.startColumn), o = e9(e.autoIndent, t, i, n, {
      shiftIndent: (a) => Ge.shiftIndent(e, a),
      unshiftIndent: (a) => Ge.unshiftIndent(e, a)
    }, e.languageConfigurationService);
    if (o === null)
      return null;
    if (o !== e.normalizeIndentation(r)) {
      const a = t.getLineFirstNonWhitespaceColumn(i.startLineNumber);
      return a === 0 ? Ge._typeCommand(new N(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(o) + n, !1) : Ge._typeCommand(new N(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(o) + t.getLineContent(i.startLineNumber).substring(a - 1, i.startColumn - 1) + n, !1);
    }
    return null;
  }
  static _isAutoClosingOvertype(e, t, i, n, r) {
    if (e.autoClosingOvertype === "never" || !e.autoClosingPairs.autoClosingPairsCloseSingleChar.has(r))
      return !1;
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      if (!l.isEmpty())
        return !1;
      const c = l.getPosition(), h = t.getLineContent(c.lineNumber);
      if (h.charAt(c.column - 1) !== r)
        return !1;
      const d = vr(r);
      if ((c.column > 2 ? h.charCodeAt(c.column - 2) : 0) === 92 && d)
        return !1;
      if (e.autoClosingOvertype === "auto") {
        let m = !1;
        for (let _ = 0, b = n.length; _ < b; _++) {
          const v = n[_];
          if (c.lineNumber === v.startLineNumber && c.column === v.startColumn) {
            m = !0;
            break;
          }
        }
        if (!m)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingOvertype(e, t, i, n, r) {
    const o = [];
    for (let a = 0, l = n.length; a < l; a++) {
      const h = n[a].getPosition(), u = new N(h.lineNumber, h.column, h.lineNumber, h.column + 1);
      o[a] = new vi(u, r);
    }
    return new ui(4, o, {
      shouldPushStackElementBefore: ud(e, 4),
      shouldPushStackElementAfter: !1
    });
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], r = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], o = n.some((l) => t.startsWith(l.open)), a = r.some((l) => t.startsWith(l.close));
    return !o && a;
  }
  static _findAutoClosingPairOpen(e, t, i, n) {
    const r = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
    if (!r)
      return null;
    let o = null;
    for (const a of r)
      if (o === null || a.open.length > o.open.length) {
        let l = !0;
        for (const c of i)
          if (t.getValueInRange(new N(c.lineNumber, c.column - a.open.length + 1, c.lineNumber, c.column)) + n !== a.open) {
            l = !1;
            break;
          }
        l && (o = a);
      }
    return o;
  }
  static _findContainedAutoClosingPair(e, t) {
    if (t.open.length <= 1)
      return null;
    const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let r = null;
    for (const o of n)
      o.open !== t.open && t.open.includes(o.open) && t.close.endsWith(o.close) && (!r || o.open.length > r.open.length) && (r = o);
    return r;
  }
  static _getAutoClosingPairClose(e, t, i, n, r) {
    const o = vr(n), a = o ? e.autoClosingQuotes : e.autoClosingBrackets, l = o ? e.shouldAutoCloseBefore.quote : e.shouldAutoCloseBefore.bracket;
    if (a === "never")
      return null;
    for (const m of i)
      if (!m.isEmpty())
        return null;
    const c = i.map((m) => {
      const _ = m.getPosition();
      return r ? { lineNumber: _.lineNumber, beforeColumn: _.column - n.length, afterColumn: _.column } : { lineNumber: _.lineNumber, beforeColumn: _.column, afterColumn: _.column };
    }), h = this._findAutoClosingPairOpen(e, t, c.map((m) => new O(m.lineNumber, m.beforeColumn)), n);
    if (!h)
      return null;
    const u = this._findContainedAutoClosingPair(e, h), d = u ? u.close : "";
    let f = !0;
    for (const m of c) {
      const { lineNumber: _, beforeColumn: b, afterColumn: v } = m, C = t.getLineContent(_), w = C.substring(0, b - 1), L = C.substring(v - 1);
      if (L.startsWith(d) || (f = !1), L.length > 0) {
        const S = L.charAt(0);
        if (!Ge._isBeforeClosingBrace(e, L) && !l(S))
          return null;
      }
      if (h.open.length === 1 && (n === "'" || n === '"') && a !== "always") {
        const S = Bl(e.wordSeparators);
        if (w.length > 0) {
          const D = w.charCodeAt(w.length - 1);
          if (S.get(D) === 0)
            return null;
        }
      }
      if (!t.tokenization.isCheapToTokenize(_))
        return null;
      t.tokenization.forceTokenization(_);
      const E = t.tokenization.getLineTokens(_), k = Ng(E, b - 1);
      if (!h.shouldAutoClose(k, b - k.firstCharOffset))
        return null;
      const y = h.findNeutralCharacter();
      if (y) {
        const S = t.tokenization.getTokenTypeIfInsertingCharacter(_, b, y);
        if (!h.isOK(S))
          return null;
      }
    }
    return f ? h.close.substring(0, h.close.length - d.length) : h.close;
  }
  static _runAutoClosingOpenCharType(e, t, i, n, r, o, a) {
    const l = [];
    for (let c = 0, h = n.length; c < h; c++) {
      const u = n[c];
      l[c] = new tE(u, r, !o, a);
    }
    return new ui(4, l, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static _shouldSurroundChar(e, t) {
    return vr(t) ? e.autoSurround === "quotes" || e.autoSurround === "languageDefined" : e.autoSurround === "brackets" || e.autoSurround === "languageDefined";
  }
  static _isSurroundSelectionType(e, t, i, n) {
    if (!Ge._shouldSurroundChar(e, n) || !e.surroundingPairs.hasOwnProperty(n))
      return !1;
    const r = vr(n);
    for (const o of i) {
      if (o.isEmpty())
        return !1;
      let a = !0;
      for (let l = o.startLineNumber; l <= o.endLineNumber; l++) {
        const c = t.getLineContent(l), h = l === o.startLineNumber ? o.startColumn - 1 : 0, u = l === o.endLineNumber ? o.endColumn - 1 : c.length, d = c.substring(h, u);
        if (/[^ \t]/.test(d)) {
          a = !1;
          break;
        }
      }
      if (a)
        return !1;
      if (r && o.startLineNumber === o.endLineNumber && o.startColumn + 1 === o.endColumn) {
        const l = t.getValueInRange(o);
        if (vr(l))
          return !1;
      }
    }
    return !0;
  }
  static _runSurroundSelectionType(e, t, i, n, r) {
    const o = [];
    for (let a = 0, l = n.length; a < l; a++) {
      const c = n[a], h = t.surroundingPairs[r];
      o[a] = new YR(c, r, h);
    }
    return new ui(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.tokenization.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, n, r) {
    if (!t.electricChars.hasOwnProperty(r) || !n.isEmpty())
      return null;
    const o = n.getPosition();
    i.tokenization.forceTokenization(o.lineNumber);
    const a = i.tokenization.getLineTokens(o.lineNumber);
    let l;
    try {
      l = t.onElectricCharacter(r, a, o.column);
    } catch (c) {
      return ct(c), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      const c = (a.getLineContent() + r).lastIndexOf(l.matchOpenBracket) + 1, h = i.bracketPairs.findMatchingBracketUp(l.matchOpenBracket, {
        lineNumber: o.lineNumber,
        column: c
      }, 500);
      if (h) {
        if (h.startLineNumber === o.lineNumber)
          return null;
        const u = i.getLineContent(h.startLineNumber), d = wi(u), f = t.normalizeIndentation(d), m = i.getLineContent(o.lineNumber), _ = i.getLineFirstNonWhitespaceColumn(o.lineNumber) || o.column, b = m.substring(_ - 1, o.column - 1), v = f + b + r, C = new N(o.lineNumber, 1, o.lineNumber, o.column), w = new vi(C, v);
        return new ui(pp(v, e), [w], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
  static compositionEndWithInterceptors(e, t, i, n, r, o) {
    if (!n)
      return null;
    let a = null;
    for (const u of n)
      if (a === null)
        a = u.insertedText;
      else if (a !== u.insertedText)
        return null;
    if (!a || a.length !== 1)
      return null;
    const l = a;
    let c = !1;
    for (const u of n)
      if (u.deletedText.length !== 0) {
        c = !0;
        break;
      }
    if (c) {
      if (!Ge._shouldSurroundChar(t, l) || !t.surroundingPairs.hasOwnProperty(l))
        return null;
      const u = vr(l);
      for (const m of n)
        if (m.deletedSelectionStart !== 0 || m.deletedSelectionEnd !== m.deletedText.length || /^[ \t]+$/.test(m.deletedText) || u && vr(m.deletedText))
          return null;
      const d = [];
      for (const m of r) {
        if (!m.isEmpty())
          return null;
        d.push(m.getPosition());
      }
      if (d.length !== n.length)
        return null;
      const f = [];
      for (let m = 0, _ = d.length; m < _; m++)
        f.push(new QR(d[m], n[m].deletedText, l));
      return new ui(4, f, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    if (this._isAutoClosingOvertype(t, i, r, o, l)) {
      const u = r.map((d) => new vi(new N(d.positionLineNumber, d.positionColumn, d.positionLineNumber, d.positionColumn + 1), "", !1));
      return new ui(4, u, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const h = this._getAutoClosingPairClose(t, i, r, l, !0);
    return h !== null ? this._runAutoClosingOpenCharType(e, t, i, r, l, !0, h) : null;
  }
  static typeWithInterceptors(e, t, i, n, r, o, a) {
    if (!e && a === `
`) {
      const h = [];
      for (let u = 0, d = r.length; u < d; u++)
        h[u] = Ge._enter(i, n, !1, r[u]);
      return new ui(4, h, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    if (!e && this._isAutoIndentType(i, n, r)) {
      const h = [];
      let u = !1;
      for (let d = 0, f = r.length; d < f; d++)
        if (h[d] = this._runAutoIndentType(i, n, r[d], a), !h[d]) {
          u = !0;
          break;
        }
      if (!u)
        return new ui(4, h, {
          shouldPushStackElementBefore: !0,
          shouldPushStackElementAfter: !1
        });
    }
    if (this._isAutoClosingOvertype(i, n, r, o, a))
      return this._runAutoClosingOvertype(t, i, n, r, a);
    if (!e) {
      const h = this._getAutoClosingPairClose(i, n, r, a, !1);
      if (h)
        return this._runAutoClosingOpenCharType(t, i, n, r, a, !1, h);
    }
    if (!e && this._isSurroundSelectionType(i, n, r, a))
      return this._runSurroundSelectionType(t, i, n, r, a);
    if (!e && this._isTypeInterceptorElectricChar(i, n, r)) {
      const h = this._typeInterceptorElectricChar(t, i, n, r[0], a);
      if (h)
        return h;
    }
    const l = [];
    for (let h = 0, u = r.length; h < u; h++)
      l[h] = new vi(r[h], a);
    const c = pp(a, t);
    return new ui(c, l, {
      shouldPushStackElementBefore: ud(t, c),
      shouldPushStackElementAfter: !1
    });
  }
  static typeWithoutInterceptors(e, t, i, n, r) {
    const o = [];
    for (let l = 0, c = n.length; l < c; l++)
      o[l] = new vi(n[l], r);
    const a = pp(r, e);
    return new ui(a, o, {
      shouldPushStackElementBefore: ud(e, a),
      shouldPushStackElementAfter: !1
    });
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let r = 0, o = i.length; r < o; r++) {
      let a = i[r].positionLineNumber;
      if (a === 1)
        n[r] = new hd(new N(1, 1, 1, 1), `
`);
      else {
        a--;
        const l = t.getLineMaxColumn(a);
        n[r] = this._enter(e, t, !1, new N(a, l, a, l));
      }
    }
    return n;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let r = 0, o = i.length; r < o; r++) {
      const a = i[r].positionLineNumber, l = t.getLineMaxColumn(a);
      n[r] = this._enter(e, t, !1, new N(a, l, a, l));
    }
    return n;
  }
  static lineBreakInsert(e, t, i) {
    const n = [];
    for (let r = 0, o = i.length; r < o; r++)
      n[r] = this._enter(e, t, !0, i[r]);
    return n;
  }
}
class tE extends Gd {
  constructor(e, t, i, n) {
    super(e, (i ? t : "") + n, 0, -n.length), this._openCharacter = t, this._closeCharacter = n, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this.closeCharacterRange = new N(n.startLineNumber, n.endColumn - this._closeCharacter.length, n.endLineNumber, n.endColumn), this.enclosingRange = new N(n.startLineNumber, n.endColumn - this._openCharacter.length - this._closeCharacter.length, n.endLineNumber, n.endColumn), super.computeCursorState(e, t);
  }
}
class t9 {
  constructor(e, t, i, n, r, o) {
    this.deletedText = e, this.deletedSelectionStart = t, this.deletedSelectionEnd = i, this.insertedText = n, this.insertedSelectionStart = r, this.insertedSelectionEnd = o;
  }
}
function pp(s, e) {
  return s === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function ud(s, e) {
  return uS(s) && !uS(e) ? !0 : s === 5 ? !1 : hS(s) !== hS(e);
}
function hS(s) {
  return s === 6 || s === 5 ? "space" : s;
}
function uS(s) {
  return s === 4 || s === 5 || s === 6;
}
var j;
(function(s) {
  s.editorSimpleInput = new ie("editorSimpleInput", !1, !0), s.editorTextFocus = new ie("editorTextFocus", !1, p("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), s.focus = new ie("editorFocus", !1, p("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), s.textInputFocus = new ie("textInputFocus", !1, p("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), s.readOnly = new ie("editorReadonly", !1, p("editorReadonly", "Whether the editor is read only")), s.inDiffEditor = new ie("inDiffEditor", !1, p("inDiffEditor", "Whether the context is a diff editor")), s.columnSelection = new ie("editorColumnSelection", !1, p("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), s.writable = s.readOnly.toNegated(), s.hasNonEmptySelection = new ie("editorHasSelection", !1, p("editorHasSelection", "Whether the editor has text selected")), s.hasOnlyEmptySelection = s.hasNonEmptySelection.toNegated(), s.hasMultipleSelections = new ie("editorHasMultipleSelections", !1, p("editorHasMultipleSelections", "Whether the editor has multiple selections")), s.hasSingleSelection = s.hasMultipleSelections.toNegated(), s.tabMovesFocus = new ie("editorTabMovesFocus", !1, p("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), s.tabDoesNotMoveFocus = s.tabMovesFocus.toNegated(), s.isInWalkThroughSnippet = new ie("isInEmbeddedEditor", !1, !0), s.canUndo = new ie("canUndo", !1, !0), s.canRedo = new ie("canRedo", !1, !0), s.hoverVisible = new ie("editorHoverVisible", !1, p("editorHoverVisible", "Whether the editor hover is visible")), s.inCompositeEditor = new ie("inCompositeEditor", void 0, p("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), s.notInCompositeEditor = s.inCompositeEditor.toNegated(), s.languageId = new ie("editorLangId", "", p("editorLangId", "The language identifier of the editor")), s.hasCompletionItemProvider = new ie("editorHasCompletionItemProvider", !1, p("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), s.hasCodeActionsProvider = new ie("editorHasCodeActionsProvider", !1, p("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), s.hasCodeLensProvider = new ie("editorHasCodeLensProvider", !1, p("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), s.hasDefinitionProvider = new ie("editorHasDefinitionProvider", !1, p("editorHasDefinitionProvider", "Whether the editor has a definition provider")), s.hasDeclarationProvider = new ie("editorHasDeclarationProvider", !1, p("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), s.hasImplementationProvider = new ie("editorHasImplementationProvider", !1, p("editorHasImplementationProvider", "Whether the editor has an implementation provider")), s.hasTypeDefinitionProvider = new ie("editorHasTypeDefinitionProvider", !1, p("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), s.hasHoverProvider = new ie("editorHasHoverProvider", !1, p("editorHasHoverProvider", "Whether the editor has a hover provider")), s.hasDocumentHighlightProvider = new ie("editorHasDocumentHighlightProvider", !1, p("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), s.hasDocumentSymbolProvider = new ie("editorHasDocumentSymbolProvider", !1, p("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), s.hasReferenceProvider = new ie("editorHasReferenceProvider", !1, p("editorHasReferenceProvider", "Whether the editor has a reference provider")), s.hasRenameProvider = new ie("editorHasRenameProvider", !1, p("editorHasRenameProvider", "Whether the editor has a rename provider")), s.hasSignatureHelpProvider = new ie("editorHasSignatureHelpProvider", !1, p("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), s.hasInlayHintsProvider = new ie("editorHasInlayHintsProvider", !1, p("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), s.hasDocumentFormattingProvider = new ie("editorHasDocumentFormattingProvider", !1, p("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), s.hasDocumentSelectionFormattingProvider = new ie("editorHasDocumentSelectionFormattingProvider", !1, p("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), s.hasMultipleDocumentFormattingProvider = new ie("editorHasMultipleDocumentFormattingProvider", !1, p("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), s.hasMultipleDocumentSelectionFormattingProvider = new ie("editorHasMultipleDocumentSelectionFormattingProvider", !1, p("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(j || (j = {}));
const be = 0;
class Je extends to {
  runEditorCommand(e, t, i) {
    const n = t._getViewModel();
    !n || this.runCoreEditorCommand(n, i || {});
  }
}
var Of;
(function(s) {
  const e = function(i) {
    if (!Pi(i))
      return !1;
    const n = i;
    return !(!Fi(n.to) || !Rn(n.by) && !Fi(n.by) || !Rn(n.value) && !oc(n.value) || !Rn(n.revealCursor) && !Vk(n.revealCursor));
  };
  s.description = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage", "editor"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Up: "up",
    Down: "down"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage",
    Editor: "editor"
  };
  function t(i) {
    let n;
    switch (i.to) {
      case s.RawDirection.Up:
        n = 1;
        break;
      case s.RawDirection.Down:
        n = 2;
        break;
      default:
        return null;
    }
    let r;
    switch (i.by) {
      case s.RawUnit.Line:
        r = 1;
        break;
      case s.RawUnit.WrappedLine:
        r = 2;
        break;
      case s.RawUnit.Page:
        r = 3;
        break;
      case s.RawUnit.HalfPage:
        r = 4;
        break;
      case s.RawUnit.Editor:
        r = 5;
        break;
      default:
        r = 2;
    }
    const o = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: n,
      unit: r,
      value: o,
      revealCursor: a,
      select: !!i.select
    };
  }
  s.parse = t;
})(Of || (Of = {}));
var nl;
(function(s) {
  const e = function(t) {
    if (!Pi(t))
      return !1;
    const i = t;
    return !(!oc(i.lineNumber) && !Fi(i.lineNumber) || !Rn(i.at) && !Fi(i.at));
  };
  s.description = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, s.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(nl || (nl = {}));
class V1 {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const n = t.get(Ct).getFocusedCodeEditor();
      return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const n = document.activeElement;
      return n && ["input", "textarea"].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const n = t.get(Ct).getActiveCodeEditor();
      return n ? (n.focus(), this._runEditorCommand(t, n, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const n = this.runEditorCommand(e, t, i);
    return n || !0;
  }
}
var wt;
(function(s) {
  class e extends Je {
    constructor(C) {
      super(C), this._minimalReveal = C.minimalReveal, this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, [
        Gt.moveTo(C, C.getPrimaryCursorState(), this._inSelectionMode, w.position, w.viewPosition)
      ]) && C.revealPrimaryCursor(w.source, !0, this._minimalReveal);
    }
  }
  s.MoveTo = se(new e({
    id: "_moveTo",
    minimalReveal: !0,
    inSelectionMode: !1,
    precondition: void 0
  })), s.MoveToSelect = se(new e({
    id: "_moveToSelect",
    minimalReveal: !1,
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends Je {
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement();
      const L = this._getColumnSelectResult(C, C.getPrimaryCursorState(), C.getCursorColumnSelectData(), w);
      C.setCursorStates(w.source, 3, L.viewStates.map((E) => he.fromViewState(E))), C.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: L.fromLineNumber,
        fromViewVisualColumn: L.fromVisualColumn,
        toViewLineNumber: L.toLineNumber,
        toViewVisualColumn: L.toVisualColumn
      }), L.reversed ? C.revealTopMostCursor(w.source) : C.revealBottomMostCursor(w.source);
    }
  }
  s.ColumnSelect = se(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(v, C, w, L) {
      const E = v.model.validatePosition(L.position), k = v.coordinatesConverter.validateViewPosition(new O(L.viewPosition.lineNumber, L.viewPosition.column), E), y = L.doColumnSelect ? w.fromViewLineNumber : k.lineNumber, S = L.doColumnSelect ? w.fromViewVisualColumn : L.mouseColumn - 1;
      return Eo.columnSelect(v.cursorConfig, v, y, S, k.lineNumber, L.mouseColumn - 1);
    }
  }()), s.CursorColumnSelectLeft = se(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(v, C, w, L) {
      return Eo.columnSelectLeft(v.cursorConfig, v, w);
    }
  }()), s.CursorColumnSelectRight = se(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(v, C, w, L) {
      return Eo.columnSelectRight(v.cursorConfig, v, w);
    }
  }());
  class i extends t {
    constructor(C) {
      super(C), this._isPaged = C.isPaged;
    }
    _getColumnSelectResult(C, w, L, E) {
      return Eo.columnSelectUp(C.cursorConfig, C, L, this._isPaged);
    }
  }
  s.CursorColumnSelectUp = se(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageUp = se(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class n extends t {
    constructor(C) {
      super(C), this._isPaged = C.isPaged;
    }
    _getColumnSelectResult(C, w, L, E) {
      return Eo.columnSelectDown(C.cursorConfig, C, L, this._isPaged);
    }
  }
  s.CursorColumnSelectDown = se(new n({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageDown = se(new n({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class r extends Je {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        description: Pf.description
      });
    }
    runCoreEditorCommand(C, w) {
      const L = Pf.parse(w);
      !L || this._runCursorMove(C, w.source, L);
    }
    _runCursorMove(C, w, L) {
      C.model.pushStackElement(), C.setCursorStates(w, 3, r._move(C, C.getCursorStates(), L)), C.revealPrimaryCursor(w, !0);
    }
    static _move(C, w, L) {
      const E = L.select, k = L.value;
      switch (L.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return Gt.simpleMove(C, w, L.direction, E, k, L.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return Gt.viewportMove(C, w, L.direction, E, k);
        default:
          return null;
      }
    }
  }
  s.CursorMoveImpl = r, s.CursorMove = se(new r());
  class o extends Je {
    constructor(C) {
      super(C), this._staticArgs = C.args;
    }
    runCoreEditorCommand(C, w) {
      let L = this._staticArgs;
      this._staticArgs.value === -1 && (L = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: w.pageSize || C.cursorConfig.pageSize
      }), C.model.pushStackElement(), C.setCursorStates(w.source, 3, Gt.simpleMove(C, C.getCursorStates(), L.direction, L.select, L.value, L.unit)), C.revealPrimaryCursor(w.source, !0);
    }
  }
  s.CursorLeft = se(new o({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [288] }
    }
  })), s.CursorLeftSelect = se(new o({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1039
    }
  })), s.CursorRight = se(new o({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [292] }
    }
  })), s.CursorRightSelect = se(new o({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1041
    }
  })), s.CursorUp = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [302] }
    }
  })), s.CursorUpSelect = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1040,
      secondary: [3088],
      mac: { primary: 1040 },
      linux: { primary: 1040 }
    }
  })), s.CursorPageUp = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 11
    }
  })), s.CursorPageUpSelect = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1035
    }
  })), s.CursorDown = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [300] }
    }
  })), s.CursorDownSelect = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1042,
      secondary: [3090],
      mac: { primary: 1042 },
      linux: { primary: 1042 }
    }
  })), s.CursorPageDown = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 12
    }
  })), s.CursorPageDownSelect = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1036
    }
  })), s.CreateCursor = se(new class extends Je {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, C) {
      let w;
      C.wholeLine ? w = Gt.line(v, v.getPrimaryCursorState(), !1, C.position, C.viewPosition) : w = Gt.moveTo(v, v.getPrimaryCursorState(), !1, C.position, C.viewPosition);
      const L = v.getCursorStates();
      if (L.length > 1) {
        const E = w.modelState ? w.modelState.position : null, k = w.viewState ? w.viewState.position : null;
        for (let y = 0, S = L.length; y < S; y++) {
          const D = L[y];
          if (!(E && !D.modelState.selection.containsPosition(E)) && !(k && !D.viewState.selection.containsPosition(k))) {
            L.splice(y, 1), v.model.pushStackElement(), v.setCursorStates(C.source, 3, L);
            return;
          }
        }
      }
      L.push(w), v.model.pushStackElement(), v.setCursorStates(C.source, 3, L);
    }
  }()), s.LastCursorMoveToSelect = se(new class extends Je {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, C) {
      const w = v.getLastAddedCursorIndex(), L = v.getCursorStates(), E = L.slice(0);
      E[w] = Gt.moveTo(v, L[w], !0, C.position, C.viewPosition), v.model.pushStackElement(), v.setCursorStates(C.source, 3, E);
    }
  }());
  class a extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Gt.moveToBeginningOfLine(C, C.getCursorStates(), this._inSelectionMode)), C.revealPrimaryCursor(w.source, !0);
    }
  }
  s.CursorHome = se(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [2063] }
    }
  })), s.CursorHomeSelect = se(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [3087] }
    }
  }));
  class l extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, this._exec(C.getCursorStates())), C.revealPrimaryCursor(w.source, !0);
    }
    _exec(C) {
      const w = [];
      for (let L = 0, E = C.length; L < E; L++) {
        const k = C[L], y = k.modelState.position.lineNumber;
        w[L] = he.fromModelState(k.modelState.move(this._inSelectionMode, y, 1, 0));
      }
      return w;
    }
  }
  s.CursorLineStart = se(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 0,
      mac: { primary: 287 }
    }
  })), s.CursorLineStartSelect = se(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 0,
      mac: { primary: 1311 }
    }
  }));
  class c extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Gt.moveToEndOfLine(C, C.getCursorStates(), this._inSelectionMode, w.sticky || !1)), C.revealPrimaryCursor(w.source, !0);
    }
  }
  s.CursorEnd = se(new c({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [2065] }
    },
    description: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: p("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), s.CursorEndSelect = se(new c({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [3089] }
    },
    description: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: p("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class h extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, this._exec(C, C.getCursorStates())), C.revealPrimaryCursor(w.source, !0);
    }
    _exec(C, w) {
      const L = [];
      for (let E = 0, k = w.length; E < k; E++) {
        const y = w[E], S = y.modelState.position.lineNumber, D = C.model.getLineMaxColumn(S);
        L[E] = he.fromModelState(y.modelState.move(this._inSelectionMode, S, D, 0));
      }
      return L;
    }
  }
  s.CursorLineEnd = se(new h({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 0,
      mac: { primary: 291 }
    }
  })), s.CursorLineEndSelect = se(new h({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 0,
      mac: { primary: 1315 }
    }
  }));
  class u extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Gt.moveToBeginningOfBuffer(C, C.getCursorStates(), this._inSelectionMode)), C.revealPrimaryCursor(w.source, !0);
    }
  }
  s.CursorTop = se(new u({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 2062,
      mac: { primary: 2064 }
    }
  })), s.CursorTopSelect = se(new u({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 3086,
      mac: { primary: 3088 }
    }
  }));
  class d extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Gt.moveToEndOfBuffer(C, C.getCursorStates(), this._inSelectionMode)), C.revealPrimaryCursor(w.source, !0);
    }
  }
  s.CursorBottom = se(new d({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 2061,
      mac: { primary: 2066 }
    }
  })), s.CursorBottomSelect = se(new d({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: be,
      kbExpr: j.textInputFocus,
      primary: 3085,
      mac: { primary: 3090 }
    }
  }));
  class f extends Je {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        description: Of.description
      });
    }
    runCoreEditorCommand(C, w) {
      const L = Of.parse(w);
      !L || this._runEditorScroll(C, w.source, L);
    }
    _runEditorScroll(C, w, L) {
      const E = this._computeDesiredScrollTop(C, L);
      if (L.revealCursor) {
        const k = C.getCompletelyVisibleViewRangeAtScrollTop(E);
        C.setCursorStates(w, 3, [
          Gt.findPositionInViewportIfOutside(C, C.getPrimaryCursorState(), k, L.select)
        ]);
      }
      C.viewLayout.setScrollPosition({ scrollTop: E }, 0);
    }
    _computeDesiredScrollTop(C, w) {
      if (w.unit === 1) {
        const k = C.getCompletelyVisibleViewRange(), y = C.coordinatesConverter.convertViewRangeToModelRange(k);
        let S;
        w.direction === 1 ? S = Math.max(1, y.startLineNumber - w.value) : S = Math.min(C.model.getLineCount(), y.startLineNumber + w.value);
        const D = C.coordinatesConverter.convertModelPositionToViewPosition(new O(S, 1));
        return C.viewLayout.getVerticalOffsetForLineNumber(D.lineNumber);
      }
      if (w.unit === 5) {
        let k = 0;
        return w.direction === 2 && (k = C.model.getLineCount() - C.cursorConfig.pageSize), C.viewLayout.getVerticalOffsetForLineNumber(k);
      }
      let L;
      w.unit === 3 ? L = C.cursorConfig.pageSize * w.value : w.unit === 4 ? L = Math.round(C.cursorConfig.pageSize / 2) * w.value : L = w.value;
      const E = (w.direction === 1 ? -1 : 1) * L;
      return C.viewLayout.getCurrentScrollTop() + E * C.cursorConfig.lineHeight;
    }
  }
  s.EditorScrollImpl = f, s.EditorScroll = se(new f()), s.ScrollLineUp = se(new class extends Je {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 2064,
          mac: { primary: 267 }
        }
      });
    }
    runCoreEditorCommand(v, C) {
      s.EditorScroll._runEditorScroll(v, C.source, {
        direction: 1,
        unit: 2,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), s.ScrollPageUp = se(new class extends Je {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 2059,
          win: { primary: 523 },
          linux: { primary: 523 }
        }
      });
    }
    runCoreEditorCommand(v, C) {
      s.EditorScroll._runEditorScroll(v, C.source, {
        direction: 1,
        unit: 3,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), s.ScrollEditorTop = se(new class extends Je {
    constructor() {
      super({
        id: "scrollEditorTop",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus
        }
      });
    }
    runCoreEditorCommand(v, C) {
      s.EditorScroll._runEditorScroll(v, C.source, {
        direction: 1,
        unit: 5,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), s.ScrollLineDown = se(new class extends Je {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 2066,
          mac: { primary: 268 }
        }
      });
    }
    runCoreEditorCommand(v, C) {
      s.EditorScroll._runEditorScroll(v, C.source, {
        direction: 2,
        unit: 2,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), s.ScrollPageDown = se(new class extends Je {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 2060,
          win: { primary: 524 },
          linux: { primary: 524 }
        }
      });
    }
    runCoreEditorCommand(v, C) {
      s.EditorScroll._runEditorScroll(v, C.source, {
        direction: 2,
        unit: 3,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), s.ScrollEditorBottom = se(new class extends Je {
    constructor() {
      super({
        id: "scrollEditorBottom",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus
        }
      });
    }
    runCoreEditorCommand(v, C) {
      s.EditorScroll._runEditorScroll(v, C.source, {
        direction: 2,
        unit: 5,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }());
  class m extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, [
        Gt.word(C, C.getPrimaryCursorState(), this._inSelectionMode, w.position)
      ]), C.revealPrimaryCursor(w.source, !0);
    }
  }
  s.WordSelect = se(new m({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), s.WordSelectDrag = se(new m({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), s.LastCursorWordSelect = se(new class extends Je {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, C) {
      const w = v.getLastAddedCursorIndex(), L = v.getCursorStates(), E = L.slice(0), k = L[w];
      E[w] = Gt.word(v, k, k.modelState.hasSelection(), C.position), v.model.pushStackElement(), v.setCursorStates(C.source, 3, E);
    }
  }());
  class _ extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, [
        Gt.line(C, C.getPrimaryCursorState(), this._inSelectionMode, w.position, w.viewPosition)
      ]), C.revealPrimaryCursor(w.source, !1);
    }
  }
  s.LineSelect = se(new _({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), s.LineSelectDrag = se(new _({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class b extends Je {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      const L = C.getLastAddedCursorIndex(), E = C.getCursorStates(), k = E.slice(0);
      k[L] = Gt.line(C, E[L], this._inSelectionMode, w.position, w.viewPosition), C.model.pushStackElement(), C.setCursorStates(w.source, 3, k);
    }
  }
  s.LastCursorLineSelect = se(new b({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), s.LastCursorLineSelectDrag = se(new b({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), s.CancelSelection = se(new class extends Je {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: j.hasNonEmptySelection,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 9,
          secondary: [1033]
        }
      });
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        Gt.cancelSelection(v, v.getPrimaryCursorState())
      ]), v.revealPrimaryCursor(C.source, !0);
    }
  }()), s.RemoveSecondaryCursors = se(new class extends Je {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: j.hasMultipleSelections,
        kbOpts: {
          weight: be + 1,
          kbExpr: j.textInputFocus,
          primary: 9,
          secondary: [1033]
        }
      });
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        v.getPrimaryCursorState()
      ]), v.revealPrimaryCursor(C.source, !0), QM(p("removedCursor", "Removed secondary cursors"));
    }
  }()), s.RevealLine = se(new class extends Je {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        description: nl.description
      });
    }
    runCoreEditorCommand(v, C) {
      const w = C, L = w.lineNumber || 0;
      let E = typeof L == "number" ? L + 1 : parseInt(L) + 1;
      E < 1 && (E = 1);
      const k = v.model.getLineCount();
      E > k && (E = k);
      const y = new N(E, 1, E, v.model.getLineMaxColumn(E));
      let S = 0;
      if (w.at)
        switch (w.at) {
          case nl.RawAtArgument.Top:
            S = 3;
            break;
          case nl.RawAtArgument.Center:
            S = 1;
            break;
          case nl.RawAtArgument.Bottom:
            S = 4;
            break;
        }
      const D = v.coordinatesConverter.convertModelRangeToViewRange(y);
      v.revealRange(C.source, !1, D, S, 0);
    }
  }()), s.SelectAll = new class extends V1 {
    constructor() {
      super(cA);
    }
    runDOMCommand() {
      sn && (document.activeElement.focus(), document.activeElement.select()), document.execCommand("selectAll");
    }
    runEditorCommand(v, C, w) {
      const L = C._getViewModel();
      !L || this.runCoreEditorCommand(L, w);
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates("keyboard", 3, [
        Gt.selectAll(v, v.getPrimaryCursorState())
      ]);
    }
  }(), s.SetSelection = se(new class extends Je {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        he.fromModelSelection(C.selection)
      ]);
    }
  }());
})(wt || (wt = {}));
const i9 = Ut.and(j.textInputFocus, j.columnSelection);
function _c(s, e) {
  Jg.registerKeybindingRule({
    id: s,
    primary: e,
    when: i9,
    weight: be + 1
  });
}
_c(wt.CursorColumnSelectLeft.id, 1039);
_c(wt.CursorColumnSelectRight.id, 1041);
_c(wt.CursorColumnSelectUp.id, 1040);
_c(wt.CursorColumnSelectPageUp.id, 1035);
_c(wt.CursorColumnSelectDown.id, 1042);
_c(wt.CursorColumnSelectPageDown.id, 1036);
function dS(s) {
  return s.register(), s;
}
var fS;
(function(s) {
  class e extends to {
    runEditorCommand(i, n, r) {
      const o = n._getViewModel();
      !o || this.runCoreEditingCommand(n, o, r || {});
    }
  }
  s.CoreEditingCommand = e, s.LineBreakInsert = se(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: j.writable,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 0,
          mac: { primary: 301 }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Ge.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((r) => r.modelState.selection)));
    }
  }()), s.Outdent = se(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: j.writable,
        kbOpts: {
          weight: be,
          kbExpr: Ut.and(j.editorTextFocus, j.tabDoesNotMoveFocus),
          primary: 1026
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Ge.outdent(i.cursorConfig, i.model, i.getCursorStates().map((r) => r.modelState.selection))), t.pushUndoStop();
    }
  }()), s.Tab = se(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: j.writable,
        kbOpts: {
          weight: be,
          kbExpr: Ut.and(j.editorTextFocus, j.tabDoesNotMoveFocus),
          primary: 2
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Ge.tab(i.cursorConfig, i.model, i.getCursorStates().map((r) => r.modelState.selection))), t.pushUndoStop();
    }
  }()), s.DeleteLeft = se(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 1,
          secondary: [1025],
          mac: { primary: 1, secondary: [1025, 294, 257] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [r, o] = ea.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      r && t.pushUndoStop(), t.executeCommands(this.id, o), i.setPrevEditOperationType(2);
    }
  }()), s.DeleteRight = se(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: be,
          kbExpr: j.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [290, 276] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [r, o] = ea.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      r && t.pushUndoStop(), t.executeCommands(this.id, o), i.setPrevEditOperationType(3);
    }
  }()), s.Undo = new class extends V1 {
    constructor() {
      super(bD);
    }
    runDOMCommand() {
      document.execCommand("undo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(83) === !0))
        return i.getModel().undo();
    }
  }(), s.Redo = new class extends V1 {
    constructor() {
      super(CD);
    }
    runDOMCommand() {
      document.execCommand("redo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(83) === !0))
        return i.getModel().redo();
    }
  }();
})(fS || (fS = {}));
class gS extends em {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      description: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(Ct).getFocusedCodeEditor();
    !i || i.trigger("keyboard", this._handlerId, t);
  }
}
function da(s, e) {
  dS(new gS("default:" + s, s)), dS(new gS(s, s, e));
}
da("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
da("replacePreviousChar");
da("compositionType");
da("compositionStart");
da("compositionEnd");
da("paste");
da("cut");
class n9 {
  constructor(e, t, i, n) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
  }
  paste(e, t, i, n) {
    this.commandDelegate.paste(e, t, i, n);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, n) {
    this.commandDelegate.compositionType(e, t, i, n);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    wt.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new O(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(72)) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(72)) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = _i && t.get(98), n = t.get(18);
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position) : this._lastCursorLineSelect(e.position) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position) : e.inSelectionMode ? this._wordSelectDrag(e.position) : this._wordSelect(e.position)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : n ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position) : this.moveTo(e.position);
  }
  _usualArgs(e) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e
    };
  }
  moveTo(e) {
    wt.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _moveToSelect(e) {
    wt.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), wt.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), wt.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e) {
    wt.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _wordSelect(e) {
    wt.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _wordSelectDrag(e) {
    wt.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorWordSelect(e) {
    wt.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lineSelect(e) {
    wt.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lineSelectDrag(e) {
    wt.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorLineSelect(e) {
    wt.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorLineSelectDrag(e) {
    wt.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _selectAll() {
    wt.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
class om {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    var t;
    (t = this.onKeyDown) === null || t === void 0 || t.call(this, e);
  }
  emitKeyUp(e) {
    var t;
    (t = this.onKeyUp) === null || t === void 0 || t.call(this, e);
  }
  emitContextMenu(e) {
    var t;
    (t = this.onContextMenu) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    var t;
    (t = this.onMouseMove) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    var t;
    (t = this.onMouseLeave) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    var t;
    (t = this.onMouseDown) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    var t;
    (t = this.onMouseUp) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    var t;
    (t = this.onMouseDrag) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    var t;
    (t = this.onMouseDrop) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    var e;
    (e = this.onMouseDropCanceled) === null || e === void 0 || e.call(this);
  }
  emitMouseWheel(e) {
    var t;
    (t = this.onMouseWheel) === null || t === void 0 || t.call(this, e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return om.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    const i = Object.assign({}, e);
    return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), i;
  }
}
var _p;
class iE {
  constructor(e) {
    this._createLine = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new Error("Illegal value for lineNumber");
    return this._lines[t];
  }
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), n = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > n)
      return null;
    let r = 0, o = 0;
    for (let l = i; l <= n; l++) {
      const c = l - this._rendLineNumberStart;
      e <= l && l <= t && (o === 0 ? (r = c, o = 1) : o++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(r, o);
  }
  onLinesChanged(e, t) {
    const i = e + t - 1;
    if (this.getCount() === 0)
      return !1;
    const n = this.getStartLineNumber(), r = this.getEndLineNumber();
    let o = !1;
    for (let a = e; a <= i; a++)
      a >= n && a <= r && (this._lines[a - this._rendLineNumberStart].onContentChanged(), o = !0);
    return o;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, n = this.getStartLineNumber(), r = this.getEndLineNumber();
    if (e <= n)
      return this._rendLineNumberStart += i, null;
    if (e > r)
      return null;
    if (i + e > r)
      return this._lines.splice(e - this._rendLineNumberStart, r - e + 1);
    const o = [];
    for (let u = 0; u < i; u++)
      o[u] = this._createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), c = this._lines.slice(a, this._lines.length - i), h = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(o).concat(c), h;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let n = !1;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), c = Math.min(i, a.toLineNumber);
      for (let h = l; h <= c; h++) {
        const u = h - this._rendLineNumberStart;
        this._lines[u].onTokensChanged(), n = !0;
      }
    }
    return n;
  }
}
class nE {
  constructor(e) {
    this._host = e, this.domNode = this._createDomNode(), this._linesCollection = new iE(() => this._host.createVisibleLine());
  }
  _createDomNode() {
    const e = me(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  onConfigurationChanged(e) {
    return !!e.hasChanged(133);
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const r = t[i].getDomNode();
        r && this.domNode.domNode.removeChild(r);
      }
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const r = t[i].getDomNode();
        r && this.domNode.domNode.removeChild(r);
      }
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new $s(this.domNode.domNode, this._host, e), n = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, r = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(r.rendLineNumberStart, r.lines);
  }
}
class $s {
  constructor(e, t, i) {
    this.domNode = e, this.host = t, this.viewportData = i;
  }
  render(e, t, i, n) {
    const r = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (r.rendLineNumberStart + r.linesLength - 1 < t || i < r.rendLineNumberStart) {
      r.rendLineNumberStart = t, r.linesLength = i - t + 1, r.lines = [];
      for (let o = t; o <= i; o++)
        r.lines[o - t] = this.host.createVisibleLine();
      return this._finishRendering(r, !0, n), r;
    }
    if (this._renderUntouchedLines(r, Math.max(t - r.rendLineNumberStart, 0), Math.min(i - r.rendLineNumberStart, r.linesLength - 1), n, t), r.rendLineNumberStart > t) {
      const o = t, a = Math.min(i, r.rendLineNumberStart - 1);
      o <= a && (this._insertLinesBefore(r, o, a, n, t), r.linesLength += a - o + 1);
    } else if (r.rendLineNumberStart < t) {
      const o = Math.min(r.linesLength, t - r.rendLineNumberStart);
      o > 0 && (this._removeLinesBefore(r, o), r.linesLength -= o);
    }
    if (r.rendLineNumberStart = t, r.rendLineNumberStart + r.linesLength - 1 < i) {
      const o = r.rendLineNumberStart + r.linesLength, a = i;
      o <= a && (this._insertLinesAfter(r, o, a, n, t), r.linesLength += a - o + 1);
    } else if (r.rendLineNumberStart + r.linesLength - 1 > i) {
      const o = Math.max(0, i - r.rendLineNumberStart + 1), l = r.linesLength - 1 - o + 1;
      l > 0 && (this._removeLinesAfter(r, l), r.linesLength -= l);
    }
    return this._finishRendering(r, !1, n), r;
  }
  _renderUntouchedLines(e, t, i, n, r) {
    const o = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const c = o + l;
      a[l].layoutLine(c, n[c - r]);
    }
  }
  _insertLinesBefore(e, t, i, n, r) {
    const o = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      o[a++] = this.host.createVisibleLine();
    e.lines = o.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++) {
      const n = e.lines[i].getDomNode();
      n && this.domNode.removeChild(n);
    }
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, n, r) {
    const o = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      o[a++] = this.host.createVisibleLine();
    e.lines = e.lines.concat(o);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let n = 0; n < t; n++) {
      const r = e.lines[i + n].getDomNode();
      r && this.domNode.removeChild(r);
    }
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, n) {
    $s._ttPolicy && (i = $s._ttPolicy.createHTML(i));
    const r = this.domNode.lastChild;
    t || !r ? this.domNode.innerHTML = i : r.insertAdjacentHTML("afterend", i);
    let o = this.domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      n[a] && (l.setDomNode(o), o = o.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const n = document.createElement("div");
    $s._ttPolicy && (t = $s._ttPolicy.createHTML(t)), n.innerHTML = t;
    for (let r = 0; r < e.linesLength; r++) {
      const o = e.lines[r];
      if (i[r]) {
        const a = n.firstChild, l = o.getDomNode();
        l.parentNode.replaceChild(a, l), o.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const n = $s._sb, r = e.linesLength, o = e.lines, a = e.rendLineNumberStart, l = [];
    {
      n.reset();
      let c = !1;
      for (let h = 0; h < r; h++) {
        const u = o[h];
        l[h] = !1, !(u.getDomNode() || !u.renderLine(h + a, i[h], this.viewportData, n)) && (l[h] = !0, c = !0);
      }
      c && this._finishRenderingNewLines(e, t, n.build(), l);
    }
    {
      n.reset();
      let c = !1;
      const h = [];
      for (let u = 0; u < r; u++) {
        const d = o[u];
        h[u] = !1, !(l[u] || !d.renderLine(u + a, i[u], this.viewportData, n)) && (h[u] = !0, c = !0);
      }
      c && this._finishRenderingInvalidLines(e, n.build(), h);
    }
  }
}
$s._ttPolicy = (_p = window.trustedTypes) === null || _p === void 0 ? void 0 : _p.createPolicy("editorViewLayer", { createHTML: (s) => s });
$s._sb = Ol(1e5);
class sE extends Ui {
  constructor(e) {
    super(e), this._visibleLines = new nE(this), this.domNode = this._visibleLines.domNode, this._dynamicOverlays = [], this._isFocused = !1, this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  createVisibleLine() {
    return new s9(this._context.configuration, this._dynamicOverlays);
  }
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let n = t; n <= i; n++)
      this._visibleLines.getVisibleLine(n).onConfigurationChanged(e);
    return !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      r.prepareRender(e), r.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class s9 {
  constructor(e, t) {
    this._configuration = e, this._lineHeight = this._configuration.options.get(61), this._dynamicOverlays = t, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = me(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  onConfigurationChanged(e) {
    this._lineHeight = this._configuration.options.get(61);
  }
  renderLine(e, t, i, n) {
    let r = "";
    for (let o = 0, a = this._dynamicOverlays.length; o < a; o++) {
      const l = this._dynamicOverlays[o];
      r += l.render(i.startLineNumber, e);
    }
    return this._renderedContent === r ? !1 : (this._renderedContent = r, n.appendASCIIString('<div style="position:absolute;top:'), n.appendASCIIString(String(t)), n.appendASCIIString("px;width:100%;height:"), n.appendASCIIString(String(this._lineHeight)), n.appendASCIIString('px;">'), n.appendASCIIString(r), n.appendASCIIString("</div>"), !0);
  }
  layoutLine(e, t) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(this._lineHeight));
  }
}
class r9 extends sE {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(133);
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(133);
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class o9 extends sE {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(133);
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), mi(this.domNode, t.get(46));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    mi(this.domNode, t.get(46));
    const i = t.get(133);
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class Pc {
  constructor(e, t) {
    this._coordinateBrand = void 0, this.top = e, this.left = t;
  }
}
class a9 extends Ui {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = me(document.createElement("div")), fs.write(this.domNode, 1), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = me(document.createElement("div")), fs.write(this.overflowingContentWidgetsDomNode, 2), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onLineMappingChanged(e);
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  addWidget(e) {
    const t = new l9(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i, n) {
    this._widgets[e.getId()].setPosition(t, i, n), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const n = i.domNode.domNode;
      n.parentNode.removeChild(n), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
class l9 {
  constructor(e, t, i) {
    this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = me(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const n = this._context.configuration.options, r = n.get(133);
    this._fixedOverflowWidgets = n.get(38), this._contentWidth = r.contentWidth, this._contentLeft = r.contentLeft, this._lineHeight = n.get(61), this._range = null, this._viewRange = null, this._affinity = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(61), e.hasChanged(133)) {
      const i = t.get(133);
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  onLineMappingChanged(e) {
    this._setPosition(this._range, this._affinity);
  }
  _setPosition(e, t) {
    var i;
    if (this._range = e, this._viewRange = null, this._affinity = t, this._range) {
      const n = this._context.viewModel.model.validateRange(this._range);
      (this._context.viewModel.coordinatesConverter.modelPositionIsVisible(n.getStartPosition()) || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(n.getEndPosition())) && (this._viewRange = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(n, (i = this._affinity) !== null && i !== void 0 ? i : void 0));
    }
  }
  _getMaxWidth() {
    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.offsetWidth || document.body.offsetWidth : this._contentWidth;
  }
  setPosition(e, t, i) {
    this._setPosition(e, i), this._preference = t, this._viewRange && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, n, r) {
    const o = e.top, a = o, l = t.top + this._lineHeight, c = r.viewportHeight - l, h = o - n, u = a >= n, d = l, f = c >= n;
    let m = e.left, _ = t.left;
    return m + i > r.scrollLeft + r.viewportWidth && (m = r.scrollLeft + r.viewportWidth - i), _ + i > r.scrollLeft + r.viewportWidth && (_ = r.scrollLeft + r.viewportWidth - i), m < r.scrollLeft && (m = r.scrollLeft), _ < r.scrollLeft && (_ = r.scrollLeft), {
      fitsAbove: u,
      aboveTop: h,
      aboveLeft: m,
      fitsBelow: f,
      belowTop: d,
      belowLeft: _
    };
  }
  _layoutHorizontalSegmentInPage(e, t, i, n) {
    const r = Math.max(0, t.left - n), o = Math.min(t.left + t.width + n, e.width);
    let a = t.left + i - tr.scrollX;
    if (a + n > o) {
      const l = a - (o - n);
      a -= l, i -= l;
    }
    if (a < r) {
      const l = a - r;
      a -= l, i -= l;
    }
    return [i, a];
  }
  _layoutBoxInPage(e, t, i, n, r) {
    const o = e.top - n, a = t.top + this._lineHeight, l = is(this._viewDomNode.domNode), c = l.top + o - tr.scrollY, h = l.top + a - tr.scrollY, u = J2(document.body), [d, f] = this._layoutHorizontalSegmentInPage(u, l, e.left - r.scrollLeft + this._contentLeft, i), [m, _] = this._layoutHorizontalSegmentInPage(u, l, t.left - r.scrollLeft + this._contentLeft, i), b = 22, v = 22, C = c >= b, w = h + n <= u.height - v;
    return this._fixedOverflowWidgets ? {
      fitsAbove: C,
      aboveTop: Math.max(c, b),
      aboveLeft: f,
      fitsBelow: w,
      belowTop: h,
      belowLeft: _
    } : {
      fitsAbove: C,
      aboveTop: o,
      aboveLeft: d,
      fitsBelow: w,
      belowTop: a,
      belowLeft: m
    };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new Pc(e.top, e.left + this._contentLeft);
  }
  _getTopAndBottomLeft(e) {
    if (!this._viewRange)
      return [null, null];
    const t = e.linesVisibleRangesForRange(this._viewRange, !1);
    if (!t || t.length === 0)
      return [null, null];
    let i = t[0], n = t[0];
    for (const u of t)
      u.lineNumber < i.lineNumber && (i = u), u.lineNumber > n.lineNumber && (n = u);
    let r = 1073741824;
    for (const u of i.ranges)
      u.left < r && (r = u.left);
    let o = 1073741824;
    for (const u of n.ranges)
      u.left < o && (o = u.left);
    const a = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.scrollTop, l = new Pc(a, r), c = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.scrollTop, h = new Pc(c, o);
    return [l, h];
  }
  _prepareRenderWidget(e) {
    if (!this._preference || this._preference.length === 0)
      return null;
    const [t, i] = this._getTopAndBottomLeft(e);
    if (!t || !i)
      return null;
    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
      let r = null;
      if (typeof this._actual.beforeRender == "function" && (r = bp(this._actual.beforeRender, this._actual)), r)
        this._cachedDomNodeOffsetWidth = r.width, this._cachedDomNodeOffsetHeight = r.height;
      else {
        const a = this.domNode.domNode.getBoundingClientRect();
        this._cachedDomNodeOffsetWidth = Math.round(a.width), this._cachedDomNodeOffsetHeight = Math.round(a.height);
      }
    }
    let n;
    this.allowEditorOverflow ? n = this._layoutBoxInPage(t, i, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : n = this._layoutBoxInViewport(t, i, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
    for (let r = 1; r <= 2; r++)
      for (const o of this._preference)
        if (o === 1) {
          if (!n)
            return null;
          if (r === 2 || n.fitsAbove)
            return { coordinate: new Pc(n.aboveTop, n.aboveLeft), position: 1 };
        } else if (o === 2) {
          if (!n)
            return null;
          if (r === 2 || n.fitsBelow)
            return { coordinate: new Pc(n.belowTop, n.belowLeft), position: 2 };
        } else
          return this.allowEditorOverflow ? { coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(t), position: 0 } : { coordinate: t, position: 0 };
    return null;
  }
  onBeforeRender(e) {
    !this._viewRange || !this._preference || this._viewRange.endLineNumber < e.startLineNumber || this._viewRange.startLineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    if (!this._renderData) {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && bp(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && bp(this._actual.afterRender, this._actual, this._renderData.position);
  }
}
function bp(s, e, ...t) {
  try {
    return s.call(e, ...t);
  } catch {
    return null;
  }
}
class rE extends pc {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(133);
    this._lineHeight = t.get(61), this._renderLineHighlight = t.get(87), this._renderLineHighlightOnlyWhenFocus = t.get(88), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new Ce(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = this._selections.map((n) => n.positionLineNumber);
    t.sort((n, r) => n - r), rs(this._cursorLineNumbers, t) || (this._cursorLineNumbers = t, e = !0);
    const i = this._selections.every((n) => n.isEmpty());
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, e = !0), e;
  }
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(133);
    return this._lineHeight = t.get(61), this._renderLineHighlight = t.get(87), this._renderLineHighlightOnlyWhenFocus = t.get(88), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = this._renderOne(e), i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, r = this._cursorLineNumbers.length;
    let o = 0;
    const a = [];
    for (let l = i; l <= n; l++) {
      const c = l - i;
      for (; o < r && this._cursorLineNumbers[o] < l; )
        o++;
      o < r && this._cursorLineNumbers[o] === l ? a[c] = t : a[c] = "";
    }
    this._renderData = a;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
  _shouldRenderInMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderInContent() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class c9 extends rE {
  _renderOne(e) {
    return `<div class="${"current-line" + (this._shouldRenderOther() ? " current-line-both" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderThis() {
    return this._shouldRenderInContent();
  }
  _shouldRenderOther() {
    return this._shouldRenderInMargin();
  }
}
class h9 extends rE {
  _renderOne(e) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "")}" style="width:${this._contentLeft}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return this._shouldRenderInContent();
  }
}
zi((s, e) => {
  const t = s.getColor(jD);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || s.defines(cS)) {
    const i = s.getColor(cS);
    i && (e.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${i}; }`), cs(s.type) && (e.addRule(".monaco-editor .view-overlays .current-line { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }")));
  }
});
class u9 extends pc {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._lineHeight = t.get(61), this._typicalHalfwidthCharacterWidth = t.get(46).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._lineHeight = t.get(61), this._typicalHalfwidthCharacterWidth = t.get(46).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], n = 0;
    for (let l = 0, c = t.length; l < c; l++) {
      const h = t[l];
      h.options.className && (i[n++] = h);
    }
    i = i.sort((l, c) => {
      if (l.options.zIndex < c.options.zIndex)
        return -1;
      if (l.options.zIndex > c.options.zIndex)
        return 1;
      const h = l.options.className, u = c.options.className;
      return h < u ? -1 : h > u ? 1 : N.compareRangesUsingStarts(l.range, c.range);
    });
    const r = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber, a = [];
    for (let l = r; l <= o; l++) {
      const c = l - r;
      a[c] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const n = String(this._lineHeight), r = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber;
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a];
      if (!c.options.isWholeLine)
        continue;
      const h = '<div class="cdr ' + c.options.className + '" style="left:0;width:100%;height:' + n + 'px;"></div>', u = Math.max(c.range.startLineNumber, r), d = Math.min(c.range.endLineNumber, o);
      for (let f = u; f <= d; f++) {
        const m = f - r;
        i[m] += h;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    const n = String(this._lineHeight), r = e.visibleRange.startLineNumber;
    let o = null, a = !1, l = null;
    for (let c = 0, h = t.length; c < h; c++) {
      const u = t[c];
      if (u.options.isWholeLine)
        continue;
      const d = u.options.className, f = Boolean(u.options.showIfCollapsed);
      let m = u.range;
      if (f && m.endColumn === 1 && m.endLineNumber !== m.startLineNumber && (m = new N(m.startLineNumber, m.startColumn, m.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(m.endLineNumber - 1))), o === d && a === f && N.areIntersectingOrTouching(l, m)) {
        l = N.plusRange(l, m);
        continue;
      }
      o !== null && this._renderNormalDecoration(e, l, o, a, n, r, i), o = d, a = f, l = m;
    }
    o !== null && this._renderNormalDecoration(e, l, o, a, n, r, i);
  }
  _renderNormalDecoration(e, t, i, n, r, o, a) {
    const l = e.linesVisibleRangesForRange(t, i === "findMatch");
    if (!!l)
      for (let c = 0, h = l.length; c < h; c++) {
        const u = l[c];
        if (u.outsideRenderedLine)
          continue;
        const d = u.lineNumber - o;
        if (n && u.ranges.length === 1) {
          const f = u.ranges[0];
          if (f.width < this._typicalHalfwidthCharacterWidth) {
            const m = Math.round(f.left + f.width / 2), _ = Math.max(0, Math.round(m - this._typicalHalfwidthCharacterWidth / 2));
            u.ranges[0] = new sm(_, this._typicalHalfwidthCharacterWidth);
          }
        }
        for (let f = 0, m = u.ranges.length; f < m; f++) {
          const _ = u.ranges[f], b = '<div class="cdr ' + i + '" style="left:' + String(_.left) + "px;width:" + String(_.width) + "px;height:" + r + 'px;"></div>';
          a[d] += b;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class am extends z {
  onclick(e, t) {
    this._register(H(e, $.CLICK, (i) => t(new Gs(i))));
  }
  onmousedown(e, t) {
    this._register(H(e, $.MOUSE_DOWN, (i) => t(new Gs(i))));
  }
  onmouseover(e, t) {
    this._register(H(e, $.MOUSE_OVER, (i) => t(new Gs(i))));
  }
  onmouseleave(e, t) {
    this._register(H(e, $.MOUSE_LEAVE, (i) => t(new Gs(i))));
  }
  onkeydown(e, t) {
    this._register(H(e, $.KEY_DOWN, (i) => t(new nt(i))));
  }
  onkeyup(e, t) {
    this._register(H(e, $.KEY_UP, (i) => t(new nt(i))));
  }
  oninput(e, t) {
    this._register(H(e, $.INPUT, t));
  }
  onblur(e, t) {
    this._register(H(e, $.BLUR, t));
  }
  onfocus(e, t) {
    this._register(H(e, $.FOCUS, t));
  }
  ignoreGesture(e) {
    Ne.ignoreTarget(e);
  }
}
const Kl = 11;
class d9 extends am {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...e.icon.classNamesArray), this.domNode.style.position = "absolute", this.domNode.style.width = Kl + "px", this.domNode.style.height = Kl + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._pointerMoveMonitor = this._register(new im()), this._register(pi(this.bgDomNode, $.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._register(pi(this.domNode, $.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._pointerdownRepeatTimer = this._register(new Nu()), this._pointerdownScheduleRepeatTimer = this._register(new oo());
  }
  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24);
    };
    this._onActivate(), this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancelAndSet(t, 200), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (i) => {
    }, () => {
      this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class f9 extends z {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._rawShouldBeVisible = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new oo());
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
  }
  setShouldBeVisible(e) {
    this._rawShouldBeVisible = e, this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const e = this._applyVisibilitySetting();
    this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      var e;
      (e = this._domNode) === null || e === void 0 || e.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    var t;
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, (t = this._domNode) === null || t === void 0 || t.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const g9 = 140;
class oE extends am {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new f9(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._pointerMoveMonitor = this._register(new im()), this._shouldRender = !0, this.domNode = me(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this._register(H(this.domNode.domNode, $.POINTER_DOWN, (t) => this._domNodePointerDown(t)));
  }
  _createArrow(e) {
    const t = this._register(new d9(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  _createSlider(e, t, i, n) {
    this.slider = me(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this._register(H(this.slider.domNode, $.POINTER_DOWN, (r) => {
      r.button === 0 && (r.preventDefault(), this._sliderPointerDown(r));
    })), this.onclick(this.slider.domNode, (r) => {
      r.leftButton && r.stopPropagation();
    });
  }
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    !this._shouldRender || (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  _domNodePointerDown(e) {
    e.target === this.domNode.domNode && this._onPointerDown(e);
  }
  delegatePointerDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), r = this._sliderPointerPosition(e);
    i <= r && r <= n ? e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e)) : this._onPointerDown(e);
  }
  _onPointerDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.offsetX == "number" && typeof e.offsetY == "number")
      t = e.offsetX, i = e.offsetY;
    else {
      const r = is(this.domNode.domNode);
      t = e.pageX - r.left, i = e.pageY - r.top;
    }
    const n = this._pointerDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e));
  }
  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._sliderPointerPosition(e), i = this._sliderOrthogonalPointerPosition(e), n = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (r) => {
      const o = this._sliderOrthogonalPointerPosition(r), a = Math.abs(o - i);
      if (Vi && a > g9) {
        this._setDesiredScrollPositionNow(n.getScrollPosition());
        return;
      }
      const c = this._sliderPointerPosition(r) - t;
      this._setDesiredScrollPositionNow(n.getDesiredScrollPositionFromDelta(c));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const m9 = 20;
class qh {
  constructor(e, t, i, n, r, o) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = r, this._scrollPosition = o, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new qh(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = Math.round(e);
  }
  setOppositeScrollbarSize(e) {
    this._oppositeScrollbarSize = Math.round(e);
  }
  static _computeValues(e, t, i, n, r) {
    const o = Math.max(0, i - e), a = Math.max(0, o - 2 * t), l = n > 0 && n > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(o),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const c = Math.round(Math.max(m9, Math.floor(i * a / n))), h = (a - c) / (n - i), u = r * h;
    return {
      computedAvailableSize: Math.round(o),
      computedIsNeeded: l,
      computedSliderSize: Math.round(c),
      computedSliderRatio: h,
      computedSliderPosition: Math.round(u)
    };
  }
  _refreshComputedValues() {
    const e = qh._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
class p9 extends oE {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), r = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new qh(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, r.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const o = (t.arrowSize - Kl) / 2, a = (t.horizontalScrollbarSize - Kl) / 2;
      this._createArrow({
        className: "scra",
        icon: g.scrollbarButtonLeft,
        top: a,
        left: o,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Vl(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: g.scrollbarButtonRight,
        top: a,
        left: void 0,
        bottom: void 0,
        right: o,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Vl(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return e;
  }
  _sliderPointerPosition(e) {
    return e.pageX;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
  }
}
class _9 extends oE {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), r = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new qh(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        0,
        n.height,
        n.scrollHeight,
        r.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const o = (t.arrowSize - Kl) / 2, a = (t.verticalScrollbarSize - Kl) / 2;
      this._createArrow({
        className: "scra",
        icon: g.scrollbarButtonUp,
        top: o,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Vl(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: g.scrollbarButtonDown,
        top: void 0,
        left: a,
        bottom: o,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Vl(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return t;
  }
  _sliderPointerPosition(e) {
    return e.pageY;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
  }
}
class Ff {
  constructor(e, t, i, n, r, o, a) {
    this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, r = r | 0, o = o | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), r < 0 && (r = 0), a + r > o && (a = o - r), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = r, this.scrollHeight = o, this.scrollTop = a;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new Ff(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new Ff(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, r = this.scrollLeft !== e.scrollLeft, o = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: n,
      scrollLeftChanged: r,
      heightChanged: o,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class Fu extends z {
  constructor(e) {
    super(), this._scrollableBrand = void 0, this._onScroll = this._register(new A()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new Ff(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    var i;
    const n = this._state.withScrollDimensions(e, t);
    this._setState(n, Boolean(this._smoothScrolling)), (i = this._smoothScrolling) === null || i === void 0 || i.acceptScrollDimensions(this._state);
  }
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let n;
      t ? n = new Gh(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = Gh.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      !this._smoothScrolling || (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        !this._smoothScrolling || (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class mS {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function Cp(s, e) {
  const t = e - s;
  return function(i) {
    return s + t * v9(i);
  };
}
function b9(s, e, t) {
  return function(i) {
    return i < t ? s(i / t) : e((i - t) / (1 - t));
  };
}
class Gh {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let r, o;
      return e < t ? (r = e + 0.75 * i, o = t - 0.75 * i) : (r = e - 0.75 * i, o = t + 0.75 * i), b9(Cp(e, r), Cp(o, t), 0.33);
    }
    return Cp(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), n = this.scrollTop(t);
      return new mS(i, n, !1);
    }
    return new mS(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return Gh.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const n = Date.now() - 10;
    return new Gh(e, t, n, i);
  }
}
function C9(s) {
  return Math.pow(s, 3);
}
function v9(s) {
  return 1 - C9(1 - s);
}
const w9 = 500, pS = 50;
class S9 {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
class W1 {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, n = this._rear;
    do {
      const r = n === this._front ? e : Math.pow(2, -i);
      if (e -= r, t += this._memory[n].score * r, n === this._front)
        break;
      n = (this._capacity + n - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  accept(e, t, i) {
    const n = new S9(e, t, i);
    n.score = this._computeScore(n), this._front === -1 && this._rear === -1 ? (this._memory[0] = n, this._front = 0, this._rear = 0) : (this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = n);
  }
  _computeScore(e) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let t = 0.5;
    return this._front === -1 && this._rear === -1 || this._memory[this._rear], (!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (t += 0.25), Math.min(Math.max(t, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
}
W1.INSTANCE = new W1();
class tC extends am {
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new A()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new A()), e.style.overflow = "hidden", this._options = L9(t), this._scrollable = i, this._register(this._scrollable.onScroll((r) => {
      this._onWillScroll.fire(r), this._onDidScroll(r), this._onScroll.fire(r);
    }));
    const n = {
      onMouseWheel: (r) => this._onMouseWheel(r),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new _9(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new p9(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = me(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = me(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = me(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (r) => this._onMouseOver(r)), this.onmouseleave(this._listenOnDomNode, (r) => this._onMouseLeave(r)), this._hideTimeout = this._register(new oo()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  get options() {
    return this._options;
  }
  dispose() {
    this._mouseWheelToDispose = je(this._mouseWheelToDispose), super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  delegateVerticalScrollbarPointerDown(e) {
    this._verticalScrollbar.delegatePointerDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  updateClassName(e) {
    this._options.className = e, Ie && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
  }
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = je(this._mouseWheelToDispose), e)) {
      const i = (n) => {
        this._onMouseWheel(new Vl(n));
      };
      this._mouseWheelToDispose.push(H(this._listenOnDomNode, $.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    const t = W1.INSTANCE;
    {
      const r = window.devicePixelRatio / c2();
      Vi || _i ? t.accept(Date.now(), e.deltaX / r, e.deltaY / r) : t.accept(Date.now(), e.deltaX, e.deltaY);
    }
    let i = !1;
    if (e.deltaY || e.deltaX) {
      let r = e.deltaY * this._options.mouseWheelScrollSensitivity, o = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (Math.abs(r) >= Math.abs(o) ? o = 0 : r = 0), this._options.flipAxes && ([r, o] = [o, r]);
      const a = !Ie && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || a) && !o && (o = r, r = 0), e.browserEvent && e.browserEvent.altKey && (o = o * this._options.fastScrollSensitivity, r = r * this._options.fastScrollSensitivity);
      const l = this._scrollable.getFutureScrollPosition();
      let c = {};
      if (r) {
        const h = pS * r, u = l.scrollTop - (h < 0 ? Math.floor(h) : Math.ceil(h));
        this._verticalScrollbar.writeScrollPosition(c, u);
      }
      if (o) {
        const h = pS * o, u = l.scrollLeft - (h < 0 ? Math.floor(h) : Math.ceil(h));
        this._horizontalScrollbar.writeScrollPosition(c, u);
      }
      c = this._scrollable.validateScrollPosition(c), (l.scrollLeft !== c.scrollLeft || l.scrollTop !== c.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(c) : this._scrollable.setScrollPositionNow(c), i = !0);
    }
    let n = i;
    !n && this._options.alwaysConsumeMouseWheel && (n = !0), !n && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (n = !0), n && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (!!this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", r = t ? " top" : "", o = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${r}`), this._topLeftShadowDomNode.setClassName(`shadow${o}${r}${n}`);
    }
  }
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseLeave(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), w9);
  }
}
class y9 extends tC {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new Fu({
      forceIntegerValues: !0,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => Bn(n)
    });
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class iC extends tC {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class aE extends tC {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new Fu({
      forceIntegerValues: !1,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => Bn(n)
    });
    super(e, t, i), this._register(i), this._element = e, this.onScroll((n) => {
      n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
    }), this.scanDomNode();
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function L9(s) {
  const e = {
    lazyRender: typeof s.lazyRender < "u" ? s.lazyRender : !1,
    className: typeof s.className < "u" ? s.className : "",
    useShadows: typeof s.useShadows < "u" ? s.useShadows : !0,
    handleMouseWheel: typeof s.handleMouseWheel < "u" ? s.handleMouseWheel : !0,
    flipAxes: typeof s.flipAxes < "u" ? s.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof s.consumeMouseWheelIfScrollbarIsNeeded < "u" ? s.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof s.alwaysConsumeMouseWheel < "u" ? s.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof s.scrollYToX < "u" ? s.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof s.mouseWheelScrollSensitivity < "u" ? s.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof s.fastScrollSensitivity < "u" ? s.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof s.scrollPredominantAxis < "u" ? s.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof s.mouseWheelSmoothScroll < "u" ? s.mouseWheelSmoothScroll : !0,
    arrowSize: typeof s.arrowSize < "u" ? s.arrowSize : 11,
    listenOnDomNode: typeof s.listenOnDomNode < "u" ? s.listenOnDomNode : null,
    horizontal: typeof s.horizontal < "u" ? s.horizontal : 1,
    horizontalScrollbarSize: typeof s.horizontalScrollbarSize < "u" ? s.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : 0,
    horizontalHasArrows: typeof s.horizontalHasArrows < "u" ? s.horizontalHasArrows : !1,
    vertical: typeof s.vertical < "u" ? s.vertical : 1,
    verticalScrollbarSize: typeof s.verticalScrollbarSize < "u" ? s.verticalScrollbarSize : 10,
    verticalHasArrows: typeof s.verticalHasArrows < "u" ? s.verticalHasArrows : !1,
    verticalSliderSize: typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : 0,
    scrollByPage: typeof s.scrollByPage < "u" ? s.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : e.verticalScrollbarSize, Ie && (e.className += " mac"), e;
}
class k9 extends Ui {
  constructor(e, t, i, n) {
    super(e);
    const r = this._context.configuration.options, o = r.get(94), a = r.get(69), l = r.get(36), c = r.get(97), h = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + Tf(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: o.vertical,
      horizontal: o.horizontal,
      verticalHasArrows: o.verticalHasArrows,
      horizontalHasArrows: o.horizontalHasArrows,
      verticalScrollbarSize: o.verticalScrollbarSize,
      verticalSliderSize: o.verticalSliderSize,
      horizontalScrollbarSize: o.horizontalScrollbarSize,
      horizontalSliderSize: o.horizontalSliderSize,
      handleMouseWheel: o.handleMouseWheel,
      alwaysConsumeMouseWheel: o.alwaysConsumeMouseWheel,
      arrowSize: o.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: c,
      scrollByPage: o.scrollByPage
    };
    this.scrollbar = this._register(new iC(t.domNode, h, this._context.viewLayout.getScrollable())), fs.write(this.scrollbar.getDomNode(), 5), this.scrollbarDomNode = me(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const u = (d, f, m) => {
      const _ = {};
      if (f) {
        const b = d.scrollTop;
        b && (_.scrollTop = this._context.viewLayout.getCurrentScrollTop() + b, d.scrollTop = 0);
      }
      if (m) {
        const b = d.scrollLeft;
        b && (_.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + b, d.scrollLeft = 0);
      }
      this._context.viewModel.viewLayout.setScrollPosition(_, 1);
    };
    this._register(H(i.domNode, "scroll", (d) => u(i.domNode, !0, !0))), this._register(H(t.domNode, "scroll", (d) => u(t.domNode, !0, !1))), this._register(H(n.domNode, "scroll", (d) => u(n.domNode, !0, !1))), this._register(H(this.scrollbarDomNode.domNode, "scroll", (d) => u(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(133);
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(67).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    this.scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  onConfigurationChanged(e) {
    if (e.hasChanged(94) || e.hasChanged(69) || e.hasChanged(36)) {
      const t = this._context.configuration.options, i = t.get(94), n = t.get(69), r = t.get(36), o = t.get(97), a = {
        vertical: i.vertical,
        horizontal: i.horizontal,
        verticalScrollbarSize: i.verticalScrollbarSize,
        horizontalScrollbarSize: i.horizontalScrollbarSize,
        scrollByPage: i.scrollByPage,
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: n,
        fastScrollSensitivity: r,
        scrollPredominantAxis: o
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(133) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + Tf(this._context.theme.type)), !0;
  }
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
zi((s, e) => {
  const t = s.getColor(gc);
  t && e.addRule(`
			.monaco-scrollable-element > .shadow.top {
				box-shadow: ${t} 0 6px 6px -6px inset;
			}

			.monaco-scrollable-element > .shadow.left {
				box-shadow: ${t} 6px 0 6px -6px inset;
			}

			.monaco-scrollable-element > .shadow.top.left {
				box-shadow: ${t} 6px 6px 6px -6px inset;
			}
		`);
  const i = s.getColor(Po);
  i && e.addRule(`
			.monaco-scrollable-element > .scrollbar > .slider {
				background: ${i};
			}
		`);
  const n = s.getColor(Oo);
  n && e.addRule(`
			.monaco-scrollable-element > .scrollbar > .slider:hover {
				background: ${n};
			}
		`);
  const r = s.getColor(Fo);
  r && e.addRule(`
			.monaco-scrollable-element > .scrollbar > .slider.active {
				background: ${r};
			}
		`);
});
class Bf {
  constructor(e, t, i) {
    this._decorationToRenderBrand = void 0, this.startLineNumber = +e, this.endLineNumber = +t, this.className = String(i);
  }
}
class nC extends pc {
  _render(e, t, i) {
    const n = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      n[l] = [];
    }
    if (i.length === 0)
      return n;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let r = null, o = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], h = c.className;
      let u = Math.max(c.startLineNumber, e) - e;
      const d = Math.min(c.endLineNumber, t) - e;
      r === h ? (u = Math.max(o + 1, u), o = Math.max(o, d)) : (r = h, o = d);
      for (let f = u; f <= o; f++)
        n[f].push(r);
    }
    return n;
  }
}
class D9 extends nC {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(133);
    this._lineHeight = t.get(61), this._glyphMargin = t.get(52), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(133);
    return this._lineHeight = t.get(61), this._glyphMargin = t.get(52), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.options.glyphMarginClassName;
      l && (i[n++] = new Bf(a.range.startLineNumber, a.range.endLineNumber, l));
    }
    return i;
  }
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), r = this._lineHeight.toString(), o = this._glyphMarginLeft.toString(), a = this._glyphMarginWidth.toString(), l = '" style="left:' + o + "px;width:" + a + "px;height:" + r + 'px;"></div>', c = [];
    for (let h = t; h <= i; h++) {
      const u = h - t, d = n[u];
      d.length === 0 ? c[u] = "" : c[u] = '<div class="cgmr codicon ' + d.join(" ") + l;
    }
    this._renderResult = c;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class lE extends z {
  constructor() {
    super(...arguments), this._isDisposed = !1;
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
  assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("TextModelPart is disposed!");
  }
}
function E9(s, e) {
  let t = 0, i = 0;
  const n = s.length;
  for (; i < n; ) {
    const r = s.charCodeAt(i);
    if (r === 32)
      t++;
    else if (r === 9)
      t = t - t % e + e;
    else
      break;
    i++;
  }
  return i === n ? -1 : t;
}
var qo;
(function(s) {
  s[s.Disabled = 0] = "Disabled", s[s.EnabledForActive = 1] = "EnabledForActive", s[s.Enabled = 2] = "Enabled";
})(qo || (qo = {}));
class Wo {
  constructor(e, t, i, n, r, o) {
    if (this.visibleColumn = e, this.column = t, this.className = i, this.horizontalLine = n, this.forWrappedLinesAfterColumn = r, this.forWrappedLinesBeforeOrAtColumn = o, e !== -1 == (t !== -1))
      throw new Error();
  }
}
class hh {
  constructor(e, t) {
    this.top = e, this.endColumn = t;
  }
}
class x9 extends lE {
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t;
  }
  getLanguageConfiguration(e) {
    return this.languageConfigurationService.getLanguageConfiguration(e);
  }
  _computeIndentLevel(e) {
    return E9(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this.assertNotDisposed();
    const n = this.textModel.getLineCount();
    if (e < 1 || e > n)
      throw new Error("Illegal value for lineNumber");
    const r = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, o = Boolean(r && r.offSide);
    let a = -2, l = -1, c = -2, h = -1;
    const u = (y) => {
      if (a !== -1 && (a === -2 || a > y - 1)) {
        a = -1, l = -1;
        for (let S = y - 2; S >= 0; S--) {
          const D = this._computeIndentLevel(S);
          if (D >= 0) {
            a = S, l = D;
            break;
          }
        }
      }
      if (c === -2) {
        c = -1, h = -1;
        for (let S = y; S < n; S++) {
          const D = this._computeIndentLevel(S);
          if (D >= 0) {
            c = S, h = D;
            break;
          }
        }
      }
    };
    let d = -2, f = -1, m = -2, _ = -1;
    const b = (y) => {
      if (d === -2) {
        d = -1, f = -1;
        for (let S = y - 2; S >= 0; S--) {
          const D = this._computeIndentLevel(S);
          if (D >= 0) {
            d = S, f = D;
            break;
          }
        }
      }
      if (m !== -1 && (m === -2 || m < y - 1)) {
        m = -1, _ = -1;
        for (let S = y; S < n; S++) {
          const D = this._computeIndentLevel(S);
          if (D >= 0) {
            m = S, _ = D;
            break;
          }
        }
      }
    };
    let v = 0, C = !0, w = 0, L = !0, E = 0, k = 0;
    for (let y = 0; C || L; y++) {
      const S = e - y, D = e + y;
      y > 1 && (S < 1 || S < t) && (C = !1), y > 1 && (D > n || D > i) && (L = !1), y > 5e4 && (C = !1, L = !1);
      let T = -1;
      if (C && S >= 1) {
        const P = this._computeIndentLevel(S - 1);
        P >= 0 ? (c = S - 1, h = P, T = Math.ceil(P / this.textModel.getOptions().indentSize)) : (u(S), T = this._getIndentLevelForWhitespaceLine(o, l, h));
      }
      let M = -1;
      if (L && D <= n) {
        const P = this._computeIndentLevel(D - 1);
        P >= 0 ? (d = D - 1, f = P, M = Math.ceil(P / this.textModel.getOptions().indentSize)) : (b(D), M = this._getIndentLevelForWhitespaceLine(o, f, _));
      }
      if (y === 0) {
        k = T;
        continue;
      }
      if (y === 1) {
        if (D <= n && M >= 0 && k + 1 === M) {
          C = !1, v = D, w = D, E = M;
          continue;
        }
        if (S >= 1 && T >= 0 && T - 1 === k) {
          L = !1, v = S, w = S, E = T;
          continue;
        }
        if (v = e, w = e, E = k, E === 0)
          return { startLineNumber: v, endLineNumber: w, indent: E };
      }
      C && (T >= E ? v = S : C = !1), L && (M >= E ? w = D : L = !1);
    }
    return { startLineNumber: v, endLineNumber: w, indent: E };
  }
  getLinesBracketGuides(e, t, i, n) {
    var r;
    const o = [];
    for (let d = e; d <= t; d++)
      o.push([]);
    const a = !0, l = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new N(e, 1, t, this.textModel.getLineMaxColumn(t)));
    let c;
    if (i && l.length > 0) {
      const d = (e <= i.lineNumber && i.lineNumber <= t ? l : this.textModel.bracketPairs.getBracketPairsInRange(N.fromPositions(i))).filter((f) => N.strictContainsPosition(f.range, i));
      c = (r = a_(d, (f) => a)) === null || r === void 0 ? void 0 : r.range;
    }
    const h = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType, u = new cE();
    for (const d of l) {
      if (!d.closingBracketRange)
        continue;
      const f = c && d.range.equalsRange(c);
      if (!f && !n.includeInactive)
        continue;
      const m = u.getInlineClassName(d.nestingLevel, d.nestingLevelOfEqualBracketType, h) + (n.highlightActive && f ? " " + u.activeClassName : ""), _ = d.openingBracketRange.getStartPosition(), b = d.closingBracketRange.getStartPosition(), v = n.horizontalGuides === qo.Enabled || n.horizontalGuides === qo.EnabledForActive && f;
      if (d.range.startLineNumber === d.range.endLineNumber) {
        v && o[d.range.startLineNumber - e].push(new Wo(-1, d.openingBracketRange.getEndPosition().column, m, new hh(!1, b.column), -1, -1));
        continue;
      }
      const C = this.getVisibleColumnFromPosition(b), w = this.getVisibleColumnFromPosition(d.openingBracketRange.getStartPosition()), L = Math.min(w, C, d.minVisibleColumnIndentation + 1);
      let E = !1;
      Bi(this.textModel.getLineContent(d.closingBracketRange.startLineNumber)) < d.closingBracketRange.startColumn - 1 && (E = !0);
      const S = Math.max(_.lineNumber, e), D = Math.min(b.lineNumber, t), T = E ? 1 : 0;
      for (let M = S; M < D + T; M++)
        o[M - e].push(new Wo(L, -1, m, null, M === _.lineNumber ? _.column : -1, M === b.lineNumber ? b.column : -1));
      v && (_.lineNumber >= e && w > L && o[_.lineNumber - e].push(new Wo(L, -1, m, new hh(!1, _.column), -1, -1)), b.lineNumber <= t && C > L && o[b.lineNumber - e].push(new Wo(L, -1, m, new hh(!E, b.column), -1, -1)));
    }
    for (const d of o)
      d.sort((f, m) => f.visibleColumn - m.visibleColumn);
    return o;
  }
  getVisibleColumnFromPosition(e) {
    return _t.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
  }
  getLinesIndentGuides(e, t) {
    this.assertNotDisposed();
    const i = this.textModel.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const n = this.textModel.getOptions(), r = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, o = Boolean(r && r.offSide), a = new Array(t - e + 1);
    let l = -2, c = -1, h = -2, u = -1;
    for (let d = e; d <= t; d++) {
      const f = d - e, m = this._computeIndentLevel(d - 1);
      if (m >= 0) {
        l = d - 1, c = m, a[f] = Math.ceil(m / n.indentSize);
        continue;
      }
      if (l === -2) {
        l = -1, c = -1;
        for (let _ = d - 2; _ >= 0; _--) {
          const b = this._computeIndentLevel(_);
          if (b >= 0) {
            l = _, c = b;
            break;
          }
        }
      }
      if (h !== -1 && (h === -2 || h < d - 1)) {
        h = -1, u = -1;
        for (let _ = d; _ < i; _++) {
          const b = this._computeIndentLevel(_);
          if (b >= 0) {
            h = _, u = b;
            break;
          }
        }
      }
      a[f] = this._getIndentLevelForWhitespaceLine(o, c, u);
    }
    return a;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    const n = this.textModel.getOptions();
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
  }
}
class cE {
  constructor() {
    this.activeClassName = "indent-active";
  }
  getInlineClassName(e, t, i) {
    return this.getInlineClassNameOfLevel(i ? t : e);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-indent-guide lvl-${e % 30}`;
  }
}
class I9 extends pc {
  constructor(e) {
    super(), this._context = e, this._primaryPosition = null;
    const t = this._context.configuration.options, i = t.get(134), n = t.get(46);
    this._lineHeight = t.get(61), this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(13), this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(134), n = t.get(46);
    return this._lineHeight = t.get(61), this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(13), !0;
  }
  onCursorStateChanged(e) {
    var t;
    const n = e.selections[0].getPosition();
    return !((t = this._primaryPosition) === null || t === void 0) && t.equals(n) ? !1 : (this._primaryPosition = n, !0);
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  prepareRender(e) {
    var t, i, n, r;
    if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === !1) {
      this._renderResult = null;
      return;
    }
    const o = e.visibleRange.startLineNumber, a = e.visibleRange.endLineNumber, l = e.scrollWidth, c = this._lineHeight, h = this._primaryPosition, u = this.getGuidesByLine(o, a, h), d = [];
    for (let f = o; f <= a; f++) {
      const m = f - o, _ = u[m];
      let b = "";
      const v = (i = (t = e.visibleRangeForPosition(new O(f, 1))) === null || t === void 0 ? void 0 : t.left) !== null && i !== void 0 ? i : 0;
      for (const C of _) {
        const w = C.column === -1 ? v + (C.visibleColumn - 1) * this._spaceWidth : e.visibleRangeForPosition(new O(f, C.column)).left;
        if (w > l || this._maxIndentLeft > 0 && w > this._maxIndentLeft)
          break;
        const L = C.horizontalLine ? C.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", E = C.horizontalLine ? ((r = (n = e.visibleRangeForPosition(new O(f, C.horizontalLine.endColumn))) === null || n === void 0 ? void 0 : n.left) !== null && r !== void 0 ? r : w + this._spaceWidth) - w : this._spaceWidth;
        b += `<div class="core-guide ${C.className} ${L}" style="left:${w}px;height:${c}px;width:${E}px"></div>`;
      }
      d[m] = b;
    }
    this._renderResult = d;
  }
  getGuidesByLine(e, t, i) {
    const n = this._bracketPairGuideOptions.bracketPairs !== !1 ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
      highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
      horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === !0 ? qo.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? qo.EnabledForActive : qo.Disabled,
      includeInactive: this._bracketPairGuideOptions.bracketPairs === !0
    }) : null, r = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
    let o = 0, a = 0, l = 0;
    if (this._bracketPairGuideOptions.highlightActiveIndentation !== !1 && i) {
      const u = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
      o = u.startLineNumber, a = u.endLineNumber, l = u.indent;
    }
    const { indentSize: c } = this._context.viewModel.model.getOptions(), h = [];
    for (let u = e; u <= t; u++) {
      const d = new Array();
      h.push(d);
      const f = n ? n[u - e] : [], m = new Ih(f), _ = r ? r[u - e] : [];
      for (let b = 1; b <= _; b++) {
        const v = (b - 1) * c + 1, C = (this._bracketPairGuideOptions.highlightActiveIndentation === "always" || f.length === 0) && o <= u && u <= a && b === l;
        d.push(...m.takeWhile((L) => L.visibleColumn < v) || []);
        const w = m.peek();
        (!w || w.visibleColumn !== v || w.horizontalLine) && d.push(new Wo(v, -1, C ? "core-guide-indent-active" : "core-guide-indent", null, -1, -1));
      }
      d.push(...m.takeWhile((b) => !0) || []);
    }
    return h;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
function dd(s) {
  if (!(s && s.isTransparent()))
    return s;
}
zi((s, e) => {
  const t = s.getColor(Pu);
  t && e.addRule(`.monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 ${t} inset; }`);
  const i = s.getColor(Ou) || t;
  i && e.addRule(`.monaco-editor .lines-content .core-guide-indent-active { box-shadow: 1px 0 0 0 ${i} inset; }`);
  const n = [
    { bracketColor: GD, guideColor: DR, guideColorActive: MR },
    { bracketColor: ZD, guideColor: ER, guideColorActive: AR },
    { bracketColor: YD, guideColor: xR, guideColorActive: RR },
    { bracketColor: QD, guideColor: IR, guideColorActive: PR },
    { bracketColor: XD, guideColor: NR, guideColorActive: OR },
    { bracketColor: JD, guideColor: TR, guideColorActive: FR }
  ], r = new cE(), o = n.map((a) => {
    var l, c;
    const h = s.getColor(a.bracketColor), u = s.getColor(a.guideColor), d = s.getColor(a.guideColorActive), f = dd((l = dd(u)) !== null && l !== void 0 ? l : h == null ? void 0 : h.transparent(0.3)), m = dd((c = dd(d)) !== null && c !== void 0 ? c : h);
    if (!(!f || !m))
      return {
        guideColor: f,
        guideColorActive: m
      };
  }).filter(qI);
  if (o.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = o[a % o.length];
      e.addRule(`.monaco-editor .${r.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
    }
    e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${r.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${r.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${r.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
  }
});
class N9 {
  constructor() {
    this._currentVisibleRange = new N(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class T9 {
  constructor(e, t, i, n, r, o, a) {
    this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = r, this.stopScrollTop = o, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
  }
}
class M9 {
  constructor(e, t, i, n, r) {
    this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = r, this.type = "selections";
    let o = t[0].startLineNumber, a = t[0].endLineNumber;
    for (let l = 1, c = t.length; l < c; l++) {
      const h = t[l];
      o = Math.min(o, h.startLineNumber), a = Math.max(a, h.endLineNumber);
    }
    this.minLineNumber = o, this.maxLineNumber = a;
  }
}
class lm extends Ui {
  constructor(e, t) {
    super(e), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new nE(this), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration, n = this._context.configuration.options, r = n.get(46), o = n.get(134), a = n.get(133);
    this._lineHeight = n.get(61), this._typicalHalfwidthCharacterWidth = r.typicalHalfwidthCharacterWidth, this._isViewportWrapping = o.isViewportWrapping, this._revealHorizontalRightPadding = n.get(91), this._horizontalScrollbarHeight = a.horizontalScrollbarHeight, this._cursorSurroundingLines = n.get(25), this._cursorSurroundingLinesStyle = n.get(26), this._canUseLayerHinting = !n.get(28), this._viewLineOptions = new oS(i, this._context.theme.type), fs.write(this.domNode, 7), this.domNode.setClassName(`view-lines ${Ko}`), mi(this.domNode, r), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new oi(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new oi(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new N9(), this._horizontalRevealRequest = null;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  createVisibleLine() {
    return new Jn(this._viewLineOptions);
  }
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(134) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(46), n = t.get(134), r = t.get(133);
    return this._lineHeight = t.get(61), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(91), this._horizontalScrollbarHeight = r.horizontalScrollbarHeight, this._cursorSurroundingLines = t.get(25), this._cursorSurroundingLinesStyle = t.get(26), this._canUseLayerHinting = !t.get(28), mi(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(133) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new oS(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let r = i; r <= n; r++)
        this._visibleLines.getVisibleLine(r).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = !1;
    for (let r = t; r <= i; r++)
      n = this._visibleLines.getVisibleLine(r).onSelectionChanged() || n;
    return n;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++)
        this._visibleLines.getVisibleLine(n).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new T9(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new M9(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const r = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.viewModel.viewLayout.setScrollPosition(i, r), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const n = this._getLineNumberFor(i);
    if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount())
      return null;
    if (this._context.viewModel.getLineMaxColumn(n) === 1)
      return new O(n, 1);
    const r = this._visibleLines.getStartLineNumber(), o = this._visibleLines.getEndLineNumber();
    if (n < r || n > o)
      return null;
    let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(n, e, t);
    const l = this._context.viewModel.getLineMinColumn(n);
    return a < l && (a = l), new O(n, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === Jn.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let n = t; n <= i; n++) {
      const r = this._visibleLines.getVisibleLine(n);
      if (e === r.getDomNode())
        return n;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    return e < t || e > i ? -1 : this._visibleLines.getVisibleLine(e).getWidth();
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, n = N.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!n)
      return null;
    const r = [];
    let o = 0;
    const a = new rS(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new O(n.startLineNumber, 1)).lineNumber);
    const c = this._visibleLines.getStartLineNumber(), h = this._visibleLines.getEndLineNumber();
    for (let u = n.startLineNumber; u <= n.endLineNumber; u++) {
      if (u < c || u > h)
        continue;
      const d = u === n.startLineNumber ? n.startColumn : 1, f = u === n.endLineNumber ? n.endColumn : this._context.viewModel.getLineMaxColumn(u), m = this._visibleLines.getVisibleLine(u).getVisibleRangesForRange(u, d, f, a);
      if (!!m) {
        if (t && u < i) {
          const _ = l;
          l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new O(u + 1, 1)).lineNumber, _ !== l && (m.ranges[m.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        r[o++] = new q7(m.outsideRenderedLine, u, sm.from(m.ranges));
      }
    }
    return o === 0 ? null : r;
  }
  _visibleRangesForLineRange(e, t, i) {
    return this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber() ? null : this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, new rS(this.domNode.domNode, this._textRangeRestingSpot));
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new G7(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  updateLineWidths() {
    this._updateLineWidths(!1);
  }
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = 1, r = !0;
    for (let o = t; o <= i; o++) {
      const a = this._visibleLines.getVisibleLine(o);
      if (e && !a.getWidthIsFast()) {
        r = !1;
        continue;
      }
      n = Math.max(n, a.getWidth());
    }
    return r && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), r;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
    for (let r = i; r <= n; r++) {
      const o = this._visibleLines.getVisibleLine(r);
      if (o.needsMonospaceFontCheck()) {
        const a = o.getWidth();
        a > t && (t = a, e = r);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let r = i; r <= n; r++)
        this._visibleLines.getVisibleLine(r).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const n = this._computeScrollLeftToReveal(i);
        n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
          scrollLeft: n.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() || this._asyncUpdateLineWidths.schedule(), _i && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let r = i; r <= n; r++)
        if (this._visibleLines.getVisibleLine(r).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, n, r, o) {
    const a = e.top, l = e.height, c = a + l;
    let h, u, d;
    if (r && r.length > 0) {
      let _ = r[0].startLineNumber, b = r[0].endLineNumber;
      for (let v = 1, C = r.length; v < C; v++) {
        const w = r[v];
        _ = Math.min(_, w.startLineNumber), b = Math.max(b, w.endLineNumber);
      }
      h = !1, u = this._context.viewLayout.getVerticalOffsetForLineNumber(_), d = this._context.viewLayout.getVerticalOffsetForLineNumber(b) + this._lineHeight;
    } else if (n)
      h = !0, u = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), d = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
    else
      return -1;
    if ((t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default")
      i || (u -= this._lineHeight);
    else {
      const _ = Math.min(l / this._lineHeight / 2, this._cursorSurroundingLines);
      u -= _ * this._lineHeight, d += Math.max(0, _ - 1) * this._lineHeight;
    }
    (o === 0 || o === 4) && (d += i ? this._horizontalScrollbarHeight : this._lineHeight);
    let m;
    if (d - u > l) {
      if (!h)
        return -1;
      m = u;
    } else if (o === 5 || o === 6)
      if (o === 6 && a <= u && d <= c)
        m = a;
      else {
        const _ = Math.max(5 * this._lineHeight, l * 0.2), b = u - _, v = d - l;
        m = Math.max(v, b);
      }
    else if (o === 1 || o === 2)
      if (o === 2 && a <= u && d <= c)
        m = a;
      else {
        const _ = (u + d) / 2;
        m = Math.max(0, _ - l / 2);
      }
    else
      m = this._computeMinimumScrolling(a, c, u, d, o === 3, o === 4);
    return m;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = t.left, n = i + t.width;
    let r = 1073741824, o = 0;
    if (e.type === "range") {
      const l = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!l)
        return null;
      for (const c of l.ranges)
        r = Math.min(r, Math.round(c.left)), o = Math.max(o, Math.round(c.left + c.width));
    } else
      for (const l of e.selections) {
        if (l.startLineNumber !== l.endLineNumber)
          return null;
        const c = this._visibleRangesForLineRange(l.startLineNumber, l.startColumn, l.endColumn);
        if (!c)
          return null;
        for (const h of c.ranges)
          r = Math.min(r, Math.round(h.left)), o = Math.max(o, Math.round(h.left + h.width));
      }
    return e.minimalReveal || (r = Math.max(0, r - lm.HORIZONTAL_EXTRA_PX), o += this._revealHorizontalRightPadding), e.type === "selections" && o - r > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(i, n, r, o),
      maxHorizontalOffset: o
    };
  }
  _computeMinimumScrolling(e, t, i, n, r, o) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, r = !!r, o = !!o;
    const a = t - e;
    if (n - i < a) {
      if (r)
        return i;
      if (o)
        return Math.max(0, n - a);
      if (i < e)
        return i;
      if (n > t)
        return Math.max(0, n - a);
    } else
      return i;
    return e;
  }
}
lm.HORIZONTAL_EXTRA_PX = 30;
class A9 extends nC {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(133);
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(133);
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.options.linesDecorationsClassName;
      l && (i[n++] = new Bf(a.range.startLineNumber, a.range.endLineNumber, l));
      const c = a.options.firstLineDecorationClassName;
      c && (i[n++] = new Bf(a.range.startLineNumber, a.range.startLineNumber, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), r = this._decorationsLeft.toString(), o = this._decorationsWidth.toString(), a = '" style="left:' + r + "px;width:" + o + 'px;"></div>', l = [];
    for (let c = t; c <= i; c++) {
      const h = c - t, u = n[h];
      let d = "";
      for (let f = 0, m = u.length; f < m; f++)
        d += '<div class="cldr ' + u[f] + a;
      l[h] = d;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class R9 extends nC {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = a.options.marginClassName;
      l && (i[n++] = new Bf(a.range.startLineNumber, a.range.endLineNumber, l));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), r = [];
    for (let o = t; o <= i; o++) {
      const a = o - t, l = n[a];
      let c = "";
      for (let h = 0, u = l.length; h < u; h++)
        c += '<div class="cmdr ' + l[h] + '" style=""></div>';
      r[a] = c;
    }
    this._renderResult = r;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class Ji {
  constructor(e, t, i, n) {
    this._rgba8Brand = void 0, this.r = Ji._clamp(e), this.g = Ji._clamp(t), this.b = Ji._clamp(i), this.a = Ji._clamp(n);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
}
Ji.Empty = new Ji(0, 0, 0, 0);
class Bu extends z {
  constructor() {
    super(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(at.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    }));
  }
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = new Bu()), this._INSTANCE;
  }
  _updateColorMap() {
    const e = at.getColorMap();
    if (!e) {
      this._colors = [Ji.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [Ji.Empty];
    for (let i = 1; i < e.length; i++) {
      const n = e[i].rgba;
      this._colors[i] = new Ji(n.r, n.g, n.b, Math.round(n.a * 255));
    }
    const t = e[2].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
}
Bu._INSTANCE = null;
const P9 = (() => {
  const s = [];
  for (let e = 32; e <= 126; e++)
    s.push(e);
  return s.push(65533), s;
})(), O9 = (s, e) => (s -= 32, s < 0 || s > 96 ? e <= 2 ? (s + 96) % 96 : 96 - 1 : s);
class Zh {
  constructor(e, t) {
    this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = Zh.soften(e, 12 / 15), this.charDataLight = Zh.soften(e, 50 / 60);
  }
  static soften(e, t) {
    const i = new Uint8ClampedArray(e.length);
    for (let n = 0, r = e.length; n < r; n++)
      i[n] = wf(e[n] * t);
    return i;
  }
  renderChar(e, t, i, n, r, o, a, l, c, h, u) {
    const d = 1 * this.scale, f = 2 * this.scale, m = u ? 1 : f;
    if (t + d > e.width || i + m > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const _ = h ? this.charDataLight : this.charDataNormal, b = O9(n, c), v = e.width * 4, C = a.r, w = a.g, L = a.b, E = r.r - C, k = r.g - w, y = r.b - L, S = Math.max(o, l), D = e.data;
    let T = b * d * f, M = i * v + t * 4;
    for (let P = 0; P < m; P++) {
      let V = M;
      for (let U = 0; U < d; U++) {
        const K = _[T++] / 255 * (o / 255);
        D[V++] = C + E * K, D[V++] = w + k * K, D[V++] = L + y * K, D[V++] = S;
      }
      M += v;
    }
  }
  blockRenderChar(e, t, i, n, r, o, a, l) {
    const c = 1 * this.scale, h = 2 * this.scale, u = l ? 1 : h;
    if (t + c > e.width || i + u > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const d = e.width * 4, f = 0.5 * (r / 255), m = o.r, _ = o.g, b = o.b, v = n.r - m, C = n.g - _, w = n.b - b, L = m + v * f, E = _ + C * f, k = b + w * f, y = Math.max(r, a), S = e.data;
    let D = i * d + t * 4;
    for (let T = 0; T < u; T++) {
      let M = D;
      for (let P = 0; P < c; P++)
        S[M++] = L, S[M++] = E, S[M++] = k, S[M++] = y;
      D += d;
    }
  }
}
const _S = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, bS = (s) => {
  const e = new Uint8ClampedArray(s.length / 2);
  for (let t = 0; t < s.length; t += 2)
    e[t >> 1] = _S[s[t]] << 4 | _S[s[t + 1]] & 15;
  return e;
}, CS = {
  1: Yo(() => bS("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: Yo(() => bS("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class uh {
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return CS[e] ? i = new Zh(CS[e](), e) : i = uh.createFromSampleData(uh.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = `${16}px`, t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold ${16}px ${e}`, i.textBaseline = "middle";
    let n = 0;
    for (const r of P9)
      i.fillText(String.fromCharCode(r), n, 16 / 2), n += 10;
    return i.getImageData(0, 0, 96 * 10, 16);
  }
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    const n = uh._downsample(e, t);
    return new Zh(n, t);
  }
  static _downsampleChar(e, t, i, n, r) {
    const o = 1 * r, a = 2 * r;
    let l = n, c = 0;
    for (let h = 0; h < a; h++) {
      const u = h / a * 16, d = (h + 1) / a * 16;
      for (let f = 0; f < o; f++) {
        const m = f / o * 10, _ = (f + 1) / o * 10;
        let b = 0, v = 0;
        for (let w = u; w < d; w++) {
          const L = t + Math.floor(w) * 3840, E = 1 - (w - Math.floor(w));
          for (let k = m; k < _; k++) {
            const y = 1 - (k - Math.floor(k)), S = L + Math.floor(k) * 4, D = y * E;
            v += D, b += e[S] * e[S + 3] / 255 * D;
          }
        }
        const C = b / v;
        c = Math.max(c, C), i[l++] = wf(C);
      }
    }
    return c;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, n = i * 96, r = new Uint8ClampedArray(n);
    let o = 0, a = 0, l = 0;
    for (let c = 0; c < 96; c++)
      l = Math.max(l, this._downsampleChar(e, a, r, o, t)), o += i, a += 10 * 4;
    if (l > 0) {
      const c = 255 / l;
      for (let h = 0; h < n; h++)
        r[h] *= c;
    }
    return r;
  }
}
const F9 = 140, B9 = 2;
class Yh {
  constructor(e, t, i) {
    const n = e.options, r = n.get(131), o = n.get(133), a = o.minimap, l = n.get(46), c = n.get(67);
    this.renderMinimap = a.renderMinimap, this.size = c.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(96), this.showSlider = c.showSlider, this.autohide = c.autohide, this.pixelRatio = r, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(61), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = o.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = o.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.charRenderer = Yo(() => uh.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(2), this.backgroundColor = Yh._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = Yh._getMinimapForegroundOpacity(t);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(A7);
    return i ? new Ji(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  static _getMinimapForegroundOpacity(e) {
    const t = e.getColor(R7);
    return t ? Ji._clamp(Math.round(255 * t.rgba.a)) : 255;
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.showSlider === e.showSlider && this.autohide === e.autohide && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
  }
}
class dh {
  constructor(e, t, i, n, r, o, a, l) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = r, this.sliderHeight = o, this.startLineNumber = a, this.endLineNumber = l;
  }
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  static create(e, t, i, n, r, o, a, l, c, h, u) {
    const d = e.pixelRatio, f = e.minimapLineHeight, m = Math.floor(e.canvasInnerHeight / f), _ = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      const E = l * e.lineHeight + (e.scrollBeyondLastLine ? r - e.lineHeight : 0), k = Math.max(1, Math.floor(r * r / E)), y = Math.max(0, e.minimapHeight - k), S = y / (h - r), D = c * S, T = y > 0, M = Math.floor(e.canvasInnerHeight / e.minimapLineHeight);
      return new dh(c, h, T, S, D, k, 1, Math.min(a, M));
    }
    let b;
    if (o && i !== a) {
      const E = i - t + 1;
      b = Math.floor(E * f / d);
    } else {
      const E = r / _;
      b = Math.floor(E * f / d);
    }
    let v;
    e.scrollBeyondLastLine ? v = (a - 1) * f / d : v = Math.max(0, a * f / d - b), v = Math.min(e.minimapHeight - b, v);
    const C = v / (h - r), w = c * C;
    let L = 0;
    if (e.scrollBeyondLastLine && (L = r / _ - 1), m >= a + L) {
      const k = a, y = v > 0;
      return new dh(c, h, y, C, w, b, 1, k);
    } else {
      let E = Math.max(1, Math.floor(t - w * d / f));
      u && u.scrollHeight === h && (u.scrollTop > c && (E = Math.min(E, u.startLineNumber)), u.scrollTop < c && (E = Math.max(E, u.startLineNumber)));
      const k = Math.min(a, E + m - 1), y = (c - n) / _, S = (t - E + y) * f / d;
      return new dh(c, h, !0, C, S, b, E, k);
    }
  }
}
class Vf {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
}
Vf.INVALID = new Vf(-1);
class vS {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new iE(() => Vf.INVALID), this._renderedLines._set(e.startLineNumber, i);
  }
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let n = 0, r = i.length; n < r; n++)
      if (i[n].dy === -1)
        return !1;
    return !0;
  }
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class sC {
  constructor(e, t, i, n) {
    this._backgroundFillData = sC._createBackgroundFillData(t, i, n), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const n = i.r, r = i.g, o = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
    let c = 0;
    for (let h = 0; h < t; h++)
      for (let u = 0; u < e; u++)
        l[c] = n, l[c + 1] = r, l[c + 2] = o, l[c + 3] = a, c += 4;
    return l;
  }
}
class Qh {
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const n = e.pixelRatio, r = e.lineHeight, o = e.scrollBeyondLastLine, { minimapLineCount: a } = hl.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: o,
      height: e.editorHeight,
      lineHeight: r,
      pixelRatio: n
    }), l = t / a, c = l / 2;
    if (!i || i.minimapLines.length === 0) {
      const w = [];
      if (w[0] = 1, a > 1) {
        for (let L = 0, E = a - 1; L < E; L++)
          w[L] = Math.round(L * l + c);
        w[a - 1] = t;
      }
      return [new Qh(l, w), []];
    }
    const h = i.minimapLines, u = h.length, d = [];
    let f = 0, m = 0, _ = 1;
    const b = 10;
    let v = [], C = null;
    for (let w = 0; w < a; w++) {
      const L = Math.max(_, Math.round(w * l)), E = Math.max(L, Math.round((w + 1) * l));
      for (; f < u && h[f] < L; ) {
        if (v.length < b) {
          const y = f + 1 + m;
          C && C.type === "deleted" && C._oldIndex === f - 1 ? C.deleteToLineNumber++ : (C = { type: "deleted", _oldIndex: f, deleteFromLineNumber: y, deleteToLineNumber: y }, v.push(C)), m--;
        }
        f++;
      }
      let k;
      if (f < u && h[f] <= E)
        k = h[f], f++;
      else if (w === 0 ? k = 1 : w + 1 === a ? k = t : k = Math.round(w * l + c), v.length < b) {
        const y = f + 1 + m;
        C && C.type === "inserted" && C._i === w - 1 ? C.insertToLineNumber++ : (C = { type: "inserted", _i: w, insertFromLineNumber: y, insertToLineNumber: y }, v.push(C)), m++;
      }
      d[w] = k, _ = k;
    }
    if (v.length < b)
      for (; f < u; ) {
        const w = f + 1 + m;
        C && C.type === "deleted" && C._oldIndex === f - 1 ? C.deleteToLineNumber++ : (C = { type: "deleted", _oldIndex: f, deleteFromLineNumber: w, deleteToLineNumber: w }, v.push(C)), m--, f++;
      }
    else
      v = [{ type: "flush" }];
    return [new Qh(l, d), v];
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let n = this.modelLineToMinimapLine(t) - 1;
    for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; )
      n++;
    if (i === n) {
      const r = this.minimapLines[i];
      if (r < e || r > t)
        return null;
    }
    return [i + 1, n + 1];
  }
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
    return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [i, n];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, n = 0;
    for (let r = this.minimapLines.length - 1; r >= 0 && !(this.minimapLines[r] < e.fromLineNumber); r--)
      this.minimapLines[r] <= e.toLineNumber ? (this.minimapLines[r] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, r), n = Math.max(n, r)) : this.minimapLines[r] -= t;
    return [i, n];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class V9 extends Ui {
  constructor(e) {
    super(e), this.tokensColorTracker = Bu.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new Yh(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = Qh.compute(this.options, this._context.viewModel.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new Wf(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new Yh(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);
      return t ? this._actual.onLinesChanged(t[0], t[1] - t[0] + 1) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i - t + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      const t = [];
      for (const i of e.ranges) {
        const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        n && t.push({ fromLineNumber: n[0], toLineNumber: n[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const n = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(n);
  }
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = Boolean(this._samplingState), [t, i] = Qh.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const n of i)
        switch (n.type) {
          case "deleted":
            this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
  }
  getRealLineCount() {
    return this._context.viewModel.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
  }
  getLineMaxColumn(e) {
    return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      const n = [];
      for (let r = 0, o = t - e + 1; r < o; r++)
        i[r] ? n[r] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + r - 1]) : n[r] = null;
      return n;
    }
    return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new Ce(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const r = this._samplingState.minimapLines[e - 1], o = this._samplingState.minimapLines[t - 1];
      i = new N(r, 1, o, this._context.viewModel.getLineMaxColumn(o));
    } else
      i = new N(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
    const n = this._context.viewModel.getDecorationsInViewport(i);
    if (this._samplingState) {
      const r = [];
      for (const o of n) {
        if (!o.options.minimap)
          continue;
        const a = o.range, l = this._samplingState.modelLineToMinimapLine(a.startLineNumber), c = this._samplingState.modelLineToMinimapLine(a.endLineNumber);
        r.push(new H2(new N(l, a.startColumn, c, a.endColumn), o.options));
      }
      return r;
    }
    return n;
  }
  getOptions() {
    return this._context.viewModel.model.getOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange("mouse", !1, new N(e, 1, e, 1), 1, 0);
  }
  setScrollTop(e) {
    this._context.viewModel.viewLayout.setScrollPosition({
      scrollTop: e
    }, 1);
  }
}
class Wf extends z {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(tS), this._domNode = me(document.createElement("div")), fs.write(this._domNode, 8), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = me(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = me(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = me(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = me(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = me(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._pointerDownListener = pi(this._domNode.domNode, $.POINTER_DOWN, (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.button === 0 && this._lastRenderData) {
          const c = is(this._slider.domNode), h = c.top + c.height / 2;
          this._startSliderDragging(i, h, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const r = this._model.options.minimapLineHeight, o = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.offsetY;
      let l = Math.floor(o / r) + this._lastRenderData.renderedLayout.startLineNumber;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderPointerMoveMonitor = new im(), this._sliderPointerDownListener = pi(this._slider.domNode, $.POINTER_DOWN, (i) => {
      i.preventDefault(), i.stopPropagation(), i.button === 0 && this._lastRenderData && this._startSliderDragging(i, i.pageY, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = Ne.addTarget(this._domNode.domNode), this._sliderTouchStartListener = H(this._domNode.domNode, We.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = H(this._domNode.domNode, We.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = pi(this._domNode.domNode, We.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const n = e.pageX;
    this._slider.toggleClassName("active", !0);
    const r = (o, a) => {
      const l = Math.abs(a - n);
      if (Vi && l > F9) {
        this._model.setScrollTop(i.scrollTop);
        return;
      }
      const c = o - t;
      this._model.setScrollTop(i.getDesiredScrollTopFromDelta(c));
    };
    e.pageY !== t && r(e.pageY, n), this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (o) => r(o.pageY, o.pageX), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._pointerDownListener.dispose(), this._sliderPointerMoveMonitor.dispose(), this._sliderPointerDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    const e = ["minimap"];
    return this._model.options.showSlider === "always" ? e.push("slider-always") : e.push("slider-mouseover"), this._model.options.autohide && e.push("autohide"), e.join(" ");
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new sC(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    var i;
    return (i = this._lastRenderData) === null || i === void 0 || i.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    var i;
    return (i = this._lastRenderData) === null || i === void 0 || i.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(tS), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = dh.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections();
      t.sort(N.compareRangesUsingStarts);
      const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
      i.sort((d, f) => (d.options.zIndex || 0) - (f.options.zIndex || 0));
      const { canvasInnerWidth: n, canvasInnerHeight: r } = this._model.options, o = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, c = this._decorationsCanvas.domNode.getContext("2d");
      c.clearRect(0, 0, n, r);
      const h = new wS(e.startLineNumber, e.endLineNumber, !1);
      this._renderSelectionLineHighlights(c, t, h, e, o), this._renderDecorationsLineHighlights(c, i, h, e, o);
      const u = new wS(e.startLineNumber, e.endLineNumber, null);
      this._renderSelectionsHighlights(c, t, u, e, o, l, a, n), this._renderDecorationsHighlights(c, i, u, e, o, l, a, n);
    }
  }
  _renderSelectionLineHighlights(e, t, i, n, r) {
    if (!this._selectionColor || this._selectionColor.isTransparent())
      return;
    e.fillStyle = this._selectionColor.transparent(0.5).toString();
    let o = 0, a = 0;
    for (const l of t) {
      const c = Math.max(n.startLineNumber, l.startLineNumber), h = Math.min(n.endLineNumber, l.endLineNumber);
      if (c > h)
        continue;
      for (let f = c; f <= h; f++)
        i.set(f, !0);
      const u = (c - n.startLineNumber) * r, d = (h - n.startLineNumber) * r + r;
      a >= u || (a > o && e.fillRect(_r, o, e.canvas.width, a - o), o = u), a = d;
    }
    a > o && e.fillRect(_r, o, e.canvas.width, a - o);
  }
  _renderDecorationsLineHighlights(e, t, i, n, r) {
    const o = /* @__PURE__ */ new Map();
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a], c = l.options.minimap;
      if (!c || c.position !== jo.Inline)
        continue;
      const h = Math.max(n.startLineNumber, l.range.startLineNumber), u = Math.min(n.endLineNumber, l.range.endLineNumber);
      if (h > u)
        continue;
      const d = c.getColor(this._theme.value);
      if (!d || d.isTransparent())
        continue;
      let f = o.get(d.toString());
      f || (f = d.transparent(0.5).toString(), o.set(d.toString(), f)), e.fillStyle = f;
      for (let m = h; m <= u; m++) {
        if (i.has(m))
          continue;
        i.set(m, !0);
        const _ = (h - n.startLineNumber) * r;
        e.fillRect(_r, _, e.canvas.width, r);
      }
    }
  }
  _renderSelectionsHighlights(e, t, i, n, r, o, a, l) {
    if (!(!this._selectionColor || this._selectionColor.isTransparent()))
      for (const c of t) {
        const h = Math.max(n.startLineNumber, c.startLineNumber), u = Math.min(n.endLineNumber, c.endLineNumber);
        if (!(h > u))
          for (let d = h; d <= u; d++)
            this.renderDecorationOnLine(e, i, c, this._selectionColor, n, d, r, r, o, a, l);
      }
  }
  _renderDecorationsHighlights(e, t, i, n, r, o, a, l) {
    for (const c of t) {
      const h = c.options.minimap;
      if (!h)
        continue;
      const u = Math.max(n.startLineNumber, c.range.startLineNumber), d = Math.min(n.endLineNumber, c.range.endLineNumber);
      if (u > d)
        continue;
      const f = h.getColor(this._theme.value);
      if (!(!f || f.isTransparent()))
        for (let m = u; m <= d; m++)
          switch (h.position) {
            case jo.Inline:
              this.renderDecorationOnLine(e, i, c.range, f, n, m, r, r, o, a, l);
              continue;
            case jo.Gutter: {
              const _ = (m - n.startLineNumber) * r, b = 2;
              this.renderDecoration(e, f, b, _, B9, r);
              continue;
            }
          }
    }
  }
  renderDecorationOnLine(e, t, i, n, r, o, a, l, c, h, u) {
    const d = (o - r.startLineNumber) * l;
    if (d + a < 0 || d > this._model.options.canvasInnerHeight)
      return;
    const { startLineNumber: f, endLineNumber: m } = i, _ = f === o ? i.startColumn : 1, b = m === o ? i.endColumn : this._model.getLineMaxColumn(o), v = this.getXOffsetForPosition(t, o, _, c, h, u), C = this.getXOffsetForPosition(t, o, b, c, h, u);
    this.renderDecoration(e, n, v, d, C - v, a);
  }
  getXOffsetForPosition(e, t, i, n, r, o) {
    if (i === 1)
      return _r;
    if ((i - 1) * r >= o)
      return o;
    let l = e.get(t);
    if (!l) {
      const c = this._model.getLineContent(t);
      l = [_r];
      let h = _r;
      for (let u = 1; u < c.length + 1; u++) {
        const d = c.charCodeAt(u - 1), f = d === 9 ? n * r : Jr(d) ? 2 * r : r, m = h + f;
        if (m >= o) {
          l[u] = o;
          break;
        }
        l[u] = m, h = m;
      }
      e.set(t, l);
    }
    return i - 1 < l.length ? l[i - 1] : o;
  }
  renderDecoration(e, t, i, n, r, o) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, n, r, o);
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const K = this._lastRenderData._get();
      return new vS(e, K.imageData, K.lines);
    }
    const r = this._getBuffer();
    if (!r)
      return null;
    const [o, a, l] = Wf._renderUntouchedLines(r, t, i, n, this._lastRenderData), c = this._model.getMinimapLinesRenderingData(t, i, l), h = this._model.getOptions().tabSize, u = this._model.options.defaultBackgroundColor, d = this._model.options.backgroundColor, f = this._model.options.foregroundAlpha, m = this._model.tokensColorTracker, _ = m.backgroundIsLight(), b = this._model.options.renderMinimap, v = this._model.options.charRenderer(), C = this._model.options.fontScale, w = this._model.options.minimapCharWidth, E = (b === 1 ? 2 : 2 + 1) * C, k = n > E ? Math.floor((n - E) / 2) : 0, y = d.a / 255, S = new Ji(Math.round((d.r - u.r) * y + u.r), Math.round((d.g - u.g) * y + u.g), Math.round((d.b - u.b) * y + u.b), 255);
    let D = 0;
    const T = [];
    for (let K = 0, J = i - t + 1; K < J; K++)
      l[K] && Wf._renderLine(r, S, d.a, _, b, w, m, f, v, D, k, h, c[K], C, n), T[K] = new Vf(D), D += n;
    const M = o === -1 ? 0 : o, V = (a === -1 ? r.height : a) - M;
    return this._canvas.domNode.getContext("2d").putImageData(r, 0, 0, 0, M, r.width, V), new vS(e, r, T);
  }
  static _renderUntouchedLines(e, t, i, n, r) {
    const o = [];
    if (!r) {
      for (let S = 0, D = i - t + 1; S < D; S++)
        o[S] = !0;
      return [-1, -1, o];
    }
    const a = r._get(), l = a.imageData.data, c = a.rendLineNumberStart, h = a.lines, u = h.length, d = e.width, f = e.data, m = (i - t + 1) * n * d * 4;
    let _ = -1, b = -1, v = -1, C = -1, w = -1, L = -1, E = 0;
    for (let S = t; S <= i; S++) {
      const D = S - t, T = S - c, M = T >= 0 && T < u ? h[T].dy : -1;
      if (M === -1) {
        o[D] = !0, E += n;
        continue;
      }
      const P = M * d * 4, V = (M + n) * d * 4, U = E * d * 4, K = (E + n) * d * 4;
      C === P && L === U ? (C = V, L = K) : (v !== -1 && (f.set(l.subarray(v, C), w), _ === -1 && v === 0 && v === w && (_ = C), b === -1 && C === m && v === w && (b = v)), v = P, C = V, w = U, L = K), o[D] = !1, E += n;
    }
    v !== -1 && (f.set(l.subarray(v, C), w), _ === -1 && v === 0 && v === w && (_ = C), b === -1 && C === m && v === w && (b = v));
    const k = _ === -1 ? -1 : _ / (d * 4), y = b === -1 ? -1 : b / (d * 4);
    return [k, y, o];
  }
  static _renderLine(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _) {
    const b = f.content, v = f.tokens, C = e.width - o, w = _ === 1;
    let L = _r, E = 0, k = 0;
    for (let y = 0, S = v.getCount(); y < S; y++) {
      const D = v.getEndOffset(y), T = v.getForeground(y), M = a.getColor(T);
      for (; E < D; E++) {
        if (L > C)
          return;
        const P = b.charCodeAt(E);
        if (P === 9) {
          const V = d - (E + k) % d;
          k += V - 1, L += V * o;
        } else if (P === 32)
          L += o;
        else {
          const V = Jr(P) ? 2 : 1;
          for (let U = 0; U < V; U++)
            if (r === 2 ? c.blockRenderChar(e, L, h + u, M, l, t, i, w) : c.renderChar(e, L, h + u, P, M, l, t, i, m, n, w), L += o, L > C)
              return;
        }
      }
    }
  }
}
class wS {
  constructor(e, t, i) {
    this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
    for (let n = 0, r = this._endLineNumber - this._startLineNumber + 1; n < r; n++)
      this._values[n] = i;
  }
  has(e) {
    return this.get(e) !== this._defaultValue;
  }
  set(e, t) {
    e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
  }
  get(e) {
    return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
  }
}
zi((s, e) => {
  const t = s.getColor(P7);
  t && e.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${t}; }`);
  const i = s.getColor(O7);
  i && e.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${i}; }`);
  const n = s.getColor(F7);
  n && e.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${n}; }`);
  const r = s.getColor(gc);
  r && e.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${r} -6px 0 6px -6px inset; }`);
});
class W9 extends Ui {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(133);
    this._widgets = {}, this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, this._domNode = me(document.createElement("div")), fs.write(this._domNode, 4), this._domNode.setClassName("overlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(133);
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  addWidget(e) {
    const t = me(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), this._domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference === t ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.parentNode.removeChild(n), this.setShouldRender();
    }
  }
  _renderWidget(e) {
    const t = e.domNode;
    if (e.preference === null) {
      t.setTop("");
      return;
    }
    if (e.preference === 0)
      t.setTop(0), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    else if (e.preference === 1) {
      const i = t.domNode.clientHeight;
      t.setTop(this._editorHeight - i - 2 * this._horizontalScrollbarHeight), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    } else
      e.preference === 2 && (t.setTop(0), t.domNode.style.right = "50%");
  }
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets);
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      this._renderWidget(this._widgets[r]);
    }
  }
}
class H9 {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(61), this.pixelRatio = i.get(131), this.overviewRulerLanes = i.get(76), this.renderBorder = i.get(75);
    const n = t.getColor(_R);
    this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(54);
    const r = t.getColor(KD);
    this.cursorColor = r ? r.transparent(0.7).toString() : null, this.themeType = t.type;
    const o = i.get(67), a = o.enabled, l = o.side, c = t.getColor(bR), h = at.getDefaultBackground();
    let u = null;
    c !== void 0 ? u = c : a && (u = h), u === null || l === "left" ? this.backgroundColor = null : this.backgroundColor = R.Format.CSS.formatHex(u);
    const f = i.get(133).overviewRuler;
    this.top = f.top, this.right = f.right, this.domWidth = f.width, this.domHeight = f.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [m, _] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = m, this.w = _;
  }
  _initLanes(e, t, i) {
    const n = t - e;
    if (i >= 3) {
      const r = Math.floor(n / 3), o = Math.floor(n / 3), a = n - r - o, l = e, c = l + r, h = l + r + a;
      return [
        [
          0,
          l,
          c,
          l,
          h,
          l,
          c,
          l
        ],
        [
          0,
          r,
          a,
          r + a,
          o,
          r + a + o,
          a + o,
          r + a + o
        ]
      ];
    } else if (i === 2) {
      const r = Math.floor(n / 2), o = n - r, a = e, l = a + r;
      return [
        [
          0,
          a,
          a,
          a,
          l,
          a,
          a,
          a
        ],
        [
          0,
          r,
          r,
          r,
          o,
          r + o,
          r + o,
          r + o
        ]
      ];
    } else {
      const r = e, o = n;
      return [
        [
          0,
          r,
          r,
          r,
          r,
          r,
          r,
          r
        ],
        [
          0,
          o,
          o,
          o,
          o,
          o,
          o,
          o
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColor === e.cursorColor && this.themeType === e.themeType && this.backgroundColor === e.backgroundColor && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class z9 extends Ui {
  constructor(e) {
    super(e), this._domNode = me(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = at.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new H9(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  onConfigurationChanged(e) {
    return this._updateSettings(!1);
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++)
      this._cursorPositions[t] = e.selections[t].getPosition();
    return this._cursorPositions.sort(O.compare), !0;
  }
  onDecorationsChanged(e) {
    return !!e.affectsOverviewRuler;
  }
  onFlushed(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this._updateSettings(!1);
  }
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render();
  }
  _render() {
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(this._settings.backgroundColor ? this._settings.backgroundColor : ""), this._domNode.setDisplay("none");
      return;
    }
    this._domNode.setDisplay("block");
    const e = this._settings.canvasWidth, t = this._settings.canvasHeight, i = this._settings.lineHeight, n = this._context.viewLayout, r = this._context.viewLayout.getScrollHeight(), o = t / r, a = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme), l = 6 * this._settings.pixelRatio | 0, c = l / 2 | 0, h = this._domNode.domNode.getContext("2d");
    this._settings.backgroundColor === null ? h.clearRect(0, 0, e, t) : (h.fillStyle = this._settings.backgroundColor, h.fillRect(0, 0, e, t));
    const u = this._settings.x, d = this._settings.w;
    a.sort(z2.cmp);
    for (const f of a) {
      const m = f.color, _ = f.data;
      h.fillStyle = m;
      let b = 0, v = 0, C = 0;
      for (let w = 0, L = _.length / 3; w < L; w++) {
        const E = _[3 * w], k = _[3 * w + 1], y = _[3 * w + 2];
        let S = n.getVerticalOffsetForLineNumber(k) * o | 0, D = (n.getVerticalOffsetForLineNumber(y) + i) * o | 0;
        if (D - S < l) {
          let M = (S + D) / 2 | 0;
          M < c ? M = c : M + c > t && (M = t - c), S = M - c, D = M + c;
        }
        S > C + 1 || E !== b ? (w !== 0 && h.fillRect(u[b], v, d[b], C - v), b = E, v = S, C = D) : D > C && (C = D);
      }
      h.fillRect(u[b], v, d[b], C - v);
    }
    if (!this._settings.hideCursor && this._settings.cursorColor) {
      const f = 2 * this._settings.pixelRatio | 0, m = f / 2 | 0, _ = this._settings.x[7], b = this._settings.w[7];
      h.fillStyle = this._settings.cursorColor;
      let v = -100, C = -100;
      for (let w = 0, L = this._cursorPositions.length; w < L; w++) {
        const E = this._cursorPositions[w];
        let k = n.getVerticalOffsetForLineNumber(E.lineNumber) * o | 0;
        k < m ? k = m : k + m > t && (k = t - m);
        const y = k - m, S = y + f;
        y > C + 1 ? (w !== 0 && h.fillRect(_, v, b, C - v), v = y, C = S) : S > C && (C = S);
      }
      h.fillRect(_, v, b, C - v);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (h.beginPath(), h.lineWidth = 1, h.strokeStyle = this._settings.borderColor, h.moveTo(0, 0), h.lineTo(0, t), h.stroke(), h.moveTo(0, 0), h.lineTo(e, 0), h.stroke());
  }
}
class SS {
  constructor(e, t, i) {
    this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class Xh {
  constructor(e, t, i, n) {
    this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class U9 {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(Xh.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), r = i / n, o = Math.floor(4 * this._pixelRatio / 2), a = [];
    for (let l = 0, c = this._zones.length; l < c; l++) {
      const h = this._zones[l];
      if (!e) {
        const L = h.getColorZones();
        if (L) {
          a.push(L);
          continue;
        }
      }
      const u = this._getVerticalOffsetForLine(h.startLineNumber), d = h.heightInLines === 0 ? this._getVerticalOffsetForLine(h.endLineNumber) + t : u + h.heightInLines * t, f = Math.floor(r * u), m = Math.floor(r * d);
      let _ = Math.floor((f + m) / 2), b = m - _;
      b < o && (b = o), _ - b < 0 && (_ = b), _ + b > i && (_ = i - b);
      const v = h.color;
      let C = this._color2Id[v];
      C || (C = ++this._lastAssignedId, this._color2Id[v] = C, this._id2Color[C] = v);
      const w = new SS(_ - b, _ + b, C);
      h.setColorZone(w), a.push(w);
    }
    return this._colorZonesInvalid = !1, a.sort(SS.compare), a;
  }
}
class $9 extends Ru {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = me(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new U9((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(61)), this._zoneManager.setPixelRatio(i.get(131)), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(61) && (this._zoneManager.setLineHeight(t.get(61)), this._render()), e.hasChanged(131) && (this._zoneManager.setPixelRatio(t.get(131)), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), r = this._domNode.domNode.getContext("2d");
    return r.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(r, i, n, e), !0;
  }
  _renderOneLane(e, t, i, n) {
    let r = 0, o = 0, a = 0;
    for (const l of t) {
      const c = l.colorId, h = l.from, u = l.to;
      c !== r ? (e.fillRect(0, o, n, a - o), r = c, e.fillStyle = i[r], o = h, a = u) : a >= h ? a = Math.max(a, u) : (e.fillRect(0, o, n, a - o), o = h, a = u);
    }
    e.fillRect(0, o, n, a - o);
  }
}
class j9 extends Ui {
  constructor(e) {
    super(e), this.domNode = me(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(93), this._typicalHalfwidthCharacterWidth = t.get(46).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(93), this._typicalHalfwidthCharacterWidth = t.get(46).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: n } = this._context.viewModel.model.getOptions(), r = n;
      let o = t - e;
      for (; o > 0; ) {
        const a = me(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(r), this.domNode.appendChild(a), this._renderedRulers.push(a), o--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const n = this._renderedRulers.pop();
      this.domNode.removeChild(n), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const n = this._renderedRulers[t], r = this._rulers[t];
      n.setBoxShadow(r.color ? `1px 0 0 0 ${r.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(r.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
zi((s, e) => {
  const t = s.getColor(pR);
  t && e.addRule(`.monaco-editor .view-ruler { box-shadow: 1px 0 0 0 ${t} inset; }`);
});
class K9 extends Ui {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(94);
    this._useShadows = i.useShadows, this._domNode = me(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(133);
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.verticalScrollbarWidth;
  }
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(94);
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
zi((s, e) => {
  const t = s.getColor(gc);
  t && e.addRule(`.monaco-editor .scroll-decoration { box-shadow: ${t} 0 6px 6px -6px inset; }`);
});
class q9 {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class G9 {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function Z9(s) {
  return new q9(s);
}
function Y9(s) {
  return new G9(s.lineNumber, s.ranges.map(Z9));
}
class Ze extends pc {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._lineHeight = t.get(61), this._roundedSelection = t.get(92), this._typicalHalfwidthCharacterWidth = t.get(46).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._lineHeight = t.get(61), this._roundedSelection = t.get(92), this._typicalHalfwidthCharacterWidth = t.get(46).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const n = this._typicalHalfwidthCharacterWidth / 4;
    let r = null, o = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let c = 0; !r && c < i.length; c++)
          i[c].lineNumber === a && (r = i[c].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let c = i.length - 1; !o && c >= 0; c--)
          i[c].lineNumber === l && (o = i[c].ranges[0]);
      r && !r.startStyle && (r = null), o && !o.startStyle && (o = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a].ranges[0], h = c.left, u = c.left + c.width, d = {
        top: 0,
        bottom: 0
      }, f = {
        top: 0,
        bottom: 0
      };
      if (a > 0) {
        const m = t[a - 1].ranges[0].left, _ = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        fd(h - m) < n ? d.top = 2 : h > m && (d.top = 1), fd(u - _) < n ? f.top = 2 : m < u && u < _ && (f.top = 1);
      } else
        r && (d.top = r.startStyle.top, f.top = r.endStyle.top);
      if (a + 1 < l) {
        const m = t[a + 1].ranges[0].left, _ = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        fd(h - m) < n ? d.bottom = 2 : m < h && h < _ && (d.bottom = 1), fd(u - _) < n ? f.bottom = 2 : u < _ && (f.bottom = 1);
      } else
        o && (d.bottom = o.startStyle.bottom, f.bottom = o.endStyle.bottom);
      c.startStyle = d, c.endStyle = f;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const r = (t.linesVisibleRangesForRange(e, !0) || []).map(Y9);
    return !this._visibleRangesHaveGaps(r) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, r, i), r;
  }
  _createSelectionPiece(e, t, i, n, r) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;left:" + n.toString() + "px;width:" + r.toString() + "px;height:" + t + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, n) {
    if (n.length === 0)
      return;
    const r = !!n[0].ranges[0].startStyle, o = this._lineHeight.toString(), a = (this._lineHeight - 1).toString(), l = n[0].lineNumber, c = n[n.length - 1].lineNumber;
    for (let h = 0, u = n.length; h < u; h++) {
      const d = n[h], f = d.lineNumber, m = f - t, _ = i && (f === c || f === l) ? a : o, b = i && f === l ? 1 : 0;
      let v = "", C = "";
      for (let w = 0, L = d.ranges.length; w < L; w++) {
        const E = d.ranges[w];
        if (r) {
          const y = E.startStyle, S = E.endStyle;
          if (y.top === 1 || y.bottom === 1) {
            v += this._createSelectionPiece(b, _, Ze.SELECTION_CLASS_NAME, E.left - Ze.ROUNDED_PIECE_WIDTH, Ze.ROUNDED_PIECE_WIDTH);
            let D = Ze.EDITOR_BACKGROUND_CLASS_NAME;
            y.top === 1 && (D += " " + Ze.SELECTION_TOP_RIGHT), y.bottom === 1 && (D += " " + Ze.SELECTION_BOTTOM_RIGHT), v += this._createSelectionPiece(b, _, D, E.left - Ze.ROUNDED_PIECE_WIDTH, Ze.ROUNDED_PIECE_WIDTH);
          }
          if (S.top === 1 || S.bottom === 1) {
            v += this._createSelectionPiece(b, _, Ze.SELECTION_CLASS_NAME, E.left + E.width, Ze.ROUNDED_PIECE_WIDTH);
            let D = Ze.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (D += " " + Ze.SELECTION_TOP_LEFT), S.bottom === 1 && (D += " " + Ze.SELECTION_BOTTOM_LEFT), v += this._createSelectionPiece(b, _, D, E.left + E.width, Ze.ROUNDED_PIECE_WIDTH);
          }
        }
        let k = Ze.SELECTION_CLASS_NAME;
        if (r) {
          const y = E.startStyle, S = E.endStyle;
          y.top === 0 && (k += " " + Ze.SELECTION_TOP_LEFT), y.bottom === 0 && (k += " " + Ze.SELECTION_BOTTOM_LEFT), S.top === 0 && (k += " " + Ze.SELECTION_TOP_RIGHT), S.bottom === 0 && (k += " " + Ze.SELECTION_BOTTOM_RIGHT);
        }
        C += this._createSelectionPiece(b, _, k, E.left, E.width);
      }
      e[m][0] += v, e[m][1] += C;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (let o = i; o <= n; o++) {
      const a = o - i;
      t[a] = ["", ""];
    }
    const r = [];
    for (let o = 0, a = this._selections.length; o < a; o++) {
      const l = this._selections[o];
      if (l.isEmpty()) {
        r[o] = null;
        continue;
      }
      const c = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[o]);
      r[o] = c, this._actualRenderOneSelection(t, i, this._selections.length > 1, c);
    }
    this._previousFrameVisibleRangesWithStyle = r, this._renderResult = t.map(([o, a]) => o + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
Ze.SELECTION_CLASS_NAME = "selected-text";
Ze.SELECTION_TOP_LEFT = "top-left-radius";
Ze.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
Ze.SELECTION_TOP_RIGHT = "top-right-radius";
Ze.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
Ze.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
Ze.ROUNDED_PIECE_WIDTH = 10;
zi((s, e) => {
  const t = s.getColor(Bo);
  t && e.addRule(`.monaco-editor .focused .selected-text { background-color: ${t}; }`);
  const i = s.getColor(Yb);
  i && e.addRule(`.monaco-editor .selected-text { background-color: ${i}; }`);
  const n = s.getColor(jA);
  n && !n.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${n}; }`);
});
function fd(s) {
  return s < 0 ? -s : s;
}
class yS {
  constructor(e, t, i, n, r, o) {
    this.top = e, this.left = t, this.width = i, this.height = n, this.textContent = r, this.textContentClassName = o;
  }
}
class LS {
  constructor(e) {
    this._context = e;
    const t = this._context.configuration.options, i = t.get(46);
    this._cursorStyle = t.get(24), this._lineHeight = t.get(61), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(27), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = me(document.createElement("div")), this._domNode.setClassName(`cursor ${Ko}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), mi(this._domNode, i), this._domNode.setDisplay("none"), this._position = new O(1, 1), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(46);
    return this._cursorStyle = t.get(24), this._lineHeight = t.get(61), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(27), this._typicalHalfwidthCharacterWidth), mi(this._domNode, i), !0;
  }
  onCursorPositionChanged(e) {
    return this._position = e, !0;
  }
  _getGraphemeAwarePosition() {
    const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, r] = xT(i, t - 1);
    return [new O(e, n + 1), i.substring(n, r)];
  }
  _prepareRender(e) {
    let t = "";
    const [i, n] = this._getGraphemeAwarePosition();
    if (this._cursorStyle === Et.Line || this._cursorStyle === Et.LineThin) {
      const d = e.visibleRangeForPosition(i);
      if (!d || d.outsideRenderedLine)
        return null;
      let f;
      this._cursorStyle === Et.Line ? (f = Ww(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), f > 2 && (t = n)) : f = Ww(1);
      let m = d.left;
      f >= 2 && m >= 1 && (m -= 1);
      const _ = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.bigNumbersDelta;
      return new yS(_, m, f, this._lineHeight, t, "");
    }
    const r = e.linesVisibleRangesForRange(new N(i.lineNumber, i.column, i.lineNumber, i.column + n.length), !1);
    if (!r || r.length === 0)
      return null;
    const o = r[0];
    if (o.outsideRenderedLine || o.ranges.length === 0)
      return null;
    const a = o.ranges[0], l = n === "	" ? this._typicalHalfwidthCharacterWidth : a.width < 1 ? this._typicalHalfwidthCharacterWidth : a.width;
    let c = "";
    if (this._cursorStyle === Et.Block) {
      const d = this._context.viewModel.getViewLineData(i.lineNumber);
      t = n;
      const f = d.tokens.findTokenIndexAtOffset(i.column - 1);
      c = d.tokens.getClassName(f);
    }
    let h = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.bigNumbersDelta, u = this._lineHeight;
    return (this._cursorStyle === Et.Underline || this._cursorStyle === Et.UnderlineThin) && (h += this._lineHeight - 2, u = 2), new yS(h, a.left, l, u, t, c);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${Ko} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
class Jh extends Ui {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(83), this._cursorBlinking = t.get(22), this._cursorStyle = t.get(24), this._cursorSmoothCaretAnimation = t.get(23), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new LS(this._context), this._secondaryCursors = [], this._renderData = [], this._domNode = me(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new oo(), this._cursorFlatBlinkInterval = new Nu(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(83), this._cursorBlinking = t.get(22), this._cursorStyle = t.get(24), this._cursorSmoothCaretAnimation = t.get(23), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, n = this._secondaryCursors.length; i < n; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t) {
    if (this._primaryCursor.onCursorPositionChanged(e), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const i = t.length - this._secondaryCursors.length;
      for (let n = 0; n < i; n++) {
        const r = new LS(this._context);
        this._domNode.domNode.insertBefore(r.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(r);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const i = this._secondaryCursors.length - t.length;
      for (let n = 0; n < i; n++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let i = 0; i < t.length; i++)
      this._secondaryCursors[i].onCursorPositionChanged(t[i]);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let n = 0, r = e.selections.length; n < r; n++)
      t[n] = e.selections[n].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1));
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let n = 0, r = e.ranges.length; n < r; n++)
        if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, Jh.BLINK_INTERVAL) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, Jh.BLINK_INTERVAL));
  }
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case Et.Line:
        e += " cursor-line-style";
        break;
      case Et.Block:
        e += " cursor-block-style";
        break;
      case Et.Underline:
        e += " cursor-underline-style";
        break;
      case Et.LineThin:
        e += " cursor-line-thin-style";
        break;
      case Et.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case Et.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return this._cursorSmoothCaretAnimation && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    const t = [];
    let i = 0;
    const n = this._primaryCursor.render(e);
    n && (t[i++] = n);
    for (let r = 0, o = this._secondaryCursors.length; r < o; r++) {
      const a = this._secondaryCursors[r].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
}
Jh.BLINK_INTERVAL = 500;
zi((s, e) => {
  const t = s.getColor(KD);
  if (t) {
    let i = s.getColor(gR);
    i || (i = t.opposite()), e.addRule(`.monaco-editor .inputarea.ime-input { caret-color: ${t}; }`), e.addRule(`.monaco-editor .cursors-layer .cursor { background-color: ${t}; border-color: ${t}; color: ${i}; }`), cs(s.type) && e.addRule(`.monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid ${i}; border-right: 1px solid ${i}; }`);
  }
});
const vp = () => {
  throw new Error("Invalid change accessor");
};
class Q9 extends Ui {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(133);
    this._lineHeight = t.get(61), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = me(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = me(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const n of e)
      t.set(n.id, n);
    let i = !1;
    return this._context.viewModel.changeWhitespace((n) => {
      const r = Object.keys(this._zones);
      for (let o = 0, a = r.length; o < a; o++) {
        const l = r[o], c = this._zones[l], h = this._computeWhitespaceProps(c.delegate);
        c.isInHiddenArea = h.isInHiddenArea;
        const u = t.get(l);
        u && (u.afterLineNumber !== h.afterViewLineNumber || u.height !== h.heightInPx) && (n.changeOneWhitespace(l, h.afterViewLineNumber, h.heightInPx), this._safeCallOnComputedHeight(c.delegate, h.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(133);
    return this._lineHeight = t.get(61), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(61) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  _getZoneOrdinal(e) {
    return typeof e.afterColumn < "u" ? e.afterColumn : 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        isInHiddenArea: !1,
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const o = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new O(o, this._context.viewModel.model.getLineMaxColumn(o));
    }
    let i;
    t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity), r = this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
    return {
      isInHiddenArea: !r,
      afterViewLineNumber: n.lineNumber,
      heightInPx: r ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.viewModel.changeWhitespace((i) => {
      const n = {
        addZone: (r) => (t = !0, this._addZone(i, r)),
        removeZone: (r) => {
          !r || (t = this._removeZone(i, r) || t);
        },
        layoutZone: (r) => {
          !r || (t = this._layoutZone(i, r) || t);
        }
      };
      X9(e, n), n.addZone = vp, n.removeZone = vp, n.layoutZone = vp;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), r = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isInHiddenArea: i.isInHiddenArea,
      isVisible: !1,
      domNode: me(t.domNode),
      marginDomNode: t.marginDomNode ? me(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(r.delegate, i.heightInPx), r.domNode.setPosition("absolute"), r.domNode.domNode.style.width = "100%", r.domNode.setDisplay("none"), r.domNode.setAttribute("monaco-view-zone", r.whitespaceId), this.domNode.appendChild(r.domNode), r.marginDomNode && (r.marginDomNode.setPosition("absolute"), r.marginDomNode.domNode.style.width = "100%", r.marginDomNode.setDisplay("none"), r.marginDomNode.setAttribute("monaco-view-zone", r.whitespaceId), this.marginDomNode.appendChild(r.marginDomNode)), this._zones[r.whitespaceId] = r, this.setShouldRender(), r.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.parentNode.removeChild(i.domNode.domNode), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.parentNode.removeChild(i.marginDomNode.domNode)), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
      return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    if (this._zones.hasOwnProperty(e)) {
      const t = this._zones[e];
      return Boolean(t.delegate.suppressMouseDown);
    }
    return !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        ct(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        ct(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let n = !1;
    for (const o of t)
      this._zones[o.id].isInHiddenArea || (i[o.id] = o, n = !0);
    const r = Object.keys(this._zones);
    for (let o = 0, a = r.length; o < a; o++) {
      const l = r[o], c = this._zones[l];
      let h = 0, u = 0, d = "none";
      i.hasOwnProperty(l) ? (h = i[l].verticalOffset - e.bigNumbersDelta, u = i[l].height, d = "block", c.isVisible || (c.domNode.setAttribute("monaco-visible-view-zone", "true"), c.isVisible = !0), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (c.isVisible && (c.domNode.removeAttribute("monaco-visible-view-zone"), c.isVisible = !1), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), c.domNode.setTop(h), c.domNode.setHeight(u), c.domNode.setDisplay(d), c.marginDomNode && (c.marginDomNode.setTop(h), c.marginDomNode.setHeight(u), c.marginDomNode.setDisplay(d));
    }
    n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function X9(s, e) {
  try {
    return s(e);
  } catch (t) {
    ct(t);
  }
}
class J9 {
  constructor(e) {
    this._theme = e;
  }
  get type() {
    return this._theme.type;
  }
  get value() {
    return this._theme;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class eP {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new J9(t), this.viewModel = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.viewModel.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.viewModel.removeViewEventHandler(e);
  }
}
class tP {
  constructor(e, t, i, n) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new N(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewportViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class iP extends Ui {
  constructor(e) {
    super(e), this.blocks = [], this.contentWidth = -1, this.domNode = me(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("blockDecorations-container"), this.update();
  }
  update() {
    let e = !1;
    const i = this._context.configuration.options.get(133), n = i.contentWidth - i.verticalScrollbarWidth;
    return this.contentWidth !== n && (this.contentWidth = n, e = !0), e;
  }
  dispose() {
    super.dispose();
  }
  onConfigurationChanged(e) {
    return this.update();
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollLeftChanged;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  prepareRender(e) {
  }
  render(e) {
    let t = 0;
    const i = e.getDecorationsInViewport();
    for (const n of i) {
      if (!n.options.blockClassName)
        continue;
      let r = this.blocks[t];
      r || (r = this.blocks[t] = me(document.createElement("div")), this.domNode.appendChild(r));
      const o = e.getVerticalOffsetForLineNumber(n.range.startLineNumber), a = e.getVerticalOffsetForLineNumber(n.range.endLineNumber + 1);
      r.setClassName("blockDecorations-block " + n.options.blockClassName), r.setLeft(e.scrollLeft), r.setWidth(this.contentWidth), r.setTop(o), r.setHeight(a - o), t++;
    }
    for (let n = t; n < this.blocks.length; n++)
      this.blocks[n].domNode.remove();
    this.blocks.length = t;
  }
}
class nP extends Ru {
  constructor(e, t, i, n, r, o) {
    super(), this._selections = [new Ce(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const a = new n9(t, n, r, e);
    this._context = new eP(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = new VR(this._context, a, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = me(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = me(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = me(document.createElement("div")), fs.write(this._overflowGuardContainer, 3), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new k9(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new lm(this._context, this._linesContent), this._viewZones = new Q9(this._context), this._viewParts.push(this._viewZones);
    const l = new z9(this._context);
    this._viewParts.push(l);
    const c = new K9(this._context);
    this._viewParts.push(c);
    const h = new r9(this._context);
    this._viewParts.push(h), h.addDynamicOverlay(new c9(this._context)), h.addDynamicOverlay(new Ze(this._context)), h.addDynamicOverlay(new I9(this._context)), h.addDynamicOverlay(new u9(this._context));
    const u = new o9(this._context);
    this._viewParts.push(u), u.addDynamicOverlay(new h9(this._context)), u.addDynamicOverlay(new D9(this._context)), u.addDynamicOverlay(new R9(this._context)), u.addDynamicOverlay(new A9(this._context)), u.addDynamicOverlay(new jl(this._context));
    const d = new Jo(this._context);
    d.getDomNode().appendChild(this._viewZones.marginDomNode), d.getDomNode().appendChild(u.getDomNode()), this._viewParts.push(d), this._contentWidgets = new a9(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new Jh(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new W9(this._context), this._viewParts.push(this._overlayWidgets);
    const f = new j9(this._context);
    this._viewParts.push(f);
    const m = new iP(this._context);
    this._viewParts.push(m);
    const _ = new V9(this._context);
    if (this._viewParts.push(_), l) {
      const b = this._scrollbar.getOverviewRulerLayoutInfo();
      b.parent.insertBefore(l.getDomNode(), b.insertBefore);
    }
    this._linesContent.appendChild(h.getDomNode()), this._linesContent.appendChild(f.domNode), this._linesContent.appendChild(m.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(d.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(c.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(_.getDomNode()), this.domNode.appendChild(this._overflowGuardContainer), o ? o.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode) : this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this._applyLayout(), this._pointerHandler = this._register(new cR(this._context, a, this._createPointerHandlerHelper()));
  }
  _flushAccumulatedAndRenderNow() {
    this._renderNow();
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      viewLinesDomNode: this._viewLines.getDomNode().domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new eR(e, t);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new O(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(133);
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(1e6), this._linesContent.setHeight(1e6);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(130) + " " + Tf(this._context.theme.type) + e;
  }
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    this._renderAnimationFrame === null && (this._renderAnimationFrame = X2(this._onRenderScheduled.bind(this), 100));
  }
  _onRenderScheduled() {
    this._renderAnimationFrame = null, this._flushAccumulatedAndRenderNow();
  }
  _renderNow() {
    sP(() => this._actualRender());
  }
  _getViewPartsToRender() {
    const e = [];
    let t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _actualRender() {
    if (!Y2(this.domNode.domNode))
      return;
    let e = this._getViewPartsToRender();
    if (!this._viewLines.shouldRender() && e.length === 0)
      return;
    const t = this._context.viewLayout.getLinesViewportData();
    this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
    const i = new tP(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
    this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender());
    const n = new K7(this._context.viewLayout, i, this._viewLines);
    for (const r of e)
      r.prepareRender(n);
    for (const r of e)
      r.render(n), r.onDidRender();
  }
  delegateVerticalScrollbarPointerDown(e) {
    this._scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  restoreState(e) {
    this._context.viewModel.viewLayout.setScrollPosition({ scrollTop: e.scrollTop }, 1), this._context.viewModel.tokenizeViewport(), this._renderNow(), this._viewLines.updateLineWidths(), this._context.viewModel.viewLayout.setScrollPosition({ scrollLeft: e.scrollLeft }, 1);
  }
  getOffsetForColumn(e, t) {
    const i = this._context.viewModel.model.validatePosition({
      lineNumber: e,
      column: t
    }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const r = this._viewLines.visibleRangeForPosition(new O(n.lineNumber, n.column));
    return r ? r.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? om.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new $9(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    var t, i;
    let n = e.position && e.position.range || null;
    if (n === null) {
      const o = e.position ? e.position.position : null;
      o !== null && (n = new N(o.lineNumber, o.column, o.lineNumber, o.column));
    }
    const r = e.position ? e.position.preference : null;
    this._contentWidgets.setWidgetPosition(e.widget, n, r, (i = (t = e.position) === null || t === void 0 ? void 0 : t.positionAffinity) !== null && i !== void 0 ? i : null), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    const t = e.position ? e.position.preference : null;
    this._overlayWidgets.setWidgetPosition(e.widget, t) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
}
function sP(s) {
  try {
    return s();
  } catch (e) {
    ct(e);
  }
}
class Hf {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new Dt(new N(1, 1, 1, 1), 0, new O(1, 1), 0), new Dt(new N(1, 1, 1, 1), 0, new O(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    !this._trackSelection || (this._selTrackedRange = e.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(this._selTrackedRange, null, 0);
  }
  asCursorState() {
    return new he(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return Ce.fromRange(t, this.modelState.selection.getDirection());
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  static _validatePositionWithCache(e, t, i, n) {
    return t.equals(i) ? n : e.normalizePosition(t, 2);
  }
  static _validateViewState(e, t) {
    const i = t.position, n = t.selectionStart.getStartPosition(), r = t.selectionStart.getEndPosition(), o = e.normalizePosition(i, 2), a = this._validatePositionWithCache(e, n, i, o), l = this._validatePositionWithCache(e, r, n, a);
    return i.equals(o) && n.equals(a) && r.equals(l) ? t : new Dt(N.fromPositions(a, l), t.selectionStartLeftoverVisibleColumns + n.column - a.column, o, t.leftoverVisibleColumns + i.column - o.column);
  }
  _setState(e, t, i) {
    if (i && (i = Hf._validateViewState(e.viewModel, i)), t) {
      const n = e.model.validateRange(t.selectionStart), r = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, o = e.model.validatePosition(t.position), a = t.position.equals(o) ? t.leftoverVisibleColumns : 0;
      t = new Dt(n, r, o, a);
    } else {
      if (!i)
        return;
      const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), r = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new Dt(n, i.selectionStartLeftoverVisibleColumns, r, i.leftoverVisibleColumns);
    }
    if (i) {
      const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), r = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new Dt(n, t.selectionStartLeftoverVisibleColumns, r, t.leftoverVisibleColumns);
    } else {
      const n = e.coordinatesConverter.convertModelPositionToViewPosition(new O(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), r = e.coordinatesConverter.convertModelPositionToViewPosition(new O(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), o = new N(n.lineNumber, n.column, r.lineNumber, r.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new Dt(o, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class kS {
  constructor(e) {
    this.context = e, this.cursors = [new Hf(e)], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    for (const e of this.cursors)
      e.dispose(this.context);
  }
  startTrackingSelections() {
    for (const e of this.cursors)
      e.startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    for (const e of this.cursors)
      e.stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    for (const e of this.cursors)
      e.ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
  }
  getAll() {
    return this.cursors.map((e) => e.asCursorState());
  }
  getViewPositions() {
    return this.cursors.map((e) => e.viewState.position);
  }
  getTopMostViewPosition() {
    return $I(this.cursors, Hd((e) => e.viewState.position, O.compare)).viewState.position;
  }
  getBottomMostViewPosition() {
    return Bk(this.cursors, Hd((e) => e.viewState.position, O.compare)).viewState.position;
  }
  getSelections() {
    return this.cursors.map((e) => e.modelState.selection);
  }
  getViewSelections() {
    return this.cursors.map((e) => e.viewState.selection);
  }
  setSelections(e) {
    this.setStates(he.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.cursors[0].asCursorState();
  }
  setStates(e) {
    e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  _setSecondaryStates(e) {
    const t = this.cursors.length - 1, i = e.length;
    if (t < i) {
      const n = i - t;
      for (let r = 0; r < n; r++)
        this._addSecondaryCursor();
    } else if (t > i) {
      const n = t - i;
      for (let r = 0; r < n; r++)
        this._removeSecondaryCursor(this.cursors.length - 2);
    }
    for (let n = 0; n < i; n++)
      this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.cursors.push(new Hf(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
  }
  getLastAddedCursorIndex() {
    return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
  }
  normalize() {
    if (this.cursors.length === 1)
      return;
    const e = this.cursors.slice(0), t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort(Hd((i) => i.selection, N.compareRangesUsingStarts));
    for (let i = 0; i < t.length - 1; i++) {
      const n = t[i], r = t[i + 1], o = n.selection, a = r.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || o.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(o.getEndPosition()) : l = a.getStartPosition().isBefore(o.getEndPosition()), l) {
        const c = n.index < r.index ? i : i + 1, h = n.index < r.index ? i + 1 : i, u = t[h].index, d = t[c].index, f = t[h].selection, m = t[c].selection;
        if (!f.equalsSelection(m)) {
          const _ = f.plusRange(m), b = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn, v = m.selectionStartLineNumber === m.startLineNumber && m.selectionStartColumn === m.startColumn;
          let C;
          u === this.lastAddedCursorIndex ? (C = b, this.lastAddedCursorIndex = d) : C = v;
          let w;
          C ? w = new Ce(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : w = new Ce(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn), t[c].selection = w;
          const L = he.fromModelSelection(w);
          e[d].setState(this.context, L.modelState, L.viewState);
        }
        for (const _ of t)
          _.index > u && _.index--;
        e.splice(u, 1), t.splice(h, 1), this._removeSecondaryCursor(u - 1), i--;
      }
    }
  }
}
class DS {
  constructor(e, t, i, n) {
    this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
  }
}
class rP {
  constructor() {
    this.changeType = 1;
  }
}
class Wn {
  constructor(e, t, i, n, r) {
    this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = r;
  }
  static applyInjectedText(e, t) {
    if (!t || t.length === 0)
      return e;
    let i = "", n = 0;
    for (const r of t)
      i += e.substring(n, r.column - 1), n = r.column - 1, i += r.options.content;
    return i += e.substring(n), i;
  }
  static fromDecorations(e) {
    const t = [];
    for (const i of e)
      i.options.before && i.options.before.content.length > 0 && t.push(new Wn(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new Wn(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
    return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
  }
}
class ES {
  constructor(e, t, i) {
    this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
  }
}
class oP {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class aP {
  constructor(e, t, i, n) {
    this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class lP {
  constructor() {
    this.changeType = 5;
  }
}
class wl {
  constructor(e, t, i, n) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.versionId, r = e.isUndoing || t.isUndoing, o = e.isRedoing || t.isRedoing;
    return new wl(i, n, r, o);
  }
}
class hE {
  constructor(e) {
    this.changes = e;
  }
}
class Go {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = wl.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = Go._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new Go(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.eol, r = t.versionId, o = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush;
    return {
      changes: i,
      eol: n,
      versionId: r,
      isUndoing: o,
      isRedoing: a,
      isFlush: l
    };
  }
}
class cP {
  constructor() {
    this.type = 0;
  }
}
class hP {
  constructor() {
    this.type = 1;
  }
}
class uP {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class dP {
  constructor(e, t) {
    this.type = 3, this.selections = e, this.modelSelections = t;
  }
}
class Ta {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0);
  }
}
class gd {
  constructor() {
    this.type = 5;
  }
}
class fP {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class gP {
  constructor() {
    this.type = 7;
  }
}
class md {
  constructor() {
    this.type = 8;
  }
}
class uE {
  constructor(e, t) {
    this.fromLineNumber = e, this.count = t, this.type = 9;
  }
}
class H1 {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class z1 {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class Zd {
  constructor(e, t, i, n, r, o, a) {
    this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = r, this.revealHorizontal = o, this.scrollType = a, this.type = 12;
  }
}
class mP {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class pP {
  constructor(e) {
    this.theme = e, this.type = 14;
  }
}
class _P {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class bP {
  constructor() {
    this.type = 16;
  }
}
class CP {
  constructor() {
    this.type = 17;
  }
}
class vP extends z {
  constructor() {
    super(), this._onEvent = this._register(new A()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOutgoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++) {
      const n = this._outgoingEvents[t].kind === e.kind ? this._outgoingEvents[t].attemptToMerge(e) : null;
      if (n) {
        this._outgoingEvents[t] = n;
        return;
      }
    }
    this._outgoingEvents.push(e);
  }
  _emitOutgoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new wP()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOutgoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class wP {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class rC {
  constructor(e, t, i, n) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new rC(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class oC {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new oC(this.oldHasFocus, e.hasFocus);
  }
}
class aC {
  constructor(e, t, i, n, r, o, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = r, this.scrollLeft = o, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new aC(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class SP {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class yP {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class zf {
  constructor(e, t, i, n, r, o, a) {
    this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = r, this.reason = o, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let r = 0; r < i; r++)
      if (!e[r].equalsSelection(t[r]))
        return !1;
    return !0;
  }
  isNoOp() {
    return zf._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new zf(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class LP {
  constructor() {
    this.kind = 5;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class kP {
  constructor(e) {
    this.event = e, this.kind = 7;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class DP {
  constructor(e) {
    this.event = e, this.kind = 8;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class EP {
  constructor(e) {
    this.event = e, this.kind = 9;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class xP {
  constructor(e) {
    this.event = e, this.kind = 10;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class IP {
  constructor(e) {
    this.event = e, this.kind = 11;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class NP {
  constructor(e) {
    this.event = e, this.kind = 12;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class ql extends z {
  constructor(e, t, i, n) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new DS(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new kS(this.context), this._hasFocus = !1, this._isHandling = !1, this._compositionState = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = je(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new DS(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      const e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, n) {
    let r = !1;
    n !== null && n.length > ql.MAX_CURSOR_COUNT && (n = n.slice(0, ql.MAX_CURSOR_COUNT), r = !0);
    const o = fh.from(this._model, this);
    return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, o, r);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealPrimary(e, t, i, n, r, o) {
    const a = this._cursors.getViewPositions();
    let l = null, c = null;
    a.length > 1 ? c = this._cursors.getViewSelections() : l = N.fromPositions(a[0], a[0]), e.emitViewEvent(new Zd(t, i, l, c, n, r, o));
  }
  saveState() {
    const e = [], t = this._cursors.getSelections();
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      e.push({
        inSelectionMode: !r.isEmpty(),
        selectionStart: {
          lineNumber: r.selectionStartLineNumber,
          column: r.selectionStartColumn
        },
        position: {
          lineNumber: r.positionLineNumber,
          column: r.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    const i = [];
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n];
      let a = 1, l = 1;
      o.position && o.position.lineNumber && (a = o.position.lineNumber), o.position && o.position.column && (l = o.position.column);
      let c = a, h = l;
      o.selectionStart && o.selectionStart.lineNumber && (c = o.selectionStart.lineNumber), o.selectionStart && o.selectionStart.column && (h = o.selectionStart.column), i.push({
        selectionStartLineNumber: c,
        selectionStartColumn: h,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, he.fromModelSelections(i)), this.revealPrimary(e, "restoreState", !1, 0, !0, 1);
  }
  onModelContentChanged(e, t) {
    if (t instanceof hE) {
      if (this._isHandling)
        return;
      this._isHandling = !0;
      try {
        this.setStates(e, "modelChange", 0, this.getCursorStates());
      } finally {
        this._isHandling = !1;
      }
    } else {
      const i = t.rawContentChangedEvent;
      if (this._knownModelVersionId = i.versionId, this._isHandling)
        return;
      const n = i.containsEvent(1);
      if (this._prevEditOperationType = 0, n)
        this._cursors.dispose(), this._cursors = new kS(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
      else if (this._hasFocus && i.resultingSelection && i.resultingSelection.length > 0) {
        const r = he.fromModelSelections(i.resultingSelection);
        this.setStates(e, "modelChange", i.isUndoing ? 5 : i.isRedoing ? 6 : 2, r) && this.revealPrimary(e, "modelChange", !1, 0, !0, 0);
      } else {
        const r = this._cursors.readSelectionFromMarkers();
        this.setStates(e, "modelChange", 2, he.fromModelSelections(r));
      }
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, n) {
    this.setStates(e, t, n, he.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  _pushAutoClosedAction(e, t) {
    const i = [], n = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
        }
      }), n.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
        }
      });
    const r = this._model.deltaDecorations([], i), o = this._model.deltaDecorations([], n);
    this._autoClosedActions.push(new xS(this._model, r, o));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = TP.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      const i = [], n = [];
      for (let r = 0; r < e.commands.length; r++) {
        const o = e.commands[r];
        o instanceof tE && o.enclosingRange && o.closeCharacterRange && (i.push(o.closeCharacterRange), n.push(o.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  _emitStateChangedIfNecessary(e, t, i, n, r) {
    const o = fh.from(this._model, this);
    if (o.equals(n))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new dP(l, a)), !n || n.cursorState.length !== o.cursorState.length || o.cursorState.some((c, h) => !c.modelState.equals(n.cursorState[h].modelState))) {
      const c = n ? n.cursorState.map((u) => u.modelState.selection) : null, h = n ? n.modelVersionId : 0;
      e.emitOutgoingEvent(new zf(c, a, h, o.modelVersionId, t || "keyboard", i, r));
    }
    return !0;
  }
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      if (!r.text || r.text.indexOf(`
`) >= 0)
        return null;
      const o = r.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!o)
        return null;
      const a = o[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const c = l[0].open, h = r.text.length - o[2].length - 1, u = r.text.lastIndexOf(c, h - 1);
      if (u === -1)
        return null;
      t.push([u, h]);
    }
    return t;
  }
  executeEdits(e, t, i, n) {
    let r = null;
    t === "snippet" && (r = this._findAutoClosingPairs(i)), r && (i[0]._isTracked = !0);
    const o = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (c) => {
      if (r)
        for (let u = 0, d = r.length; u < d; u++) {
          const [f, m] = r[u], _ = c[u], b = _.range.startLineNumber, v = _.range.startColumn - 1 + f, C = _.range.startColumn - 1 + m;
          o.push(new N(b, C + 1, b, C + 2)), a.push(new N(b, v + 1, b, C + 2));
        }
      const h = n(c);
      return h && (this._isHandling = !0), h;
    });
    l && (this._isHandling = !1, this.setSelections(e, t, l, 0)), o.length > 0 && this._pushAutoClosedAction(o, a);
  }
  _executeEdit(e, t, i, n = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const r = fh.from(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (o) {
      ct(o);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, r, !1) && this.revealPrimary(t, i, !1, 0, !0, 0);
  }
  getAutoClosedCharacters() {
    return xS.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._compositionState = new gh(this._model, this.getSelections());
  }
  endComposition(e, t) {
    const i = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
    this._compositionState = null, this._executeEdit(() => {
      t === "keyboard" && this._executeEditOperation(Ge.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, i, this.getSelections(), this.getAutoClosedCharacters()));
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const n = t.length;
        let r = 0;
        for (; r < n; ) {
          const o = Db(t, r), a = t.substr(r, o);
          this._executeEditOperation(Ge.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), r += o;
        }
      } else
        this._executeEditOperation(Ge.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, n, r, o) {
    if (t.length === 0 && i === 0 && n === 0) {
      if (r !== 0) {
        const a = this.getSelections().map((l) => {
          const c = l.getPosition();
          return new Ce(c.lineNumber, c.column + r, c.lineNumber, c.column + r);
        });
        this.setSelections(e, o, a, 0);
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(Ge.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, r));
    }, e, o);
  }
  paste(e, t, i, n, r) {
    this._executeEdit(() => {
      this._executeEditOperation(Ge.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
    }, e, r, 4);
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(ea.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new ui(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new ui(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
ql.MAX_CURSOR_COUNT = 1e4;
class fh {
  constructor(e, t) {
    this.modelVersionId = e, this.cursorState = t;
  }
  static from(e, t) {
    return new fh(e.getVersionId(), t.getCursorStates());
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class xS {
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    const e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    const t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (n && (t.push(n), n.startLineNumber !== n.endLineNumber))
        return !1;
    }
    t.sort(N.compareRangesUsingStarts), e.sort(N.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class TP {
  static executeCommands(e, t, i) {
    const n = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, r = this._innerExecuteCommands(n, i);
    for (let o = 0, a = n.trackedRanges.length; o < a; o++)
      n.model._setTrackedRange(n.trackedRanges[o], null, 0);
    return r;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const n = i.operations, r = this._getLoserCursorMap(n);
    if (r.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    const o = [];
    for (let c = 0, h = n.length; c < h; c++)
      r.hasOwnProperty(n[c].identifier.major.toString()) || o.push(n[c]);
    i.hadTrackedEditOperation && o.length > 0 && (o[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, o, (c) => {
      const h = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        h[f] = [];
      for (const f of c)
        !f.identifier || h[f.identifier.major].push(f);
      const u = (f, m) => f.identifier.minor - m.identifier.minor, d = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        h[f].length > 0 ? (h[f].sort(u), d[f] = t[f].computeCursorState(e.model, {
          getInverseEditOperations: () => h[f],
          getTrackedSelection: (m) => {
            const _ = parseInt(m, 10), b = e.model._getTrackedRange(e.trackedRanges[_]);
            return e.trackedRangesDirection[_] === 0 ? new Ce(b.startLineNumber, b.startColumn, b.endLineNumber, b.endColumn) : new Ce(b.endLineNumber, b.endColumn, b.startLineNumber, b.startColumn);
          }
        })) : d[f] = e.selectionsBefore[f];
      return d;
    });
    a || (a = e.selectionsBefore);
    const l = [];
    for (const c in r)
      r.hasOwnProperty(c) && l.push(parseInt(c, 10));
    l.sort((c, h) => h - c);
    for (const c of l)
      a.splice(c, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], n = !1;
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, r, a);
        i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: n
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    const n = [];
    let r = 0;
    const o = (u, d, f = !1) => {
      N.isEmpty(u) && d === "" || n.push({
        identifier: {
          major: t,
          minor: r++
        },
        range: u,
        text: d,
        forceMoveMarkers: f,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const h = {
      addEditOperation: o,
      addTrackedEditOperation: (u, d, f) => {
        a = !0, o(u, d, f);
      },
      trackSelection: (u, d) => {
        const f = Ce.liftSelection(u);
        let m;
        if (f.isEmpty())
          if (typeof d == "boolean")
            d ? m = 2 : m = 3;
          else {
            const v = e.model.getLineMaxColumn(f.startLineNumber);
            f.startColumn === v ? m = 2 : m = 3;
          }
        else
          m = 1;
        const _ = e.trackedRanges.length, b = e.model._setTrackedRange(null, f, m);
        return e.trackedRanges[_] = b, e.trackedRangesDirection[_] = f.getDirection(), _.toString();
      }
    };
    try {
      i.getEditOperations(e.model, h);
    } catch (u) {
      return ct(u), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: n,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, n) => -N.compareRangesUsingEnds(i.range, n.range));
    const t = {};
    for (let i = 1; i < e.length; i++) {
      const n = e[i - 1], r = e[i];
      if (N.getStartPosition(n.range).isBefore(N.getEndPosition(r.range))) {
        let o;
        n.identifier.major > r.identifier.major ? o = n.identifier.major : o = r.identifier.major, t[o.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === o && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class MP {
  constructor(e, t, i) {
    this.text = e, this.startSelection = t, this.endSelection = i;
  }
}
class gh {
  constructor(e, t) {
    this._original = gh._capture(e, t);
  }
  static _capture(e, t) {
    const i = [];
    for (const n of t) {
      if (n.startLineNumber !== n.endLineNumber)
        return null;
      i.push(new MP(e.getLineContent(n.startLineNumber), n.startColumn - 1, n.endColumn - 1));
    }
    return i;
  }
  deduceOutcome(e, t) {
    if (!this._original)
      return null;
    const i = gh._capture(e, t);
    if (!i || this._original.length !== i.length)
      return null;
    const n = [];
    for (let r = 0, o = this._original.length; r < o; r++)
      n.push(gh._deduceOutcome(this._original[r], i[r]));
    return n;
  }
  static _deduceOutcome(e, t) {
    const i = Math.min(e.startSelection, t.startSelection, i1(e.text, t.text)), n = Math.min(e.text.length - e.endSelection, t.text.length - t.endSelection, n1(e.text, t.text)), r = e.text.substring(i, e.text.length - n), o = t.text.substring(i, t.text.length - n);
    return new t9(r, e.startSelection - i, e.endSelection - i, o, t.startSelection - i, t.endSelection - i);
  }
}
class dE {
  constructor(e, t, i, n, r, o) {
    this.id = e, this.label = t, this.alias = i, this._precondition = n, this._run = r, this._contextKeyService = o;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run() {
    return this.isSupported() ? this._run() : Promise.resolve(void 0);
  }
}
function Gl(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let r = 0, o = s.length; r < o; r++) {
    const a = s.charCodeAt(r);
    a === 13 ? (e === 0 && (t = r), e++, r + 1 < o && s.charCodeAt(r + 1) === 10 ? (n |= 2, r++) : n |= 3, i = r + 1) : a === 10 && (n |= 1, e === 0 && (t = r), e++, i = r + 1);
  }
  return e === 0 && (t = s.length), [e, t, s.length - i, n];
}
class pd {
  constructor(e, t, i, n) {
    this.range = e, this.nestingLevel = t, this.nestingLevelOfEqualBracketType = i, this.isInvalid = n;
  }
}
class AP {
  constructor(e, t, i, n, r, o) {
    this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n, this.nestingLevelOfEqualBracketType = r, this.bracketPairNode = o;
  }
  get openingBracketInfo() {
    return this.bracketPairNode.openingBracket.bracketInfo;
  }
}
class RP extends AP {
  constructor(e, t, i, n, r, o, a) {
    super(e, t, i, n, r, o), this.minVisibleColumnIndentation = a;
  }
}
class U1 {
  constructor(e, t) {
    this.lineCount = e, this.columnCount = t;
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
}
U1.zero = new U1(0, 0);
function PP(s, e, t, i) {
  return s !== t ? tt(t - s, i) : tt(0, i - e);
}
const An = 0;
function OP(s) {
  return s === 0;
}
const Oi = Math.pow(2, 26);
function tt(s, e) {
  return s * Oi + e;
}
function Yr(s) {
  const e = s, t = Math.floor(e / Oi), i = e - t * Oi;
  return new U1(t, i);
}
function FP(s) {
  return Math.floor(s / Oi);
}
function bt(s, e) {
  return e < Oi ? s + e : s - s % Oi + e;
}
function BP(s, e) {
  const t = s, i = e;
  if (i - t <= 0)
    return An;
  const r = Math.floor(t / Oi), o = Math.floor(i / Oi), a = i - o * Oi;
  if (r === o) {
    const l = t - r * Oi;
    return tt(0, a - l);
  } else
    return tt(o - r, a);
}
function Sl(s, e) {
  return s < e;
}
function Vr(s, e) {
  return s <= e;
}
function Yc(s, e) {
  return s >= e;
}
function Ma(s) {
  return tt(s.lineNumber - 1, s.column - 1);
}
function er(s, e) {
  const t = s, i = Math.floor(t / Oi), n = t - i * Oi, r = e, o = Math.floor(r / Oi), a = r - o * Oi;
  return new N(i + 1, n + 1, o + 1, a + 1);
}
function VP(s) {
  const e = xu(s);
  return tt(e.length - 1, e[e.length - 1].length);
}
class IS {
  constructor(e, t, i) {
    this.startOffset = e, this.endOffset = t, this.newLength = i;
  }
}
class WP {
  constructor(e, t) {
    this.documentLength = t, this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((i) => lC.from(i));
  }
  getOffsetBeforeChange(e) {
    return this.adjustNextEdit(e), this.translateCurToOld(e);
  }
  getDistanceToNextChange(e) {
    this.adjustNextEdit(e);
    const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : this.documentLength;
    return BP(e, i);
  }
  translateOldToCur(e) {
    return e.lineCount === this.deltaLineIdxInOld ? tt(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : tt(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
  }
  translateCurToOld(e) {
    const t = Yr(e);
    return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? tt(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : tt(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
  }
  adjustNextEdit(e) {
    for (; this.nextEditIdx < this.edits.length; ) {
      const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
      if (Vr(i, e)) {
        this.nextEditIdx++;
        const n = Yr(i), r = Yr(this.translateOldToCur(t.endOffsetBeforeObj)), o = n.lineCount - r.lineCount;
        this.deltaOldToNewLineCount += o;
        const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - r.columnCount;
        this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
      } else
        break;
    }
  }
}
class lC {
  constructor(e, t, i) {
    this.endOffsetBeforeObj = Yr(t), this.endOffsetAfterObj = Yr(bt(e, i)), this.offsetObj = Yr(e);
  }
  static from(e) {
    return new lC(e.startOffset, e.endOffset, e.newLength);
  }
}
const Yd = new Array();
class ot {
  constructor(e, t) {
    this.items = e, this.additionalItems = t;
  }
  static create(e, t) {
    if (e <= 128 && t.length === 0) {
      let i = ot.cache[e];
      return i || (i = new ot(e, t), ot.cache[e] = i), i;
    }
    return new ot(e, t);
  }
  static getEmpty() {
    return this.empty;
  }
  add(e, t) {
    const i = t.getKey(e);
    let n = i >> 5;
    if (n === 0) {
      const o = 1 << i | this.items;
      return o === this.items ? this : ot.create(o, this.additionalItems);
    }
    n--;
    const r = this.additionalItems.slice(0);
    for (; r.length < n; )
      r.push(0);
    return r[n] |= 1 << (i & 31), ot.create(this.items, r);
  }
  merge(e) {
    const t = this.items | e.items;
    if (this.additionalItems === Yd && e.additionalItems === Yd)
      return t === this.items ? this : t === e.items ? e : ot.create(t, Yd);
    const i = new Array();
    for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
      const r = this.additionalItems[n] || 0, o = e.additionalItems[n] || 0;
      i.push(r | o);
    }
    return ot.create(t, i);
  }
  intersects(e) {
    if ((this.items & e.items) !== 0)
      return !0;
    for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++)
      if ((this.additionalItems[t] & e.additionalItems[t]) !== 0)
        return !0;
    return !1;
  }
}
ot.cache = new Array(129);
ot.empty = ot.create(0, Yd);
const NS = {
  getKey(s) {
    return s;
  }
};
class HP {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  getKey(e) {
    let t = this.items.get(e);
    return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
  }
}
class cC {
  constructor(e) {
    this._length = e;
  }
  get length() {
    return this._length;
  }
}
class eu extends cC {
  constructor(e, t, i, n, r) {
    super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = r;
  }
  static create(e, t, i) {
    let n = e.length;
    return t && (n = bt(n, t.length)), i && (n = bt(n, i.length)), new eu(n, e, t, i, t ? t.missingOpeningBracketIds : ot.getEmpty());
  }
  get kind() {
    return 2;
  }
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 3;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this.openingBracket;
      case 1:
        return this.child;
      case 2:
        return this.closingBracket;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    const e = new Array();
    return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
  }
  canBeReused(e) {
    return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
  }
  deepClone() {
    return new eu(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return this.child ? this.child.computeMinIndentation(bt(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
  }
}
class gs extends cC {
  constructor(e, t, i) {
    super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  static create23(e, t, i, n = !1) {
    let r = e.length, o = e.missingOpeningBracketIds;
    if (e.listHeight !== t.listHeight)
      throw new Error("Invalid list heights");
    if (r = bt(r, t.length), o = o.merge(t.missingOpeningBracketIds), i) {
      if (e.listHeight !== i.listHeight)
        throw new Error("Invalid list heights");
      r = bt(r, i.length), o = o.merge(i.missingOpeningBracketIds);
    }
    return n ? new zP(r, e.listHeight + 1, e, t, i, o) : new tu(r, e.listHeight + 1, e, t, i, o);
  }
  static getEmpty() {
    return new UP(An, 0, [], ot.getEmpty());
  }
  get kind() {
    return 4;
  }
  get missingOpeningBracketIds() {
    return this._missingOpeningBracketIds;
  }
  throwIfImmutable() {
  }
  makeLastElementMutable() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    if (e === 0)
      return;
    const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(e - 1, i), i;
  }
  makeFirstElementMutable() {
    if (this.throwIfImmutable(), this.childrenLength === 0)
      return;
    const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(0, i), i;
  }
  canBeReused(e) {
    if (e.intersects(this.missingOpeningBracketIds))
      return !1;
    let t = this, i;
    for (; t.kind === 4 && (i = t.childrenLength) > 0; )
      t = t.getChild(i - 1);
    return t.canBeReused(e);
  }
  handleChildrenChanged() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
    for (let n = 1; n < e; n++) {
      const r = this.getChild(n);
      t = bt(t, r.length), i = i.merge(r.missingOpeningBracketIds);
    }
    this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  computeMinIndentation(e, t) {
    if (this.cachedMinIndentation !== -1)
      return this.cachedMinIndentation;
    let i = Number.MAX_SAFE_INTEGER, n = e;
    for (let r = 0; r < this.childrenLength; r++) {
      const o = this.getChild(r);
      o && (i = Math.min(i, o.computeMinIndentation(n, t)), n = bt(n, o.length));
    }
    return this.cachedMinIndentation = i, i;
  }
}
class tu extends gs {
  constructor(e, t, i, n, r, o) {
    super(e, t, o), this._item1 = i, this._item2 = n, this._item3 = r;
  }
  get childrenLength() {
    return this._item3 !== null ? 3 : 2;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this._item1;
      case 1:
        return this._item2;
      case 2:
        return this._item3;
    }
    throw new Error("Invalid child index");
  }
  setChild(e, t) {
    switch (e) {
      case 0:
        this._item1 = t;
        return;
      case 1:
        this._item2 = t;
        return;
      case 2:
        this._item3 = t;
        return;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
  }
  get item1() {
    return this._item1;
  }
  get item2() {
    return this._item2;
  }
  get item3() {
    return this._item3;
  }
  deepClone() {
    return new tu(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot append to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
  }
  unappendChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item3;
    return this._item3 = null, this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot prepend to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
  }
  unprependChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item1;
    return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class zP extends tu {
  toMutable() {
    return new tu(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
class Uf extends gs {
  constructor(e, t, i, n) {
    super(e, t, n), this._children = i;
  }
  get childrenLength() {
    return this._children.length;
  }
  getChild(e) {
    return this._children[e];
  }
  setChild(e, t) {
    this._children[e] = t;
  }
  get children() {
    return this._children;
  }
  deepClone() {
    const e = new Array(this._children.length);
    for (let t = 0; t < this._children.length; t++)
      e[t] = this._children[t].deepClone();
    return new Uf(this.length, this.listHeight, e, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
  }
  unappendChild() {
    this.throwIfImmutable();
    const e = this._children.pop();
    return this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
  }
  unprependChild() {
    this.throwIfImmutable();
    const e = this._children.shift();
    return this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class UP extends Uf {
  toMutable() {
    return new Uf(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
const $P = [];
class hC extends cC {
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 0;
  }
  getChild(e) {
    return null;
  }
  get children() {
    return $P;
  }
  deepClone() {
    return this;
  }
}
class Wa extends hC {
  get kind() {
    return 0;
  }
  get missingOpeningBracketIds() {
    return ot.getEmpty();
  }
  canBeReused(e) {
    return !0;
  }
  computeMinIndentation(e, t) {
    const i = Yr(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, r = FP(bt(e, this.length)) + 1;
    let o = Number.MAX_SAFE_INTEGER;
    for (let a = n; a <= r; a++) {
      const l = t.getLineFirstNonWhitespaceColumn(a), c = t.getLineContent(a);
      if (l === 0)
        continue;
      const h = _t.visibleColumnFromColumn(c, l, t.getOptions().tabSize);
      o = Math.min(o, h);
    }
    return o;
  }
}
class $f extends hC {
  constructor(e, t, i) {
    super(e), this.bracketInfo = t, this.bracketIds = i;
  }
  static create(e, t, i) {
    return new $f(e, t, i);
  }
  get kind() {
    return 1;
  }
  get missingOpeningBracketIds() {
    return ot.getEmpty();
  }
  get text() {
    return this.bracketInfo.bracketText;
  }
  get languageId() {
    return this.bracketInfo.languageId;
  }
  canBeReused(e) {
    return !1;
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class jP extends hC {
  constructor(e, t) {
    super(t), this.missingOpeningBracketIds = e;
  }
  get kind() {
    return 3;
  }
  canBeReused(e) {
    return !e.intersects(this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class Tr {
  constructor(e, t, i, n, r) {
    this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = r;
  }
}
class KP {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.reader = new qP(this.textModel, this.bracketTokens), this._offset = An, this.didPeek = !1, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  get offset() {
    return this._offset;
  }
  get length() {
    return tt(this.textBufferLineCount, this.textBufferLastLineLength);
  }
  skip(e) {
    this.didPeek = !1, this._offset = bt(this._offset, e);
    const t = Yr(this._offset);
    this.reader.setPosition(t.lineCount, t.columnCount);
  }
  read() {
    let e;
    return this.peeked ? (this.didPeek = !1, e = this.peeked) : e = this.reader.read(), e && (this._offset = bt(this._offset, e.length)), e;
  }
  peek() {
    return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0), this.peeked;
  }
}
class qP {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  setPosition(e, t) {
    e === this.lineIdx ? (this.lineCharOffset = t, this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset)) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
  }
  read() {
    if (this.peekedToken) {
      const r = this.peekedToken;
      return this.peekedToken = null, this.lineCharOffset += r.length, r;
    }
    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)
      return null;
    this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
    const e = this.lineIdx, t = this.lineCharOffset;
    let i = 0;
    for (; ; ) {
      const r = this.lineTokens, o = r.getCount();
      let a = null;
      if (this.lineTokenOffset < o) {
        const l = r.getMetadata(this.lineTokenOffset);
        for (; this.lineTokenOffset + 1 < o && l === r.getMetadata(this.lineTokenOffset + 1); )
          this.lineTokenOffset++;
        const c = ki.getTokenType(l) === 0, h = ki.containsBalancedBrackets(l), u = r.getEndOffset(this.lineTokenOffset);
        if (h && c && this.lineCharOffset < u) {
          const d = r.getLanguageId(this.lineTokenOffset), f = this.line.substring(this.lineCharOffset, u), m = this.bracketTokens.getSingleLanguageBracketTokens(d), _ = m.regExpGlobal;
          if (_) {
            _.lastIndex = 0;
            const b = _.exec(f);
            b && (a = m.getToken(b[0]), a && (this.lineCharOffset += b.index));
          }
        }
        if (i += u - this.lineCharOffset, a)
          if (e !== this.lineIdx || t !== this.lineCharOffset) {
            this.peekedToken = a;
            break;
          } else
            return this.lineCharOffset += a.length, a;
        else
          this.lineTokenOffset++, this.lineCharOffset = u;
      } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3))
        break;
      if (i > 1500)
        break;
    }
    const n = PP(e, t, this.lineIdx, this.lineCharOffset);
    return new Tr(n, 0, -1, ot.getEmpty(), new Wa(n));
  }
}
class GP {
  constructor(e, t) {
    this.text = e, this._offset = An, this.idx = 0;
    const i = t.getRegExpStr(), n = i ? new RegExp(i + `|
`, "gi") : null, r = [];
    let o, a = 0, l = 0, c = 0, h = 0;
    const u = new Array();
    for (let m = 0; m < 60; m++)
      u.push(new Tr(tt(0, m), 0, -1, ot.getEmpty(), new Wa(tt(0, m))));
    const d = new Array();
    for (let m = 0; m < 60; m++)
      d.push(new Tr(tt(1, m), 0, -1, ot.getEmpty(), new Wa(tt(1, m))));
    if (n)
      for (n.lastIndex = 0; (o = n.exec(e)) !== null; ) {
        const m = o.index, _ = o[0];
        if (_ === `
`)
          a++, l = m + 1;
        else {
          if (c !== m) {
            let b;
            if (h === a) {
              const v = m - c;
              if (v < u.length)
                b = u[v];
              else {
                const C = tt(0, v);
                b = new Tr(C, 0, -1, ot.getEmpty(), new Wa(C));
              }
            } else {
              const v = a - h, C = m - l;
              if (v === 1 && C < d.length)
                b = d[C];
              else {
                const w = tt(v, C);
                b = new Tr(w, 0, -1, ot.getEmpty(), new Wa(w));
              }
            }
            r.push(b);
          }
          r.push(t.getToken(_)), c = m + _.length, h = a;
        }
      }
    const f = e.length;
    if (c !== f) {
      const m = h === a ? tt(0, f - c) : tt(a - h, f - l);
      r.push(new Tr(m, 0, -1, ot.getEmpty(), new Wa(m)));
    }
    this.length = tt(a, f - l), this.tokens = r;
  }
  get offset() {
    return this._offset;
  }
  read() {
    return this.tokens[this.idx++] || null;
  }
  peek() {
    return this.tokens[this.idx] || null;
  }
  skip(e) {
    throw new HN();
  }
}
class uC {
  constructor(e) {
    this.map = e, this.hasRegExp = !1, this._regExpGlobal = null;
  }
  static createFromLanguage(e, t) {
    function i(r) {
      return t.getKey(`${r.languageId}:::${r.bracketText}`);
    }
    const n = /* @__PURE__ */ new Map();
    for (const r of e.bracketsNew.openingBrackets) {
      const o = tt(0, r.bracketText.length), a = i(r), l = ot.getEmpty().add(a, NS);
      n.set(r.bracketText, new Tr(o, 1, a, l, $f.create(o, r, l)));
    }
    for (const r of e.bracketsNew.closingBrackets) {
      const o = tt(0, r.bracketText.length);
      let a = ot.getEmpty();
      const l = r.getClosedBrackets();
      for (const c of l)
        a = a.add(i(c), NS);
      n.set(r.bracketText, new Tr(o, 2, i(l[0]), a, $f.create(o, r, a)));
    }
    return new uC(n);
  }
  getRegExpStr() {
    if (this.isEmpty)
      return null;
    {
      const e = [...this.map.keys()];
      return e.sort(), e.reverse(), e.map((t) => ZP(t)).join("|");
    }
  }
  get regExpGlobal() {
    if (!this.hasRegExp) {
      const e = this.getRegExpStr();
      this._regExpGlobal = e ? new RegExp(e, "gi") : null, this.hasRegExp = !0;
    }
    return this._regExpGlobal;
  }
  getToken(e) {
    return this.map.get(e.toLowerCase());
  }
  findClosingTokenText(e) {
    for (const [t, i] of this.map)
      if (i.kind === 2 && i.bracketIds.intersects(e))
        return t;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
}
function ZP(s) {
  let e = sr(s);
  return /^[\w ]+/.test(s) && (e = `\\b${e}`), /[\w ]+$/.test(s) && (e = `${e}\\b`), e;
}
class YP {
  constructor(e, t) {
    this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
  }
  didLanguageChange(e) {
    return this.languageIdToBracketTokens.has(e);
  }
  getSingleLanguageBracketTokens(e) {
    let t = this.languageIdToBracketTokens.get(e);
    return t || (t = uC.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
  }
}
function QP(s) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let e = 0;
  function t() {
    if (e >= s.length)
      return null;
    const o = e, a = s[o].listHeight;
    for (e++; e < s.length && s[e].listHeight === a; )
      e++;
    return e - o >= 2 ? fE(o === 0 && e === s.length ? s : s.slice(o, e), !1) : s[o];
  }
  let i = t(), n = t();
  if (!n)
    return i;
  for (let o = t(); o; o = t())
    TS(i, n) <= TS(n, o) ? (i = wp(i, n), n = o) : n = wp(n, o);
  return wp(i, n);
}
function fE(s, e = !1) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let t = s.length;
  for (; t > 3; ) {
    const i = t >> 1;
    for (let n = 0; n < i; n++) {
      const r = n << 1;
      s[n] = gs.create23(s[r], s[r + 1], r + 3 === t ? s[r + 2] : null, e);
    }
    t = i;
  }
  return gs.create23(s[0], s[1], t >= 3 ? s[2] : null, e);
}
function TS(s, e) {
  return Math.abs(s.listHeight - e.listHeight);
}
function wp(s, e) {
  return s.listHeight === e.listHeight ? gs.create23(s, e, null, !1) : s.listHeight > e.listHeight ? XP(s, e) : JP(e, s);
}
function XP(s, e) {
  s = s.toMutable();
  let t = s;
  const i = new Array();
  let n;
  for (; ; ) {
    if (e.listHeight === t.listHeight) {
      n = e;
      break;
    }
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeLastElementMutable();
  }
  for (let r = i.length - 1; r >= 0; r--) {
    const o = i[r];
    n ? o.childrenLength >= 3 ? n = gs.create23(o.unappendChild(), n, null, !1) : (o.appendChildOfSameHeight(n), n = void 0) : o.handleChildrenChanged();
  }
  return n ? gs.create23(s, n, null, !1) : s;
}
function JP(s, e) {
  s = s.toMutable();
  let t = s;
  const i = new Array();
  for (; e.listHeight !== t.listHeight; ) {
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeFirstElementMutable();
  }
  let n = e;
  for (let r = i.length - 1; r >= 0; r--) {
    const o = i[r];
    n ? o.childrenLength >= 3 ? n = gs.create23(n, o.unprependChild(), null, !1) : (o.prependChildOfSameHeight(n), n = void 0) : o.handleChildrenChanged();
  }
  return n ? gs.create23(n, s, null, !1) : s;
}
class e8 {
  constructor(e) {
    this.lastOffset = An, this.nextNodes = [e], this.offsets = [An], this.idxs = [];
  }
  readLongestNodeAt(e, t) {
    if (Sl(e, this.lastOffset))
      throw new Error("Invalid offset");
    for (this.lastOffset = e; ; ) {
      const i = Oc(this.nextNodes);
      if (!i)
        return;
      const n = Oc(this.offsets);
      if (Sl(e, n))
        return;
      if (Sl(n, e))
        if (bt(n, i.length) <= e)
          this.nextNodeAfterCurrent();
        else {
          const r = Sp(i);
          r !== -1 ? (this.nextNodes.push(i.getChild(r)), this.offsets.push(n), this.idxs.push(r)) : this.nextNodeAfterCurrent();
        }
      else {
        if (t(i))
          return this.nextNodeAfterCurrent(), i;
        {
          const r = Sp(i);
          if (r === -1) {
            this.nextNodeAfterCurrent();
            return;
          } else
            this.nextNodes.push(i.getChild(r)), this.offsets.push(n), this.idxs.push(r);
        }
      }
    }
  }
  nextNodeAfterCurrent() {
    for (; ; ) {
      const e = Oc(this.offsets), t = Oc(this.nextNodes);
      if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0)
        break;
      const i = Oc(this.nextNodes), n = Sp(i, this.idxs[this.idxs.length - 1]);
      if (n !== -1) {
        this.nextNodes.push(i.getChild(n)), this.offsets.push(bt(e, t.length)), this.idxs[this.idxs.length - 1] = n;
        break;
      } else
        this.idxs.pop();
    }
  }
}
function Sp(s, e = -1) {
  for (; ; ) {
    if (e++, e >= s.childrenLength)
      return -1;
    if (s.getChild(e))
      return e;
  }
}
function Oc(s) {
  return s.length > 0 ? s[s.length - 1] : void 0;
}
function MS(s, e, t, i) {
  return new t8(s, e, t, i).parseDocument();
}
class t8 {
  constructor(e, t, i, n) {
    if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n)
      throw new Error("Not supported");
    this.oldNodeReader = i ? new e8(i) : void 0, this.positionMapper = new WP(t, e.length);
  }
  parseDocument() {
    this._itemsConstructed = 0, this._itemsFromCache = 0;
    let e = this.parseList(ot.getEmpty());
    return e || (e = gs.getEmpty()), e;
  }
  parseList(e) {
    const t = new Array();
    for (; ; ) {
      const n = this.tokenizer.peek();
      if (!n || n.kind === 2 && n.bracketIds.intersects(e))
        break;
      const r = this.parseChild(e);
      r.kind === 4 && r.childrenLength === 0 || t.push(r);
    }
    return this.oldNodeReader ? QP(t) : fE(t, this.createImmutableLists);
  }
  parseChild(e) {
    if (this.oldNodeReader) {
      const i = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
      if (!OP(i)) {
        const n = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (r) => Sl(r.length, i) ? r.canBeReused(e) : !1);
        if (n)
          return this._itemsFromCache++, this.tokenizer.skip(n.length), n;
      }
    }
    this._itemsConstructed++;
    const t = this.tokenizer.read();
    switch (t.kind) {
      case 2:
        return new jP(t.bracketIds, t.length);
      case 0:
        return t.astNode;
      case 1: {
        const i = e.merge(t.bracketIds), n = this.parseList(i), r = this.tokenizer.peek();
        return r && r.kind === 2 && (r.bracketId === t.bracketId || r.bracketIds.intersects(t.bracketIds)) ? (this.tokenizer.read(), eu.create(t.astNode, n, r.astNode)) : eu.create(t.astNode, n, null);
      }
      default:
        throw new Error("unexpected");
    }
  }
}
class i8 extends z {
  constructor(e, t) {
    if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new A(), this.denseKeyProvider = new HP(), this.brackets = new YP(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, e.tokenization.backgroundTokenizationState === 0) {
      const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new GP(this.textModel.getValue(), i);
      this.initialAstWithoutTokens = MS(n, [], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens;
    } else
      e.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : e.tokenization.backgroundTokenizationState === 1 && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens);
  }
  didLanguageChange(e) {
    return this.brackets.didLanguageChange(e);
  }
  handleDidChangeBackgroundTokenizationState() {
    if (this.textModel.tokenization.backgroundTokenizationState === 2) {
      const e = this.initialAstWithoutTokens === void 0;
      this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
    }
  }
  handleDidChangeTokens({ ranges: e }) {
    const t = e.map((i) => new IS(tt(i.fromLineNumber - 1, 0), tt(i.toLineNumber, 0), tt(i.toLineNumber - i.fromLineNumber + 1, 0)));
    this.astWithTokens = this.parseDocumentFromTextBuffer(t, this.astWithTokens, !1), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
  }
  handleContentChanged(e) {
    const t = e.changes.map((i) => {
      const n = N.lift(i.range);
      return new IS(Ma(n.getStartPosition()), Ma(n.getEndPosition()), VP(i.text));
    }).reverse();
    this.astWithTokens = this.parseDocumentFromTextBuffer(t, this.astWithTokens, !1), this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(t, this.initialAstWithoutTokens, !1));
  }
  parseDocumentFromTextBuffer(e, t, i) {
    const n = t, r = new KP(this.textModel, this.brackets);
    return MS(r, e, n, i);
  }
  getBracketsInRange(e) {
    const t = tt(e.startLineNumber - 1, e.startColumn - 1), i = tt(e.endLineNumber - 1, e.endColumn - 1), n = new Array(), r = this.initialAstWithoutTokens || this.astWithTokens;
    return $1(r, An, r.length, t, i, n, 0, /* @__PURE__ */ new Map()), n;
  }
  getBracketPairsInRange(e, t) {
    const i = new Array(), n = Ma(e.getStartPosition()), r = Ma(e.getEndPosition()), o = this.initialAstWithoutTokens || this.astWithTokens, a = new n8(i, t, this.textModel);
    return j1(o, An, o.length, n, r, a, 0, /* @__PURE__ */ new Map()), i;
  }
  getFirstBracketAfter(e) {
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return mE(t, An, t.length, Ma(e));
  }
  getFirstBracketBefore(e) {
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return gE(t, An, t.length, Ma(e));
  }
}
function gE(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    const n = [];
    for (const r of s.children)
      t = bt(e, r.length), n.push({ nodeOffsetStart: e, nodeOffsetEnd: t }), e = t;
    for (let r = n.length - 1; r >= 0; r--) {
      const { nodeOffsetStart: o, nodeOffsetEnd: a } = n[r];
      if (Sl(o, i)) {
        const l = gE(s.children[r], o, a, i);
        if (l)
          return l;
      }
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = er(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function mE(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    for (const n of s.children) {
      if (t = bt(e, n.length), Sl(i, t)) {
        const r = mE(n, e, t, i);
        if (r)
          return r;
      }
      e = t;
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = er(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function $1(s, e, t, i, n, r, o, a) {
  if (!(o > 200)) {
    if (s.kind === 4)
      for (const l of s.children)
        t = bt(e, l.length), Vr(e, n) && Yc(t, i) && $1(l, e, t, i, n, r, o, a), e = t;
    else if (s.kind === 2) {
      let l = 0;
      if (a) {
        let c = a.get(s.openingBracket.text);
        c === void 0 && (c = 0), l = c, c++, a.set(s.openingBracket.text, c);
      }
      {
        const c = s.openingBracket;
        if (t = bt(e, c.length), Vr(e, n) && Yc(t, i)) {
          const h = er(e, t);
          r.push(new pd(h, o, l, !s.closingBracket));
        }
        e = t;
      }
      if (s.child) {
        const c = s.child;
        t = bt(e, c.length), Vr(e, n) && Yc(t, i) && $1(c, e, t, i, n, r, o + 1, a), e = t;
      }
      if (s.closingBracket) {
        const c = s.closingBracket;
        if (t = bt(e, c.length), Vr(e, n) && Yc(t, i)) {
          const h = er(e, t);
          r.push(new pd(h, o, l, !1));
        }
        e = t;
      }
      a == null || a.set(s.openingBracket.text, l);
    } else if (s.kind === 3) {
      const l = er(e, t);
      r.push(new pd(l, o - 1, 0, !0));
    } else if (s.kind === 1) {
      const l = er(e, t);
      r.push(new pd(l, o - 1, 0, !1));
    }
  }
}
class n8 {
  constructor(e, t, i) {
    this.result = e, this.includeMinIndentation = t, this.textModel = i;
  }
}
function j1(s, e, t, i, n, r, o, a) {
  var l;
  if (!(o > 200))
    if (s.kind === 2) {
      let c = 0;
      if (a) {
        let d = a.get(s.openingBracket.text);
        d === void 0 && (d = 0), c = d, d++, a.set(s.openingBracket.text, d);
      }
      const h = bt(e, s.openingBracket.length);
      let u = -1;
      if (r.includeMinIndentation && (u = s.computeMinIndentation(e, r.textModel)), r.result.push(new RP(er(e, t), er(e, h), s.closingBracket ? er(bt(h, ((l = s.child) === null || l === void 0 ? void 0 : l.length) || An), t) : void 0, o, c, s, u)), e = h, s.child) {
        const d = s.child;
        t = bt(e, d.length), Vr(e, n) && Yc(t, i) && j1(d, e, t, i, n, r, o + 1, a);
      }
      a == null || a.set(s.openingBracket.text, c);
    } else {
      let c = e;
      for (const h of s.children) {
        const u = c;
        c = bt(c, h.length), Vr(u, n) && Vr(i, c) && j1(h, u, c, i, n, r, o, a);
      }
    }
}
class s8 extends z {
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new $k()), this.onDidChangeEmitter = new A(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = !1, this._register(this.languageConfigurationService.onDidChange((i) => {
      var n;
      (!i.languageId || ((n = this.bracketPairsTree.value) === null || n === void 0 ? void 0 : n.object.didLanguageChange(i.languageId))) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
    }));
  }
  get canBuildAST() {
    return this.textModel.getValueLength() <= 5e6;
  }
  handleDidChangeOptions(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeLanguage(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeContent(e) {
    var t;
    (t = this.bracketPairsTree.value) === null || t === void 0 || t.object.handleContentChanged(e);
  }
  handleDidChangeBackgroundTokenizationState() {
    var e;
    (e = this.bracketPairsTree.value) === null || e === void 0 || e.object.handleDidChangeBackgroundTokenizationState();
  }
  handleDidChangeTokens(e) {
    var t;
    (t = this.bracketPairsTree.value) === null || t === void 0 || t.object.handleDidChangeTokens(e);
  }
  updateBracketPairsTree() {
    if (this.bracketsRequested && this.canBuildAST) {
      if (!this.bracketPairsTree.value) {
        const e = new le();
        this.bracketPairsTree.value = r8(e.add(new i8(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
      }
    } else
      this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
  }
  getBracketPairsInRange(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketPairsInRange(e, !1)) || [];
  }
  getBracketPairsInRangeWithMinIndentation(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketPairsInRange(e, !0)) || [];
  }
  getBracketsInRange(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketsInRange(e)) || [];
  }
  findMatchingBracketUp(e, t, i) {
    const n = this.textModel.validatePosition(t), r = this.textModel.getLanguageIdAtPosition(n.lineNumber, n.column);
    if (this.canBuildAST) {
      const o = this.languageConfigurationService.getLanguageConfiguration(r).bracketsNew.getClosingBracketInfo(e);
      if (!o)
        return null;
      const a = a_(this.getBracketPairsInRange(N.fromPositions(t, t)) || [], (l) => o.closes(l.openingBracketInfo));
      return a ? a.openingBracketRange : null;
    } else {
      const o = e.toLowerCase(), a = this.languageConfigurationService.getLanguageConfiguration(r).brackets;
      if (!a)
        return null;
      const l = a.textIsBracket[o];
      return l ? _d(this._findMatchingBracketUp(l, n, yp(i))) : null;
    }
  }
  matchBracket(e, t) {
    if (this.canBuildAST) {
      const i = Bk(this.getBracketPairsInRange(N.fromPositions(e, e)).filter((n) => n.closingBracketRange !== void 0 && (n.openingBracketRange.containsPosition(e) || n.closingBracketRange.containsPosition(e))), Hd((n) => n.openingBracketRange.containsPosition(e) ? n.openingBracketRange : n.closingBracketRange, N.compareRangesUsingStarts));
      return i ? [i.openingBracketRange, i.closingBracketRange] : null;
    } else {
      const i = yp(t);
      return this._matchBracket(this.textModel.validatePosition(e), i);
    }
  }
  _establishBracketSearchOffsets(e, t, i, n) {
    const r = t.getCount(), o = t.getLanguageId(n);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let c = n - 1; c >= 0; c--) {
      const h = t.getEndOffset(c);
      if (h <= a)
        break;
      if (Kn(t.getStandardTokenType(c)) || t.getLanguageId(c) !== o) {
        a = h;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let c = n + 1; c < r; c++) {
      const h = t.getStartOffset(c);
      if (h >= l)
        break;
      if (Kn(t.getStandardTokenType(c)) || t.getLanguageId(c) !== o) {
        l = h;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e, t) {
    const i = e.lineNumber, n = this.textModel.tokenization.getLineTokens(i), r = this.textModel.getLineContent(i), o = n.findTokenIndexAtOffset(e.column - 1);
    if (o < 0)
      return null;
    const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(o)).brackets;
    if (a && !Kn(n.getStandardTokenType(o))) {
      let { searchStartOffset: l, searchEndOffset: c } = this._establishBracketSearchOffsets(e, n, a, o), h = null;
      for (; ; ) {
        const u = cn.findNextBracketInRange(a.forwardRegex, i, r, l, c);
        if (!u)
          break;
        if (u.startColumn <= e.column && e.column <= u.endColumn) {
          const d = r.substring(u.startColumn - 1, u.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(u, a.textIsBracket[d], a.textIsOpenBracket[d], t);
          if (f) {
            if (f instanceof Bs)
              return null;
            h = f;
          }
        }
        l = u.endColumn - 1;
      }
      if (h)
        return h;
    }
    if (o > 0 && n.getStartOffset(o) === e.column - 1) {
      const l = o - 1, c = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
      if (c && !Kn(n.getStandardTokenType(l))) {
        const { searchStartOffset: h, searchEndOffset: u } = this._establishBracketSearchOffsets(e, n, c, l), d = cn.findPrevBracketInRange(c.reversedRegex, i, r, h, u);
        if (d && d.startColumn <= e.column && e.column <= d.endColumn) {
          const f = r.substring(d.startColumn - 1, d.endColumn - 1).toLowerCase(), m = this._matchFoundBracket(d, c.textIsBracket[f], c.textIsOpenBracket[f], t);
          if (m)
            return m instanceof Bs ? null : m;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, n) {
    if (!t)
      return null;
    const r = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
    return r ? r instanceof Bs ? r : [e, r] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const n = e.languageId, r = e.reversedRegex;
    let o = -1, a = 0;
    const l = (c, h, u, d) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return Bs.INSTANCE;
        const f = cn.findPrevBracketInRange(r, c, h, u, d);
        if (!f)
          break;
        const m = h.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
        if (e.isOpen(m) ? o++ : e.isClose(m) && o--, o === 0)
          return f;
        d = f.startColumn - 1;
      }
      return null;
    };
    for (let c = t.lineNumber; c >= 1; c--) {
      const h = this.textModel.tokenization.getLineTokens(c), u = h.getCount(), d = this.textModel.getLineContent(c);
      let f = u - 1, m = d.length, _ = d.length;
      c === t.lineNumber && (f = h.findTokenIndexAtOffset(t.column - 1), m = t.column - 1, _ = t.column - 1);
      let b = !0;
      for (; f >= 0; f--) {
        const v = h.getLanguageId(f) === n && !Kn(h.getStandardTokenType(f));
        if (v)
          b ? m = h.getStartOffset(f) : (m = h.getStartOffset(f), _ = h.getEndOffset(f));
        else if (b && m !== _) {
          const C = l(c, d, m, _);
          if (C)
            return C;
        }
        b = v;
      }
      if (b && m !== _) {
        const v = l(c, d, m, _);
        if (v)
          return v;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const n = e.languageId, r = e.forwardRegex;
    let o = 1, a = 0;
    const l = (h, u, d, f) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return Bs.INSTANCE;
        const m = cn.findNextBracketInRange(r, h, u, d, f);
        if (!m)
          break;
        const _ = u.substring(m.startColumn - 1, m.endColumn - 1).toLowerCase();
        if (e.isOpen(_) ? o++ : e.isClose(_) && o--, o === 0)
          return m;
        d = m.endColumn - 1;
      }
      return null;
    }, c = this.textModel.getLineCount();
    for (let h = t.lineNumber; h <= c; h++) {
      const u = this.textModel.tokenization.getLineTokens(h), d = u.getCount(), f = this.textModel.getLineContent(h);
      let m = 0, _ = 0, b = 0;
      h === t.lineNumber && (m = u.findTokenIndexAtOffset(t.column - 1), _ = t.column - 1, b = t.column - 1);
      let v = !0;
      for (; m < d; m++) {
        const C = u.getLanguageId(m) === n && !Kn(u.getStandardTokenType(m));
        if (C)
          v || (_ = u.getStartOffset(m)), b = u.getEndOffset(m);
        else if (v && _ !== b) {
          const w = l(h, f, _, b);
          if (w)
            return w;
        }
        v = C;
      }
      if (v && _ !== b) {
        const C = l(h, f, _, b);
        if (C)
          return C;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    var t;
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getFirstBracketBefore(i)) || null;
    let n = null, r = null, o = null;
    for (let a = i.lineNumber; a >= 1; a--) {
      const l = this.textModel.tokenization.getLineTokens(a), c = l.getCount(), h = this.textModel.getLineContent(a);
      let u = c - 1, d = h.length, f = h.length;
      if (a === i.lineNumber) {
        u = l.findTokenIndexAtOffset(i.column - 1), d = i.column - 1, f = i.column - 1;
        const _ = l.getLanguageId(u);
        n !== _ && (n = _, r = this.languageConfigurationService.getLanguageConfiguration(n).brackets, o = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew);
      }
      let m = !0;
      for (; u >= 0; u--) {
        const _ = l.getLanguageId(u);
        if (n !== _) {
          if (r && o && m && d !== f) {
            const v = cn.findPrevBracketInRange(r.reversedRegex, a, h, d, f);
            if (v)
              return this._toFoundBracket(o, v);
            m = !1;
          }
          n = _, r = this.languageConfigurationService.getLanguageConfiguration(n).brackets, o = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew;
        }
        const b = !!r && !Kn(l.getStandardTokenType(u));
        if (b)
          m ? d = l.getStartOffset(u) : (d = l.getStartOffset(u), f = l.getEndOffset(u));
        else if (o && r && m && d !== f) {
          const v = cn.findPrevBracketInRange(r.reversedRegex, a, h, d, f);
          if (v)
            return this._toFoundBracket(o, v);
        }
        m = b;
      }
      if (o && r && m && d !== f) {
        const _ = cn.findPrevBracketInRange(r.reversedRegex, a, h, d, f);
        if (_)
          return this._toFoundBracket(o, _);
      }
    }
    return null;
  }
  findNextBracket(e) {
    var t;
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getFirstBracketAfter(i)) || null;
    const n = this.textModel.getLineCount();
    let r = null, o = null, a = null;
    for (let l = i.lineNumber; l <= n; l++) {
      const c = this.textModel.tokenization.getLineTokens(l), h = c.getCount(), u = this.textModel.getLineContent(l);
      let d = 0, f = 0, m = 0;
      if (l === i.lineNumber) {
        d = c.findTokenIndexAtOffset(i.column - 1), f = i.column - 1, m = i.column - 1;
        const b = c.getLanguageId(d);
        r !== b && (r = b, o = this.languageConfigurationService.getLanguageConfiguration(r).brackets, a = this.languageConfigurationService.getLanguageConfiguration(r).bracketsNew);
      }
      let _ = !0;
      for (; d < h; d++) {
        const b = c.getLanguageId(d);
        if (r !== b) {
          if (a && o && _ && f !== m) {
            const C = cn.findNextBracketInRange(o.forwardRegex, l, u, f, m);
            if (C)
              return this._toFoundBracket(a, C);
            _ = !1;
          }
          r = b, o = this.languageConfigurationService.getLanguageConfiguration(r).brackets, a = this.languageConfigurationService.getLanguageConfiguration(r).bracketsNew;
        }
        const v = !!o && !Kn(c.getStandardTokenType(d));
        if (v)
          _ || (f = c.getStartOffset(d)), m = c.getEndOffset(d);
        else if (a && o && _ && f !== m) {
          const C = cn.findNextBracketInRange(o.forwardRegex, l, u, f, m);
          if (C)
            return this._toFoundBracket(a, C);
        }
        _ = v;
      }
      if (a && o && _ && f !== m) {
        const b = cn.findNextBracketInRange(o.forwardRegex, l, u, f, m);
        if (b)
          return this._toFoundBracket(a, b);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST) {
      const f = N.fromPositions(i), m = a_(this.getBracketPairsInRange(N.fromPositions(i, i)), (_) => _.closingBracketRange !== void 0 && _.range.strictContainsRange(f));
      return m ? [m.openingBracketRange, m.closingBracketRange] : null;
    }
    const n = yp(t), r = this.textModel.getLineCount(), o = /* @__PURE__ */ new Map();
    let a = [];
    const l = (f, m) => {
      if (!o.has(f)) {
        const _ = [];
        for (let b = 0, v = m ? m.brackets.length : 0; b < v; b++)
          _[b] = 0;
        o.set(f, _);
      }
      a = o.get(f);
    };
    let c = 0;
    const h = (f, m, _, b, v) => {
      for (; ; ) {
        if (n && ++c % 100 === 0 && !n())
          return Bs.INSTANCE;
        const C = cn.findNextBracketInRange(f.forwardRegex, m, _, b, v);
        if (!C)
          break;
        const w = _.substring(C.startColumn - 1, C.endColumn - 1).toLowerCase(), L = f.textIsBracket[w];
        if (L && (L.isOpen(w) ? a[L.index]++ : L.isClose(w) && a[L.index]--, a[L.index] === -1))
          return this._matchFoundBracket(C, L, !1, n);
        b = C.endColumn - 1;
      }
      return null;
    };
    let u = null, d = null;
    for (let f = i.lineNumber; f <= r; f++) {
      const m = this.textModel.tokenization.getLineTokens(f), _ = m.getCount(), b = this.textModel.getLineContent(f);
      let v = 0, C = 0, w = 0;
      if (f === i.lineNumber) {
        v = m.findTokenIndexAtOffset(i.column - 1), C = i.column - 1, w = i.column - 1;
        const E = m.getLanguageId(v);
        u !== E && (u = E, d = this.languageConfigurationService.getLanguageConfiguration(u).brackets, l(u, d));
      }
      let L = !0;
      for (; v < _; v++) {
        const E = m.getLanguageId(v);
        if (u !== E) {
          if (d && L && C !== w) {
            const y = h(d, f, b, C, w);
            if (y)
              return _d(y);
            L = !1;
          }
          u = E, d = this.languageConfigurationService.getLanguageConfiguration(u).brackets, l(u, d);
        }
        const k = !!d && !Kn(m.getStandardTokenType(v));
        if (k)
          L || (C = m.getStartOffset(v)), w = m.getEndOffset(v);
        else if (d && L && C !== w) {
          const y = h(d, f, b, C, w);
          if (y)
            return _d(y);
        }
        L = k;
      }
      if (d && L && C !== w) {
        const E = h(d, f, b, C, w);
        if (E)
          return _d(E);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.textModel.getValueInRange(t);
    i = i.toLowerCase();
    const n = e.getBracketInfo(i);
    return n ? {
      range: t,
      bracketInfo: n
    } : null;
  }
}
function r8(s, e) {
  return {
    object: s,
    dispose: () => e == null ? void 0 : e.dispose()
  };
}
function yp(s) {
  if (typeof s > "u")
    return () => !0;
  {
    const e = Date.now();
    return () => Date.now() - e <= s;
  }
}
class Bs {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
}
Bs.INSTANCE = new Bs();
function _d(s) {
  return s instanceof Bs ? null : s;
}
class o8 extends z {
  constructor(e) {
    super(), this.textModel = e, this.colorProvider = new pE(), this.onDidChangeEmitter = new A(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
      this.onDidChangeEmitter.fire();
    }));
  }
  handleDidChangeOptions(e) {
    this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
  }
  getDecorationsInRange(e, t, i) {
    if (t === void 0)
      return [];
    if (!this.colorizationOptions.enabled)
      return [];
    const n = new Array(), r = this.textModel.bracketPairs.getBracketsInRange(e);
    for (const o of r)
      n.push({
        id: `bracket${o.range.toString()}-${o.nestingLevel}`,
        options: {
          description: "BracketPairColorization",
          inlineClassName: this.colorProvider.getInlineClassName(o, this.colorizationOptions.independentColorPoolPerBracketType)
        },
        ownerId: 0,
        range: o.range
      });
    return n;
  }
  getAllDecorations(e, t) {
    return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new N(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
  }
}
class pE {
  constructor() {
    this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
  }
  getInlineClassName(e, t) {
    return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(t ? e.nestingLevelOfEqualBracketType : e.nestingLevel);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-highlighting-${e % 30}`;
  }
}
zi((s, e) => {
  const t = [
    GD,
    ZD,
    YD,
    QD,
    XD,
    JD
  ], i = new pE();
  e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${s.getColor(kR)}; }`);
  const n = t.map((r) => s.getColor(r)).filter((r) => !!r).filter((r) => !r.isTransparent());
  for (let r = 0; r < 30; r++) {
    const o = n[r % n.length];
    e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(r)} { color: ${o}; }`);
  }
});
function bd(s) {
  return s.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class At {
  constructor(e, t, i, n) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
  }
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${bd(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${bd(this.oldText)}")` : `(replace@${this.oldPosition} "${bd(this.oldText)}" with "${bd(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const n = t.length;
    yn(e, n, i), i += 4;
    for (let r = 0; r < n; r++)
      i4(e, t.charCodeAt(r), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = Sn(e, t);
    return t += 4, l1(e, t, i);
  }
  writeSize() {
    return 4 + 4 + At._writeStringSize(this.oldText) + At._writeStringSize(this.newText);
  }
  write(e, t) {
    return yn(e, this.oldPosition, t), t += 4, yn(e, this.newPosition, t), t += 4, t = At._writeString(e, this.oldText, t), t = At._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const n = Sn(e, t);
    t += 4;
    const r = Sn(e, t);
    t += 4;
    const o = At._readString(e, t);
    t += At._writeStringSize(o);
    const a = At._readString(e, t);
    return t += At._writeStringSize(a), i.push(new At(n, o, r, a)), t;
  }
}
function a8(s, e) {
  return s === null || s.length === 0 ? e : new Gn(s, e).compress();
}
class Gn {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (n === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldEnd <= i.newPosition) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= n.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldPosition < i.newPosition) {
        const [c, h] = Gn._splitCurr(n, i.newPosition - n.oldPosition);
        this._acceptCurr(c), n = h;
        continue;
      }
      if (i.newPosition < n.oldPosition) {
        const [c, h] = Gn._splitPrev(i, n.oldPosition - i.newPosition);
        this._acceptPrev(c), i = h;
        continue;
      }
      let a, l;
      if (n.oldEnd === i.newEnd)
        a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
      else if (n.oldEnd < i.newEnd) {
        const [c, h] = Gn._splitPrev(i, n.oldLength);
        a = c, l = n, i = h, n = this._getCurr(++t);
      } else {
        const [c, h] = Gn._splitCurr(n, i.newLength);
        a = i, l = c, i = this._getPrev(++e), n = h;
      }
      this._result[this._resultLen++] = new At(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const r = Gn._merge(this._result);
    return Gn._removeNoOps(r);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = Gn._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = Gn._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new At(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new At(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), n = e.newText.substr(t);
    return [
      new At(e.oldPosition, e.oldText, e.newPosition, i),
      new At(e.oldEnd, "", e.newPosition + t, n)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
    return [
      new At(e.oldPosition, i, e.newPosition, e.newText),
      new At(e.oldPosition + t, n, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0, n = e[0];
    for (let r = 1; r < e.length; r++) {
      const o = e[r];
      n.oldEnd === o.oldPosition ? n = new At(n.oldPosition, n.oldText + o.oldText, n.newPosition, n.newText + o.newText) : (t[i++] = n, n = o);
    }
    return t[i++] = n, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      r.oldText !== r.newText && (t[i++] = r);
    }
    return t;
  }
}
function fr(s) {
  return s === 47 || s === 92;
}
function _E(s) {
  return s.replace(/[\\/]/g, lt.sep);
}
function l8(s) {
  return s.indexOf("/") === -1 && (s = _E(s)), /^[a-zA-Z]:(\/|$)/.test(s) && (s = "/" + s), s;
}
function AS(s, e = lt.sep) {
  if (!s)
    return "";
  const t = s.length, i = s.charCodeAt(0);
  if (fr(i)) {
    if (fr(s.charCodeAt(1)) && !fr(s.charCodeAt(2))) {
      let r = 3;
      const o = r;
      for (; r < t && !fr(s.charCodeAt(r)); r++)
        ;
      if (o !== r && !fr(s.charCodeAt(r + 1))) {
        for (r += 1; r < t; r++)
          if (fr(s.charCodeAt(r)))
            return s.slice(0, r + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (c8(i) && s.charCodeAt(1) === 58)
    return fr(s.charCodeAt(2)) ? s.slice(0, 2) + e : s.slice(0, 2);
  let n = s.indexOf("://");
  if (n !== -1) {
    for (n += 3; n < t; n++)
      if (fr(s.charCodeAt(n)))
        return s.slice(0, n + 1);
  }
  return "";
}
function K1(s, e, t, i = Uo) {
  if (s === e)
    return !0;
  if (!s || !e || e.length > s.length)
    return !1;
  if (t) {
    if (!yb(s, e))
      return !1;
    if (e.length === s.length)
      return !0;
    let r = e.length;
    return e.charAt(e.length - 1) === i && r--, s.charAt(r) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), s.indexOf(e) === 0;
}
function c8(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122;
}
function Es(s) {
  return ff(s, !0);
}
class dC {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : t1(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  isEqualOrParent(e, t, i = !1) {
    if (e.scheme === t.scheme) {
      if (e.scheme === we.file)
        return K1(Es(e), Es(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
      if (RS(e.authority, t.authority))
        return K1(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
    }
    return !1;
  }
  joinPath(e, ...t) {
    return Le.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return fC(e) || e.authority;
  }
  basename(e) {
    return lt.basename(e.path);
  }
  extname(e) {
    return lt.extname(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === we.file ? t = Le.file(lT(Es(e))).path : (t = lt.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === we.file ? t = Le.file(Yk(Es(e))).path : t = lt.normalize(e.path), e.with({
      path: t
    });
  }
  relativePath(e, t) {
    if (e.scheme !== t.scheme || !RS(e.authority, t.authority))
      return;
    if (e.scheme === we.file) {
      const r = aT(Es(e), Es(t));
      return Vi ? _E(r) : r;
    }
    let i = e.path || "/";
    const n = t.path || "/";
    if (this._ignorePathCasing(e)) {
      let r = 0;
      for (const o = Math.min(i.length, n.length); r < o && !(i.charCodeAt(r) !== n.charCodeAt(r) && i.charAt(r).toLowerCase() !== n.charAt(r).toLowerCase()); r++)
        ;
      i = n.substr(0, r) + i.substr(r);
    }
    return lt.relative(i, n);
  }
  resolvePath(e, t) {
    if (e.scheme === we.file) {
      const i = Le.file(oT(Es(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = l8(t), e.with({
      path: lt.resolve(e.path, t)
    });
  }
  isAbsolutePath(e) {
    return !!e.path && e.path[0] === "/";
  }
  isEqualAuthority(e, t) {
    return e === t || e !== void 0 && t !== void 0 && Ka(e, t);
  }
  hasTrailingPathSeparator(e, t = Uo) {
    if (e.scheme === we.file) {
      const i = Es(e);
      return i.length > AS(i).length && i[i.length - 1] === t;
    } else {
      const i = e.path;
      return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
    }
  }
  removeTrailingPathSeparator(e, t = Uo) {
    return PS(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
  }
  addTrailingPathSeparator(e, t = Uo) {
    let i = !1;
    if (e.scheme === we.file) {
      const n = Es(e);
      i = n !== void 0 && n.length === AS(n).length && n[n.length - 1] === t;
    } else {
      t = "/";
      const n = e.path;
      i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
    }
    return !i && !PS(e, t) ? e.with({ path: e.path + "/" }) : e;
  }
}
const Fe = new dC(() => !1);
new dC((s) => s.scheme === we.file ? !_i : !0);
new dC((s) => !0);
Fe.isEqual.bind(Fe);
Fe.isEqualOrParent.bind(Fe);
Fe.getComparisonKey.bind(Fe);
Fe.basenameOrAuthority.bind(Fe);
const fC = Fe.basename.bind(Fe);
Fe.extname.bind(Fe);
Fe.dirname.bind(Fe);
Fe.joinPath.bind(Fe);
const h8 = Fe.normalizePath.bind(Fe);
Fe.relativePath.bind(Fe);
Fe.resolvePath.bind(Fe);
Fe.isAbsolutePath.bind(Fe);
const RS = Fe.isEqualAuthority.bind(Fe), PS = Fe.hasTrailingPathSeparator.bind(Fe);
Fe.removeTrailingPathSeparator.bind(Fe);
Fe.addTrailingPathSeparator.bind(Fe);
var jf;
(function(s) {
  s.META_DATA_LABEL = "label", s.META_DATA_DESCRIPTION = "description", s.META_DATA_SIZE = "size", s.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((o) => {
      const [a, l] = o.split(":");
      a && l && i.set(a, l);
    });
    const r = t.path.substring(0, t.path.indexOf(";"));
    return r && i.set(s.META_DATA_MIME, r), i;
  }
  s.parseMetaData = e;
})(jf || (jf = {}));
function Aa(s) {
  return s.toString();
}
class St {
  constructor(e, t, i, n, r, o, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = r, this.afterCursorState = o, this.changes = a;
  }
  static create(e, t) {
    const i = e.getAlternativeVersionId(), n = q1(e);
    return new St(i, i, n, n, t, t, []);
  }
  append(e, t, i, n, r) {
    t.length > 0 && (this.changes = a8(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = r;
  }
  static _writeSelectionsSize(e) {
    return 4 + 4 * 4 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (yn(e, t ? t.length : 0, i), i += 4, t)
      for (const n of t)
        yn(e, n.selectionStartLineNumber, i), i += 4, yn(e, n.selectionStartColumn, i), i += 4, yn(e, n.positionLineNumber, i), i += 4, yn(e, n.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const n = Sn(e, t);
    t += 4;
    for (let r = 0; r < n; r++) {
      const o = Sn(e, t);
      t += 4;
      const a = Sn(e, t);
      t += 4;
      const l = Sn(e, t);
      t += 4;
      const c = Sn(e, t);
      t += 4, i.push(new Ce(o, a, l, c));
    }
    return t;
  }
  serialize() {
    let e = 10 + St._writeSelectionsSize(this.beforeCursorState) + St._writeSelectionsSize(this.afterCursorState) + 4;
    for (const n of this.changes)
      e += n.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    yn(t, this.beforeVersionId, i), i += 4, yn(t, this.afterVersionId, i), i += 4, ew(t, this.beforeEOL, i), i += 1, ew(t, this.afterEOL, i), i += 1, i = St._writeSelections(t, this.beforeCursorState, i), i = St._writeSelections(t, this.afterCursorState, i), yn(t, this.changes.length, i), i += 4;
    for (const n of this.changes)
      i = n.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const n = Sn(t, i);
    i += 4;
    const r = Sn(t, i);
    i += 4;
    const o = Jv(t, i);
    i += 1;
    const a = Jv(t, i);
    i += 1;
    const l = [];
    i = St._readSelections(t, i, l);
    const c = [];
    i = St._readSelections(t, i, c);
    const h = Sn(t, i);
    i += 4;
    const u = [];
    for (let d = 0; d < h; d++)
      i = At.read(t, i, u);
    return new St(n, r, o, a, l, c, u);
  }
}
class bE {
  constructor(e, t, i, n) {
    this.label = e, this.code = t, this.model = i, this._data = St.create(i, n);
  }
  get type() {
    return 0;
  }
  get resource() {
    return Le.isUri(this.model) ? this.model : this.model.uri;
  }
  toString() {
    return (this._data instanceof St ? this._data : St.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (Le.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof St;
  }
  append(e, t, i, n, r) {
    this._data instanceof St && this._data.append(e, t, i, n, r);
  }
  close() {
    this._data instanceof St && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof St || (this._data = St.deserialize(this._data));
  }
  undo() {
    if (Le.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof St && (this._data = this._data.serialize());
    const e = St.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (Le.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof St && (this._data = this._data.serialize());
    const e = St.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof St && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class u8 {
  constructor(e, t, i) {
    this.label = e, this.code = t, this.type = 1, this._isOpen = !0, this._editStackElementsArr = i.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const n of this._editStackElementsArr) {
      const r = Aa(n.resource);
      this._editStackElementsMap.set(r, n);
    }
    this._delegate = null;
  }
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = Aa(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = Aa(Le.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = Aa(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, n, r) {
    const o = Aa(e.uri);
    this._editStackElementsMap.get(o).append(e, t, i, n, r);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = Aa(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    const e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${fC(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function q1(s) {
  return s.getEOL() === `
` ? 0 : 1;
}
function Vs(s) {
  return s ? s instanceof bE || s instanceof u8 : !1;
}
class gC {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Vs(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Vs(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e) {
    const t = this._undoRedoService.getLastElement(this._model.uri);
    if (Vs(t) && t.canAppend(this._model))
      return t;
    const i = new bE(p("edit", "Typing"), "undoredo.textBufferEdit", this._model, e);
    return this._undoRedoService.pushElement(i), i;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null);
    this._model.setEOL(e), t.append(this._model, [], q1(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i) {
    const n = this._getOrCreateEditStackElement(e), r = this._model.applyEdits(t, !0), o = gC._computeCursorState(i, r), a = r.map((l, c) => ({ index: c, textChange: l.textChange }));
    return a.sort((l, c) => l.textChange.oldPosition === c.textChange.oldPosition ? l.index - c.index : l.textChange.oldPosition - c.textChange.oldPosition), n.append(this._model, a.map((l) => l.textChange), q1(this._model), this._model.getAlternativeVersionId(), o), o;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return ct(i), null;
    }
  }
}
class d8 {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function f8(s, e, t, i, n) {
  n.spacesDiff = 0, n.looksLikeAlignment = !1;
  let r;
  for (r = 0; r < e && r < i; r++) {
    const d = s.charCodeAt(r), f = t.charCodeAt(r);
    if (d !== f)
      break;
  }
  let o = 0, a = 0;
  for (let d = r; d < e; d++)
    s.charCodeAt(d) === 32 ? o++ : a++;
  let l = 0, c = 0;
  for (let d = r; d < i; d++)
    t.charCodeAt(d) === 32 ? l++ : c++;
  if (o > 0 && a > 0 || l > 0 && c > 0)
    return;
  const h = Math.abs(a - c), u = Math.abs(o - l);
  if (h === 0) {
    n.spacesDiff = u, u > 0 && 0 <= l - 1 && l - 1 < s.length && l < t.length && t.charCodeAt(l) !== 32 && s.charCodeAt(l - 1) === 32 && s.charCodeAt(s.length - 1) === 44 && (n.looksLikeAlignment = !0);
    return;
  }
  if (u % h === 0) {
    n.spacesDiff = u / h;
    return;
  }
}
function OS(s, e, t) {
  const i = Math.min(s.getLineCount(), 1e4);
  let n = 0, r = 0, o = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], c = 8, h = [0, 0, 0, 0, 0, 0, 0, 0, 0], u = new d8();
  for (let m = 1; m <= i; m++) {
    const _ = s.getLineLength(m), b = s.getLineContent(m), v = _ <= 65536;
    let C = !1, w = 0, L = 0, E = 0;
    for (let y = 0, S = _; y < S; y++) {
      const D = v ? b.charCodeAt(y) : s.getLineCharCode(m, y);
      if (D === 9)
        E++;
      else if (D === 32)
        L++;
      else {
        C = !0, w = y;
        break;
      }
    }
    if (!C || (E > 0 ? n++ : L > 1 && r++, f8(o, a, b, w, u), u.looksLikeAlignment && !(t && e === u.spacesDiff)))
      continue;
    const k = u.spacesDiff;
    k <= c && h[k]++, o = b, a = w;
  }
  let d = t;
  n !== r && (d = n < r);
  let f = e;
  if (d) {
    let m = d ? 0 : 0.1 * i;
    l.forEach((_) => {
      const b = h[_];
      b > m && (m = b, f = _);
    }), f === 4 && h[4] > 0 && h[2] > 0 && h[2] >= h[4] / 2 && (f = 2);
  }
  return {
    insertSpaces: d,
    tabSize: f
  };
}
function di(s) {
  return (s.metadata & 1) >>> 0;
}
function Me(s, e) {
  s.metadata = s.metadata & 254 | e << 0;
}
function Ot(s) {
  return (s.metadata & 2) >>> 1 === 1;
}
function Te(s, e) {
  s.metadata = s.metadata & 253 | (e ? 1 : 0) << 1;
}
function CE(s) {
  return (s.metadata & 4) >>> 2 === 1;
}
function FS(s, e) {
  s.metadata = s.metadata & 251 | (e ? 1 : 0) << 2;
}
function g8(s) {
  return (s.metadata & 24) >>> 3;
}
function BS(s, e) {
  s.metadata = s.metadata & 231 | e << 3;
}
function m8(s) {
  return (s.metadata & 32) >>> 5 === 1;
}
function VS(s, e) {
  s.metadata = s.metadata & 223 | (e ? 1 : 0) << 5;
}
class vE {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, Me(this, 1), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, FS(this, !1), BS(this, 1), VS(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, Te(this, !1);
  }
  reset(e, t, i, n) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
  }
  setOptions(e) {
    this.options = e;
    const t = this.options.className;
    FS(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), BS(this, this.options.stickiness), VS(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const oe = new vE(null, 0, 0);
oe.parent = oe;
oe.left = oe;
oe.right = oe;
Me(oe, 0);
class Lp {
  constructor() {
    this.root = oe, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, n, r) {
    return this.root === oe ? [] : y8(this, e, t, i, n, r);
  }
  search(e, t, i) {
    return this.root === oe ? [] : S8(this, e, t, i);
  }
  collectNodesFromOwner(e) {
    return v8(this, e);
  }
  collectNodesPostOrder() {
    return w8(this);
  }
  insert(e) {
    WS(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    HS(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let n = 0;
    for (; e !== this.root; )
      e === e.parent.right && (n += e.parent.delta), e = e.parent;
    const r = i.start + n, o = i.end + n;
    i.setCachedOffsets(r, o, t);
  }
  acceptReplace(e, t, i, n) {
    const r = b8(this, e, e + t);
    for (let o = 0, a = r.length; o < a; o++) {
      const l = r[o];
      HS(this, l);
    }
    this._normalizeDeltaIfNecessary(), C8(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let o = 0, a = r.length; o < a; o++) {
      const l = r[o];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, _8(l, e, e + t, i, n), l.maxEnd = l.end, WS(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    !this.requestNormalizeDelta || (this.requestNormalizeDelta = !1, p8(this));
  }
}
function p8(s) {
  let e = s.root, t = 0;
  for (; e !== oe; ) {
    if (e.left !== oe && !Ot(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== oe && !Ot(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, no(e), Te(e, !0), Te(e.left, !1), Te(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  Te(s.root, !1);
}
function Ra(s, e, t, i) {
  return s < t ? !0 : s > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function _8(s, e, t, i, n) {
  const r = g8(s), o = r === 0 || r === 2, a = r === 1 || r === 2, l = t - e, c = i, h = Math.min(l, c), u = s.start;
  let d = !1;
  const f = s.end;
  let m = !1;
  e <= u && f <= t && m8(s) && (s.start = e, d = !0, s.end = e, m = !0);
  {
    const b = n ? 1 : l > 0 ? 2 : 0;
    !d && Ra(u, o, e, b) && (d = !0), !m && Ra(f, a, e, b) && (m = !0);
  }
  if (h > 0 && !n) {
    const b = l > c ? 2 : 0;
    !d && Ra(u, o, e + h, b) && (d = !0), !m && Ra(f, a, e + h, b) && (m = !0);
  }
  {
    const b = n ? 1 : 0;
    !d && Ra(u, o, t, b) && (s.start = e + c, d = !0), !m && Ra(f, a, t, b) && (s.end = e + c, m = !0);
  }
  const _ = c - l;
  d || (s.start = Math.max(0, u + _)), m || (s.end = Math.max(0, f + _)), s.start > s.end && (s.end = s.start);
}
function b8(s, e, t) {
  let i = s.root, n = 0, r = 0, o = 0, a = 0;
  const l = [];
  let c = 0;
  for (; i !== oe; ) {
    if (Ot(i)) {
      Te(i.left, !1), Te(i.right, !1), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!Ot(i.left)) {
      if (r = n + i.maxEnd, r < e) {
        Te(i, !0);
        continue;
      }
      if (i.left !== oe) {
        i = i.left;
        continue;
      }
    }
    if (o = n + i.start, o > t) {
      Te(i, !0);
      continue;
    }
    if (a = n + i.end, a >= e && (i.setCachedOffsets(o, a, 0), l[c++] = i), Te(i, !0), i.right !== oe && !Ot(i.right)) {
      n += i.delta, i = i.right;
      continue;
    }
  }
  return Te(s.root, !1), l;
}
function C8(s, e, t, i) {
  let n = s.root, r = 0, o = 0, a = 0;
  const l = i - (t - e);
  for (; n !== oe; ) {
    if (Ot(n)) {
      Te(n.left, !1), Te(n.right, !1), n === n.parent.right && (r -= n.parent.delta), no(n), n = n.parent;
      continue;
    }
    if (!Ot(n.left)) {
      if (o = r + n.maxEnd, o < e) {
        Te(n, !0);
        continue;
      }
      if (n.left !== oe) {
        n = n.left;
        continue;
      }
    }
    if (a = r + n.start, a > t) {
      n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (s.requestNormalizeDelta = !0), Te(n, !0);
      continue;
    }
    if (Te(n, !0), n.right !== oe && !Ot(n.right)) {
      r += n.delta, n = n.right;
      continue;
    }
  }
  Te(s.root, !1);
}
function v8(s, e) {
  let t = s.root;
  const i = [];
  let n = 0;
  for (; t !== oe; ) {
    if (Ot(t)) {
      Te(t.left, !1), Te(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== oe && !Ot(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[n++] = t), Te(t, !0), t.right !== oe && !Ot(t.right)) {
      t = t.right;
      continue;
    }
  }
  return Te(s.root, !1), i;
}
function w8(s) {
  let e = s.root;
  const t = [];
  let i = 0;
  for (; e !== oe; ) {
    if (Ot(e)) {
      Te(e.left, !1), Te(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== oe && !Ot(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== oe && !Ot(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, Te(e, !0);
  }
  return Te(s.root, !1), t;
}
function S8(s, e, t, i) {
  let n = s.root, r = 0, o = 0, a = 0;
  const l = [];
  let c = 0;
  for (; n !== oe; ) {
    if (Ot(n)) {
      Te(n.left, !1), Te(n.right, !1), n === n.parent.right && (r -= n.parent.delta), n = n.parent;
      continue;
    }
    if (n.left !== oe && !Ot(n.left)) {
      n = n.left;
      continue;
    }
    o = r + n.start, a = r + n.end, n.setCachedOffsets(o, a, i);
    let h = !0;
    if (e && n.ownerId && n.ownerId !== e && (h = !1), t && CE(n) && (h = !1), h && (l[c++] = n), Te(n, !0), n.right !== oe && !Ot(n.right)) {
      r += n.delta, n = n.right;
      continue;
    }
  }
  return Te(s.root, !1), l;
}
function y8(s, e, t, i, n, r) {
  let o = s.root, a = 0, l = 0, c = 0, h = 0;
  const u = [];
  let d = 0;
  for (; o !== oe; ) {
    if (Ot(o)) {
      Te(o.left, !1), Te(o.right, !1), o === o.parent.right && (a -= o.parent.delta), o = o.parent;
      continue;
    }
    if (!Ot(o.left)) {
      if (l = a + o.maxEnd, l < e) {
        Te(o, !0);
        continue;
      }
      if (o.left !== oe) {
        o = o.left;
        continue;
      }
    }
    if (c = a + o.start, c > t) {
      Te(o, !0);
      continue;
    }
    if (h = a + o.end, h >= e) {
      o.setCachedOffsets(c, h, r);
      let f = !0;
      i && o.ownerId && o.ownerId !== i && (f = !1), n && CE(o) && (f = !1), f && (u[d++] = o);
    }
    if (Te(o, !0), o.right !== oe && !Ot(o.right)) {
      a += o.delta, o = o.right;
      continue;
    }
  }
  return Te(s.root, !1), u;
}
function WS(s, e) {
  if (s.root === oe)
    return e.parent = oe, e.left = oe, e.right = oe, Me(e, 0), s.root = e, s.root;
  L8(s, e), wr(e.parent);
  let t = e;
  for (; t !== s.root && di(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      di(i) === 1 ? (Me(t.parent, 0), Me(i, 0), Me(t.parent.parent, 1), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, mh(s, t)), Me(t.parent, 0), Me(t.parent.parent, 1), ph(s, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      di(i) === 1 ? (Me(t.parent, 0), Me(i, 0), Me(t.parent.parent, 1), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, ph(s, t)), Me(t.parent, 0), Me(t.parent.parent, 1), mh(s, t.parent.parent));
    }
  return Me(s.root, 0), e;
}
function L8(s, e) {
  let t = 0, i = s.root;
  const n = e.start, r = e.end;
  for (; ; )
    if (D8(n, r, i.start + t, i.end + t) < 0)
      if (i.left === oe) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === oe) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = oe, e.right = oe, Me(e, 1);
}
function HS(s, e) {
  let t, i;
  if (e.left === oe ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === oe ? (t = e.left, i = e) : (i = k8(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (s.requestNormalizeDelta = !0)), i === s.root) {
    s.root = t, Me(t, 0), e.detach(), kp(), no(t), s.root.parent = oe;
    return;
  }
  const n = di(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, Me(i, di(e)), e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== oe && (i.left.parent = i), i.right !== oe && (i.right.parent = i)), e.detach(), n) {
    wr(t.parent), i !== e && (wr(i), wr(i.parent)), kp();
    return;
  }
  wr(t), wr(t.parent), i !== e && (wr(i), wr(i.parent));
  let r;
  for (; t !== s.root && di(t) === 0; )
    t === t.parent.left ? (r = t.parent.right, di(r) === 1 && (Me(r, 0), Me(t.parent, 1), mh(s, t.parent), r = t.parent.right), di(r.left) === 0 && di(r.right) === 0 ? (Me(r, 1), t = t.parent) : (di(r.right) === 0 && (Me(r.left, 0), Me(r, 1), ph(s, r), r = t.parent.right), Me(r, di(t.parent)), Me(t.parent, 0), Me(r.right, 0), mh(s, t.parent), t = s.root)) : (r = t.parent.left, di(r) === 1 && (Me(r, 0), Me(t.parent, 1), ph(s, t.parent), r = t.parent.left), di(r.left) === 0 && di(r.right) === 0 ? (Me(r, 1), t = t.parent) : (di(r.left) === 0 && (Me(r.right, 0), Me(r, 1), mh(s, r), r = t.parent.left), Me(r, di(t.parent)), Me(t.parent, 0), Me(r.left, 0), ph(s, t.parent), t = s.root));
  Me(t, 0), kp();
}
function k8(s) {
  for (; s.left !== oe; )
    s = s.left;
  return s;
}
function kp() {
  oe.parent = oe, oe.delta = 0, oe.start = 0, oe.end = 0;
}
function mh(s, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== oe && (t.left.parent = e), t.parent = e.parent, e.parent === oe ? s.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, no(e), no(t);
}
function ph(s, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (s.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== oe && (t.right.parent = e), t.parent = e.parent, e.parent === oe ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, no(e), no(t);
}
function wE(s) {
  let e = s.end;
  if (s.left !== oe) {
    const t = s.left.maxEnd;
    t > e && (e = t);
  }
  if (s.right !== oe) {
    const t = s.right.maxEnd + s.delta;
    t > e && (e = t);
  }
  return e;
}
function no(s) {
  s.maxEnd = wE(s);
}
function wr(s) {
  for (; s !== oe; ) {
    const e = wE(s);
    if (s.maxEnd === e)
      return;
    s.maxEnd = e, s = s.parent;
  }
}
function D8(s, e, t, i) {
  return s === t ? e - i : s - t;
}
class G1 {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== te)
      return mC(this.right);
    let e = this;
    for (; e.parent !== te && e.parent.left !== e; )
      e = e.parent;
    return e.parent === te ? te : e.parent;
  }
  prev() {
    if (this.left !== te)
      return SE(this.left);
    let e = this;
    for (; e.parent !== te && e.parent.right !== e; )
      e = e.parent;
    return e.parent === te ? te : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const te = new G1(null, 0);
te.parent = te;
te.left = te;
te.right = te;
te.color = 0;
function mC(s) {
  for (; s.left !== te; )
    s = s.left;
  return s;
}
function SE(s) {
  for (; s.right !== te; )
    s = s.right;
  return s;
}
function pC(s) {
  return s === te ? 0 : s.size_left + s.piece.length + pC(s.right);
}
function _C(s) {
  return s === te ? 0 : s.lf_left + s.piece.lineFeedCnt + _C(s.right);
}
function Dp() {
  te.parent = te;
}
function _h(s, e) {
  const t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== te && (t.left.parent = e), t.parent = e.parent, e.parent === te ? s.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function bh(s, e) {
  const t = e.left;
  e.left = t.right, t.right !== te && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === te ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function Cd(s, e) {
  let t, i;
  if (e.left === te ? (i = e, t = i.right) : e.right === te ? (i = e, t = i.left) : (i = mC(e.right), t = i.right), i === s.root) {
    s.root = t, t.color = 0, e.detach(), Dp(), s.root.parent = te;
    return;
  }
  const n = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, Qc(s, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, Qc(s, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== te && (i.left.parent = i), i.right !== te && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, Qc(s, i)), e.detach(), t.parent.left === t) {
    const o = pC(t), a = _C(t);
    if (o !== t.parent.size_left || a !== t.parent.lf_left) {
      const l = o - t.parent.size_left, c = a - t.parent.lf_left;
      t.parent.size_left = o, t.parent.lf_left = a, As(s, t.parent, l, c);
    }
  }
  if (Qc(s, t.parent), n) {
    Dp();
    return;
  }
  let r;
  for (; t !== s.root && t.color === 0; )
    t === t.parent.left ? (r = t.parent.right, r.color === 1 && (r.color = 0, t.parent.color = 1, _h(s, t.parent), r = t.parent.right), r.left.color === 0 && r.right.color === 0 ? (r.color = 1, t = t.parent) : (r.right.color === 0 && (r.left.color = 0, r.color = 1, bh(s, r), r = t.parent.right), r.color = t.parent.color, t.parent.color = 0, r.right.color = 0, _h(s, t.parent), t = s.root)) : (r = t.parent.left, r.color === 1 && (r.color = 0, t.parent.color = 1, bh(s, t.parent), r = t.parent.left), r.left.color === 0 && r.right.color === 0 ? (r.color = 1, t = t.parent) : (r.left.color === 0 && (r.right.color = 0, r.color = 1, _h(s, r), r = t.parent.left), r.color = t.parent.color, t.parent.color = 0, r.left.color = 0, bh(s, t.parent), t = s.root));
  t.color = 0, Dp();
}
function zS(s, e) {
  for (Qc(s, e); e !== s.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, _h(s, e)), e.parent.color = 0, e.parent.parent.color = 1, bh(s, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, bh(s, e)), e.parent.color = 0, e.parent.parent.color = 1, _h(s, e.parent.parent));
    }
  s.root.color = 0;
}
function As(s, e, t, i) {
  for (; e !== s.root && e !== te; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function Qc(s, e) {
  let t = 0, i = 0;
  if (e !== s.root) {
    for (; e !== s.root && e === e.parent.right; )
      e = e.parent;
    if (e !== s.root)
      for (e = e.parent, t = pC(e.left) - e.size_left, i = _C(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== s.root && (t !== 0 || i !== 0); )
        e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
const xs = 65535;
function yE(s) {
  let e;
  return s[s.length - 1] < 65536 ? e = new Uint16Array(s.length) : e = new Uint32Array(s.length), e.set(s, 0), e;
}
class E8 {
  constructor(e, t, i, n, r) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = r;
  }
}
function Ps(s, e = !0) {
  const t = [0];
  let i = 1;
  for (let n = 0, r = s.length; n < r; n++) {
    const o = s.charCodeAt(n);
    o === 13 ? n + 1 < r && s.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : o === 10 && (t[i++] = n + 1);
  }
  return e ? yE(t) : t;
}
function x8(s, e) {
  s.length = 0, s[0] = 0;
  let t = 1, i = 0, n = 0, r = 0, o = !0;
  for (let l = 0, c = e.length; l < c; l++) {
    const h = e.charCodeAt(l);
    h === 13 ? l + 1 < c && e.charCodeAt(l + 1) === 10 ? (r++, s[t++] = l + 2, l++) : (i++, s[t++] = l + 1) : h === 10 ? (n++, s[t++] = l + 1) : o && h !== 9 && (h < 32 || h > 126) && (o = !1);
  }
  const a = new E8(yE(s), i, n, r, o);
  return s.length = 0, a;
}
class Ci {
  constructor(e, t, i, n, r) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = r;
  }
}
class Io {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class I8 {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== te && e.iterate(e.root, (i) => (i !== te && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class N8 {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1;
    const i = this._cache;
    for (let n = 0; n < i.length; n++) {
      const r = i[n];
      if (r.node.parent === null || r.nodeStartOffset >= e) {
        i[n] = null, t = !0;
        continue;
      }
    }
    if (t) {
      const n = [];
      for (const r of i)
        r !== null && n.push(r);
      this._cache = n;
    }
  }
}
class T8 {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new Io("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = te, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let n = null;
    for (let r = 0, o = e.length; r < o; r++)
      if (e[r].buffer.length > 0) {
        e[r].lineStarts || (e[r].lineStarts = Ps(e[r].buffer));
        const a = new Ci(r + 1, { line: 0, column: 0 }, { line: e[r].lineStarts.length - 1, column: e[r].buffer.length - e[r].lineStarts[e[r].lineStarts.length - 1] }, e[r].lineStarts.length - 1, e[r].buffer.length);
        this._buffers.push(e[r]), n = this.rbInsertRight(n, a);
      }
    this._searchCache = new N8(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    const t = xs, i = t - Math.floor(t / 3), n = i * 2;
    let r = "", o = 0;
    const a = [];
    if (this.iterate(this.root, (l) => {
      const c = this.getNodeContent(l), h = c.length;
      if (o <= i || o + h < n)
        return r += c, o += h, !0;
      const u = r.replace(/\r\n|\r|\n/g, e);
      return a.push(new Io(u, Ps(u))), r = c, o = h, !0;
    }), o > 0) {
      const l = r.replace(/\r\n|\r|\n/g, e);
      a.push(new Io(l, Ps(l)));
    }
    this.create(a, e, !0);
  }
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new I8(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, n = this.root;
    for (; n !== te; )
      if (n.left !== te && n.lf_left + 1 >= e)
        n = n.left;
      else if (n.lf_left + n.piece.lineFeedCnt + 1 >= e) {
        i += n.size_left;
        const r = this.getAccumulatedValue(n, e - n.lf_left - 2);
        return i += r + t - 1;
      } else
        e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0;
    const n = e;
    for (; t !== te; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        const r = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + r.index, r.index === 0) {
          const o = this.getOffsetAt(i + 1, 1), a = n - o;
          return new O(i + 1, a + 1);
        }
        return new O(i + 1, r.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === te) {
        const r = this.getOffsetAt(i + 1, 1), o = n - e - r;
        return new O(i + 1, o + 1);
      } else
        t = t.right;
    return new O(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), r = this.getValueInRange2(i, n);
    return t ? t !== this._EOL || !this._EOLNormalized ? r.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? r : r.replace(/\r\n|\r|\n/g, t) : r;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, c = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(c + e.remainder, c + t.remainder);
    }
    let i = e.node;
    const n = this._buffers[i.piece.bufferIndex].buffer, r = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
    let o = n.substring(r + e.remainder, r + i.piece.length);
    for (i = i.next(); i !== te; ) {
      const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        o += a.substring(l, l + t.remainder);
        break;
      } else
        o += a.substr(l, i.piece.length);
      i = i.next();
    }
    return o;
  }
  getLinesContent() {
    const e = [];
    let t = 0, i = "", n = !1;
    return this.iterate(this.root, (r) => {
      if (r === te)
        return !0;
      const o = r.piece;
      let a = o.length;
      if (a === 0)
        return !0;
      const l = this._buffers[o.bufferIndex].buffer, c = this._buffers[o.bufferIndex].lineStarts, h = o.start.line, u = o.end.line;
      let d = c[h] + o.start.column;
      if (n && (l.charCodeAt(d) === 10 && (d++, a--), e[t++] = i, i = "", n = !1, a === 0))
        return !0;
      if (h === u)
        return !this._EOLNormalized && l.charCodeAt(d + a - 1) === 13 ? (n = !0, i += l.substr(d, a - 1)) : i += l.substr(d, a), !0;
      i += this._EOLNormalized ? l.substring(d, Math.max(d, c[h + 1] - this._EOLLength)) : l.substring(d, c[h + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let f = h + 1; f < u; f++)
        i = this._EOLNormalized ? l.substring(c[f], c[f + 1] - this._EOLLength) : l.substring(c[f], c[f + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(c[u] + o.end.column - 1) === 13 ? (n = !0, o.end.column === 0 ? t-- : i = l.substr(c[u], o.end.column - 1)) : i = l.substr(c[u], o.end.column), !0;
    }), n && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      const t = e.node.next();
      if (!t)
        return 0;
      const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(n);
    } else {
      const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(n);
    }
  }
  getLineCharCode(e, t) {
    const i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      const t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, n, r, o, a, l, c, h, u) {
    const d = this._buffers[e.piece.bufferIndex], f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), m = this.offsetInBuffer(e.piece.bufferIndex, r), _ = this.offsetInBuffer(e.piece.bufferIndex, o);
    let b;
    const v = { line: 0, column: 0 };
    let C, w;
    t._wordSeparators ? (C = d.buffer.substring(m, _), w = (L) => L + m, t.reset(0)) : (C = d.buffer, w = (L) => L, t.reset(m));
    do
      if (b = t.next(C), b) {
        if (w(b.index) >= _)
          return h;
        this.positionInBuffer(e, w(b.index) - f, v);
        const L = this.getLineFeedCnt(e.piece.bufferIndex, r, v), E = v.line === r.line ? v.column - r.column + n : v.column + 1, k = E + b[0].length;
        if (u[h++] = yo(new N(i + L, E, i + L, k), b, l), w(b.index) + b[0].length >= _ || h >= c)
          return h;
      }
    while (b);
    return h;
  }
  findMatchesLineByLine(e, t, i, n) {
    const r = [];
    let o = 0;
    const a = new Ga(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    const c = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (c === null)
      return [];
    let h = this.positionInBuffer(l.node, l.remainder);
    const u = this.positionInBuffer(c.node, c.remainder);
    if (l.node === c.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, h, u, t, i, n, o, r), r;
    let d = e.startLineNumber, f = l.node;
    for (; f !== c.node; ) {
      const _ = this.getLineFeedCnt(f.piece.bufferIndex, h, f.piece.end);
      if (_ >= 1) {
        const v = this._buffers[f.piece.bufferIndex].lineStarts, C = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start), w = v[h.line + _], L = d === e.startLineNumber ? e.startColumn : 1;
        if (o = this.findMatchesInNode(f, a, d, L, h, this.positionInBuffer(f, w - C), t, i, n, o, r), o >= n)
          return r;
        d += _;
      }
      const b = d === e.startLineNumber ? e.startColumn - 1 : 0;
      if (d === e.endLineNumber) {
        const v = this.getLineContent(d).substring(b, e.endColumn - 1);
        return o = this._findMatchesInLine(t, a, v, e.endLineNumber, b, o, r, i, n), r;
      }
      if (o = this._findMatchesInLine(t, a, this.getLineContent(d).substr(b), d, b, o, r, i, n), o >= n)
        return r;
      d++, l = this.nodeAt2(d, 1), f = l.node, h = this.positionInBuffer(l.node, l.remainder);
    }
    if (d === e.endLineNumber) {
      const _ = d === e.startLineNumber ? e.startColumn - 1 : 0, b = this.getLineContent(d).substring(_, e.endColumn - 1);
      return o = this._findMatchesInLine(t, a, b, e.endLineNumber, _, o, r, i, n), r;
    }
    const m = d === e.startLineNumber ? e.startColumn : 1;
    return o = this.findMatchesInNode(c.node, a, d, m, h, u, t, i, n, o, r), r;
  }
  _findMatchesInLine(e, t, i, n, r, o, a, l, c) {
    const h = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const d = e.simpleSearch, f = d.length, m = i.length;
      let _ = -f;
      for (; (_ = i.indexOf(d, _ + f)) !== -1; )
        if ((!h || Vb(h, i, m, _, f)) && (a[o++] = new Ah(new N(n, _ + 1 + r, n, _ + 1 + f + r), null), o >= c))
          return o;
      return o;
    }
    let u;
    t.reset(0);
    do
      if (u = t.next(i), u && (a[o++] = yo(new N(n, u.index + 1 + r, n, u.index + 1 + u[0].length + r), u, l), o >= c))
        return o;
    while (u);
    return o;
  }
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== te) {
      const { node: n, remainder: r, nodeStartOffset: o } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, c = this.positionInBuffer(n, r);
      if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && o + a.length === e && t.length < xs) {
        this.appendToNode(n, t), this.computeBufferMetadata();
        return;
      }
      if (o === e)
        this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
      else if (o + n.piece.length > e) {
        const h = [];
        let u = new Ci(a.bufferIndex, c, a.end, this.getLineFeedCnt(a.bufferIndex, c, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, c));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, r) === 10) {
          const _ = { line: u.start.line + 1, column: 0 };
          u = new Ci(u.bufferIndex, _, u.end, this.getLineFeedCnt(u.bufferIndex, _, u.end), u.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(n, r - 1) === 13) {
            const _ = this.positionInBuffer(n, r - 1);
            this.deleteNodeTail(n, _), t = "\r" + t, n.piece.length === 0 && h.push(n);
          } else
            this.deleteNodeTail(n, c);
        else
          this.deleteNodeTail(n, c);
        const d = this.createNewPieces(t);
        u.length > 0 && this.rbInsertRight(n, u);
        let f = n;
        for (let m = 0; m < d.length; m++)
          f = this.rbInsertRight(f, d[m]);
        this.deleteNodes(h);
      } else
        this.insertContentToNodeRight(t, n);
    } else {
      const n = this.createNewPieces(t);
      let r = this.rbInsertLeft(null, n[0]);
      for (let o = 1; o < n.length; o++)
        r = this.rbInsertRight(r, n[o]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === te)
      return;
    const i = this.nodeAt(e), n = this.nodeAt(e + t), r = i.node, o = n.node;
    if (r === o) {
      const d = this.positionInBuffer(r, i.remainder), f = this.positionInBuffer(r, n.remainder);
      if (i.nodeStartOffset === e) {
        if (t === r.piece.length) {
          const m = r.next();
          Cd(this, r), this.validateCRLFWithPrevNode(m), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(r, f), this._searchCache.validate(e), this.validateCRLFWithPrevNode(r), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + r.piece.length === e + t) {
        this.deleteNodeTail(r, d), this.validateCRLFWithNextNode(r), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(r, d, f), this.computeBufferMetadata();
      return;
    }
    const a = [], l = this.positionInBuffer(r, i.remainder);
    this.deleteNodeTail(r, l), this._searchCache.validate(e), r.piece.length === 0 && a.push(r);
    const c = this.positionInBuffer(o, n.remainder);
    this.deleteNodeHead(o, c), o.piece.length === 0 && a.push(o);
    const h = r.next();
    for (let d = h; d !== te && d !== o; d = d.next())
      a.push(d);
    const u = r.piece.length === 0 ? r.prev() : r;
    this.deleteNodes(a), this.validateCRLFWithNextNode(u), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    const i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      const o = t.piece, a = { line: o.start.line + 1, column: 0 }, l = new Ci(o.bufferIndex, a, o.end, this.getLineFeedCnt(o.bufferIndex, a, o.end), o.length - 1);
      t.piece = l, e += `
`, As(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    const n = this.createNewPieces(e);
    let r = this.rbInsertLeft(t, n[n.length - 1]);
    for (let o = n.length - 2; o >= 0; o--)
      r = this.rbInsertLeft(r, n[o]);
    this.validateCRLFWithPrevNode(r), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
    let r = n;
    for (let o = 1; o < i.length; o++)
      r = this.rbInsertRight(r, i[o]);
    this.validateCRLFWithPrevNode(n);
  }
  positionInBuffer(e, t, i) {
    const n = e.piece, r = e.piece.bufferIndex, o = this._buffers[r].lineStarts, l = o[n.start.line] + n.start.column + t;
    let c = n.start.line, h = n.end.line, u = 0, d = 0, f = 0;
    for (; c <= h && (u = c + (h - c) / 2 | 0, f = o[u], u !== h); )
      if (d = o[u + 1], l < f)
        h = u - 1;
      else if (l >= d)
        c = u + 1;
      else
        break;
    return i ? (i.line = u, i.column = l - f, null) : {
      line: u,
      column: l - f
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    const n = this._buffers[e].lineStarts;
    if (i.line === n.length - 1)
      return i.line - t.line;
    const r = n[i.line + 1], o = n[i.line] + i.column;
    if (r > o + 1)
      return i.line - t.line;
    const a = o - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      Cd(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > xs) {
      const h = [];
      for (; e.length > xs; ) {
        const d = e.charCodeAt(xs - 1);
        let f;
        d === 13 || d >= 55296 && d <= 56319 ? (f = e.substring(0, xs - 1), e = e.substring(xs - 1)) : (f = e.substring(0, xs), e = e.substring(xs));
        const m = Ps(f);
        h.push(new Ci(this._buffers.length, { line: 0, column: 0 }, { line: m.length - 1, column: f.length - m[m.length - 1] }, m.length - 1, f.length)), this._buffers.push(new Io(f, m));
      }
      const u = Ps(e);
      return h.push(new Ci(this._buffers.length, { line: 0, column: 0 }, { line: u.length - 1, column: e.length - u[u.length - 1] }, u.length - 1, e.length)), this._buffers.push(new Io(e, u)), h;
    }
    let t = this._buffers[0].buffer.length;
    const i = Ps(e, !1);
    let n = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, n = this._lastChangeBufferPos;
      for (let h = 0; h < i.length; h++)
        i[h] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let h = 0; h < i.length; h++)
          i[h] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const r = this._buffers[0].buffer.length, o = this._buffers[0].lineStarts.length - 1, a = r - this._buffers[0].lineStarts[o], l = { line: o, column: a }, c = new Ci(0, n, l, this.getLineFeedCnt(0, n, l), r - t);
    return this._lastChangeBufferPos = l, [c];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, n = "";
    const r = this._searchCache.get2(e);
    if (r) {
      i = r.node;
      const o = this.getAccumulatedValue(i, e - r.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (r.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        n = a.substring(l + o, l + i.piece.length);
      else {
        const c = this.getAccumulatedValue(i, e - r.nodeStartLineNumber);
        return a.substring(l + o, l + c - t);
      }
    } else {
      let o = 0;
      const a = e;
      for (; i !== te; )
        if (i.left !== te && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this.getAccumulatedValue(i, e - i.lf_left - 1), h = this._buffers[i.piece.bufferIndex].buffer, u = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return o += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: o,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), h.substring(u + l, u + c - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          n = c.substring(h + l, h + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, o += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== te; ) {
      const o = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return n += o.substring(l, l + a - t), n;
      } else {
        const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        n += o.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return n;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== te; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  getIndexOf(e, t) {
    const i = e.piece, n = this.positionInBuffer(e, t), r = n.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      const o = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
      if (o !== r)
        return { index: o, remainder: 0 };
    }
    return { index: r, remainder: n.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, r = i.start.line + t + 1;
    return r > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[r] - n[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, n = i.lineFeedCnt, r = this.offsetInBuffer(i.bufferIndex, i.end), o = t, a = this.offsetInBuffer(i.bufferIndex, o), l = this.getLineFeedCnt(i.bufferIndex, i.start, o), c = l - n, h = a - r, u = i.length + h;
    e.piece = new Ci(i.bufferIndex, i.start, o, l, u), As(this, e, h, c);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, n = i.lineFeedCnt, r = this.offsetInBuffer(i.bufferIndex, i.start), o = t, a = this.getLineFeedCnt(i.bufferIndex, o, i.end), l = this.offsetInBuffer(i.bufferIndex, o), c = a - n, h = r - l, u = i.length + h;
    e.piece = new Ci(i.bufferIndex, o, i.end, a, u), As(this, e, h, c);
  }
  shrinkNode(e, t, i) {
    const n = e.piece, r = n.start, o = n.end, a = n.length, l = n.lineFeedCnt, c = t, h = this.getLineFeedCnt(n.bufferIndex, n.start, c), u = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, r);
    e.piece = new Ci(n.bufferIndex, n.start, c, h, u), As(this, e, u - a, h - l);
    const d = new Ci(n.bufferIndex, i, o, this.getLineFeedCnt(n.bufferIndex, i, o), this.offsetInBuffer(n.bufferIndex, o) - this.offsetInBuffer(n.bufferIndex, i)), f = this.rbInsertRight(e, d);
    this.validateCRLFWithPrevNode(f);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const r = Ps(t, !1);
    for (let f = 0; f < r.length; f++)
      r[f] += n;
    if (i) {
      const f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: n - f };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(r.slice(1));
    const o = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[o], l = { line: o, column: a }, c = e.piece.length + t.length, h = e.piece.lineFeedCnt, u = this.getLineFeedCnt(0, e.piece.start, l), d = u - h;
    e.piece = new Ci(e.piece.bufferIndex, e.piece.start, l, u, c), this._lastChangeBufferPos = l, As(this, e, t.length, d);
  }
  nodeAt(e) {
    let t = this.root;
    const i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let n = 0;
    for (; t !== te; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        n += t.size_left;
        const r = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: n
        };
        return this._searchCache.set(r), r;
      } else
        e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, n = 0;
    for (; i !== te; )
      if (i.left !== te && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        const r = this.getAccumulatedValue(i, e - i.lf_left - 2), o = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return n += i.size_left, {
          node: i,
          remainder: Math.min(r + t - 1, o),
          nodeStartOffset: n
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        const r = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (r + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: r + t - 1,
            nodeStartOffset: n
          };
        t -= i.piece.length - r;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== te; ) {
      if (i.piece.lineFeedCnt > 0) {
        const r = this.getAccumulatedValue(i, 0), o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, r),
          nodeStartOffset: o
        };
      } else if (i.piece.length >= t - 1) {
        const r = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: r
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(n);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === te || e.piece.lineFeedCnt === 0)
      return !1;
    const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, r = i[n] + t.start.column;
    return n === i.length - 1 || i[n + 1] > r + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(r) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === te || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      const t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
    let r;
    e.piece.end.column === 0 ? r = { line: e.piece.end.line - 1, column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1 } : r = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const o = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new Ci(e.piece.bufferIndex, e.piece.start, r, a, o), As(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    const l = { line: t.piece.start.line + 1, column: 0 }, c = t.piece.length - 1, h = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new Ci(t.piece.bufferIndex, l, t.piece.end, h, c), As(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    const u = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, u[0]);
    for (let d = 0; d < i.length; d++)
      Cd(this, i[d]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          Cd(this, i);
        else {
          const n = i.piece, r = { line: n.start.line + 1, column: 0 }, o = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, r, n.end);
          i.piece = new Ci(n.bufferIndex, r, n.end, a, o), As(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  iterate(e, t) {
    if (e === te)
      return t(te);
    const i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === te)
      return "";
    const t = this._buffers[e.piece.bufferIndex], i = e.piece, n = this.offsetInBuffer(i.bufferIndex, i.start), r = this.offsetInBuffer(i.bufferIndex, i.end);
    return t.buffer.substring(n, r);
  }
  getPieceContent(e) {
    const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, n);
  }
  rbInsertRight(e, t) {
    const i = new G1(t, 1);
    if (i.left = te, i.right = te, i.parent = te, i.size_left = 0, i.lf_left = 0, this.root === te)
      this.root = i, i.color = 0;
    else if (e.right === te)
      e.right = i, i.parent = e;
    else {
      const r = mC(e.right);
      r.left = i, i.parent = r;
    }
    return zS(this, i), i;
  }
  rbInsertLeft(e, t) {
    const i = new G1(t, 1);
    if (i.left = te, i.right = te, i.parent = te, i.size_left = 0, i.lf_left = 0, this.root === te)
      this.root = i, i.color = 0;
    else if (e.left === te)
      e.left = i, i.parent = e;
    else {
      const n = SE(e.left);
      n.right = i, i.parent = n;
    }
    return zS(this, i), i;
  }
}
class yl extends z {
  constructor(e, t, i, n, r, o, a) {
    super(), this._onDidChangeContent = this._register(new A()), this._BOM = t, this._mightContainNonBasicASCII = !o, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = r, this._pieceTree = new T8(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    const i = e + t, n = this.getPositionAt(e), r = this.getPositionAt(i);
    return new N(n.lineNumber, n.column, r.lineNumber, r.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    const i = this.getOffsetAt(e.startLineNumber, e.startColumn);
    return this.getOffsetAt(e.endLineNumber, e.endColumn) - i;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const n = e.startLineNumber, r = e.endLineNumber;
      for (let o = n; o <= r; o++) {
        const a = this.getLineContent(o), l = o === n ? e.startColumn - 1 : 0, c = o === r ? e.endColumn - 1 : a.length;
        for (let h = l; h < c; h++)
          Lt(a.charCodeAt(h)) ? (i = i + 1, h = h + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (r - n), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Bi(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = cc(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let n = this._mightContainRTL, r = this._mightContainUnusualLineTerminators, o = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let _ = 0; _ < e.length; _++) {
      const b = e[_];
      a && b._isTracked && (a = !1);
      const v = b.range;
      if (b.text) {
        let k = !0;
        o || (k = !Eb(b.text), o = k), !n && k && (n = Th(b.text)), !r && k && (r = a2(b.text));
      }
      let C = "", w = 0, L = 0, E = 0;
      if (b.text) {
        let k;
        [w, L, E, k] = Gl(b.text);
        const y = this.getEOL();
        k === 0 || k === (y === `\r
` ? 2 : 1) ? C = b.text : C = b.text.replace(/\r\n|\r|\n/g, y);
      }
      l[_] = {
        sortIndex: _,
        identifier: b.identifier || null,
        range: v,
        rangeOffset: this.getOffsetAt(v.startLineNumber, v.startColumn),
        rangeLength: this.getValueLengthInRange(v),
        text: C,
        eolCount: w,
        firstLineLength: L,
        lastLineLength: E,
        forceMoveMarkers: Boolean(b.forceMoveMarkers),
        isAutoWhitespaceEdit: b.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(yl._sortOpsAscending);
    let c = !1;
    for (let _ = 0, b = l.length - 1; _ < b; _++) {
      const v = l[_].range.getEndPosition(), C = l[_ + 1].range.getStartPosition();
      if (C.isBeforeOrEqual(v)) {
        if (C.isBefore(v))
          throw new Error("Overlapping ranges are not allowed!");
        c = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    const h = i || t ? yl._getInverseEditRanges(l) : [], u = [];
    if (t)
      for (let _ = 0; _ < l.length; _++) {
        const b = l[_], v = h[_];
        if (b.isAutoWhitespaceEdit && b.range.isEmpty())
          for (let C = v.startLineNumber; C <= v.endLineNumber; C++) {
            let w = "";
            C === v.startLineNumber && (w = this.getLineContent(b.range.startLineNumber), Bi(w) !== -1) || u.push({ lineNumber: C, oldContent: w });
          }
      }
    let d = null;
    if (i) {
      let _ = 0;
      d = [];
      for (let b = 0; b < l.length; b++) {
        const v = l[b], C = h[b], w = this.getValueInRange(v.range), L = v.rangeOffset + _;
        _ += v.text.length - w.length, d[b] = {
          sortIndex: v.sortIndex,
          identifier: v.identifier,
          range: C,
          text: w,
          textChange: new At(v.rangeOffset, w, L, v.text)
        };
      }
      c || d.sort((b, v) => b.sortIndex - v.sortIndex);
    }
    this._mightContainRTL = n, this._mightContainUnusualLineTerminators = r, this._mightContainNonBasicASCII = o;
    const f = this._doApplyEdits(l);
    let m = null;
    if (t && u.length > 0) {
      u.sort((_, b) => b.lineNumber - _.lineNumber), m = [];
      for (let _ = 0, b = u.length; _ < b; _++) {
        const v = u[_].lineNumber;
        if (_ > 0 && u[_ - 1].lineNumber === v)
          continue;
        const C = u[_].oldContent, w = this.getLineContent(v);
        w.length === 0 || w === C || Bi(w) !== -1 || m.push(v);
      }
    }
    return this._onDidChangeContent.fire(), new QT(d, f, m);
  }
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, n = e[e.length - 1].range, r = new N(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
    let o = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let f = 0, m = e.length; f < m; f++) {
      const _ = e[f], b = _.range;
      t = t || _.forceMoveMarkers, l.push(this.getValueInRange(new N(o, a, b.startLineNumber, b.startColumn))), _.text.length > 0 && l.push(_.text), o = b.endLineNumber, a = b.endColumn;
    }
    const c = l.join(""), [h, u, d] = Gl(c);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: r,
      rangeOffset: this.getOffsetAt(r.startLineNumber, r.startColumn),
      rangeLength: this.getValueLengthInRange(r, 0),
      text: c,
      eolCount: h,
      firstLineLength: u,
      lastLineLength: d,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(yl._sortOpsDescending);
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], r = n.range.startLineNumber, o = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
      if (r === a && o === l && n.text.length === 0)
        continue;
      n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, !0)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
      const c = new N(r, o, a, l);
      t.push({
        range: c,
        rangeLength: n.rangeLength,
        text: n.text,
        rangeOffset: n.rangeOffset,
        forceMoveMarkers: n.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, n);
  }
  static _getInverseEditRanges(e) {
    const t = [];
    let i = 0, n = 0, r = null;
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o];
      let c, h;
      r ? r.range.endLineNumber === l.range.startLineNumber ? (c = i, h = n + (l.range.startColumn - r.range.endColumn)) : (c = i + (l.range.startLineNumber - r.range.endLineNumber), h = l.range.startColumn) : (c = l.range.startLineNumber, h = l.range.startColumn);
      let u;
      if (l.text.length > 0) {
        const d = l.eolCount + 1;
        d === 1 ? u = new N(c, h, c, h + l.firstLineLength) : u = new N(c, h, c + d - 1, l.lastLineLength + 1);
      } else
        u = new N(c, h, c, h);
      i = u.endLineNumber, n = u.endColumn, t.push(u), r = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    const i = N.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    const i = N.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class M8 {
  constructor(e, t, i, n, r, o, a, l, c) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = r, this._containsRTL = o, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = c;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e), i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let r = 0, o = i.length; r < o; r++) {
        const a = i[r].buffer.replace(/\r\n|\r|\n/g, t), l = Ps(a);
        i[r] = new Io(a, l);
      }
    const n = new yl(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: n, disposable: n };
  }
}
class LE {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && Ib(e) && (this.BOM = TT, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = x8(this._tmpLineStarts, e);
    this.chunks.push(new Io(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, this.isBasicASCII && (this.isBasicASCII = t.isBasicASCII), !this.isBasicASCII && !this.containsRTL && (this.containsRTL = Th(e)), !this.isBasicASCII && !this.containsUnusualLineTerminators && (this.containsUnusualLineTerminators = a2(e));
  }
  finish(e = !0) {
    return this._finish(), new M8(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      const e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      const t = Ps(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class A8 {
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t;
  }
  get startLineNumber() {
    return this._startLineNumber;
  }
  get endLineNumber() {
    return this._startLineNumber + this._tokens.length - 1;
  }
  getLineTokens(e) {
    return this._tokens[e - this._startLineNumber];
  }
  appendLineTokens(e) {
    this._tokens.push(e);
  }
}
class Ep {
  constructor() {
    this._tokens = [];
  }
  add(e, t) {
    if (this._tokens.length > 0) {
      const i = this._tokens[this._tokens.length - 1];
      if (i.endLineNumber + 1 === e) {
        i.appendLineTokens(t);
        return;
      }
    }
    this._tokens.push(new A8(e, [t]));
  }
  finalize() {
    return this._tokens;
  }
}
class US {
  constructor(e) {
    this._default = e, this._store = [];
  }
  get(e) {
    return e < this._store.length ? this._store[e] : this._default;
  }
  set(e, t) {
    for (; e >= this._store.length; )
      this._store[this._store.length] = this._default;
    this._store[e] = t;
  }
  delete(e, t) {
    t === 0 || e >= this._store.length || this._store.splice(e, t);
  }
  insert(e, t) {
    if (t === 0 || e >= this._store.length)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = this._default;
    this._store = kg(this._store, e, i);
  }
}
class R8 {
  constructor(e, t) {
    this.tokenizationSupport = e, this.initialState = t, this._lineBeginState = new US(null), this._lineNeedsTokenization = new US(!0), this._firstLineNeedsTokenization = 0, this._lineBeginState.set(0, this.initialState);
  }
  get invalidLineStartIndex() {
    return this._firstLineNeedsTokenization;
  }
  markMustBeTokenized(e) {
    this._lineNeedsTokenization.set(e, !0), this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, e);
  }
  getBeginState(e) {
    return this._lineBeginState.get(e);
  }
  setEndState(e, t, i) {
    if (this._lineNeedsTokenization.set(t, !1), this._firstLineNeedsTokenization = t + 1, t === e - 1)
      return;
    const n = this._lineBeginState.get(t + 1);
    if (n === null || !i.equals(n)) {
      this._lineBeginState.set(t + 1, i), this.markMustBeTokenized(t + 1);
      return;
    }
    let r = t + 1;
    for (; r < e && !this._lineNeedsTokenization.get(r); )
      r++;
    this._firstLineNeedsTokenization = r;
  }
  applyEdits(e, t) {
    this.markMustBeTokenized(e.startLineNumber - 1), this._lineBeginState.delete(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineNeedsTokenization.delete(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineBeginState.insert(e.startLineNumber, t), this._lineNeedsTokenization.insert(e.startLineNumber, t);
  }
}
class P8 extends z {
  constructor(e, t, i) {
    super(), this._textModel = e, this._tokenizationPart = t, this._languageIdCodec = i, this._isScheduled = !1, this._isDisposed = !1, this._tokenizationStateStore = null, this._register(at.onDidChange((n) => {
      const r = this._textModel.getLanguageId();
      n.changedLanguages.indexOf(r) !== -1 && (this._resetTokenizationState(), this._tokenizationPart.clearTokens());
    })), this._resetTokenizationState();
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  handleDidChangeContent(e) {
    if (e.isFlush) {
      this._resetTokenizationState();
      return;
    }
    if (this._tokenizationStateStore)
      for (let t = 0, i = e.changes.length; t < i; t++) {
        const n = e.changes[t], [r] = Gl(n.text);
        this._tokenizationStateStore.applyEdits(n.range, r);
      }
    this._beginBackgroundTokenization();
  }
  handleDidChangeAttached() {
    this._beginBackgroundTokenization();
  }
  handleDidChangeLanguage(e) {
    this._resetTokenizationState(), this._tokenizationPart.clearTokens();
  }
  _resetTokenizationState() {
    const [e, t] = O8(this._textModel, this._tokenizationPart);
    e && t ? this._tokenizationStateStore = new R8(e, t) : this._tokenizationStateStore = null, this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = !0, vf((e) => {
      this._isScheduled = !1, this._backgroundTokenizeWithDeadline(e);
    }));
  }
  _backgroundTokenizeWithDeadline(e) {
    const t = Date.now() + e.timeRemaining(), i = () => {
      this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? Nk(i) : this._beginBackgroundTokenization());
    };
    i();
  }
  _backgroundTokenizeForAtLeast1ms() {
    const e = this._textModel.getLineCount(), t = new Ep(), i = aa.create(!1);
    do
      if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e)
        break;
    while (this._hasLinesToTokenize());
    this._tokenizationPart.setTokens(t.finalize(), this._isTokenizationComplete());
  }
  tokenizeViewport(e, t) {
    const i = new Ep();
    this._tokenizeViewport(i, e, t), this._tokenizationPart.setTokens(i.finalize(), this._isTokenizationComplete());
  }
  reset() {
    this._resetTokenizationState(), this._tokenizationPart.clearTokens();
  }
  forceTokenization(e) {
    const t = new Ep();
    this._updateTokensUntilLine(t, e), this._tokenizationPart.setTokens(t.finalize(), this._isTokenizationComplete());
  }
  getTokenTypeIfInsertingCharacter(e, t) {
    if (!this._tokenizationStateStore)
      return 0;
    this.forceTokenization(e.lineNumber);
    const i = this._tokenizationStateStore.getBeginState(e.lineNumber - 1);
    if (!i)
      return 0;
    const n = this._textModel.getLanguageId(), r = this._textModel.getLineContent(e.lineNumber), o = r.substring(0, e.column - 1) + t + r.substring(e.column - 1), a = Fc(this._languageIdCodec, n, this._tokenizationStateStore.tokenizationSupport, o, !0, i), l = new Pt(a.tokens, o, this._languageIdCodec);
    if (l.getCount() === 0)
      return 0;
    const c = l.findTokenIndexAtOffset(e.column - 1);
    return l.getStandardTokenType(c);
  }
  tokenizeLineWithEdit(e, t, i) {
    const n = e.lineNumber, r = e.column;
    if (!this._tokenizationStateStore)
      return null;
    this.forceTokenization(n);
    const o = this._tokenizationStateStore.getBeginState(n - 1);
    if (!o)
      return null;
    const a = this._textModel.getLineContent(n), l = a.substring(0, r - 1) + i + a.substring(r - 1 + t), c = this._textModel.getLanguageIdAtPosition(n, 0), h = Fc(this._languageIdCodec, c, this._tokenizationStateStore.tokenizationSupport, l, !0, o);
    return new Pt(h.tokens, l, this._languageIdCodec);
  }
  isCheapToTokenize(e) {
    if (!this._tokenizationStateStore)
      return !0;
    const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
    return e > t ? !1 : e < t || this._textModel.getLineLength(e) < 2048;
  }
  _hasLinesToTokenize() {
    return this._tokenizationStateStore ? this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount() : !1;
  }
  _isTokenizationComplete() {
    return this._tokenizationStateStore ? this._tokenizationStateStore.invalidLineStartIndex >= this._textModel.getLineCount() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    if (!this._tokenizationStateStore || !this._hasLinesToTokenize())
      return this._textModel.getLineCount() + 1;
    const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
    return this._updateTokensUntilLine(e, t), t;
  }
  _updateTokensUntilLine(e, t) {
    if (!this._tokenizationStateStore)
      return;
    const i = this._textModel.getLanguageId(), n = this._textModel.getLineCount(), r = t - 1;
    for (let o = this._tokenizationStateStore.invalidLineStartIndex; o <= r; o++) {
      const a = this._textModel.getLineContent(o + 1), l = this._tokenizationStateStore.getBeginState(o), c = Fc(this._languageIdCodec, i, this._tokenizationStateStore.tokenizationSupport, a, !0, l);
      e.add(o + 1, c.tokens), this._tokenizationStateStore.setEndState(n, o, c.endState), o = this._tokenizationStateStore.invalidLineStartIndex - 1;
    }
  }
  _tokenizeViewport(e, t, i) {
    if (!this._tokenizationStateStore || i <= this._tokenizationStateStore.invalidLineStartIndex)
      return;
    if (t <= this._tokenizationStateStore.invalidLineStartIndex) {
      this._updateTokensUntilLine(e, i);
      return;
    }
    let n = this._textModel.getLineFirstNonWhitespaceColumn(t);
    const r = [];
    let o = null;
    for (let c = t - 1; n > 1 && c >= 1; c--) {
      const h = this._textModel.getLineFirstNonWhitespaceColumn(c);
      if (h !== 0 && h < n && (r.push(this._textModel.getLineContent(c)), n = h, o = this._tokenizationStateStore.getBeginState(c - 1), o))
        break;
    }
    o || (o = this._tokenizationStateStore.initialState);
    const a = this._textModel.getLanguageId();
    let l = o;
    for (let c = r.length - 1; c >= 0; c--)
      l = Fc(this._languageIdCodec, a, this._tokenizationStateStore.tokenizationSupport, r[c], !1, l).endState;
    for (let c = t; c <= i; c++) {
      const h = this._textModel.getLineContent(c), u = Fc(this._languageIdCodec, a, this._tokenizationStateStore.tokenizationSupport, h, !0, l);
      e.add(c, u.tokens), this._tokenizationStateStore.markMustBeTokenized(c - 1), l = u.endState;
    }
  }
}
function O8(s, e) {
  if (s.isTooLargeForTokenization())
    return [null, null];
  const t = at.get(e.getLanguageId());
  if (!t)
    return [null, null];
  let i;
  try {
    i = t.getInitialState();
  } catch (n) {
    return ct(n), [null, null];
  }
  return [t, i];
}
function Fc(s, e, t, i, n, r) {
  let o = null;
  if (t)
    try {
      o = t.tokenizeEncoded(i, n, r.clone());
    } catch (a) {
      ct(a);
    }
  return o || (o = x2(s.encodeLanguageId(e), r)), Pt.convertToEndOffset(o.tokens, i.length), o;
}
const Os = new Uint32Array(0).buffer;
class Zn {
  static deleteBeginning(e, t) {
    return e === null || e === Os ? e : Zn.delete(e, 0, t);
  }
  static deleteEnding(e, t) {
    if (e === null || e === Os)
      return e;
    const i = js(e), n = i[i.length - 2];
    return Zn.delete(e, t, n);
  }
  static delete(e, t, i) {
    if (e === null || e === Os || t === i)
      return e;
    const n = js(e), r = n.length >>> 1;
    if (t === 0 && n[n.length - 2] === i)
      return Os;
    const o = Pt.findIndexInTokensArray(n, t), a = o > 0 ? n[o - 1 << 1] : 0, l = n[o << 1];
    if (i < l) {
      const f = i - t;
      for (let m = o; m < r; m++)
        n[m << 1] -= f;
      return e;
    }
    let c, h;
    a !== t ? (n[o << 1] = t, c = o + 1 << 1, h = t) : (c = o << 1, h = a);
    const u = i - t;
    for (let f = o + 1; f < r; f++) {
      const m = n[f << 1] - u;
      m > h && (n[c++] = m, n[c++] = n[(f << 1) + 1], h = m);
    }
    if (c === n.length)
      return e;
    const d = new Uint32Array(c);
    return d.set(n.subarray(0, c), 0), d.buffer;
  }
  static append(e, t) {
    if (t === Os)
      return e;
    if (e === Os)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = js(e), n = js(t), r = n.length >>> 1, o = new Uint32Array(i.length + n.length);
    o.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let c = 0; c < r; c++)
      o[a++] = n[c << 1] + l, o[a++] = n[(c << 1) + 1];
    return o.buffer;
  }
  static insert(e, t, i) {
    if (e === null || e === Os)
      return e;
    const n = js(e), r = n.length >>> 1;
    let o = Pt.findIndexInTokensArray(n, t);
    o > 0 && n[o - 1 << 1] === t && o--;
    for (let a = o; a < r; a++)
      n[a << 1] += i;
    return e;
  }
}
function js(s) {
  return s instanceof Uint32Array ? s : new Uint32Array(s);
}
class Kf {
  constructor(e) {
    this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  getTokens(e, t, i) {
    let n = null;
    if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== Os)
      return new Pt(js(n), i, this._languageIdCodec);
    const r = new Uint32Array(2);
    return r[0] = i.length, r[1] = $S(this._languageIdCodec.encodeLanguageId(e)), new Pt(r, i, this._languageIdCodec);
  }
  static _massageTokens(e, t, i) {
    const n = i ? js(i) : null;
    if (t === 0) {
      let r = !1;
      if (n && n.length > 1 && (r = ki.getLanguageId(n[1]) !== e), !r)
        return Os;
    }
    if (!n || n.length === 0) {
      const r = new Uint32Array(2);
      return r[0] = t, r[1] = $S(e), r.buffer;
    }
    return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = null;
    this._lineTokens = kg(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, n, r) {
    const o = Kf._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = o, r ? !Kf._equals(a, o) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = js(e), n = js(t);
    if (i.length !== n.length)
      return !1;
    for (let r = 0, o = i.length; r < o; r++)
      if (i[r] !== n[r])
        return !1;
    return !0;
  }
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new O(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = Zn.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = Zn.deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let n = null;
    i < this._len && (n = Zn.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = Zn.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const n = e.lineNumber - 1;
    if (!(n >= this._len)) {
      if (t === 0) {
        this._lineTokens[n] = Zn.insert(this._lineTokens[n], e.column - 1, i);
        return;
      }
      this._lineTokens[n] = Zn.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = Zn.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
}
function $S(s) {
  return (s << 0 | 0 << 8 | 0 << 11 | 1 << 15 | 2 << 24 | 1024) >>> 0;
}
class bC {
  constructor(e) {
    this._pieces = [], this._isComplete = !1, this._languageIdCodec = e;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const r = t[0].getRange(), o = t[t.length - 1].getRange();
      if (!r || !o)
        return e;
      i = e.plusRange(r).plusRange(o);
    }
    let n = null;
    for (let r = 0, o = this._pieces.length; r < o; r++) {
      const a = this._pieces[r];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: r };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(r, 1), r--, o--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: r };
        continue;
      }
      const [l, c] = a.split(i);
      if (l.isEmpty()) {
        n = n || { index: r };
        continue;
      }
      c.isEmpty() || (this._pieces.splice(r, 1, l, c), r++, o++, n = n || { index: r });
    }
    return n = n || { index: this._pieces.length }, t.length > 0 && (this._pieces = kg(this._pieces, n.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSparseTokens(e, t) {
    if (t.getLineContent().length === 0)
      return t;
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const n = bC._findFirstPieceWithLine(i, e), r = i[n].getLineTokens(e);
    if (!r)
      return t;
    const o = t.getCount(), a = r.getCount();
    let l = 0;
    const c = [];
    let h = 0, u = 0;
    const d = (f, m) => {
      f !== u && (u = f, c[h++] = f, c[h++] = m);
    };
    for (let f = 0; f < a; f++) {
      const m = r.getStartCharacter(f), _ = r.getEndCharacter(f), b = r.getMetadata(f), v = ((b & 1 ? 2048 : 0) | (b & 2 ? 4096 : 0) | (b & 4 ? 8192 : 0) | (b & 8 ? 16384 : 0) | (b & 16 ? 16744448 : 0) | (b & 32 ? 4278190080 : 0)) >>> 0, C = ~v >>> 0;
      for (; l < o && t.getEndOffset(l) <= m; )
        d(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < o && t.getStartOffset(l) < m && d(m, t.getMetadata(l)); l < o && t.getEndOffset(l) < _; )
        d(t.getEndOffset(l), t.getMetadata(l) & C | b & v), l++;
      if (l < o)
        d(_, t.getMetadata(l) & C | b & v), t.getEndOffset(l) === _ && l++;
      else {
        const w = Math.min(Math.max(0, l - 1), o - 1);
        d(_, t.getMetadata(w) & C | b & v);
      }
    }
    for (; l < o; )
      d(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new Pt(new Uint32Array(c), t.getLineContent(), this._languageIdCodec);
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, n = e.length - 1;
    for (; i < n; ) {
      let r = i + Math.floor((n - i) / 2);
      if (e[r].endLineNumber < t)
        i = r + 1;
      else if (e[r].startLineNumber > t)
        n = r - 1;
      else {
        for (; r > i && e[r - 1].startLineNumber <= t && t <= e[r - 1].endLineNumber; )
          r--;
        return r;
      }
    }
    return i;
  }
  acceptEdit(e, t, i, n, r) {
    for (const o of this._pieces)
      o.acceptEdit(e, t, i, n, r);
  }
}
class qf extends lE {
  constructor(e, t, i, n, r) {
    super(), this._languageService = e, this._languageConfigurationService = t, this._textModel = i, this.bracketPairsTextModelPart = n, this._languageId = r, this._onDidChangeLanguage = this._register(new A()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new A()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new A()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._backgroundTokenizationState = 0, this._onBackgroundTokenizationStateChanged = this._register(new A()), this._tokens = new Kf(this._languageService.languageIdCodec), this._semanticTokens = new bC(this._languageService.languageIdCodec), this._tokenization = new P8(i, this, this._languageService.languageIdCodec), this._languageRegistryListener = this._languageConfigurationService.onDidChange((o) => {
      o.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
    });
  }
  acceptEdit(e, t, i, n, r) {
    this._tokens.acceptEdit(e, i, n), this._semanticTokens.acceptEdit(e, i, n, r, t.length > 0 ? t.charCodeAt(0) : 0);
  }
  handleDidChangeAttached() {
    this._tokenization.handleDidChangeAttached();
  }
  flush() {
    this._tokens.flush(), this._semanticTokens.flush();
  }
  handleDidChangeContent(e) {
    this._tokenization.handleDidChangeContent(e);
  }
  dispose() {
    this._languageRegistryListener.dispose(), this._tokenization.dispose(), super.dispose();
  }
  get backgroundTokenizationState() {
    return this._backgroundTokenizationState;
  }
  handleTokenizationProgress(e) {
    if (this._backgroundTokenizationState === 2)
      return;
    const t = e ? 2 : 1;
    this._backgroundTokenizationState !== t && (this._backgroundTokenizationState = t, this.bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState(), this._onBackgroundTokenizationStateChanged.fire());
  }
  setTokens(e, t = !1) {
    if (e.length !== 0) {
      const i = [];
      for (let n = 0, r = e.length; n < r; n++) {
        const o = e[n];
        let a = 0, l = 0, c = !1;
        for (let h = o.startLineNumber; h <= o.endLineNumber; h++)
          c ? (this._tokens.setTokens(this._languageId, h - 1, this._textModel.getLineLength(h), o.getLineTokens(h), !1), l = h) : this._tokens.setTokens(this._languageId, h - 1, this._textModel.getLineLength(h), o.getLineTokens(h), !0) && (c = !0, a = h, l = h);
        c && i.push({
          fromLineNumber: a,
          toLineNumber: l
        });
      }
      i.length > 0 && this._emitModelTokensChangedEvent({
        tokenizationSupportChanged: !1,
        semanticTokensApplied: !1,
        ranges: i
      });
    }
    this.handleTokenizationProgress(t);
  }
  setSemanticTokens(e, t) {
    this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._semanticTokens.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._semanticTokens.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._textModel.validateRange(this._semanticTokens.setPartial(e, t));
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: !0,
      ranges: [
        {
          fromLineNumber: i.startLineNumber,
          toLineNumber: i.endLineNumber
        }
      ]
    });
  }
  tokenizeViewport(e, t) {
    e = Math.max(1, e), t = Math.min(this._textModel.getLineCount(), t), this._tokenization.tokenizeViewport(e, t);
  }
  clearTokens() {
    this._tokens.flush(), this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !0,
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    });
  }
  _emitModelTokensChangedEvent(e) {
    this._textModel._isDisposing() || (this.bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
  }
  resetTokenization() {
    this._tokenization.reset();
  }
  forceTokenization(e) {
    if (e < 1 || e > this._textModel.getLineCount())
      throw new Error("Illegal value for lineNumber");
    this._tokenization.forceTokenization(e);
  }
  isCheapToTokenize(e) {
    return this._tokenization.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
  getLineTokens(e) {
    if (e < 1 || e > this._textModel.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._getLineTokens(e);
  }
  _getLineTokens(e) {
    const t = this._textModel.getLineContent(e), i = this._tokens.getTokens(this._languageId, e - 1, t);
    return this._semanticTokens.addSparseTokens(e, i);
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    const n = this._textModel.validatePosition(new O(e, t));
    return this._tokenization.getTokenTypeIfInsertingCharacter(n, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    const n = this._textModel.validatePosition(e);
    return this._tokenization.tokenizeLineWithEdit(n, t, i);
  }
  getLanguageConfiguration(e) {
    return this._languageConfigurationService.getLanguageConfiguration(e);
  }
  getWordAtPosition(e) {
    this.assertNotDisposed();
    const t = this._textModel.validatePosition(e), i = this._textModel.getLineContent(t.lineNumber), n = this._getLineTokens(t.lineNumber), r = n.findTokenIndexAtOffset(t.column - 1), [o, a] = qf._findLanguageBoundaries(n, r), l = xh(t.column, this.getLanguageConfiguration(n.getLanguageId(r)).getWordDefinition(), i.substring(o, a), o);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (r > 0 && o === t.column - 1) {
      const [c, h] = qf._findLanguageBoundaries(n, r - 1), u = xh(t.column, this.getLanguageConfiguration(n.getLanguageId(r - 1)).getWordDefinition(), i.substring(c, h), c);
      if (u && u.startColumn <= e.column && e.column <= u.endColumn)
        return u;
    }
    return null;
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let n = 0;
    for (let o = t; o >= 0 && e.getLanguageId(o) === i; o--)
      n = e.getStartOffset(o);
    let r = e.getLineContent().length;
    for (let o = t, a = e.getCount(); o < a && e.getLanguageId(o) === i; o++)
      r = e.getEndOffset(o);
    return [n, r];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : {
      word: "",
      startColumn: e.column,
      endColumn: e.column
    };
  }
  getLanguageId() {
    return this._languageId;
  }
  getLanguageIdAtPosition(e, t) {
    const i = this._textModel.validatePosition(new O(e, t)), n = this.getLineTokens(i.lineNumber);
    return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
  }
  setLanguageId(e) {
    if (this._languageId === e)
      return;
    const t = {
      oldLanguage: this._languageId,
      newLanguage: e
    };
    this._languageId = e, this.bracketPairsTextModelPart.handleDidChangeLanguage(t), this._tokenization.handleDidChangeLanguage(t), this._onDidChangeLanguage.fire(t), this._onDidChangeLanguageConfiguration.fire({});
  }
}
const CC = Se("undoRedoService");
class kE {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
class Zl {
  constructor() {
    this.id = Zl._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
Zl._ID = 0;
Zl.None = new Zl();
class es {
  constructor() {
    this.id = es._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
es._ID = 0;
es.None = new es();
var F8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, xp = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function B8(s) {
  const e = new LE();
  return e.acceptChunk(s), e.finish();
}
function V8(s) {
  const e = new LE();
  let t;
  for (; typeof (t = s.read()) == "string"; )
    e.acceptChunk(t);
  return e.finish();
}
function jS(s, e) {
  let t;
  return typeof s == "string" ? t = B8(s) : ZT(s) ? t = V8(s) : t = s, t.create(e);
}
let vd = 0;
const W8 = 999, H8 = 1e4;
class z8 {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    const e = [];
    let t = 0, i = 0;
    do {
      const n = this._source.read();
      if (n === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const Bc = () => {
  throw new Error("Invalid change accessor");
};
let ta = class Xc extends z {
  constructor(e, t, i, n = null, r, o, a) {
    super(), this._undoRedoService = r, this._languageService = o, this._languageConfigurationService = a, this._onWillDispose = this._register(new A()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new K8((d) => this.handleBeforeFireDecorationsChangedEvent(d))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeOptions = this._register(new A()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new A()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new A()), this._eventEmitter = this._register(new q8()), this._deltaDecorationCallCnt = 0, vd++, this.id = "$model" + vd, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = Le.parse("inmemory://model/" + vd) : this._associatedResource = n, this._attachedEditorCount = 0;
    const { textBuffer: l, disposable: c } = jS(e, i.defaultEOL);
    this._buffer = l, this._bufferDisposable = c, this._options = Xc.resolveOptions(this._buffer, i), this._bracketPairs = this._register(new s8(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new x9(this, this._languageConfigurationService)), this._decorationProvider = this._register(new o8(this)), this._tokenizationTextModelPart = new qf(this._languageService, this._languageConfigurationService, this, this._bracketPairs, t);
    const h = this._buffer.getLineCount(), u = this._buffer.getValueLengthInRange(new N(1, 1, h, this._buffer.getLineLength(h) + 1), 0);
    i.largeFileOptimizations ? this._isTooLargeForTokenization = u > Xc.LARGE_FILE_SIZE_THRESHOLD || h > Xc.LARGE_FILE_LINE_COUNT_THRESHOLD : this._isTooLargeForTokenization = !1, this._isTooLargeForSyncing = u > Xc.MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this.__isDisposing = !1, this._instanceId = l2(vd), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new KS(), this._commandManager = new gC(this, this._undoRedoService), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._register(this._decorationProvider.onDidChange(() => {
      this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
    }));
  }
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = OS(e, t.tabSize, t.insertSpaces);
      return new $d({
        tabSize: i.tabSize,
        indentSize: i.tabSize,
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL,
        bracketPairColorizationOptions: t.bracketPairColorizationOptions
      });
    }
    return new $d({
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      insertSpaces: t.insertSpaces,
      trimAutoWhitespace: t.trimAutoWhitespace,
      defaultEOL: t.defaultEOL,
      bracketPairColorizationOptions: t.bracketPairColorizationOptions
    });
  }
  get onDidChangeLanguage() {
    return this._tokenizationTextModelPart.onDidChangeLanguage;
  }
  get onDidChangeLanguageConfiguration() {
    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
  }
  get onDidChangeTokens() {
    return this._tokenizationTextModelPart.onDidChangeTokens;
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContentOrInjectedText(e) {
    return zr(this._eventEmitter.fastEvent((t) => e(t)), this._onDidChangeInjectedText.event((t) => e(t)));
  }
  _isDisposing() {
    return this.__isDisposing;
  }
  get tokenization() {
    return this._tokenizationTextModelPart;
  }
  get bracketPairs() {
    return this._bracketPairs;
  }
  get guides() {
    return this._guidesTextModelPart;
  }
  dispose() {
    this.__isDisposing = !0, this._onWillDispose.fire(), this._tokenizationTextModelPart.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this.__isDisposing = !1;
    const e = new yl([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e, this._bufferDisposable = z.None;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(t), this._bracketPairs.handleDidChangeContent(t), this._eventEmitter.fire(new Go(e, t)));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e === null)
      return;
    const { textBuffer: t, disposable: i } = jS(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, n, r, o, a) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: n
      }],
      eol: this._buffer.getEOL(),
      versionId: this.getVersionId(),
      isUndoing: r,
      isRedoing: o,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), r = this.getLineCount(), o = this.getLineMaxColumn(r);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._tokenizationTextModelPart.flush(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new KS(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new wl([
      new rP()
    ], this._versionId, !1, !1), this._createContentChanged2(new N(1, 1, r, o), 0, n, this.getValue(), !1, !1, !0));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), r = this.getLineCount(), o = this.getLineMaxColumn(r);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new wl([
      new lP()
    ], this._versionId, !1, !1), this._createContentChanged2(new N(1, 1, r, o), 0, n, this.getValue(), !1, !1, !1));
  }
  _onBeforeEOLChange() {
    this._decorationsTree.ensureAllNodesHaveRanges(this);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i], o = r.range, a = r.cachedAbsoluteStart - r.start, l = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), c = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
      r.cachedAbsoluteStart = l, r.cachedAbsoluteEnd = c, r.cachedVersionId = e, r.start = l - a, r.end = c - a, no(r);
    }
  }
  onBeforeAttached() {
    this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0));
  }
  onBeforeDetached() {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0));
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let n = 1; n <= i; n++) {
      const r = this._buffer.getLineLength(n);
      r >= H8 ? t += r : e += r;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.indentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, r = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, o = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new $d({
      tabSize: t,
      indentSize: i,
      insertSpaces: n,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: r,
      bracketPairColorizationOptions: o
    });
    if (this._options.equals(a))
      return;
    const l = this._options.createChangeEvent(a);
    this._options = a, this._bracketPairs.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    const i = OS(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
    });
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), eE(e, this._options.indentSize, this._options.insertSpaces);
  }
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(o2.source, !1, !0, !1, null, !1, 1073741824);
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    const t = this._validatePosition(e.lineNumber, e.column, 0);
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    const t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + n : n;
  }
  createSnapshot(e = !1) {
    return new z8(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + n : n;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    return this._assertNotDisposed(), this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
    let r = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), o = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
    if (r < 1)
      r = 1, o = 1;
    else if (r > t)
      r = t, o = this.getLineMaxColumn(r);
    else if (o <= 1)
      o = 1;
    else {
      const u = this.getLineMaxColumn(r);
      o >= u && (o = u);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let c = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), h = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (c < 1)
      c = 1, h = 1;
    else if (c > t)
      c = t, h = this.getLineMaxColumn(c);
    else if (h <= 1)
      h = 1;
    else {
      const u = this.getLineMaxColumn(c);
      h >= u && (h = u);
    }
    return i === r && n === o && a === c && l === h && e instanceof N && !(e instanceof Ce) ? e : new N(r, o, c, h);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const n = this._buffer.getLineCount();
    if (e > n)
      return !1;
    if (t === 1)
      return !0;
    const r = this.getLineMaxColumn(e);
    if (t > r)
      return !1;
    if (i === 1) {
      const o = this._buffer.getLineCharCode(e, t - 2);
      if (Lt(o))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), r = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), o = this._buffer.getLineCount();
    if (n < 1)
      return new O(1, 1);
    if (n > o)
      return new O(o, this.getLineMaxColumn(o));
    if (r <= 1)
      return new O(n, 1);
    const a = this.getLineMaxColumn(n);
    if (r >= a)
      return new O(n, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(n, r - 2);
      if (Lt(l))
        return new O(n, r - 1);
    }
    return new O(n, r);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof O && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, n = e.startColumn, r = e.endLineNumber, o = e.endColumn;
    if (!this._isValidPosition(i, n, 0) || !this._isValidPosition(r, o, 0))
      return !1;
    if (t === 1) {
      const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = o > 1 && o <= this._buffer.getLineLength(r) ? this._buffer.getLineCharCode(r, o - 2) : 0, c = Lt(a), h = Lt(l);
      return !c && !h;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof N && !(e instanceof Ce) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(e.startLineNumber, e.startColumn, 0), n = this._validatePosition(e.endLineNumber, e.endColumn, 0), r = i.lineNumber, o = i.column, a = n.lineNumber, l = n.column;
    {
      const c = o > 1 ? this._buffer.getLineCharCode(r, o - 2) : 0, h = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, u = Lt(c), d = Lt(h);
      return !u && !d ? new N(r, o, a, l) : r === a && o === l ? new N(r, o - 1, a, l - 1) : u && d ? new N(r, o - 1, a, l + 1) : u ? new N(r, o - 1, a, l) : new N(r, o, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    const i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new N(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._buffer.findMatchesLineByLine(e, t, i, n);
  }
  findMatches(e, t, i, n, r, o, a = W8) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((u) => N.isIRange(u)) && (l = t.map((u) => this.validateRange(u)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((u, d) => u.startLineNumber - d.startLineNumber || u.startColumn - d.startColumn);
    const c = [];
    c.push(l.reduce((u, d) => N.areIntersecting(u, d) ? u.plusRange(d) : (c.push(u), d)));
    let h;
    if (!i && e.indexOf(`
`) < 0) {
      const d = new Ia(e, i, n, r).parseSearchRequest();
      if (!d)
        return [];
      h = (f) => this.findMatchesLineByLine(f, d, o, a);
    } else
      h = (u) => Ju.findMatches(this, new Ia(e, i, n, r), u, o, a);
    return c.map(h).reduce((u, d) => u.concat(d), []);
  }
  findNextMatch(e, t, i, n, r, o) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const c = new Ia(e, i, n, r).parseSearchRequest();
      if (!c)
        return null;
      const h = this.getLineCount();
      let u = new N(a.lineNumber, a.column, h, this.getLineMaxColumn(h)), d = this.findMatchesLineByLine(u, c, o, 1);
      return Ju.findNextMatch(this, new Ia(e, i, n, r), a, o), d.length > 0 || (u = new N(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), d = this.findMatchesLineByLine(u, c, o, 1), d.length > 0) ? d[0] : null;
    }
    return Ju.findNextMatch(this, new Ia(e, i, n, r), a, o);
  }
  findPreviousMatch(e, t, i, n, r, o) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return Ju.findPreviousMatch(this, new Ia(e, i, n, r), a, o);
  }
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof Um ? e : new Um(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      const n = t.map((o) => ({
        range: this.validateRange(o.range),
        text: o.text
      }));
      let r = !0;
      if (e)
        for (let o = 0, a = e.length; o < a; o++) {
          const l = e[o];
          let c = !1;
          for (let h = 0, u = n.length; h < u; h++) {
            const d = n[h].range, f = d.startLineNumber > l.endLineNumber, m = l.startLineNumber > d.endLineNumber;
            if (!f && !m) {
              c = !0;
              break;
            }
          }
          if (!c) {
            r = !1;
            break;
          }
        }
      if (r)
        for (let o = 0, a = this._trimAutoWhitespaceLines.length; o < a; o++) {
          const l = this._trimAutoWhitespaceLines[o], c = this.getLineMaxColumn(l);
          let h = !0;
          for (let u = 0, d = n.length; u < d; u++) {
            const f = n[u].range, m = n[u].text;
            if (!(l < f.startLineNumber || l > f.endLineNumber) && !(l === f.startLineNumber && f.startColumn === c && f.isEmpty() && m && m.length > 0 && m.charAt(0) === `
`) && !(l === f.startLineNumber && f.startColumn === 1 && f.isEmpty() && m && m.length > 0 && m.charAt(m.length - 1) === `
`)) {
              h = !1;
              break;
            }
          }
          if (h) {
            const u = new N(l, 1, l, c);
            t.push(new Um(null, u, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i);
  }
  _applyUndo(e, t, i, n) {
    const r = e.map((o) => {
      const a = this.getPositionAt(o.newPosition), l = this.getPositionAt(o.newEnd);
      return {
        range: new N(a.lineNumber, a.column, l.lineNumber, l.column),
        text: o.oldText
      };
    });
    this._applyUndoRedoEdits(r, t, !0, !1, i, n);
  }
  _applyRedo(e, t, i, n) {
    const r = e.map((o) => {
      const a = this.getPositionAt(o.oldPosition), l = this.getPositionAt(o.oldEnd);
      return {
        range: new N(a.lineNumber, a.column, l.lineNumber, l.column),
        text: o.newText
      };
    });
    this._applyUndoRedoEdits(r, t, !1, !0, i, n);
  }
  _applyUndoRedoEdits(e, t, i, n, r, o) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(r);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(o), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), r = this._buffer.getLineCount(), o = n.changes;
    if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, o.length !== 0) {
      for (let c = 0, h = o.length; c < h; c++) {
        const u = o[c], [d, f, m] = Gl(u.text);
        this._tokenizationTextModelPart.acceptEdit(u.range, u.text, d, f, m), this._decorationsTree.acceptReplace(u.rangeOffset, u.rangeLength, u.text.length, u.forceMoveMarkers);
      }
      const a = [];
      this._increaseVersionId();
      let l = i;
      for (let c = 0, h = o.length; c < h; c++) {
        const u = o[c], [d] = Gl(u.text);
        this._onDidChangeDecorations.fire();
        const f = u.range.startLineNumber, m = u.range.endLineNumber, _ = m - f, b = d, v = Math.min(_, b), C = b - _, w = r - l - C + f, L = w, E = w + b, k = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new O(L, 1)), this.getOffsetAt(new O(E, this.getLineMaxColumn(E))), 0), y = Wn.fromDecorations(k), S = new Ih(y);
        for (let D = v; D >= 0; D--) {
          const T = f + D, M = w + D;
          S.takeFromEndWhile((V) => V.lineNumber > M);
          const P = S.takeFromEndWhile((V) => V.lineNumber === M);
          a.push(new ES(T, this.getLineContent(M), P));
        }
        if (v < _) {
          const D = f + v;
          a.push(new oP(D + 1, m));
        }
        if (v < b) {
          const D = new Ih(y), T = f + v, M = b - v, P = r - l - M + T + 1, V = [], U = [];
          for (let K = 0; K < M; K++) {
            const J = P + K;
            U[K] = this.getLineContent(J), D.takeWhile((ee) => ee.lineNumber < J), V[K] = D.takeWhile((ee) => ee.lineNumber === J);
          }
          a.push(new aP(T + 1, f + b, U, V));
        }
        l += C;
      }
      this._emitContentChangedEvent(new wl(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: o,
        eol: this._buffer.getEOL(),
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return n.reverseEdits === null ? void 0 : n.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  handleBeforeFireDecorationsChangedEvent(e) {
    if (e === null || e.size === 0)
      return;
    const i = Array.from(e).map((n) => new ES(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
    this._onDidChangeInjectedText.fire(new hE(i));
  }
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    const i = {
      addDecoration: (r, o) => this._deltaDecorationsImpl(e, [], [{ range: r, options: o }])[0],
      changeDecoration: (r, o) => {
        this._changeDecorationImpl(r, o);
      },
      changeDecorationOptions: (r, o) => {
        this._changeDecorationOptionsImpl(r, GS(o));
      },
      removeDecoration: (r) => {
        this._deltaDecorationsImpl(e, [r], []);
      },
      deltaDecorations: (r, o) => r.length === 0 && o.length === 0 ? [] : this._deltaDecorationsImpl(e, r, o)
    };
    let n = null;
    try {
      n = t(i);
    } catch (r) {
      ct(r);
    }
    return i.addDecoration = Bc, i.changeDecoration = Bc, i.changeDecorationOptions = Bc, i.removeDecoration = Bc, i.deltaDecorations = Bc, n;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), ct(new Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const n = e ? this._decorations[e] : null;
    if (!n)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: qS[i] }])[0] : null;
    if (!t)
      return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
    const r = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), a = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
    return this._decorationsTree.delete(n), n.reset(this.getVersionId(), o, a, r), n.setOptions(qS[i]), this._decorationsTree.insert(n), n.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      this._decorationsTree.delete(r), delete this._decorations[r.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    return t ? this._decorationsTree.getNodeRange(this, t) : null;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, n = !1) {
    const r = this.getLineCount(), o = Math.min(r, Math.max(1, e)), a = Math.min(r, Math.max(1, t)), l = this.getLineMaxColumn(a), c = new N(o, 1, a, l), h = this._getDecorationsInRange(c, i, n);
    return Tv(h, this._decorationProvider.getDecorationsInRange(c, i, n)), h;
  }
  getDecorationsInRange(e, t = 0, i = !1) {
    const n = this.validateRange(e), r = this._getDecorationsInRange(n, t, i);
    return Tv(r, this._decorationProvider.getDecorationsInRange(n, t, i)), r;
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    return this._decorationsTree.getAll(this, e, t, !0);
  }
  getInjectedTextDecorations(e = 0) {
    return this._decorationsTree.getAllInjectedText(this, e);
  }
  _getInjectedTextInLine(e) {
    const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
    return Wn.fromDecorations(n).filter((r) => r.lineNumber === e);
  }
  getAllDecorations(e = 0, t = !1) {
    let i = this._decorationsTree.getAll(this, e, t, !1);
    return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
  }
  _getDecorationsInRange(e, t, i) {
    const n = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), r = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
    return this._decorationsTree.getAllInInterval(this, n, r, t, i);
  }
  getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    if (i.options.after) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
    }
    if (i.options.before) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
    }
    const n = this._validateRangeRelaxedNoAllocations(t), r = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), o = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), r, o, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), r = !!(t.overviewRuler && t.overviewRuler.color);
    if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
      const o = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(o.endLineNumber);
    }
    if (i.options.before || t.before) {
      const o = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(o.startLineNumber);
    }
    n !== r ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i) {
    const n = this.getVersionId(), r = t.length;
    let o = 0;
    const a = i.length;
    let l = 0;
    const c = new Array(a);
    for (; o < r || l < a; ) {
      let h = null;
      if (o < r) {
        do
          h = this._decorations[t[o++]];
        while (!h && o < r);
        if (h) {
          if (h.options.after) {
            const u = this._decorationsTree.getNodeRange(this, h);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.endLineNumber);
          }
          if (h.options.before) {
            const u = this._decorationsTree.getNodeRange(this, h);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.startLineNumber);
          }
          this._decorationsTree.delete(h), this._onDidChangeDecorations.checkAffectedAndFire(h.options);
        }
      }
      if (l < a) {
        if (!h) {
          const b = ++this._lastDecorationId, v = `${this._instanceId};${b}`;
          h = new vE(v, 0, 0), this._decorations[v] = h;
        }
        const u = i[l], d = this._validateRangeRelaxedNoAllocations(u.range), f = GS(u.options), m = this._buffer.getOffsetAt(d.startLineNumber, d.startColumn), _ = this._buffer.getOffsetAt(d.endLineNumber, d.endColumn);
        h.ownerId = e, h.reset(n, m, _, d), h.setOptions(f), h.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(d.endLineNumber), h.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(d.startLineNumber), this._onDidChangeDecorations.checkAffectedAndFire(f), this._decorationsTree.insert(h), c[l] = h.id, l++;
      } else
        h && delete this._decorations[h.id];
    }
    return c;
  }
  getLanguageId() {
    return this.tokenization.getLanguageId();
  }
  setMode(e) {
    this.tokenization.setLanguageId(e);
  }
  getLanguageIdAtPosition(e, t) {
    return this.tokenization.getLanguageIdAtPosition(e, t);
  }
  getWordAtPosition(e) {
    return this._tokenizationTextModelPart.getWordAtPosition(e);
  }
  getWordUntilPosition(e) {
    return this._tokenizationTextModelPart.getWordUntilPosition(e);
  }
  normalizePosition(e, t) {
    return e;
  }
  getLineIndentColumn(e) {
    return U8(this.getLineContent(e)) + 1;
  }
};
ta.MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
ta.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
ta.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
ta.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: zt.tabSize,
  indentSize: zt.indentSize,
  insertSpaces: zt.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: zt.trimAutoWhitespace,
  largeFileOptimizations: zt.largeFileOptimizations,
  bracketPairColorizationOptions: zt.bracketPairColorizationOptions
};
ta = F8([
  xp(4, CC),
  xp(5, Xt),
  xp(6, bs)
], ta);
function U8(s) {
  let e = 0;
  for (const t of s)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
function Ip(s) {
  return !!(s.options.overviewRuler && s.options.overviewRuler.color);
}
function Np(s) {
  return !!s.options.after || !!s.options.before;
}
class KS {
  constructor() {
    this._decorationsTree0 = new Lp(), this._decorationsTree1 = new Lp(), this._injectedTextDecorationsTree = new Lp();
  }
  ensureAllNodesHaveRanges(e) {
    this.getAll(e, 0, !1, !1);
  }
  _ensureNodesHaveRanges(e, t) {
    for (const i of t)
      i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
    return t;
  }
  getAllInInterval(e, t, i, n, r) {
    const o = e.getVersionId(), a = this._intervalSearch(t, i, n, r, o);
    return this._ensureNodesHaveRanges(e, a);
  }
  _intervalSearch(e, t, i, n, r) {
    const o = this._decorationsTree0.intervalSearch(e, t, i, n, r), a = this._decorationsTree1.intervalSearch(e, t, i, n, r), l = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, r);
    return o.concat(a).concat(l);
  }
  getInjectedTextInInterval(e, t, i, n) {
    const r = e.getVersionId(), o = this._injectedTextDecorationsTree.intervalSearch(t, i, n, !1, r);
    return this._ensureNodesHaveRanges(e, o).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
  }
  getAllInjectedText(e, t) {
    const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, !1, i);
    return this._ensureNodesHaveRanges(e, n).filter((r) => r.options.showIfCollapsed || !r.range.isEmpty());
  }
  getAll(e, t, i, n) {
    const r = e.getVersionId(), o = this._search(t, i, n, r);
    return this._ensureNodesHaveRanges(e, o);
  }
  _search(e, t, i, n) {
    if (i)
      return this._decorationsTree1.search(e, t, n);
    {
      const r = this._decorationsTree0.search(e, t, n), o = this._decorationsTree1.search(e, t, n), a = this._injectedTextDecorationsTree.search(e, t, n);
      return r.concat(o).concat(a);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
    return t.concat(i).concat(n);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
    return e.concat(t).concat(i);
  }
  insert(e) {
    Np(e) ? this._injectedTextDecorationsTree.insert(e) : Ip(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    Np(e) ? this._injectedTextDecorationsTree.delete(e) : Ip(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  getNodeRange(e, t) {
    const i = e.getVersionId();
    return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  _resolveNode(e, t) {
    Np(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : Ip(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, n) {
    this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
  }
}
function Is(s) {
  return s.replace(/[^a-z0-9\-_]/gi, " ");
}
class DE {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class $8 extends DE {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : _f.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    const i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class j8 extends DE {
  constructor(e) {
    super(e), this.position = e.position;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? R.fromHex(e) : t.getColor(e.id);
  }
}
class iu {
  constructor(e) {
    this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
  }
  static from(e) {
    return e instanceof iu ? e : new iu(e);
  }
}
class mt {
  constructor(e) {
    var t, i;
    this.description = e.description, this.blockClassName = e.blockClassName ? Is(e.blockClassName) : null, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? Is(e.className) : null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new $8(e.overviewRuler) : null, this.minimap = e.minimap ? new j8(e.minimap) : null, this.glyphMarginClassName = e.glyphMarginClassName ? Is(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? Is(e.linesDecorationsClassName) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? Is(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? Is(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? Is(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? Is(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? Is(e.afterContentClassName) : null, this.after = e.after ? iu.from(e.after) : null, this.before = e.before ? iu.from(e.before) : null, this.hideInCommentTokens = (t = e.hideInCommentTokens) !== null && t !== void 0 ? t : !1, this.hideInStringTokens = (i = e.hideInStringTokens) !== null && i !== void 0 ? i : !1;
  }
  static register(e) {
    return new mt(e);
  }
  static createDynamic(e) {
    return new mt(e);
  }
}
mt.EMPTY = mt.register({ description: "empty" });
const qS = [
  mt.register({ description: "tracked-range-always-grows-when-typing-at-edges", stickiness: 0 }),
  mt.register({ description: "tracked-range-never-grows-when-typing-at-edges", stickiness: 1 }),
  mt.register({ description: "tracked-range-grows-only-when-typing-before", stickiness: 2 }),
  mt.register({ description: "tracked-range-grows-only-when-typing-after", stickiness: 3 })
];
function GS(s) {
  return s instanceof mt ? s : mt.createDynamic(s);
}
class K8 extends z {
  constructor(e) {
    super(), this.handleBeforeFire = e, this._actual = this._register(new A()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    var e;
    if (this._deferredCnt--, this._deferredCnt === 0) {
      if (this._shouldFire) {
        this.handleBeforeFire(this._affectedInjectedTextLines);
        const t = {
          affectsMinimap: this._affectsMinimap,
          affectsOverviewRuler: this._affectsOverviewRuler
        };
        this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._actual.fire(t);
      }
      (e = this._affectedInjectedTextLines) === null || e === void 0 || e.clear(), this._affectedInjectedTextLines = null;
    }
  }
  recordLineAffectedByInjectedText(e) {
    this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
  }
  checkAffectedAndFire(e) {
    this._affectsMinimap || (this._affectsMinimap = !!(e.minimap && e.minimap.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!(e.overviewRuler && e.overviewRuler.color)), this._shouldFire = !0;
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._shouldFire = !0;
  }
}
class q8 extends z {
  constructor() {
    super(), this._fastEmitter = this._register(new A()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new A()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
globalThis && globalThis.__awaiter;
function G8(s, e, t, i, n, r, o) {
  let a = "<div>", l = i, c = 0, h = !0;
  for (let u = 0, d = e.getCount(); u < d; u++) {
    const f = e.getEndOffset(u);
    if (f <= i)
      continue;
    let m = "";
    for (; l < f && l < n; l++) {
      const _ = s.charCodeAt(l);
      switch (_) {
        case 9: {
          let b = r - (l + c) % r;
          for (c += b - 1; b > 0; )
            o && h ? (m += "&#160;", h = !1) : (m += " ", h = !0), b--;
          break;
        }
        case 60:
          m += "&lt;", h = !1;
          break;
        case 62:
          m += "&gt;", h = !1;
          break;
        case 38:
          m += "&amp;", h = !1;
          break;
        case 0:
          m += "&#00;", h = !1;
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          m += "\uFFFD", h = !1;
          break;
        case 13:
          m += "&#8203", h = !1;
          break;
        case 32:
          o && h ? (m += "&#160;", h = !1) : (m += " ", h = !0);
          break;
        default:
          m += String.fromCharCode(_), h = !1;
      }
    }
    if (a += `<span style="${e.getInlineStyle(u, t)}">${m}</span>`, f > n || l >= n)
      break;
  }
  return a += "</div>", a;
}
class Z8 {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, n = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
  }
}
class Y8 {
  constructor(e, t, i, n, r) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = r, this.prefixSum = 0;
  }
}
class nu {
  constructor(e, t, i, n) {
    this._instanceId = l2(++nu.INSTANCE_COUNT), this._pendingChanges = new Z8(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
  }
  static findInsertionIndex(e, t, i) {
    let n = 0, r = e.length;
    for (; n < r; ) {
      const o = n + r >>> 1;
      t === e[o].afterLineNumber ? i < e[o].ordinal ? r = o : n = o + 1 : t < e[o].afterLineNumber ? r = o : n = o + 1;
    }
    return n;
  }
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (n, r, o, a) => {
          t = !0, n = n | 0, r = r | 0, o = o | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new Y8(l, n, r, o, a)), l;
        },
        changeOneWhitespace: (n, r, o) => {
          t = !0, r = r | 0, o = o | 0, this._pendingChanges.change({ id: n, newAfterLineNumber: r, newHeight: o });
        },
        removeWhitespace: (n) => {
          t = !0, this._pendingChanges.remove({ id: n });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const c = this._findWhitespaceIndex(l.id);
        c !== -1 && this._removeWhitespace(c);
      }
      return;
    }
    const n = /* @__PURE__ */ new Set();
    for (const l of i)
      n.add(l.id);
    const r = /* @__PURE__ */ new Map();
    for (const l of t)
      r.set(l.id, l);
    const o = (l) => {
      const c = [];
      for (const h of l)
        if (!n.has(h.id)) {
          if (r.has(h.id)) {
            const u = r.get(h.id);
            h.afterLineNumber = u.newAfterLineNumber, h.height = u.newHeight;
          }
          c.push(h);
        }
      return c;
    }, a = o(this._arr).concat(o(e));
    a.sort((l, c) => l.afterLineNumber === c.afterLineNumber ? l.ordinal - c.ordinal : l.afterLineNumber - c.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = nu.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const n = this._findWhitespaceIndex(e);
    if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
      const r = this._arr[n];
      this._removeWhitespace(n), r.afterLineNumber = t, this._insertWhitespace(r);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const r = this._arr[i].afterLineNumber;
      e <= r && r <= t ? this._arr[i].afterLineNumber = e - 1 : r > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const r = this._arr[i].afterLineNumber;
      e <= r && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, n = t.length - 1;
    for (; i <= n; ) {
      const o = (n - i | 0) / 2 | 0, a = i + o | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        n = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  getVerticalOffsetForLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    let i;
    e > 1 ? i = this._lineHeight * (e - 1) : i = 0;
    const n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e - (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    const i = this._lineHeight * e, n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e + (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let n = 1, r = t;
    for (; n < r; ) {
      const o = (n + r) / 2 | 0, a = this.getVerticalOffsetForLineNumber(o) | 0;
      if (e >= a + i)
        n = o + 1;
      else {
        if (e >= a)
          return o;
        r = o;
      }
    }
    return n > t ? t : n;
  }
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, r = this.getVerticalOffsetForLineNumber(n) | 0;
    let o = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
    const l = this.getWhitespacesCount() | 0;
    let c, h;
    a === -1 ? (a = l, h = o + 1, c = 0) : (h = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
    let u = r, d = u;
    const f = 5e5;
    let m = 0;
    r >= f && (m = Math.floor(r / f) * f, m = Math.floor(m / i) * i, d -= m);
    const _ = [], b = e + (t - e) / 2;
    let v = -1;
    for (let E = n; E <= o; E++) {
      if (v === -1) {
        const k = u, y = u + i;
        (k <= b && b < y || k > b) && (v = E);
      }
      for (u += i, _[E - n] = d, d += i; h === E; )
        d += c, u += c, a++, a >= l ? h = o + 1 : (h = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
      if (u >= t) {
        o = E;
        break;
      }
    }
    v === -1 && (v = o);
    const C = this.getVerticalOffsetForLineNumber(o) | 0;
    let w = n, L = o;
    return w < L && r < e && w++, w < L && C + i > t && L--, {
      bigNumbersDelta: m,
      startLineNumber: n,
      endLineNumber: o,
      relativeVerticalOffset: _,
      centeredLineNumber: v,
      completelyVisibleStartLineNumber: w,
      completelyVisibleEndLineNumber: L
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let n;
    return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const n = this.getVerticalOffsetForWhitespaceIndex(i), r = this.getHeightForWhitespaceIndex(i);
    if (e >= n + r)
      return -1;
    for (; t < i; ) {
      const o = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(o), l = this.getHeightForWhitespaceIndex(o);
      if (e >= a + l)
        t = o + 1;
      else {
        if (e >= a)
          return o;
        i = o;
      }
    }
    return t;
  }
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const n = this.getHeightForWhitespaceIndex(t), r = this.getIdForWhitespaceIndex(t), o = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: r,
      afterLineNumber: o,
      verticalOffset: i,
      height: n
    };
  }
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    const r = [];
    for (let o = i; o <= n; o++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(o), l = this.getHeightForWhitespaceIndex(o);
      if (a >= t)
        break;
      r.push({
        id: this.getIdForWhitespaceIndex(o),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(o),
        verticalOffset: a,
        height: l
      });
    }
    return r;
  }
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
}
nu.INSTANCE_COUNT = 0;
const Q8 = 125;
class Jc {
  constructor(e, t, i, n) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class X8 extends z {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new A()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new Jc(0, 0, 0, 0), this._scrollable = this._register(new Fu({
      forceIntegerValues: !0,
      smoothScrollDuration: e,
      scheduleAtNextAnimationFrame: t
    })), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
    (i || n) && this._onDidContentSizeChange.fire(new rC(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
}
class J8 extends z {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const n = this._configuration.options, r = n.get(133), o = n.get(77);
    this._linesLayout = new nu(t, n.get(61), o.top, o.bottom), this._scrollable = this._register(new X8(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new Jc(r.contentWidth, 0, r.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(105) ? Q8 : 0);
  }
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(61) && this._linesLayout.setLineHeight(t.get(61)), e.hasChanged(77)) {
      const i = t.get(77);
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(133)) {
      const i = t.get(133), n = i.contentWidth, r = i.height, o = this._scrollable.getScrollDimensions(), a = o.contentWidth;
      this._scrollable.setScrollDimensions(new Jc(n, o.contentWidth, r, this._getContentHeight(n, r, a)));
    } else
      this._updateHeight();
    e.hasChanged(105) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  _getHorizontalScrollbarHeight(e, t) {
    const n = this._configuration.options.get(94);
    return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const n = this._configuration.options;
    let r = this._linesLayout.getLinesTotalHeight();
    return n.get(96) ? r += Math.max(0, t - n.get(61) - n.get(77).bottom) : r += this._getHorizontalScrollbarHeight(e, i), r;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
    this._scrollable.setScrollDimensions(new Jc(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
  }
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new kw(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new kw(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth(e) {
    const t = this._configuration.options, i = t.get(134), n = t.get(46), r = t.get(133);
    if (i.isViewportWrapping) {
      const o = t.get(67);
      return e > r.contentWidth + n.typicalHalfwidthCharacterWidth && o.enabled && o.side === "right" ? e + r.verticalScrollbarWidth : e;
    } else {
      const o = t.get(95) * n.typicalHalfwidthCharacterWidth, a = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(e + o + r.verticalScrollbarWidth, a);
    }
  }
  setMaxLineWidth(e) {
    const t = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new Jc(t.width, this._computeContentWidth(e), t.height, t.contentHeight)), this._updateHeight();
  }
  saveState() {
    const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - n,
      scrollLeft: e.scrollLeft
    };
  }
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class e3 {
  constructor(e, t, i, n, r) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = r, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const n = e.range, r = e.options;
      let o;
      if (r.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new O(n.startLineNumber, 1), 0), l = this._coordinatesConverter.convertModelPositionToViewPosition(new O(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)), 1);
        o = new N(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        o = this._coordinatesConverter.convertModelRangeToViewRange(n, 1);
      i = new H2(o, r), this._decorationsCache[t] = i;
    }
    return i;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsInRange(e), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  getInlineDecorationsOnLine(e) {
    const t = new N(e, this._linesCollection.getViewLineMinColumn(e), e, this._linesCollection.getViewLineMaxColumn(e));
    return this._getDecorationsInRange(t).inlineDecorations[0];
  }
  _getDecorationsInRange(e) {
    const t = this._linesCollection.getDecorationsInRange(e, this.editorId, cf(this.configuration.options)), i = e.startLineNumber, n = e.endLineNumber, r = [];
    let o = 0;
    const a = [];
    for (let l = i; l <= n; l++)
      a[l - i] = [];
    for (let l = 0, c = t.length; l < c; l++) {
      const h = t[l], u = h.options;
      if (!t3(this.model, h))
        continue;
      const d = this._getOrCreateViewModelDecoration(h), f = d.range;
      if (r[o++] = d, u.inlineClassName) {
        const m = new lh(f, u.inlineClassName, u.inlineClassNameAffectsLetterSpacing ? 3 : 0), _ = Math.max(i, f.startLineNumber), b = Math.min(n, f.endLineNumber);
        for (let v = _; v <= b; v++)
          a[v - i].push(m);
      }
      if (u.beforeContentClassName && i <= f.startLineNumber && f.startLineNumber <= n) {
        const m = new lh(new N(f.startLineNumber, f.startColumn, f.startLineNumber, f.startColumn), u.beforeContentClassName, 1);
        a[f.startLineNumber - i].push(m);
      }
      if (u.afterContentClassName && i <= f.endLineNumber && f.endLineNumber <= n) {
        const m = new lh(new N(f.endLineNumber, f.endColumn, f.endLineNumber, f.endColumn), u.afterContentClassName, 2);
        a[f.endLineNumber - i].push(m);
      }
    }
    return {
      decorations: r,
      inlineDecorations: a
    };
  }
}
function t3(s, e) {
  return !(e.options.hideInCommentTokens && i3(s, e) || e.options.hideInStringTokens && n3(s, e));
}
function i3(s, e) {
  return EE(s, e.range, (t) => t === 1);
}
function n3(s, e) {
  return EE(s, e.range, (t) => t === 2);
}
function EE(s, e, t) {
  for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
    const n = s.tokenization.getLineTokens(i), r = i === e.startLineNumber, o = i === e.endLineNumber;
    let a = r ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
    for (; a < n.getCount() && !(o && n.getStartOffset(a) > e.endColumn - 1); ) {
      if (!t(n.getStandardTokenType(a)))
        return !1;
      a++;
    }
  }
  return !0;
}
function Tp(s, e) {
  return s === null ? e ? Gf.INSTANCE : Zf.INSTANCE : new s3(s, e);
}
class s3 {
  constructor(e, t) {
    this._projectionData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getProjectionData() {
    return this._projectionData;
  }
  getViewLineCount() {
    return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
  }
  getViewLineContent(e, t, i) {
    this._assertVisible();
    const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, r = this._projectionData.breakOffsets[i];
    let o;
    if (this._projectionData.injectionOffsets !== null) {
      const a = this._projectionData.injectionOffsets.map((c, h) => new Wn(0, 0, c + 1, this._projectionData.injectionOptions[h], 0));
      o = Wn.applyInjectedText(e.getLineContent(t), a).substring(n, r);
    } else
      o = e.getValueInRange({
        startLineNumber: t,
        startColumn: n + 1,
        endLineNumber: t,
        endColumn: r + 1
      });
    return i > 0 && (o = ZS(this._projectionData.wrappedTextIndentLength) + o), o;
  }
  getViewLineLength(e, t, i) {
    return this._assertVisible(), this._projectionData.getLineLength(i);
  }
  getViewLineMinColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
  }
  getViewLineMaxColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
  }
  getViewLineData(e, t, i) {
    const n = new Array();
    return this.getViewLinesData(e, t, i, 1, 0, [!0], n), n[0];
  }
  getViewLinesData(e, t, i, n, r, o, a) {
    this._assertVisible();
    const l = this._projectionData, c = l.injectionOffsets, h = l.injectionOptions;
    let u = null;
    if (c) {
      u = [];
      let f = 0, m = 0;
      for (let _ = 0; _ < l.getOutputLineCount(); _++) {
        const b = new Array();
        u[_] = b;
        const v = _ > 0 ? l.breakOffsets[_ - 1] : 0, C = l.breakOffsets[_];
        for (; m < c.length; ) {
          const w = h[m].content.length, L = c[m] + f, E = L + w;
          if (L > C)
            break;
          if (v < E) {
            const k = h[m];
            if (k.inlineClassName) {
              const y = _ > 0 ? l.wrappedTextIndentLength : 0, S = y + Math.max(L - v, 0), D = y + Math.min(E - v, C);
              S !== D && b.push(new K5(S, D, k.inlineClassName, k.inlineClassNameAffectsLetterSpacing));
            }
          }
          if (E <= C)
            f += w, m++;
          else
            break;
        }
      }
    }
    let d;
    c ? d = e.tokenization.getLineTokens(t).withInserted(c.map((f, m) => ({
      offset: f,
      text: h[m].content,
      tokenMetadata: Pt.defaultTokenMetadata
    }))) : d = e.tokenization.getLineTokens(t);
    for (let f = i; f < i + n; f++) {
      const m = r + f - i;
      if (!o[m]) {
        a[m] = null;
        continue;
      }
      a[m] = this._getViewLineData(d, u ? u[f] : null, f);
    }
  }
  _getViewLineData(e, t, i) {
    this._assertVisible();
    const n = this._projectionData, r = i > 0 ? n.wrappedTextIndentLength : 0, o = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(o, a, r);
    let c = l.getLineContent();
    i > 0 && (c = ZS(n.wrappedTextIndentLength) + c);
    const h = this._projectionData.getMinOutputOffset(i) + 1, u = c.length + 1, d = i + 1 < this.getViewLineCount(), f = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
    return new Ub(c, d, h, u, f, l, t);
  }
  getModelColumnOfViewPosition(e, t) {
    return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
  }
  getViewPositionOfModelPosition(e, t, i = 2) {
    return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    this._assertVisible();
    const i = this._projectionData.translateToOutputPosition(t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i) {
    const n = t.lineNumber - e;
    return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
  }
  getInjectedTextAt(e, t) {
    return this._projectionData.getInjectedText(e, t - 1);
  }
  _assertVisible() {
    if (!this._isVisible)
      throw new Error("Not supported");
  }
}
class Gf {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : Zf.INSTANCE;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    const n = e.tokenization.getLineTokens(t), r = n.getLineContent();
    return new Ub(r, !1, 1, r.length + 1, 0, n.inflate(), null);
  }
  getViewLinesData(e, t, i, n, r, o, a) {
    if (!o[r]) {
      a[r] = null;
      return;
    }
    a[r] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new O(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i) {
    return t;
  }
  getInjectedTextAt(e, t) {
    return null;
  }
}
Gf.INSTANCE = new Gf();
class Zf {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? Gf.INSTANCE : this;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, n, r, o, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i) {
    throw new Error("Not supported");
  }
  getInjectedTextAt(e, t) {
    throw new Error("Not supported");
  }
}
Zf.INSTANCE = new Zf();
const Mp = [""];
function ZS(s) {
  if (s >= Mp.length)
    for (let e = 1; e <= s; e++)
      Mp[e] = r3(e);
  return Mp[s];
}
function r3(s) {
  return new Array(s + 1).join(" ");
}
class o3 {
  constructor(e, t, i, n, r, o, a, l, c) {
    this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = r, this.tabSize = o, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = c, this._constructLines(!0, null);
  }
  dispose() {
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
  }
  createCoordinatesConverter() {
    return new l3(this);
  }
  _constructLines(e, t) {
    this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
    const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), r = i.length, o = this.createLineBreaksComputer(), a = new Ih(Wn.fromDecorations(n));
    for (let _ = 0; _ < r; _++) {
      const b = a.takeWhile((v) => v.lineNumber === _ + 1);
      o.addRequest(i[_], b, t ? t[_] : null);
    }
    const l = o.finalize(), c = [], h = this.hiddenAreasDecorationIds.map((_) => this.model.getDecorationRange(_)).sort(N.compareRangesUsingStarts);
    let u = 1, d = 0, f = -1, m = f + 1 < h.length ? d + 1 : r + 2;
    for (let _ = 0; _ < r; _++) {
      const b = _ + 1;
      b === m && (f++, u = h[f].startLineNumber, d = h[f].endLineNumber, m = f + 1 < h.length ? d + 1 : r + 2);
      const v = b >= u && b <= d, C = Tp(l[_], !v);
      c[_] = C.getViewLineCount(), this.modelLineProjections[_] = C;
    }
    this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new l5(c);
  }
  getHiddenAreas() {
    return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
  }
  setHiddenAreas(e) {
    const t = e.map((d) => this.model.validateRange(d)), i = a3(t), n = this.hiddenAreasDecorationIds.map((d) => this.model.getDecorationRange(d)).sort(N.compareRangesUsingStarts);
    if (i.length === n.length) {
      let d = !1;
      for (let f = 0; f < i.length; f++)
        if (!i[f].equalsRange(n[f])) {
          d = !0;
          break;
        }
      if (!d)
        return !1;
    }
    const r = i.map((d) => ({
      range: d,
      options: mt.EMPTY
    }));
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, r);
    const o = i;
    let a = 1, l = 0, c = -1, h = c + 1 < o.length ? l + 1 : this.modelLineProjections.length + 2, u = !1;
    for (let d = 0; d < this.modelLineProjections.length; d++) {
      const f = d + 1;
      f === h && (c++, a = o[c].startLineNumber, l = o[c].endLineNumber, h = c + 1 < o.length ? l + 1 : this.modelLineProjections.length + 2);
      let m = !1;
      if (f >= a && f <= l ? this.modelLineProjections[d].isVisible() && (this.modelLineProjections[d] = this.modelLineProjections[d].setVisible(!1), m = !0) : (u = !0, this.modelLineProjections[d].isVisible() || (this.modelLineProjections[d] = this.modelLineProjections[d].setVisible(!0), m = !0)), m) {
        const _ = this.modelLineProjections[d].getViewLineCount();
        this.projectedModelLineLineCounts.setValue(d, _);
      }
    }
    return u || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.modelLineProjections.length ? !1 : this.modelLineProjections[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(!1, null), !0);
  }
  setWrappingSettings(e, t, i, n) {
    const r = this.fontInfo.equals(e), o = this.wrappingStrategy === t, a = this.wrappingColumn === i, l = this.wrappingIndent === n;
    if (r && o && a && l)
      return !1;
    const c = r && o && !a && l;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n;
    let h = null;
    if (c) {
      h = [];
      for (let u = 0, d = this.modelLineProjections.length; u < d; u++)
        h[u] = this.modelLineProjections[u].getProjectionData();
    }
    return this._constructLines(!1, h), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);
  }
  onModelFlushed() {
    this._constructLines(!0, null);
  }
  onModelLinesDeleted(e, t, i) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, r = this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new H1(n, r);
  }
  onModelLinesInserted(e, t, i, n) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const r = t > 2 && !this.modelLineProjections[t - 2].isVisible(), o = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
    let a = 0;
    const l = [], c = [];
    for (let h = 0, u = n.length; h < u; h++) {
      const d = Tp(n[h], !r);
      l.push(d);
      const f = d.getViewLineCount();
      a += f, c[h] = f;
    }
    return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, c), new z1(o, o + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e !== null && e <= this._validModelVersionId)
      return [!1, null, null, null];
    const n = t - 1, r = this.modelLineProjections[n].getViewLineCount(), o = this.modelLineProjections[n].isVisible(), a = Tp(i, o);
    this.modelLineProjections[n] = a;
    const l = this.modelLineProjections[n].getViewLineCount();
    let c = !1, h = 0, u = -1, d = 0, f = -1, m = 0, _ = -1;
    r > l ? (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, u = h + l - 1, m = u + 1, _ = m + (r - l) - 1, c = !0) : r < l ? (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, u = h + r - 1, d = u + 1, f = d + (l - r) - 1, c = !0) : (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, u = h + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
    const b = h <= u ? new uE(h, u - h + 1) : null, v = d <= f ? new z1(d, f) : null, C = m <= _ ? new H1(m, _) : null;
    return [c, b, v, C];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.projectedModelLineLineCounts.getTotalSum();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), r = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), o = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, r.lineNumber, o.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), c = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: c.lineNumber,
      indent: a.indent
    };
  }
  getViewLineInfo(e) {
    e = this._toValidViewLineNumber(e);
    const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
    return new YS(i + 1, n);
  }
  getMinColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getMaxColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getModelStartPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new O(e.modelLineNumber, n);
  }
  getModelEndPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new O(e.modelLineNumber, n);
  }
  getViewLineInfosGroupedByModelRanges(e, t) {
    const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), r = new Array();
    let o = this.getModelStartPositionOfViewLine(i), a = new Array();
    for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
      const c = this.modelLineProjections[l - 1];
      if (c.isVisible()) {
        const h = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, u = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : c.getViewLineCount();
        for (let d = h; d < u; d++)
          a.push(new YS(l, d));
      }
      if (!c.isVisible() && o) {
        const h = new O(l - 1, this.model.getLineMaxColumn(l - 1) + 1), u = N.fromPositions(o, h);
        r.push(new QS(u, a)), a = [], o = null;
      } else
        c.isVisible() && !o && (o = new O(l, 1));
    }
    if (o) {
      const l = N.fromPositions(o, this.getModelEndPositionOfViewLine(n));
      r.push(new QS(l, a));
    }
    return r;
  }
  getViewLinesBracketGuides(e, t, i, n) {
    const r = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, o = [];
    for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
      const l = a.modelRange.startLineNumber, c = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, r, n);
      for (const h of a.viewLines) {
        const d = c[h.modelLineNumber - l].map((f) => {
          if (f.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.forWrappedLinesAfterColumn).lineNumber >= h.modelLineWrappedLineIdx || f.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.forWrappedLinesBeforeOrAtColumn).lineNumber < h.modelLineWrappedLineIdx)
            return;
          if (!f.horizontalLine)
            return f;
          let m = -1;
          if (f.column !== -1) {
            const v = this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.column);
            if (v.lineNumber === h.modelLineWrappedLineIdx)
              m = v.column;
            else if (v.lineNumber < h.modelLineWrappedLineIdx)
              m = this.getMinColumnOfViewLine(h);
            else if (v.lineNumber > h.modelLineWrappedLineIdx)
              return;
          }
          const _ = this.convertModelPositionToViewPosition(h.modelLineNumber, f.horizontalLine.endColumn), b = this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.horizontalLine.endColumn);
          return b.lineNumber === h.modelLineWrappedLineIdx ? new Wo(f.visibleColumn, m, f.className, new hh(f.horizontalLine.top, _.column), -1, -1) : b.lineNumber < h.modelLineWrappedLineIdx || f.visibleColumn !== -1 ? void 0 : new Wo(f.visibleColumn, m, f.className, new hh(f.horizontalLine.top, this.getMaxColumnOfViewLine(h)), -1, -1);
        });
        o.push(d.filter((f) => !!f));
      }
    }
    return o;
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let r = [];
    const o = [], a = [], l = i.lineNumber - 1, c = n.lineNumber - 1;
    let h = null;
    for (let m = l; m <= c; m++) {
      const _ = this.modelLineProjections[m];
      if (_.isVisible()) {
        const b = _.getViewLineNumberOfModelPosition(0, m === l ? i.column : 1), v = _.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(m + 1)), C = v - b + 1;
        let w = 0;
        C > 1 && _.getViewLineMinColumn(this.model, m + 1, v) === 1 && (w = b === 0 ? 1 : 2), o.push(C), a.push(w), h === null && (h = new O(m + 1, 0));
      } else
        h !== null && (r = r.concat(this.model.guides.getLinesIndentGuides(h.lineNumber, m)), h = null);
    }
    h !== null && (r = r.concat(this.model.guides.getLinesIndentGuides(h.lineNumber, n.lineNumber)), h = null);
    const u = t - e + 1, d = new Array(u);
    let f = 0;
    for (let m = 0, _ = r.length; m < _; m++) {
      let b = r[m];
      const v = Math.min(u - f, o[m]), C = a[m];
      let w;
      C === 2 ? w = 0 : C === 1 ? w = 1 : w = v;
      for (let L = 0; L < v; L++)
        L === w && (b = 0), d[f++] = b;
    }
    return d;
  }
  getViewLineContent(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineLength(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMinColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMaxColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineData(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
    let r = e;
    const o = n.index, a = n.remainder, l = [];
    for (let c = o, h = this.model.getLineCount(); c < h; c++) {
      const u = this.modelLineProjections[c];
      if (!u.isVisible())
        continue;
      const d = c === o ? a : 0;
      let f = u.getViewLineCount() - d, m = !1;
      if (r + f > t && (m = !0, f = t - r + 1), u.getViewLinesData(this.model, c + 1, d, f, r - e, i, l), r += f, m)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), r = n.index, o = n.remainder, a = this.modelLineProjections[r], l = a.getViewLineMinColumn(this.model, r + 1, o), c = a.getViewLineMaxColumn(this.model, r + 1, o);
    t < l && (t = l), t > c && (t = c);
    const h = a.getModelColumnOfViewPosition(o, t);
    return this.model.validatePosition(new O(r + 1, h)).equals(i) ? new O(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new N(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  convertViewPositionToModelPosition(e, t) {
    const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
    return this.model.validatePosition(new O(i.modelLineNumber, n));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new N(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t, i = 2) {
    const n = this.model.validatePosition(new O(e, t)), r = n.lineNumber, o = n.column;
    let a = r - 1, l = !1;
    for (; a > 0 && !this.modelLineProjections[a].isVisible(); )
      a--, l = !0;
    if (a === 0 && !this.modelLineProjections[a].isVisible())
      return new O(1, 1);
    const c = 1 + this.projectedModelLineLineCounts.getPrefixSum(a);
    let h;
    return l ? h = this.modelLineProjections[a].getViewPositionOfModelPosition(c, this.model.getLineMaxColumn(a + 1), i) : h = this.modelLineProjections[r - 1].getViewPositionOfModelPosition(c, o, i), h;
  }
  convertModelRangeToViewRange(e, t = 0) {
    if (e.isEmpty()) {
      const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
      return N.fromPositions(i);
    } else {
      const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, 1), n = this.convertModelPositionToViewPosition(e.endLineNumber, e.endColumn, 0);
      return new N(i.lineNumber, i.column, n.lineNumber, n.column);
    }
  }
  getViewLineNumberOfModelPosition(e, t) {
    let i = e - 1;
    if (this.modelLineProjections[i].isVisible()) {
      const r = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections[i].getViewLineNumberOfModelPosition(r, t);
    }
    for (; i > 0 && !this.modelLineProjections[i].isVisible(); )
      i--;
    if (i === 0 && !this.modelLineProjections[i].isVisible())
      return 1;
    const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
  }
  getDecorationsInRange(e, t, i) {
    const n = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), r = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (r.lineNumber - n.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new N(n.lineNumber, 1, r.lineNumber, r.column), t, i);
    let o = [];
    const a = n.lineNumber - 1, l = r.lineNumber - 1;
    let c = null;
    for (let f = a; f <= l; f++)
      if (this.modelLineProjections[f].isVisible())
        c === null && (c = new O(f + 1, f === a ? n.column : 1));
      else if (c !== null) {
        const _ = this.model.getLineMaxColumn(f);
        o = o.concat(this.model.getDecorationsInRange(new N(c.lineNumber, c.column, f, _), t, i)), c = null;
      }
    c !== null && (o = o.concat(this.model.getDecorationsInRange(new N(c.lineNumber, c.column, r.lineNumber, r.column), t, i)), c = null), o.sort((f, m) => {
      const _ = N.compareRangesUsingStarts(f.range, m.range);
      return _ === 0 ? f.id < m.id ? -1 : f.id > m.id ? 1 : 0 : _;
    });
    const h = [];
    let u = 0, d = null;
    for (const f of o) {
      const m = f.id;
      d !== m && (d = m, h[u++] = f);
    }
    return h;
  }
  getInjectedTextAt(e) {
    const t = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
  }
  normalizePosition(e, t) {
    const i = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
  }
  getLineIndentColumn(e) {
    const t = this.getViewLineInfo(e);
    return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
  }
}
function a3(s) {
  if (s.length === 0)
    return [];
  const e = s.slice();
  e.sort(N.compareRangesUsingStarts);
  const t = [];
  let i = e[0].startLineNumber, n = e[0].endLineNumber;
  for (let r = 1, o = e.length; r < o; r++) {
    const a = e[r];
    a.startLineNumber > n + 1 ? (t.push(new N(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
  }
  return t.push(new N(i, 1, n, 1)), t;
}
class YS {
  constructor(e, t) {
    this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
  }
}
class QS {
  constructor(e, t) {
    this.modelRange = e, this.viewLines = t;
  }
}
class l3 {
  constructor(e) {
    this._lines = e;
  }
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  convertModelPositionToViewPosition(e, t) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t);
  }
  convertModelRangeToViewRange(e, t) {
    return this._lines.convertModelRangeToViewRange(e, t);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return this._lines.getViewLineNumberOfModelPosition(e, t);
  }
}
class c3 {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new h3(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, n) {
    return !1;
  }
  createLineBreaksComputer() {
    const e = [];
    return {
      addRequest: (t, i, n) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new H1(t, i);
  }
  onModelLinesInserted(e, t, i, n) {
    return new z1(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new uE(t, 1), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesBracketGuides(e, t, i) {
    return new Array(t - e + 1).fill([]);
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1, n = new Array(i);
    for (let r = 0; r < i; r++)
      n[r] = 0;
    return n;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    const t = this.model.tokenization.getLineTokens(e), i = t.getLineContent();
    return new Ub(i, !1, 1, i.length + 1, 0, t.inflate(), null);
  }
  getViewLinesData(e, t, i) {
    const n = this.model.getLineCount();
    e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
    const r = [];
    for (let o = e; o <= t; o++) {
      const a = o - e;
      r[a] = i[a] ? this.getViewLineData(o) : null;
    }
    return r;
  }
  getDecorationsInRange(e, t, i) {
    return this.model.getDecorationsInRange(e, t, i);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
  getInjectedTextAt(e) {
    return null;
  }
}
class h3 {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
}
class u3 extends z {
  constructor(e, t, i, n, r, o, a, l) {
    if (super(), this.languageConfigurationService = a, this._themeService = l, this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new vP(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new Na(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._tokenizeViewportSoon = this._register(new oi(() => this.tokenizeViewport(), 50)), this._updateConfigurationViewLineCount = this._register(new oi(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStart = vC.create(this.model), this.model.isTooLargeForTokenization())
      this._lines = new c3(this.model);
    else {
      const c = this._configuration.options, h = c.get(46), u = c.get(127), d = c.get(134), f = c.get(126);
      this._lines = new o3(this._editorId, this.model, n, r, h, this.model.getOptions().tabSize, u, d.wrappingColumn, f);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new ql(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new J8(this._configuration, this.getLineCount(), o)), this._register(this.viewLayout.onDidScroll((c) => {
      c.scrollTopChanged && this._tokenizeViewportSoon.schedule(), c.scrollTopChanged && this._viewportStart.invalidate(), this._eventDispatcher.emitSingleViewEvent(new mP(c)), this._eventDispatcher.emitOutgoingEvent(new aC(c.oldScrollWidth, c.oldScrollLeft, c.oldScrollHeight, c.oldScrollTop, c.scrollWidth, c.scrollLeft, c.scrollHeight, c.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((c) => {
      this._eventDispatcher.emitOutgoingEvent(c);
    })), this._decorations = new e3(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((c) => {
      try {
        const h = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(h, c);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(Bu.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new bP());
    })), this._register(this._themeService.onDidColorThemeChange((c) => {
      this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new pP(c));
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStart.dispose(), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  tokenizeViewport() {
    const e = this.viewLayout.getLinesViewportData(), t = new N(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber)), i = this._toModelVisibleRanges(t);
    for (const n of i)
      this.model.tokenization.tokenizeViewport(n.startLineNumber, n.endLineNumber);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new fP(e)), this._eventDispatcher.emitOutgoingEvent(new oC(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new cP());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new hP());
  }
  _onConfigurationChanged(e, t) {
    let i = null;
    if (this._viewportStart.isValid) {
      const h = new O(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));
      i = this.coordinatesConverter.convertViewPositionToModelPosition(h);
    }
    let n = !1;
    const r = this._configuration.options, o = r.get(46), a = r.get(127), l = r.get(134), c = r.get(126);
    if (this._lines.setWrappingSettings(o, a, l.wrappingColumn, c) && (e.emitViewEvent(new gd()), e.emitViewEvent(new md()), e.emitViewEvent(new Ta(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.getCurrentScrollTop() !== 0 && (n = !0), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(83) && (this._decorations.reset(), e.emitViewEvent(new Ta(null))), e.emitViewEvent(new uP(t)), this.viewLayout.onConfigurationChanged(t), n && i) {
      const h = this.coordinatesConverter.convertModelPositionToViewPosition(i), u = this.viewLayout.getVerticalOffsetForLineNumber(h.lineNumber);
      this.viewLayout.setScrollPosition({ scrollTop: u + this._viewportStart.startLineDelta }, 1);
    }
    Na.shouldRecreate(t) && (this.cursorConfig = new Na(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeContentOrInjectedText((e) => {
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        let n = !1, r = !1;
        const o = e instanceof Go ? e.rawContentChangedEvent.changes : e.changes, a = e instanceof Go ? e.rawContentChangedEvent.versionId : null, l = this._lines.createLineBreaksComputer();
        for (const u of o)
          switch (u.changeType) {
            case 4: {
              for (let d = 0; d < u.detail.length; d++) {
                const f = u.detail[d];
                let m = u.injectedTexts[d];
                m && (m = m.filter((_) => !_.ownerId || _.ownerId === this._editorId)), l.addRequest(f, m, null);
              }
              break;
            }
            case 2: {
              let d = null;
              u.injectedText && (d = u.injectedText.filter((f) => !f.ownerId || f.ownerId === this._editorId)), l.addRequest(u.detail, d, null);
              break;
            }
          }
        const c = l.finalize(), h = new Ih(c);
        for (const u of o)
          switch (u.changeType) {
            case 1: {
              this._lines.onModelFlushed(), i.emitViewEvent(new gd()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), n = !0;
              break;
            }
            case 3: {
              const d = this._lines.onModelLinesDeleted(a, u.fromLineNumber, u.toLineNumber);
              d !== null && (i.emitViewEvent(d), this.viewLayout.onLinesDeleted(d.fromLineNumber, d.toLineNumber)), n = !0;
              break;
            }
            case 4: {
              const d = h.takeCount(u.detail.length), f = this._lines.onModelLinesInserted(a, u.fromLineNumber, u.toLineNumber, d);
              f !== null && (i.emitViewEvent(f), this.viewLayout.onLinesInserted(f.fromLineNumber, f.toLineNumber)), n = !0;
              break;
            }
            case 2: {
              const d = h.dequeue(), [f, m, _, b] = this._lines.onModelLineChanged(a, u.lineNumber, d);
              r = f, m && i.emitViewEvent(m), _ && (i.emitViewEvent(_), this.viewLayout.onLinesInserted(_.fromLineNumber, _.toLineNumber)), b && (i.emitViewEvent(b), this.viewLayout.onLinesDeleted(b.fromLineNumber, b.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        a !== null && this._lines.acceptVersionId(a), this.viewLayout.onHeightMaybeChanged(), !n && r && (i.emitViewEvent(new md()), i.emitViewEvent(new Ta(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      const t = this._viewportStart.isValid;
      if (this._viewportStart.invalidate(), this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && t) {
        const i = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);
        if (i) {
          const n = this.coordinatesConverter.convertModelPositionToViewPosition(i.getStartPosition()), r = this.viewLayout.getVerticalOffsetForLineNumber(n.lineNumber);
          this.viewLayout.setScrollPosition({ scrollTop: r + this._viewportStart.startLineDelta }, 1);
        }
      }
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        e instanceof Go && i.emitOutgoingEvent(new xP(e.contentChangedEvent)), this._cursor.onModelContentChanged(i, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._tokenizeViewportSoon.schedule();
    })), this._register(this.model.onDidChangeTokens((e) => {
      const t = [];
      for (let i = 0, n = e.ranges.length; i < n; i++) {
        const r = e.ranges[i], o = this.coordinatesConverter.convertModelPositionToViewPosition(new O(r.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new O(r.toLineNumber, this.model.getLineMaxColumn(r.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: o,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new _P(t)), e.tokenizationSupportChanged && this._tokenizeViewportSoon.schedule(), this._eventDispatcher.emitOutgoingEvent(new NP(e));
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new gP()), this.cursorConfig = new Na(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new EP(e));
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new Na(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new DP(e));
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new gd()), t.emitViewEvent(new md()), t.emitViewEvent(new Ta(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new Na(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new IP(e));
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new Ta(e)), this._eventDispatcher.emitOutgoingEvent(new kP(e));
    }));
  }
  setHiddenAreas(e) {
    let t = !1;
    try {
      const i = this._eventDispatcher.beginEmitViewEvents();
      t = this._lines.setHiddenAreas(e), t && (i.emitViewEvent(new gd()), i.emitViewEvent(new md()), i.emitViewEvent(new Ta(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule(), t && this._eventDispatcher.emitOutgoingEvent(new yP());
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(133), t = this._configuration.options.get(61), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), r = Math.max(1, n.completelyVisibleStartLineNumber - i), o = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new N(r, this.getLineMinColumn(r), o, this.getLineMaxColumn(o)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  getHiddenAreas() {
    return this._lines.getHiddenAreas();
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    const n = [];
    let r = 0, o = t.startLineNumber, a = t.startColumn;
    const l = t.endLineNumber, c = t.endColumn;
    for (let h = 0, u = i.length; h < u; h++) {
      const d = i[h].startLineNumber, f = i[h].endLineNumber;
      f < o || d > l || (o < d && (n[r++] = new N(o, a, d - 1, this.model.getLineMaxColumn(d - 1))), o = f + 1, a = 1);
    }
    return (o < l || o === l && a < c) && (n[r++] = new N(o, a, l, c)), n;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new N(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
    return new N(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new O(i, this.getLineMinColumn(i))), r = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: n,
      firstPositionDeltaTop: r
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: n
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  setViewport(e, t, i) {
    this._viewportStart.update(this, e);
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getBracketGuidesInRangeByLine(e, t, i, n) {
    return this._lines.getViewLinesBracketGuides(e, t, i, n);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Bi(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = cc(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getInjectedTextAt(e) {
    return this._lines.getInjectedTextAt(e);
  }
  getViewportViewLineRenderingData(e, t) {
    const n = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return this._getViewLineRenderingData(t, n);
  }
  getViewLineRenderingData(e) {
    const t = this._decorations.getInlineDecorationsOnLine(e);
    return this._getViewLineRenderingData(e, t);
  }
  _getViewLineRenderingData(e, t) {
    const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), r = this.getTabSize(), o = this._lines.getViewLineData(e);
    return o.inlineDecorations && (t = [
      ...t,
      ...o.inlineDecorations.map((a) => a.toInlineDecoration(e))
    ]), new Wi(o.minColumn, o.maxColumn, o.content, o.continuesWithWrappedLine, i, n, o.tokens, t, r, o.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    const n = this._lines.getViewLinesData(e, t, i);
    return new j5(this.getTabSize(), n);
  }
  getAllOverviewRulerDecorations(e) {
    const t = this.model.getOverviewRulerDecorations(this._editorId, cf(this._configuration.options)), i = new d3();
    for (const n of t) {
      const r = n.options, o = r.overviewRuler;
      if (!o)
        continue;
      const a = o.position;
      if (a === 0)
        continue;
      const l = o.getColor(e.value), c = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), h = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
      i.accept(l, r.zIndex, c, h, a);
    }
    return i.asArray;
  }
  _invalidateDecorationsColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e) {
      const i = t.options.overviewRuler;
      i && i.invalidateCachedColor();
      const n = t.options.minimap;
      n && n.invalidateCachedColor();
    }
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const o = this.model.getOffsetAt(n) + t;
    return this.model.getPositionAt(o);
  }
  getPlainTextToCopy(e, t, i) {
    const n = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(N.compareRangesUsingStarts);
    let r = !1, o = !1;
    for (const l of e)
      l.isEmpty() ? r = !0 : o = !0;
    if (!o) {
      if (!t)
        return "";
      const l = e.map((h) => h.startLineNumber);
      let c = "";
      for (let h = 0; h < l.length; h++)
        h > 0 && l[h - 1] === l[h] || (c += this.model.getLineContent(l[h]) + n);
      return c;
    }
    if (r && t) {
      const l = [];
      let c = 0;
      for (const h of e) {
        const u = h.startLineNumber;
        h.isEmpty() ? u !== c && l.push(this.model.getLineContent(u)) : l.push(this.model.getValueInRange(h, i ? 2 : 0)), c = u;
      }
      return l.length === 1 ? l[0] : l;
    }
    const a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(l, i ? 2 : 0));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageId();
    if (i === os || e.length !== 1)
      return null;
    let n = e[0];
    if (n.isEmpty()) {
      if (!t)
        return null;
      const h = n.startLineNumber;
      n = new N(h, this.model.getLineMinColumn(h), h, this.model.getLineMaxColumn(h));
    }
    const r = this._configuration.options.get(46), o = this._getColorMap(), l = /[:;\\\/<>]/.test(r.fontFamily) || r.fontFamily === tn.fontFamily;
    let c;
    return l ? c = tn.fontFamily : (c = r.fontFamily, c = c.replace(/"/g, "'"), /[,']/.test(c) || /[+ ]/.test(c) && (c = `'${c}'`), c = `${c}, ${tn.fontFamily}`), {
      mode: i,
      html: `<div style="color: ${o[1]};background-color: ${o[2]};font-family: ${c};font-weight: ${r.fontWeight};font-size: ${r.fontSize}px;line-height: ${r.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, o) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, n = e.startColumn, r = e.endLineNumber, o = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let c = i; c <= r; c++) {
      const h = this.model.tokenization.getLineTokens(c), u = h.getLineContent(), d = c === i ? n - 1 : 0, f = c === r ? o - 1 : u.length;
      u === "" ? l += "<br>" : l += G8(u, h.inflate(), t, d, f, a, Vi);
    }
    return l;
  }
  _getColorMap() {
    const e = at.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, n = e.length; i < n; i++)
        t[i] = R.Format.CSS.formatHex(e[i]);
    return t;
  }
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new LP());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
  }
  startComposition() {
    this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, n, r) {
    this._executeCursorEdit((o) => this._cursor.compositionType(o, e, t, i, n, r));
  }
  paste(e, t, i, n) {
    this._executeCursorEdit((r) => this._cursor.paste(r, e, t, i, n));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealPrimaryCursor(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealPrimary(n, e, i, 0, t, 0));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new N(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new Zd(e, !1, i, null, 0, !0, 0)));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new N(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new Zd(e, !1, i, null, 0, !0, 0)));
  }
  revealRange(e, t, i, n, r) {
    this._withViewEventsCollector((o) => o.emitViewEvent(new Zd(e, !1, i, null, n, t, r)));
  }
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new CP()), this._eventDispatcher.emitOutgoingEvent(new SP()));
  }
  _withViewEventsCollector(e) {
    try {
      const t = this._eventDispatcher.beginEmitViewEvents();
      return e(t);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
}
class vC {
  constructor(e, t, i, n, r) {
    this._model = e, this._viewLineNumber = t, this._isValid = i, this._modelTrackedRange = n, this._startLineDelta = r;
  }
  static create(e) {
    const t = e._setTrackedRange(null, new N(1, 1, 1, 1), 1);
    return new vC(e, 1, !1, t, 0);
  }
  get viewLineNumber() {
    return this._viewLineNumber;
  }
  get isValid() {
    return this._isValid;
  }
  get modelTrackedRange() {
    return this._modelTrackedRange;
  }
  get startLineDelta() {
    return this._startLineDelta;
  }
  dispose() {
    this._model._setTrackedRange(this._modelTrackedRange, null, 1);
  }
  update(e, t) {
    const i = e.coordinatesConverter.convertViewPositionToModelPosition(new O(t, e.getLineMinColumn(t))), n = e.model._setTrackedRange(this._modelTrackedRange, new N(i.lineNumber, i.column, i.lineNumber, i.column), 1), r = e.viewLayout.getVerticalOffsetForLineNumber(t), o = e.viewLayout.getCurrentScrollTop();
    this._viewLineNumber = t, this._isValid = !0, this._modelTrackedRange = n, this._startLineDelta = o - r;
  }
  invalidate() {
    this._isValid = !1;
  }
}
class d3 {
  constructor() {
    this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
  }
  accept(e, t, i, n, r) {
    const o = this._asMap[e];
    if (o) {
      const a = o.data, l = a[a.length - 3], c = a[a.length - 1];
      if (l === r && c + 1 >= i) {
        n > c && (a[a.length - 1] = n);
        return;
      }
      a.push(r, i, n);
    } else {
      const a = new z2(e, t, [r, i, n]);
      this._asMap[e] = a, this.asArray.push(a);
    }
  }
}
class cm {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  get(e) {
    return this._entries.get(e);
  }
}
var su;
(function(s) {
  s[s.Ignore = 0] = "Ignore", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error";
})(su || (su = {}));
(function(s) {
  const e = "error", t = "warning", i = "warn", n = "info", r = "ignore";
  function o(l) {
    return l ? Ka(e, l) ? s.Error : Ka(t, l) || Ka(i, l) ? s.Warning : Ka(n, l) ? s.Info : s.Ignore : s.Ignore;
  }
  s.fromValue = o;
  function a(l) {
    switch (l) {
      case s.Error:
        return e;
      case s.Warning:
        return t;
      case s.Info:
        return n;
      default:
        return r;
    }
  }
  s.toString = a;
})(su || (su = {}));
const pt = su, vs = Se("notificationService");
class f3 {
}
class Ch {
  constructor(e, t, i, n, r) {
    this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = r;
  }
  getOutputLineCount() {
    return this.breakOffsets.length;
  }
  getMinOutputOffset(e) {
    return e > 0 ? this.wrappedTextIndentLength : 0;
  }
  getLineLength(e) {
    const t = e > 0 ? this.breakOffsets[e - 1] : 0;
    let n = this.breakOffsets[e] - t;
    return e > 0 && (n += this.wrappedTextIndentLength), n;
  }
  getMaxOutputOffset(e) {
    return this.getLineLength(e);
  }
  translateToInputOffset(e, t) {
    e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
    let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
    if (this.injectionOffsets !== null)
      for (let r = 0; r < this.injectionOffsets.length && n > this.injectionOffsets[r]; r++)
        n < this.injectionOffsets[r] + this.injectionOptions[r].content.length ? n = this.injectionOffsets[r] : n -= this.injectionOptions[r].content.length;
    return n;
  }
  translateToOutputPosition(e, t = 2) {
    let i = e;
    if (this.injectionOffsets !== null)
      for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++)
        i += this.injectionOptions[n].content.length;
    return this.offsetInInputWithInjectionsToOutputPosition(i, t);
  }
  offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
    let i = 0, n = this.breakOffsets.length - 1, r = 0, o = 0;
    for (; i <= n; ) {
      r = i + (n - i) / 2 | 0;
      const l = this.breakOffsets[r];
      if (o = r > 0 ? this.breakOffsets[r - 1] : 0, t === 0)
        if (e <= o)
          n = r - 1;
        else if (e > l)
          i = r + 1;
        else
          break;
      else if (e < o)
        n = r - 1;
      else if (e >= l)
        i = r + 1;
      else
        break;
    }
    let a = e - o;
    return r > 0 && (a += this.wrappedTextIndentLength), new wd(r, a);
  }
  normalizeOutputPosition(e, t, i) {
    if (this.injectionOffsets !== null) {
      const n = this.outputPositionToOffsetInInputWithInjections(e, t), r = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
      if (r !== n)
        return this.offsetInInputWithInjectionsToOutputPosition(r, i);
    }
    if (i === 0) {
      if (e > 0 && t === this.getMinOutputOffset(e))
        return new wd(e - 1, this.getMaxOutputOffset(e - 1));
    } else if (i === 1) {
      const n = this.getOutputLineCount() - 1;
      if (e < n && t === this.getMaxOutputOffset(e))
        return new wd(e + 1, this.getMinOutputOffset(e + 1));
    }
    return new wd(e, t);
  }
  outputPositionToOffsetInInputWithInjections(e, t) {
    return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
  }
  normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
    const i = this.getInjectedTextAtOffset(e);
    if (!i)
      return e;
    if (t === 2) {
      if (e === i.offsetInInputWithInjections + i.length && XS(this.injectionOptions[i.injectedTextIndex].cursorStops))
        return i.offsetInInputWithInjections + i.length;
      {
        let n = i.offsetInInputWithInjections;
        if (JS(this.injectionOptions[i.injectedTextIndex].cursorStops))
          return n;
        let r = i.injectedTextIndex - 1;
        for (; r >= 0 && this.injectionOffsets[r] === this.injectionOffsets[i.injectedTextIndex] && !(XS(this.injectionOptions[r].cursorStops) || (n -= this.injectionOptions[r].content.length, JS(this.injectionOptions[r].cursorStops))); )
          r--;
        return n;
      }
    } else if (t === 1 || t === 4) {
      let n = i.offsetInInputWithInjections + i.length, r = i.injectedTextIndex;
      for (; r + 1 < this.injectionOffsets.length && this.injectionOffsets[r + 1] === this.injectionOffsets[r]; )
        n += this.injectionOptions[r + 1].content.length, r++;
      return n;
    } else if (t === 0 || t === 3) {
      let n = i.offsetInInputWithInjections, r = i.injectedTextIndex;
      for (; r - 1 >= 0 && this.injectionOffsets[r - 1] === this.injectionOffsets[r]; )
        n -= this.injectionOptions[r - 1].content.length, r--;
      return n;
    }
    fb();
  }
  getInjectedText(e, t) {
    const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
    return n ? {
      options: this.injectionOptions[n.injectedTextIndex]
    } : null;
  }
  getInjectedTextAtOffset(e) {
    const t = this.injectionOffsets, i = this.injectionOptions;
    if (t !== null) {
      let n = 0;
      for (let r = 0; r < t.length; r++) {
        const o = i[r].content.length, a = t[r] + n, l = t[r] + n + o;
        if (a > e)
          break;
        if (e <= l)
          return {
            injectedTextIndex: r,
            offsetInInputWithInjections: a,
            length: o
          };
        n += o;
      }
    }
  }
}
function XS(s) {
  return s == null ? !0 : s === Pl.Right || s === Pl.Both;
}
function JS(s) {
  return s == null ? !0 : s === Pl.Left || s === Pl.Both;
}
class wd {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
  toString() {
    return `${this.outputLineIndex}:${this.outputOffset}`;
  }
  toPosition(e) {
    return new O(e + this.outputLineIndex, this.outputOffset + 1);
  }
}
class wC {
  constructor(e, t) {
    this.classifier = new g3(e, t);
  }
  static create(e) {
    return new wC(e.get(122), e.get(121));
  }
  createLineBreaksComputer(e, t, i, n) {
    const r = [], o = [], a = [];
    return {
      addRequest: (l, c, h) => {
        r.push(l), o.push(c), a.push(h);
      },
      finalize: () => {
        const l = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, c = [];
        for (let h = 0, u = r.length; h < u; h++) {
          const d = o[h], f = a[h];
          f && !f.injectionOptions && !d ? c[h] = m3(this.classifier, f, r[h], t, i, l, n) : c[h] = p3(this.classifier, r[h], d, t, i, l, n);
        }
        return Z1.length = 0, Y1.length = 0, c;
      }
    };
  }
}
class g3 extends Tu {
  constructor(e, t) {
    super(0);
    for (let i = 0; i < e.length; i++)
      this.set(e.charCodeAt(i), 1);
    for (let i = 0; i < t.length; i++)
      this.set(t.charCodeAt(i), 2);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let Z1 = [], Y1 = [];
function m3(s, e, t, i, n, r, o) {
  if (n === -1)
    return null;
  const a = t.length;
  if (a <= 1)
    return null;
  const l = e.breakOffsets, c = e.breakOffsetsVisibleColumn, h = xE(t, i, n, r, o), u = n - h, d = Z1, f = Y1;
  let m = 0, _ = 0, b = 0, v = n;
  const C = l.length;
  let w = 0;
  if (w >= 0) {
    let L = Math.abs(c[w] - v);
    for (; w + 1 < C; ) {
      const E = Math.abs(c[w + 1] - v);
      if (E >= L)
        break;
      L = E, w++;
    }
  }
  for (; w < C; ) {
    let L = w < 0 ? 0 : l[w], E = w < 0 ? 0 : c[w];
    _ > L && (L = _, E = b);
    let k = 0, y = 0, S = 0, D = 0;
    if (E <= v) {
      let M = E, P = L === 0 ? 0 : t.charCodeAt(L - 1), V = L === 0 ? 0 : s.get(P), U = !0;
      for (let K = L; K < a; K++) {
        const J = K, ee = t.charCodeAt(K);
        let ne, ue;
        if (Lt(ee) ? (K++, ne = 0, ue = 2) : (ne = s.get(ee), ue = vh(ee, M, i, r)), J > _ && Q1(P, V, ee, ne) && (k = J, y = M), M += ue, M > v) {
          J > _ ? (S = J, D = M - ue) : (S = K + 1, D = M), M - y > u && (k = 0), U = !1;
          break;
        }
        P = ee, V = ne;
      }
      if (U) {
        m > 0 && (d[m] = l[l.length - 1], f[m] = c[l.length - 1], m++);
        break;
      }
    }
    if (k === 0) {
      let M = E, P = t.charCodeAt(L), V = s.get(P), U = !1;
      for (let K = L - 1; K >= _; K--) {
        const J = K + 1, ee = t.charCodeAt(K);
        if (ee === 9) {
          U = !0;
          break;
        }
        let ne, ue;
        if (Rl(ee) ? (K--, ne = 0, ue = 2) : (ne = s.get(ee), ue = Jr(ee) ? r : 1), M <= v) {
          if (S === 0 && (S = J, D = M), M <= v - u)
            break;
          if (Q1(ee, ne, P, V)) {
            k = J, y = M;
            break;
          }
        }
        M -= ue, P = ee, V = ne;
      }
      if (k !== 0) {
        const K = u - (D - y);
        if (K <= i) {
          const J = t.charCodeAt(S);
          let ee;
          Lt(J) ? ee = 2 : ee = vh(J, D, i, r), K - ee < 0 && (k = 0);
        }
      }
      if (U) {
        w--;
        continue;
      }
    }
    if (k === 0 && (k = S, y = D), k <= _) {
      const M = t.charCodeAt(_);
      Lt(M) ? (k = _ + 2, y = b + 2) : (k = _ + 1, y = b + vh(M, b, i, r));
    }
    for (_ = k, d[m] = k, b = y, f[m] = y, m++, v = y + u; w < 0 || w < C && c[w] < y; )
      w++;
    let T = Math.abs(c[w] - v);
    for (; w + 1 < C; ) {
      const M = Math.abs(c[w + 1] - v);
      if (M >= T)
        break;
      T = M, w++;
    }
  }
  return m === 0 ? null : (d.length = m, f.length = m, Z1 = e.breakOffsets, Y1 = e.breakOffsetsVisibleColumn, e.breakOffsets = d, e.breakOffsetsVisibleColumn = f, e.wrappedTextIndentLength = h, e);
}
function p3(s, e, t, i, n, r, o) {
  const a = Wn.applyInjectedText(e, t);
  let l, c;
  if (t && t.length > 0 ? (l = t.map((y) => y.options), c = t.map((y) => y.column - 1)) : (l = null, c = null), n === -1)
    return l ? new Ch(c, l, [a.length], [], 0) : null;
  const h = a.length;
  if (h <= 1)
    return l ? new Ch(c, l, [a.length], [], 0) : null;
  const u = xE(a, i, n, r, o), d = n - u, f = [], m = [];
  let _ = 0, b = 0, v = 0, C = n, w = a.charCodeAt(0), L = s.get(w), E = vh(w, 0, i, r), k = 1;
  Lt(w) && (E += 1, w = a.charCodeAt(1), L = s.get(w), k++);
  for (let y = k; y < h; y++) {
    const S = y, D = a.charCodeAt(y);
    let T, M;
    Lt(D) ? (y++, T = 0, M = 2) : (T = s.get(D), M = vh(D, E, i, r)), Q1(w, L, D, T) && (b = S, v = E), E += M, E > C && ((b === 0 || E - v > d) && (b = S, v = E - M), f[_] = b, m[_] = v, _++, C = v + d, b = 0), w = D, L = T;
  }
  return _ === 0 && (!t || t.length === 0) ? null : (f[_] = h, m[_] = E, new Ch(c, l, f, m, u));
}
function vh(s, e, t, i) {
  return s === 9 ? t - e % t : Jr(s) || s < 32 ? i : 1;
}
function ey(s, e) {
  return e - s % e;
}
function Q1(s, e, t, i) {
  return t !== 32 && (e === 2 && i !== 2 || e !== 1 && i === 1 || e === 3 && i !== 2 || i === 3 && e !== 1);
}
function xE(s, e, t, i, n) {
  let r = 0;
  if (n !== 0) {
    const o = Bi(s);
    if (o !== -1) {
      for (let l = 0; l < o; l++) {
        const c = s.charCodeAt(l) === 9 ? ey(r, e) : 1;
        r += c;
      }
      const a = n === 3 ? 2 : n === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const c = ey(r, e);
        r += c;
      }
      r + i > t && (r = 0);
    }
  }
  return r;
}
var Ap;
const Rp = (Ap = window.trustedTypes) === null || Ap === void 0 ? void 0 : Ap.createPolicy("domLineBreaksComputer", { createHTML: (s) => s });
class SC {
  static create() {
    return new SC();
  }
  constructor() {
  }
  createLineBreaksComputer(e, t, i, n) {
    const r = [], o = [];
    return {
      addRequest: (a, l, c) => {
        r.push(a), o.push(l);
      },
      finalize: () => _3(r, e, t, i, n, o)
    };
  }
}
function _3(s, e, t, i, n, r) {
  var o;
  function a(S) {
    const D = r[S];
    if (D) {
      const T = Wn.applyInjectedText(s[S], D), M = D.map((V) => V.options), P = D.map((V) => V.column - 1);
      return new Ch(P, M, [T.length], [], 0);
    } else
      return null;
  }
  if (i === -1) {
    const S = [];
    for (let D = 0, T = s.length; D < T; D++)
      S[D] = a(D);
    return S;
  }
  const l = Math.round(i * e.typicalHalfwidthCharacterWidth), h = Math.round(t * (n === 3 ? 2 : n === 2 ? 1 : 0)), u = Math.ceil(e.spaceWidth * h), d = document.createElement("div");
  mi(d, e);
  const f = Ol(1e4), m = [], _ = [], b = [], v = [], C = [];
  for (let S = 0; S < s.length; S++) {
    const D = Wn.applyInjectedText(s[S], r[S]);
    let T = 0, M = 0, P = l;
    if (n !== 0)
      if (T = Bi(D), T === -1)
        T = 0;
      else {
        for (let J = 0; J < T; J++) {
          const ee = D.charCodeAt(J) === 9 ? t - M % t : 1;
          M += ee;
        }
        const K = Math.ceil(e.spaceWidth * M);
        K + e.typicalFullwidthCharacterWidth > l ? (T = 0, M = 0) : P = l - K;
      }
    const V = D.substr(T), U = b3(V, M, t, P, f, u);
    m[S] = T, _[S] = M, b[S] = V, v[S] = U[0], C[S] = U[1];
  }
  const w = f.build(), L = (o = Rp == null ? void 0 : Rp.createHTML(w)) !== null && o !== void 0 ? o : w;
  d.innerHTML = L, d.style.position = "absolute", d.style.top = "10000", d.style.wordWrap = "break-word", document.body.appendChild(d);
  const E = document.createRange(), k = Array.prototype.slice.call(d.children, 0), y = [];
  for (let S = 0; S < s.length; S++) {
    const D = k[S], T = C3(E, D, b[S], v[S]);
    if (T === null) {
      y[S] = a(S);
      continue;
    }
    const M = m[S], P = _[S] + h, V = C[S], U = [];
    for (let ne = 0, ue = T.length; ne < ue; ne++)
      U[ne] = V[T[ne]];
    if (M !== 0)
      for (let ne = 0, ue = T.length; ne < ue; ne++)
        T[ne] += M;
    let K, J;
    const ee = r[S];
    ee ? (K = ee.map((ne) => ne.options), J = ee.map((ne) => ne.column - 1)) : (K = null, J = null), y[S] = new Ch(J, K, T, U, P);
  }
  return document.body.removeChild(d), y;
}
function b3(s, e, t, i, n, r) {
  if (r !== 0) {
    const d = String(r);
    n.appendASCIIString('<div style="text-indent: -'), n.appendASCIIString(d), n.appendASCIIString("px; padding-left: "), n.appendASCIIString(d), n.appendASCIIString("px; box-sizing: border-box; width:");
  } else
    n.appendASCIIString('<div style="width:');
  n.appendASCIIString(String(i)), n.appendASCIIString('px;">');
  const o = s.length;
  let a = e, l = 0;
  const c = [], h = [];
  let u = 0 < o ? s.charCodeAt(0) : 0;
  n.appendASCIIString("<span>");
  for (let d = 0; d < o; d++) {
    d !== 0 && d % 16384 === 0 && n.appendASCIIString("</span><span>"), c[d] = l, h[d] = a;
    const f = u;
    u = d + 1 < o ? s.charCodeAt(d + 1) : 0;
    let m = 1, _ = 1;
    switch (f) {
      case 9:
        m = t - a % t, _ = m;
        for (let b = 1; b <= m; b++)
          b < m ? n.write1(160) : n.appendASCII(32);
        break;
      case 32:
        u === 32 ? n.write1(160) : n.appendASCII(32);
        break;
      case 60:
        n.appendASCIIString("&lt;");
        break;
      case 62:
        n.appendASCIIString("&gt;");
        break;
      case 38:
        n.appendASCIIString("&amp;");
        break;
      case 0:
        n.appendASCIIString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        n.write1(65533);
        break;
      default:
        Jr(f) && _++, f < 32 ? n.write1(9216 + f) : n.write1(f);
    }
    l += m, a += _;
  }
  return n.appendASCIIString("</span>"), c[s.length] = l, h[s.length] = a, n.appendASCIIString("</div>"), [c, h];
}
function C3(s, e, t, i) {
  if (t.length <= 1)
    return null;
  const n = Array.prototype.slice.call(e.children, 0), r = [];
  try {
    X1(s, n, i, 0, null, t.length - 1, null, r);
  } catch (o) {
    return console.log(o), null;
  }
  return r.length === 0 ? null : (r.push(t.length), r);
}
function X1(s, e, t, i, n, r, o, a) {
  if (i === r || (n = n || Pp(s, e, t[i], t[i + 1]), o = o || Pp(s, e, t[r], t[r + 1]), Math.abs(n[0].top - o[0].top) <= 0.1))
    return;
  if (i + 1 === r) {
    a.push(r);
    return;
  }
  const l = i + (r - i) / 2 | 0, c = Pp(s, e, t[l], t[l + 1]);
  X1(s, e, t, i, n, l, c, a), X1(s, e, t, l, c, r, o, a);
}
function Pp(s, e, t, i) {
  return s.setStart(e[t / 16384 | 0].firstChild, t % 16384), s.setEnd(e[i / 16384 | 0].firstChild, i % 16384), s.getClientRects();
}
var v3 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Ns = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, w3 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
let S3 = 0;
class y3 {
  constructor(e, t, i, n, r) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = r;
  }
  dispose() {
    je(this.listenersToRemove), this.model.onBeforeDetached(), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
}
let ru = class Ha extends z {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d) {
    super(), this.languageConfigurationService = u, this._deliveryQueue = new jk(), this._onDidDispose = this._register(new A()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeModelTokens = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelTokens = this._onDidChangeModelTokens.event, this._onDidChangeConfiguration = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onDidChangeModel = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new ty({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new ty({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onWillType = this._onWillType.event, this._onDidType = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onDropIntoEditor = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDropIntoEditor = this._onDropIntoEditor.event, this._onContextMenu = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._bannerDomNode = null, this._dropIntoEditorDecorations = this.createDecorationsCollection();
    const f = Object.assign({}, t);
    this._domElement = e, this._overflowWidgetsDomNode = f.overflowWidgetsDomNode, delete f.overflowWidgetsDomNode, this._id = ++S3, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || !1, f, h)), this._register(this._configuration.onDidChange((b) => {
      this._onDidChangeConfiguration.fire(b);
      const v = this._configuration.options;
      if (b.hasChanged(133)) {
        const C = v.get(133);
        this._onDidLayoutChange.fire(C);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = c, this._codeEditorService = r, this._commandService = o, this._themeService = l, this._register(new L3(this, this._contextKeyService)), this._register(new k3(this, this._contextKeyService, d)), this._instantiationService = n.createChild(new cm([Qe, this._contextKeyService])), this._modelData = null, this._contributions = {}, this._actions = {}, this._focusTracker = new D3(e), this._register(this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    })), this._contentWidgets = {}, this._overlayWidgets = {};
    let m;
    Array.isArray(i.contributions) ? m = i.contributions : m = bl.getEditorContributions();
    for (const b of m) {
      if (this._contributions[b.id]) {
        ct(new Error(`Cannot have two contributions with the same id ${b.id}`));
        continue;
      }
      try {
        const v = this._instantiationService.createInstance(b.ctor, this);
        this._contributions[b.id] = v;
      } catch (v) {
        ct(v);
      }
    }
    bl.getEditorActions().forEach((b) => {
      if (this._actions[b.id]) {
        ct(new Error(`Cannot have two actions with the same id ${b.id}`));
        return;
      }
      const v = new dE(b.id, b.label, b.alias, Er(b.precondition), () => this._instantiationService.invokeFunction((C) => Promise.resolve(b.runEditorCommand(C, this, null))), this._contextKeyService);
      this._actions[v.id] = v;
    });
    const _ = () => !this._configuration.options.get(83) && this._configuration.options.get(32).enabled;
    this._register(new ZM(this._domElement, {
      onDragEnter: () => {
      },
      onDragOver: (b) => {
        if (!_())
          return;
        const v = this.getTargetAtClientPoint(b.clientX, b.clientY);
        v != null && v.position && this.showDropIndicatorAt(v.position);
      },
      onDrop: (b) => w3(this, void 0, void 0, function* () {
        if (!_() || (this.removeDropIndicator(), !b.dataTransfer))
          return;
        const v = this.getTargetAtClientPoint(b.clientX, b.clientY);
        v != null && v.position && this._onDropIntoEditor.fire({ position: v.position, event: b });
      }),
      onDragLeave: () => {
        this.removeDropIndicator();
      },
      onDragEnd: () => {
        this.removeDropIndicator();
      }
    })), this._codeEditorService.addCodeEditor(this);
  }
  get isSimpleWidget() {
    return this._configuration.isSimpleWidget;
  }
  _createConfiguration(e, t, i) {
    return new T1(e, t, this._domElement, i);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return Rb.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose();
    const e = Object.keys(this._contributions);
    for (let t = 0, i = e.length; t < i; t++) {
      const n = e[t];
      this._contributions[n].dispose();
    }
    this._contributions = {}, this._actions = {}, this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e || {});
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? et.getWordAtPosition(this._modelData.model, this._configuration.options.get(119), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    !this._modelData || this._modelData.model.setValue(e);
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    const t = e;
    if (this._modelData === null && t === null || this._modelData && this._modelData.model === t)
      return;
    const i = this.hasTextFocus(), n = this._detachModel();
    this._attachModel(t), i && this.hasModel() && this.focus();
    const r = {
      oldModelUrl: n ? n.uri : null,
      newModelUrl: t ? t.uri : null
    };
    this._removeDecorationTypes(), this._onDidChangeModel.fire(r), this._postDetachModelCleanup(n);
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (const e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (const i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetAfterPosition(e, t, i, n) {
    const r = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(r);
    return e.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(o.lineNumber, n);
  }
  getTopForLineNumber(e, t = !1) {
    return this._modelData ? Ha._getVerticalOffsetForPosition(this._modelData, e, 1, t) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? Ha._getVerticalOffsetForPosition(this._modelData, e, t, !1) : -1;
  }
  static _getVerticalOffsetForPosition(e, t, i, n = !1) {
    const r = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(r);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(o.lineNumber, n);
  }
  getBottomForLineNumber(e, t = !1) {
    return this._modelData ? Ha._getVerticalOffsetAfterPosition(this._modelData, e, 1, t) : -1;
  }
  setHiddenAreas(e) {
    var t;
    (t = this._modelData) === null || t === void 0 || t.viewModel.setHiddenAreas(e.map((i) => N.lift(i)));
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return _t.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e, t = "api") {
    if (!!this._modelData) {
      if (!O.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, n) {
    if (!this._modelData)
      return;
    if (!N.isIRange(e))
      throw new Error("Invalid arguments");
    const r = this._modelData.model.validateRange(e), o = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(r);
    this._modelData.viewModel.revealRange("api", i, o, t, n);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new N(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, n) {
    if (!O.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new N(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e, t = "api") {
    const i = Ce.isISelection(e), n = N.isIRange(e);
    if (!i && !n)
      throw new Error("Invalid arguments");
    if (i)
      this._setSelectionImpl(e, t);
    else if (n) {
      const r = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(r, t);
    }
  }
  _setSelectionImpl(e, t) {
    if (!this._modelData)
      return;
    const i = new Ce(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections(t, [i]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, n) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new N(e, 1, t, 1), i, !1, n);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._revealRange(e, i ? 1 : 0, n, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, n) {
    if (!N.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(N.lift(e), t, i, n);
  }
  setSelections(e, t = "api", i = 0) {
    if (!!this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let n = 0, r = e.length; n < r; n++)
        if (!Ce.isISelection(e[n]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (!!this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (!!this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    !this._modelData || this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = {}, t = Object.keys(this._contributions);
    for (const r of t) {
      const o = this._contributions[r];
      typeof o.saveViewState == "function" && (e[r] = o.saveViewState());
    }
    const i = this._modelData.viewModel.saveCursorState(), n = this._modelData.viewModel.saveState();
    return {
      cursorState: i,
      viewState: n,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]);
      const n = t.contributionsState || {}, r = Object.keys(this._contributions);
      for (let a = 0, l = r.length; a < l; a++) {
        const c = r[a], h = this._contributions[c];
        typeof h.restoreViewState == "function" && h.restoreViewState(n[c]);
      }
      const o = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(o);
    }
  }
  getContribution(e) {
    return this._contributions[e] || null;
  }
  getActions() {
    const e = [], t = Object.keys(this._actions);
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      e.push(this._actions[r]);
    }
    return e;
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions[e] || null;
  }
  trigger(e, t, i) {
    switch (i = i || {}, t) {
      case "compositionStart":
        this._startComposition();
        return;
      case "compositionEnd":
        this._endComposition(e);
        return;
      case "type": {
        const r = i;
        this._type(e, r.text || "");
        return;
      }
      case "replacePreviousChar": {
        const r = i;
        this._compositionType(e, r.text || "", r.replaceCharCnt || 0, 0, 0);
        return;
      }
      case "compositionType": {
        const r = i;
        this._compositionType(e, r.text || "", r.replacePrevCharCnt || 0, r.replaceNextCharCnt || 0, r.positionDelta || 0);
        return;
      }
      case "paste": {
        const r = i;
        this._paste(e, r.text || "", r.pasteOnNewLine || !1, r.multicursorText || null, r.mode || null);
        return;
      }
      case "cut":
        this._cut(e);
        return;
    }
    const n = this.getAction(t);
    if (n) {
      Promise.resolve(n.run()).then(void 0, ct);
      return;
    }
    !this._modelData || this._triggerEditorCommand(e, t, i) || this._triggerCommand(t, i);
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    !this._modelData || (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    !this._modelData || (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, n, r) {
    !this._modelData || this._modelData.viewModel.compositionType(t, i, n, r, e);
  }
  _paste(e, t, i, n, r) {
    if (!this._modelData || t.length === 0)
      return;
    const o = this._modelData.viewModel, a = o.getSelection().getStartPosition();
    o.paste(t, i, n, e);
    const l = o.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      range: new N(a.lineNumber, a.column, l.lineNumber, l.column),
      languageId: r
    });
  }
  _cut(e) {
    !this._modelData || this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const n = bl.getEditorCommand(t);
    return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((r) => {
      Promise.resolve(n.runEditorCommand(r, this, i)).then(void 0, ct);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(83) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(83) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(83))
      return !1;
    let n;
    return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), !0;
  }
  executeCommand(e, t) {
    !this._modelData || this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    !this._modelData || this._modelData.viewModel.executeCommands(t, e);
  }
  createDecorationsCollection(e) {
    return new E3(this, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, cf(this._configuration.options)) : null;
  }
  getDecorationsInRange(e) {
    return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, cf(this._configuration.options)) : null;
  }
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    !this._modelData || e.length === 0 || this._modelData.model.changeDecorations((t) => {
      t.deltaDecorations(e, []);
    });
  }
  removeDecorationsByType(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.deltaDecorations(t, []), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(133);
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarPointerDown(e);
  }
  layout(e) {
    this._configuration.observeContainer(e), this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id."), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(133), r = Ha._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), o = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
    return {
      top: r,
      left: o,
      height: i.get(61)
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.render(!0, e);
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    mi(e, this._configuration.options.get(46));
  }
  setBanner(e, t) {
    this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._domElement.removeChild(this._bannerDomNode), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount()), e.onBeforeAttached();
    const i = new u3(this._id, this._configuration, e, SC.create(), wC.create(this._configuration.options), (o) => Bn(o), this.languageConfigurationService, this._themeService);
    t.push(e.onWillDispose(() => this.setModel(null))), t.push(i.onEvent((o) => {
      switch (o.kind) {
        case 0:
          this._onDidContentSizeChange.fire(o);
          break;
        case 1:
          this._editorTextFocus.setValue(o.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(o);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidChangeHiddenAreas.fire();
          break;
        case 5:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 6: {
          o.reachedMaxCursorCount && this._notificationService.warn(p("cursors.maximum", "The number of cursors has been limited to {0}.", ql.MAX_CURSOR_COUNT));
          const a = [];
          for (let h = 0, u = o.selections.length; h < u; h++)
            a[h] = o.selections[h].getPosition();
          const l = {
            position: a[0],
            secondaryPositions: a.slice(1),
            reason: o.reason,
            source: o.source
          };
          this._onDidChangeCursorPosition.fire(l);
          const c = {
            selection: o.selections[0],
            secondarySelections: o.selections.slice(1),
            modelVersionId: o.modelVersionId,
            oldSelections: o.oldSelections,
            oldModelVersionId: o.oldModelVersionId,
            source: o.source,
            reason: o.reason
          };
          this._onDidChangeCursorSelection.fire(c);
          break;
        }
        case 7:
          this._onDidChangeModelDecorations.fire(o.event);
          break;
        case 8:
          this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(o.event);
          break;
        case 9:
          this._onDidChangeModelLanguageConfiguration.fire(o.event);
          break;
        case 10:
          this._onDidChangeModelContent.fire(o.event);
          break;
        case 11:
          this._onDidChangeModelOptions.fire(o.event);
          break;
        case 12:
          this._onDidChangeModelTokens.fire(o.event);
          break;
      }
    }));
    const [n, r] = this._createView(i);
    if (r) {
      this._domElement.appendChild(n.domNode.domNode);
      let o = Object.keys(this._contentWidgets);
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a];
        n.addContentWidget(this._contentWidgets[c]);
      }
      o = Object.keys(this._overlayWidgets);
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a];
        n.addOverlayWidget(this._overlayWidgets[c]);
      }
      n.render(!1, !0), n.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new y3(e, i, n, r, t);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (r, o, a, l) => {
        this._paste("keyboard", r, o, a, l);
      },
      type: (r) => {
        this._type("keyboard", r);
      },
      compositionType: (r, o, a, l) => {
        this._compositionType("keyboard", r, o, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (r, o, a, l) => {
        const c = { text: r, pasteOnNewLine: o, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", c);
      },
      type: (r) => {
        const o = { text: r };
        this._commandService.executeCommand("type", o);
      },
      compositionType: (r, o, a, l) => {
        if (a || l) {
          const c = { text: r, replacePrevCharCnt: o, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", c);
        } else {
          const c = { text: r, replaceCharCnt: o };
          this._commandService.executeCommand("replacePreviousChar", c);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new om(e.coordinatesConverter);
    return i.onKeyDown = (r) => this._onKeyDown.fire(r), i.onKeyUp = (r) => this._onKeyUp.fire(r), i.onContextMenu = (r) => this._onContextMenu.fire(r), i.onMouseMove = (r) => this._onMouseMove.fire(r), i.onMouseLeave = (r) => this._onMouseLeave.fire(r), i.onMouseDown = (r) => this._onMouseDown.fire(r), i.onMouseUp = (r) => this._onMouseUp.fire(r), i.onMouseDrag = (r) => this._onMouseDrag.fire(r), i.onMouseDrop = (r) => this._onMouseDrop.fire(r), i.onMouseDropCanceled = (r) => this._onMouseDropCanceled.fire(r), i.onMouseWheel = (r) => this._onMouseWheel.fire(r), [new nP(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode), !0];
  }
  _postDetachModelCleanup(e) {
    e == null || e.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    if (!this._modelData)
      return null;
    const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && this._domElement.removeChild(t), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._domElement.removeChild(this._bannerDomNode), e;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
  showDropIndicatorAt(e) {
    const t = [{
      range: new N(e.lineNumber, e.column, e.lineNumber, e.column),
      options: Ha.dropIntoEditorDecorationOptions
    }];
    this._dropIntoEditorDecorations.set(t), this.revealPosition(e, 1);
  }
  removeDropIndicator() {
    this._dropIntoEditorDecorations.clear();
  }
};
ru.dropIntoEditorDecorationOptions = mt.register({
  description: "workbench-dnd-target",
  className: "dnd-target"
});
ru = v3([
  Ns(3, It),
  Ns(4, Ct),
  Ns(5, an),
  Ns(6, Qe),
  Ns(7, vt),
  Ns(8, vs),
  Ns(9, ha),
  Ns(10, bs),
  Ns(11, De)
], ru);
class ty extends z {
  constructor(e) {
    super(), this._emitterOptions = e, this._onDidChangeToTrue = this._register(new A(this._emitterOptions)), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new A(this._emitterOptions)), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class L3 extends z {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = j.editorSimpleInput.bindTo(t), this._editorFocus = j.focus.bindTo(t), this._textInputFocus = j.textInputFocus.bindTo(t), this._editorTextFocus = j.editorTextFocus.bindTo(t), this._editorTabMovesFocus = j.tabMovesFocus.bindTo(t), this._editorReadonly = j.readOnly.bindTo(t), this._inDiffEditor = j.inDiffEditor.bindTo(t), this._editorColumnSelection = j.columnSelection.bindTo(t), this._hasMultipleSelections = j.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = j.hasNonEmptySelection.bindTo(t), this._canUndo = j.canUndo.bindTo(t), this._canRedo = j.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._editorTabMovesFocus.set(e.get(132)), this._editorReadonly.set(e.get(83)), this._inDiffEditor.set(e.get(56)), this._editorColumnSelection.set(e.get(18));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(Boolean(e && e.canUndo())), this._canRedo.set(Boolean(e && e.canRedo()));
  }
}
class k3 extends z {
  constructor(e, t, i) {
    super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = j.languageId.bindTo(t), this._hasCompletionItemProvider = j.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = j.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = j.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = j.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = j.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = j.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = j.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = j.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = j.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = j.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = j.hasReferenceProvider.bindTo(t), this._hasRenameProvider = j.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = j.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = j.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = j.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = j.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = j.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = j.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInWalkThrough = j.isInWalkThroughSnippet.bindTo(t);
    const n = () => this._update();
    this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInWalkThrough.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInWalkThrough.set(e.uri.scheme === we.walkThroughSnippet);
    });
  }
}
class D3 extends z {
  constructor(e) {
    super(), this._onChange = this._register(new A()), this.onChange = this._onChange.event, this._hasFocus = !1, this._domFocusTracker = this._register(Hg(e)), this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasFocus = !0, this._onChange.fire(void 0);
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasFocus = !1, this._onChange.fire(void 0);
    }));
  }
  hasFocus() {
    return this._hasFocus;
  }
}
class E3 {
  constructor(e, t) {
    this._editor = e, this._decorationIds = [], this._isChangingDecorations = !1, Array.isArray(t) && t.length > 0 && this.set(t);
  }
  get length() {
    return this._decorationIds.length;
  }
  onDidChange(e, t, i) {
    return this._editor.onDidChangeModelDecorations((n) => {
      this._isChangingDecorations || e.call(t, n);
    }, i);
  }
  getRange(e) {
    return !this._editor.hasModel() || e >= this._decorationIds.length ? null : this._editor.getModel().getDecorationRange(this._decorationIds[e]);
  }
  getRanges() {
    if (!this._editor.hasModel())
      return [];
    const e = this._editor.getModel(), t = [];
    for (const i of this._decorationIds) {
      const n = e.getDecorationRange(i);
      n && t.push(n);
    }
    return t;
  }
  has(e) {
    return this._decorationIds.includes(e.id);
  }
  clear() {
    this._decorationIds.length !== 0 && this.set([]);
  }
  set(e) {
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((t) => {
        this._decorationIds = t.deltaDecorations(this._decorationIds, e);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
  }
}
const x3 = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), I3 = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function Op(s) {
  return x3 + encodeURIComponent(s.toString()) + I3;
}
const N3 = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), T3 = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function M3(s) {
  return N3 + encodeURIComponent(s.toString()) + T3;
}
zi((s, e) => {
  const t = s.getColor(MA);
  t && e.addRule(`.monaco-editor .squiggly-error { border-bottom: 4px double ${t}; }`);
  const i = s.getColor(Qs);
  i && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${Op(i)}") repeat-x bottom left; }`);
  const n = s.getColor(TA);
  n && e.addRule(`.monaco-editor .squiggly-error::before { display: block; content: ''; width: 100%; height: 100%; background: ${n}; }`);
  const r = s.getColor(jh);
  r && e.addRule(`.monaco-editor .squiggly-warning { border-bottom: 4px double ${r}; }`);
  const o = s.getColor(Xi);
  o && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${Op(o)}") repeat-x bottom left; }`);
  const a = s.getColor(AA);
  a && e.addRule(`.monaco-editor .squiggly-warning::before { display: block; content: ''; width: 100%; height: 100%; background: ${a}; }`);
  const l = s.getColor(A1);
  l && e.addRule(`.monaco-editor .squiggly-info { border-bottom: 4px double ${l}; }`);
  const c = s.getColor(Mn);
  c && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${Op(c)}") repeat-x bottom left; }`);
  const h = s.getColor(RA);
  h && e.addRule(`.monaco-editor .squiggly-info::before { display: block; content: ''; width: 100%; height: 100%; background: ${h}; }`);
  const u = s.getColor(OA);
  u && e.addRule(`.monaco-editor .squiggly-hint { border-bottom: 2px dotted ${u}; }`);
  const d = s.getColor(PA);
  d && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${M3(d)}") no-repeat bottom left; }`);
  const f = s.getColor(wR);
  f && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${f.rgba.a}; }`);
  const m = s.getColor(vR);
  m && e.addRule(`.monaco-editor.showUnused .squiggly-unnecessary { border-bottom: 2px dashed ${m}; }`);
  const _ = s.getColor(mc) || "inherit";
  e.addRule(`.monaco-editor.showDeprecated .squiggly-inline-deprecated { text-decoration: line-through; text-decoration-color: ${_}}`);
});
class Ve {
  constructor(e, t, i) {
    const n = (r) => this.emitter.fire(r);
    this.emitter = new A({
      onFirstListenerAdd: () => e.addEventListener(t, n, i),
      onLastListenerRemove: () => e.removeEventListener(t, n, i)
    });
  }
  get event() {
    return this.emitter.event;
  }
  dispose() {
    this.emitter.dispose();
  }
}
function J1(s) {
  return s.preventDefault(), s.stopPropagation(), s;
}
var bc = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
};
const A3 = !1;
var iy;
(function(s) {
  s.North = "north", s.South = "south", s.East = "east", s.West = "west";
})(iy || (iy = {}));
let R3 = 4;
const P3 = new A();
let O3 = 300;
const F3 = new A();
class yC {
  constructor() {
    this.disposables = new le();
  }
  get onPointerMove() {
    return this.disposables.add(new Ve(window, "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Ve(window, "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
bc([
  dt
], yC.prototype, "onPointerMove", null);
bc([
  dt
], yC.prototype, "onPointerUp", null);
class LC {
  constructor(e) {
    this.el = e, this.disposables = new le();
  }
  get onPointerMove() {
    return this.disposables.add(new Ve(this.el, We.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Ve(this.el, We.End)).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
bc([
  dt
], LC.prototype, "onPointerMove", null);
bc([
  dt
], LC.prototype, "onPointerUp", null);
class Yf {
  constructor(e) {
    this.factory = e;
  }
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  dispose() {
  }
}
bc([
  dt
], Yf.prototype, "onPointerMove", null);
bc([
  dt
], Yf.prototype, "onPointerUp", null);
const ny = "pointer-events-disabled";
class ji extends z {
  constructor(e, t, i) {
    super(), this.hoverDelay = O3, this.hoverDelayer = this._register(new Og(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new A()), this._onDidStart = this._register(new A()), this._onDidChange = this._register(new A()), this._onDidReset = this._register(new A()), this._onDidEnd = this._register(new A()), this.orthogonalStartSashDisposables = this._register(new le()), this.orthogonalStartDragHandleDisposables = this._register(new le()), this.orthogonalEndSashDisposables = this._register(new le()), this.orthogonalEndDragHandleDisposables = this._register(new le()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = Y(e, ae(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), Ie && this.el.classList.add("mac");
    const n = this._register(new Ve(this.el, "mousedown")).event;
    this._register(n((u) => this.onPointerStart(u, new yC()), this));
    const r = this._register(new Ve(this.el, "dblclick")).event;
    this._register(r(this.onPointerDoublePress, this));
    const o = this._register(new Ve(this.el, "mouseenter")).event;
    this._register(o(() => ji.onMouseEnter(this)));
    const a = this._register(new Ve(this.el, "mouseleave")).event;
    this._register(a(() => ji.onMouseLeave(this))), this._register(Ne.addTarget(this.el));
    const l = Q.map(this._register(new Ve(this.el, We.Start)).event, (u) => {
      var d;
      return Object.assign(Object.assign({}, u), { target: (d = u.initialTarget) !== null && d !== void 0 ? d : null });
    });
    this._register(l((u) => this.onPointerStart(u, new LC(this.el)), this));
    const c = this._register(new Ve(this.el, We.Tap)).event, h = Q.map(Q.filter(Q.debounce(c, (u, d) => {
      var f;
      return { event: d, count: ((f = u == null ? void 0 : u.count) !== null && f !== void 0 ? f : 0) + 1 };
    }, 250), ({ count: u }) => u === 2), ({ event: u }) => {
      var d;
      return Object.assign(Object.assign({}, u), { target: (d = u.initialTarget) !== null && d !== void 0 ? d : null });
    });
    this._register(h(this.onPointerDoublePress, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = R3, this._register(P3.event((u) => {
      this.size = u, this.layout();
    }))), this._register(F3.event((u) => this.hoverDelay = u)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", A3), this.layout();
  }
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set state(e) {
    this._state !== e && (this.el.classList.toggle("disabled", e === 0), this.el.classList.toggle("minimum", e === 1), this.el.classList.toggle("maximum", e === 2), this._state = e, this.onDidEnablementChange.fire(e));
  }
  set orthogonalStartSash(e) {
    if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
      const t = (i) => {
        this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = Y(this.el, ae(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(ze(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new Ve(this._orthogonalStartDragHandle, "mouseenter")).event(() => ji.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new Ve(this._orthogonalStartDragHandle, "mouseleave")).event(() => ji.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
      };
      this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
    }
    this._orthogonalStartSash = e;
  }
  set orthogonalEndSash(e) {
    if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
      const t = (i) => {
        this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = Y(this.el, ae(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(ze(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Ve(this._orthogonalEndDragHandle, "mouseenter")).event(() => ji.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Ve(this._orthogonalEndDragHandle, "mouseleave")).event(() => ji.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
      };
      this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
    }
    this._orthogonalEndSash = e;
  }
  onPointerStart(e, t) {
    Oe.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const m = this.getOrthogonalSash(e);
      m && (i = !0, e.__orthogonalSashEvent = !0, m.onPointerStart(e, new Yf(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new Yf(t))), !this.state)
      return;
    const n = qM("iframe");
    for (const m of n)
      m.classList.add(ny);
    const r = e.pageX, o = e.pageY, a = e.altKey, l = { startX: r, currentX: r, startY: o, currentY: o, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const c = Vn(this.el), h = () => {
      let m = "";
      i ? m = "all-scroll" : this.orientation === 1 ? this.state === 1 ? m = "s-resize" : this.state === 2 ? m = "n-resize" : m = Ie ? "row-resize" : "ns-resize" : this.state === 1 ? m = "e-resize" : this.state === 2 ? m = "w-resize" : m = Ie ? "col-resize" : "ew-resize", c.textContent = `* { cursor: ${m} !important; }`;
    }, u = new le();
    h(), i || this.onDidEnablementChange.event(h, null, u);
    const d = (m) => {
      Oe.stop(m, !1);
      const _ = { startX: r, currentX: m.pageX, startY: o, currentY: m.pageY, altKey: a };
      this._onDidChange.fire(_);
    }, f = (m) => {
      Oe.stop(m, !1), this.el.removeChild(c), this.el.classList.remove("active"), this._onDidEnd.fire(), u.dispose();
      for (const _ of n)
        _.classList.remove(ny);
    };
    t.onPointerMove(d, null, u), t.onPointerUp(f, null, u), u.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && ji.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && ji.onMouseLeave(e.linkedSash, !0);
  }
  clearSashHoverState() {
    ji.onMouseLeave(this);
  }
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  getOrthogonalSash(e) {
    if (!(!e.target || !(e.target instanceof HTMLElement)) && e.target.classList.contains("orthogonal-drag-handle"))
      return e.target.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
class kC {
  constructor(e, t, i) {
    this._visiblePosition = e, this._visiblePositionScrollDelta = t, this._cursorPosition = i;
  }
  static capture(e) {
    let t = null, i = 0;
    if (e.getScrollTop() !== 0) {
      const n = e.getVisibleRanges();
      if (n.length > 0) {
        t = n[0].getStartPosition();
        const r = e.getTopForPosition(t.lineNumber, t.column);
        i = e.getScrollTop() - r;
      }
    }
    return new kC(t, i, e.getPosition());
  }
  restore(e) {
    if (this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(e.getScrollTop() + i);
  }
}
const IE = {
  RESOURCES: "ResourceURLs",
  DOWNLOAD_URL: "DownloadURL",
  FILES: "Files",
  TEXT: zs.text
}, bo = {
  CurrentDragAndDropData: void 0
};
var sy, ry;
class B3 {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class V3 {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? Sb(e, this._value, 0, e.length, this._from, this._to) : Iu(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class W3 {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
    for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
      const i = this._value.charCodeAt(t);
      if (!(i === 47 || this._splitOnBackslash && i === 92))
        break;
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._valueLen; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? Sb(e, this._value, 0, e.length, this._from, this._to) : Iu(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class H3 {
  constructor(e, t) {
    this._ignorePathCasing = e, this._ignoreQueryAndFragment = t, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(1), this._value.authority && this._states.push(2), this._value.path && (this._pathIterator = new W3(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(3)), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(4), this._value.fragment && this._states.push(5)), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return Zv(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return Zv(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return t1(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return t1(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class Sd {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const e = this.right;
    return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
  }
  rotateRight() {
    const e = this.left;
    return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    var e, t;
    return (t = (e = this.left) === null || e === void 0 ? void 0 : e.height) !== null && t !== void 0 ? t : 0;
  }
  get heightRight() {
    var e, t;
    return (t = (e = this.right) === null || e === void 0 ? void 0 : e.height) !== null && t !== void 0 ? t : 0;
  }
}
class wh {
  constructor(e) {
    this._iter = e;
  }
  static forUris(e = () => !1, t = () => !1) {
    return new wh(new H3(e, t));
  }
  static forStrings() {
    return new wh(new B3());
  }
  static forConfigKeys() {
    return new wh(new V3());
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let n;
    this._root || (this._root = new Sd(), this._root.segment = i.value());
    const r = [];
    for (n = this._root; ; ) {
      const a = i.cmp(n.segment);
      if (a > 0)
        n.left || (n.left = new Sd(), n.left.segment = i.value()), r.push([-1, n]), n = n.left;
      else if (a < 0)
        n.right || (n.right = new Sd(), n.right.segment = i.value()), r.push([1, n]), n = n.right;
      else if (i.hasNext())
        i.next(), n.mid || (n.mid = new Sd(), n.mid.segment = i.value()), r.push([0, n]), n = n.mid;
      else
        break;
    }
    const o = n.value;
    n.value = t, n.key = e;
    for (let a = r.length - 1; a >= 0; a--) {
      const l = r[a][1];
      l.updateHeight();
      const c = l.balanceFactor();
      if (c < -1 || c > 1) {
        const h = r[a][0], u = r[a + 1][0];
        if (h === 1 && u === 1)
          r[a][1] = l.rotateLeft();
        else if (h === -1 && u === -1)
          r[a][1] = l.rotateRight();
        else if (h === 1 && u === -1)
          l.right = r[a + 1][1] = r[a + 1][1].rotateRight(), r[a][1] = l.rotateLeft();
        else if (h === -1 && u === 1)
          l.left = r[a + 1][1] = r[a + 1][1].rotateLeft(), r[a][1] = l.rotateRight();
        else
          throw new Error();
        if (a > 0)
          switch (r[a - 1][0]) {
            case -1:
              r[a - 1][1].left = r[a][1];
              break;
            case 1:
              r[a - 1][1].right = r[a][1];
              break;
            case 0:
              r[a - 1][1].mid = r[a][1];
              break;
          }
        else
          this._root = r[0][1];
      }
    }
    return o;
  }
  get(e) {
    var t;
    return (t = this._getNode(e)) === null || t === void 0 ? void 0 : t.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const n = t.cmp(i.segment);
      if (n > 0)
        i = i.left;
      else if (n < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    var i;
    const n = this._iter.reset(e), r = [];
    let o = this._root;
    for (; o; ) {
      const a = n.cmp(o.segment);
      if (a > 0)
        r.push([-1, o]), o = o.left;
      else if (a < 0)
        r.push([1, o]), o = o.right;
      else if (n.hasNext())
        n.next(), r.push([0, o]), o = o.mid;
      else
        break;
    }
    if (!!o) {
      if (t ? (o.left = void 0, o.mid = void 0, o.right = void 0, o.height = 1) : (o.key = void 0, o.value = void 0), !o.mid && !o.value)
        if (o.left && o.right) {
          const a = this._min(o.right), { key: l, value: c, segment: h } = a;
          this._delete(a.key, !1), o.key = l, o.value = c, o.segment = h;
        } else {
          const a = (i = o.left) !== null && i !== void 0 ? i : o.right;
          if (r.length > 0) {
            const [l, c] = r[r.length - 1];
            switch (l) {
              case -1:
                c.left = a;
                break;
              case 0:
                c.mid = a;
                break;
              case 1:
                c.right = a;
                break;
            }
          } else
            this._root = a;
        }
      for (let a = r.length - 1; a >= 0; a--) {
        const l = r[a][1];
        l.updateHeight();
        const c = l.balanceFactor();
        if (c > 1 ? (l.right.balanceFactor() >= 0 || (l.right = l.right.rotateRight()), r[a][1] = l.rotateLeft()) : c < -1 && (l.left.balanceFactor() <= 0 || (l.left = l.left.rotateLeft()), r[a][1] = l.rotateRight()), a > 0)
          switch (r[a - 1][0]) {
            case -1:
              r[a - 1][1].left = r[a][1];
              break;
            case 1:
              r[a - 1][1].right = r[a][1];
              break;
            case 0:
              r[a - 1][1].mid = r[a][1];
              break;
          }
        else
          this._root = r[0][1];
      }
    }
  }
  _min(e) {
    for (; e.left; )
      e = e.left;
    return e;
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, n;
    for (; i; ) {
      const r = t.cmp(i.segment);
      if (r > 0)
        i = i.left;
      else if (r < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), n = i.value || n, i = i.mid;
      else
        break;
    }
    return i && i.value || n;
  }
  findSuperstr(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const n = t.cmp(i.segment);
      if (n > 0)
        i = i.left;
      else if (n < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        return i.mid ? this._entries(i.mid) : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(e) {
    const t = [];
    return this._dfsEntries(e, t), t[Symbol.iterator]();
  }
  _dfsEntries(e, t) {
    !e || (e.left && this._dfsEntries(e.left, t), e.value && t.push([e.key, e.value]), e.mid && this._dfsEntries(e.mid, t), e.right && this._dfsEntries(e.right, t));
  }
}
class z3 {
  constructor(e, t) {
    this.uri = e, this.value = t;
  }
}
class si {
  constructor(e, t) {
    this[sy] = "ResourceMap", e instanceof si ? (this.map = new Map(e.map), this.toKey = t != null ? t : si.defaultToKey) : (this.map = /* @__PURE__ */ new Map(), this.toKey = e != null ? e : si.defaultToKey);
  }
  set(e, t) {
    return this.map.set(this.toKey(e), new z3(e, t)), this;
  }
  get(e) {
    var t;
    return (t = this.map.get(this.toKey(e))) === null || t === void 0 ? void 0 : t.value;
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, t) {
    typeof t < "u" && (e = e.bind(t));
    for (const [i, n] of this.map)
      e(n.value, n.uri, this);
  }
  *values() {
    for (const e of this.map.values())
      yield e.value;
  }
  *keys() {
    for (const e of this.map.values())
      yield e.uri;
  }
  *entries() {
    for (const e of this.map.values())
      yield [e.uri, e.value];
  }
  *[(sy = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, e] of this.map)
      yield [e.uri, e.value];
  }
}
si.defaultToKey = (s) => s.toString();
class U3 {
  constructor() {
    this[ry] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var e;
    return (e = this._head) === null || e === void 0 ? void 0 : e.value;
  }
  get last() {
    var e;
    return (e = this._tail) === null || e === void 0 ? void 0 : e.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, t = 0) {
    const i = this._map.get(e);
    if (!!i)
      return t !== 0 && this.touch(i, t), i.value;
  }
  set(e, t, i = 0) {
    let n = this._map.get(e);
    if (n)
      n.value = t, i !== 0 && this.touch(n, i);
    else {
      switch (n = { key: e, value: t, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(n);
          break;
        case 1:
          this.addItemFirst(n);
          break;
        case 2:
          this.addItemLast(n);
          break;
        default:
          this.addItemLast(n);
          break;
      }
      this._map.set(e, n), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const t = this._map.get(e);
    if (!!t)
      return this._map.delete(e), this.removeItem(t), this._size--, t.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, t) {
    const i = this._state;
    let n = this._head;
    for (; n; ) {
      if (t ? e.bind(t)(n.value, n.key, this) : e(n.value, n.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      n = n.next;
    }
  }
  keys() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const r = { value: i.key, done: !1 };
          return i = i.next, r;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  values() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const r = { value: i.value, done: !1 };
          return i = i.next, r;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  entries() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const r = { value: [i.key, i.value], done: !1 };
          return i = i.next, r;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  [(ry = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._head, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.next, i--;
    this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const t = e.next, i = e.previous;
      if (!t || !i)
        throw new Error("Invalid list");
      t.previous = i, i.next = t;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, t) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(t !== 1 && t !== 2)) {
      if (t === 1) {
        if (e === this._head)
          return;
        const i = e.next, n = e.previous;
        e === this._tail ? (n.next = void 0, this._tail = n) : (i.previous = n, n.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (t === 2) {
        if (e === this._tail)
          return;
        const i = e.next, n = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = n, n.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((t, i) => {
      e.push([i, t]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [t, i] of e)
      this.set(t, i);
  }
}
class DC extends U3 {
  constructor(e, t = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, t = 2) {
    return super.get(e, t);
  }
  peek(e) {
    return super.get(e, 0);
  }
  set(e, t) {
    return super.set(e, t, 2), this.checkTrim(), this;
  }
  checkTrim() {
    this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
  }
}
function NE(...s) {
  return function(e, t) {
    for (let i = 0, n = s.length; i < n; i++) {
      const r = s[i](e, t);
      if (r)
        return r;
    }
    return null;
  };
}
TE.bind(void 0, !1);
const EC = TE.bind(void 0, !0);
function TE(s, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return s ? i = yb(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function $3(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + s.length }];
}
function j3(s, e) {
  return e0(s.toLowerCase(), e.toLowerCase(), 0, 0);
}
function e0(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] === e[i]) {
    let n = null;
    return (n = e0(s, e, t + 1, i + 1)) ? AE({ start: i, end: i + 1 }, n) : null;
  }
  return e0(s, e, t, i + 1);
}
function xC(s) {
  return 97 <= s && s <= 122;
}
function hm(s) {
  return 65 <= s && s <= 90;
}
function IC(s) {
  return 48 <= s && s <= 57;
}
function K3(s) {
  return s === 32 || s === 9 || s === 10 || s === 13;
}
const q3 = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => q3.add(s.charCodeAt(0)));
function ME(s) {
  return xC(s) || hm(s) || IC(s);
}
function AE(s, e) {
  return e.length === 0 ? e = [s] : s.end === e[0].start ? e[0].start = s.start : e.unshift(s), e;
}
function RE(s, e) {
  for (let t = e; t < s.length; t++) {
    const i = s.charCodeAt(t);
    if (hm(i) || IC(i) || t > 0 && !ME(s.charCodeAt(t - 1)))
      return t;
  }
  return s.length;
}
function t0(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] !== e[i].toLowerCase())
    return null;
  {
    let n = null, r = i + 1;
    for (n = t0(s, e, t + 1, i + 1); !n && (r = RE(e, r)) < e.length; )
      n = t0(s, e, t + 1, r), r++;
    return n === null ? null : AE({ start: i, end: i + 1 }, n);
  }
}
function G3(s) {
  let e = 0, t = 0, i = 0, n = 0, r = 0;
  for (let h = 0; h < s.length; h++)
    r = s.charCodeAt(h), hm(r) && e++, xC(r) && t++, ME(r) && i++, IC(r) && n++;
  const o = e / s.length, a = t / s.length, l = i / s.length, c = n / s.length;
  return { upperPercent: o, lowerPercent: a, alphaPercent: l, numericPercent: c };
}
function Z3(s) {
  const { upperPercent: e, lowerPercent: t } = s;
  return t === 0 && e > 0.6;
}
function Y3(s) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = s;
  return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
}
function Q3(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let r = 0; r < s.length; r++)
    i = s.charCodeAt(r), hm(i) && e++, xC(i) && t++, K3(i) && n++;
  return (e === 0 || t === 0) && n === 0 ? s.length <= 30 : e <= 5;
}
function PE(s, e) {
  if (!e || (e = e.trim(), e.length === 0) || !Q3(s) || e.length > 60)
    return null;
  const t = G3(e);
  if (!Y3(t)) {
    if (!Z3(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, n = 0;
  for (s = s.toLowerCase(); n < e.length && (i = t0(s, e, 0, n)) === null; )
    n = RE(e, n + 1);
  return i;
}
const X3 = NE(EC, PE, $3), J3 = NE(EC, PE, j3), oy = new DC(1e4);
function ay(s, e, t = !1) {
  if (typeof s != "string" || typeof e != "string")
    return null;
  let i = oy.get(s);
  i || (i = new RegExp(kT(s), "i"), oy.set(s, i));
  const n = i.exec(e);
  return n ? [{ start: n.index, end: n.index + n[0].length }] : t ? J3(s, e) : X3(s, e);
}
const Wr = 128;
function NC() {
  const s = [], e = [];
  for (let t = 0; t <= Wr; t++)
    e[t] = 0;
  for (let t = 0; t <= Wr; t++)
    s.push(e.slice(0));
  return s;
}
function OE(s) {
  const e = [];
  for (let t = 0; t <= s; t++)
    e[t] = 0;
  return e;
}
const FE = OE(2 * Wr), i0 = OE(2 * Wr), Ts = NC(), Co = NC(), yd = NC();
function Ld(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  const t = s.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return !0;
    case void 0:
      return !1;
    default:
      return !!xb(t);
  }
}
function ly(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  switch (s.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function Qd(s, e, t) {
  return e[s] !== t[s];
}
function eO(s, e, t, i, n, r, o = !1) {
  for (; e < t && n < r; )
    s[e] === i[n] && (o && (FE[e] = n), e += 1), n += 1;
  return e === t;
}
var Ll;
(function(s) {
  s.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  s.isDefault = e;
})(Ll || (Ll = {}));
class BE {
  constructor(e, t) {
    this.firstMatchCanBeWeak = e, this.boostFullMatch = t;
  }
}
BE.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 };
function tO(s, e, t, i, n, r, o = BE.default) {
  const a = s.length > Wr ? Wr : s.length, l = i.length > Wr ? Wr : i.length;
  if (t >= a || r >= l || a - t > l - r || !eO(e, t, a, n, r, l, !0))
    return;
  iO(a, l, t, r, e, n);
  let c = 1, h = 1, u = t, d = r;
  const f = [!1];
  for (c = 1, u = t; u < a; c++, u++) {
    const C = FE[u], w = i0[u], L = u + 1 < a ? i0[u + 1] : l;
    for (h = C - r + 1, d = C; d < L; h++, d++) {
      let E = Number.MIN_SAFE_INTEGER, k = !1;
      d <= w && (E = nO(s, e, u, t, i, n, d, l, r, Ts[c - 1][h - 1] === 0, f));
      let y = 0;
      E !== Number.MAX_SAFE_INTEGER && (k = !0, y = E + Co[c - 1][h - 1]);
      const S = d > C, D = S ? Co[c][h - 1] + (Ts[c][h - 1] > 0 ? -5 : 0) : 0, T = d > C + 1 && Ts[c][h - 1] > 0, M = T ? Co[c][h - 2] + (Ts[c][h - 2] > 0 ? -5 : 0) : 0;
      if (T && (!S || M >= D) && (!k || M >= y))
        Co[c][h] = M, yd[c][h] = 3, Ts[c][h] = 0;
      else if (S && (!k || D >= y))
        Co[c][h] = D, yd[c][h] = 2, Ts[c][h] = 0;
      else if (k)
        Co[c][h] = y, yd[c][h] = 1, Ts[c][h] = Ts[c - 1][h - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!f[0] && !o.firstMatchCanBeWeak)
    return;
  c--, h--;
  const m = [Co[c][h], r];
  let _ = 0, b = 0;
  for (; c >= 1; ) {
    let C = h;
    do {
      const w = yd[c][C];
      if (w === 3)
        C = C - 2;
      else if (w === 2)
        C = C - 1;
      else
        break;
    } while (C >= 1);
    _ > 1 && e[t + c - 1] === n[r + h - 1] && !Qd(C + r - 1, i, n) && _ + 1 > Ts[c][C] && (C = h), C === h ? _++ : _ = 1, b || (b = C), c--, h = C - 1, m.push(h);
  }
  l === a && o.boostFullMatch && (m[0] += 2);
  const v = b - a;
  return m[0] -= v, m;
}
function iO(s, e, t, i, n, r) {
  let o = s - 1, a = e - 1;
  for (; o >= t && a >= i; )
    n[o] === r[a] && (i0[o] = a, o--), a--;
}
function nO(s, e, t, i, n, r, o, a, l, c, h) {
  if (e[t] !== r[o])
    return Number.MIN_SAFE_INTEGER;
  let u = 1, d = !1;
  return o === t - i ? u = s[t] === n[o] ? 7 : 5 : Qd(o, n, r) && (o === 0 || !Qd(o - 1, n, r)) ? (u = s[t] === n[o] ? 7 : 5, d = !0) : Ld(r, o) && (o === 0 || !Ld(r, o - 1)) ? u = 5 : (Ld(r, o - 1) || ly(r, o - 1)) && (u = 5, d = !0), u > 1 && t === i && (h[0] = !0), d || (d = Qd(o, n, r) || Ld(r, o - 1) || ly(r, o - 1)), t === i ? o > l && (u -= d ? 3 : 5) : c ? u += d ? 2 : 0 : u += d ? 0 : 1, o + 1 === a && (u -= d ? 3 : 5), u;
}
const Sh = "$(", TC = new RegExp(`\\$\\(${Di.iconNameExpression}(?:${Di.iconModifierExpression})?\\)`, "g"), sO = new RegExp(Di.iconNameCharacter), rO = new RegExp(`(\\\\)?${TC.source}`, "g");
function oO(s) {
  return s.replace(rO, (e, t) => t ? e : `\\${e}`);
}
new RegExp(`\\\\${TC.source}`, "g");
const aO = new RegExp(`(\\s)?(\\\\)?${TC.source}(\\s)?`, "g");
function VE(s) {
  return s.indexOf(Sh) === -1 ? s : s.replace(aO, (e, t, i, n) => i ? e : t || n || "");
}
function Pa(s) {
  const e = s.indexOf(Sh);
  return e === -1 ? { text: s } : lO(s, e);
}
function lO(s, e) {
  const t = [];
  let i = "";
  function n(d) {
    if (d) {
      i += d;
      for (const f of d)
        t.push(a);
    }
  }
  let r = -1, o = "", a = 0, l, c, h = e;
  const u = s.length;
  for (n(s.substr(0, e)); h < u; ) {
    if (l = s[h], c = s[h + 1], l === Sh[0] && c === Sh[1])
      r = h, n(o), o = Sh, h++;
    else if (l === ")" && r !== -1) {
      const d = h - r + 1;
      a += d, r = -1, o = "";
    } else
      r !== -1 ? sO.test(l) ? o += l : (n(o), r = -1, o = "") : n(l);
    h++;
  }
  return n(o), { text: i, iconOffsets: t };
}
function kd(s, e, t = !1) {
  const { text: i, iconOffsets: n } = e;
  if (!n || n.length === 0)
    return ay(s, i, t);
  const r = wb(i, " "), o = i.length - r.length, a = ay(s, r, t);
  if (a)
    for (const l of a) {
      const c = n[l.start + o] + o;
      l.start += c, l.end += c;
    }
  return a;
}
class cO {
  constructor(e = "", t = !1) {
    var i, n, r;
    if (this.value = e, typeof this.value != "string")
      throw gb("value");
    typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = (i = t.isTrusted) !== null && i !== void 0 ? i : void 0, this.supportThemeIcons = (n = t.supportThemeIcons) !== null && n !== void 0 ? n : !1, this.supportHtml = (r = t.supportHtml) !== null && r !== void 0 ? r : !1);
  }
  appendText(e, t = 0) {
    return this.value += uO(this.supportThemeIcons ? oO(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
  }
  appendMarkdown(e) {
    return this.value += e, this;
  }
  appendCodeblock(e, t) {
    return this.value += "\n```", this.value += e, this.value += `
`, this.value += t, this.value += "\n```\n", this;
  }
  appendLink(e, t, i) {
    return this.value += "[", this.value += this._escape(t, "]"), this.value += "](", this.value += this._escape(String(e), ")"), i && (this.value += ` "${this._escape(this._escape(i, '"'), ")")}"`), this.value += ")", this;
  }
  _escape(e, t) {
    const i = new RegExp(sr(t), "g");
    return e.replace(i, (n, r) => e.charAt(r - 1) !== "\\" ? `\\${n}` : n);
  }
}
function hO(s) {
  return s instanceof cO ? !0 : s && typeof s == "object" ? typeof s.value == "string" && (typeof s.isTrusted == "boolean" || s.isTrusted === void 0) && (typeof s.supportThemeIcons == "boolean" || s.supportThemeIcons === void 0) : !1;
}
function uO(s) {
  return s.replace(/[\\`*_{}[\]()#+\-!]/g, "\\$&");
}
var n0 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
function dO(s, e) {
  Fi(e) ? s.title = VE(e) : e != null && e.markdownNotSupportedFallback ? s.title = e.markdownNotSupportedFallback : s.removeAttribute("title");
}
class fO {
  constructor(e, t, i) {
    this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
  }
  update(e, t, i) {
    var n;
    return n0(this, void 0, void 0, function* () {
      if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0), this.isDisposed)
        return;
      let r;
      if (e === void 0 || Fi(e) || e instanceof HTMLElement)
        r = e;
      else if (!lf(e.markdown))
        r = (n = e.markdown) !== null && n !== void 0 ? n : e.markdownNotSupportedFallback;
      else {
        this._hoverWidget || this.show(p("iconLabel.loading", "Loading..."), t), this._cancellationTokenSource = new lc();
        const o = this._cancellationTokenSource.token;
        if (r = yield e.markdown(o), r === void 0 && (r = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested)
          return;
      }
      this.show(r, t, i);
    });
  }
  show(e, t, i) {
    const n = this._hoverWidget;
    if (this.hasContent(e)) {
      const r = Object.assign({ content: e, target: this.target, showPointer: this.hoverDelegate.placement === "element", hoverPosition: 2, skipFadeInAnimation: !this.fadeInAnimation || !!n }, i);
      this._hoverWidget = this.hoverDelegate.showHover(r, t);
    }
    n == null || n.dispose();
  }
  hasContent(e) {
    return e ? hO(e) ? !!e.value : !0 : !1;
  }
  get isDisposed() {
    var e;
    return (e = this._hoverWidget) === null || e === void 0 ? void 0 : e.isDisposed;
  }
  dispose() {
    var e, t;
    (e = this._hoverWidget) === null || e === void 0 || e.dispose(), (t = this._cancellationTokenSource) === null || t === void 0 || t.dispose(!0), this._cancellationTokenSource = void 0;
  }
}
function WE(s, e, t, i) {
  let n, r;
  const o = (u, d) => {
    var f;
    u && (r == null || r.dispose(), r = void 0), d && (n == null || n.dispose(), n = void 0), (f = s.onDidHideHover) === null || f === void 0 || f.call(s);
  }, a = (u, d, f) => new oo(() => n0(this, void 0, void 0, function* () {
    (!r || r.isDisposed) && (r = new fO(s, f || e, u > 0), yield r.update(t, d, i));
  }), u), l = () => {
    if (n)
      return;
    const u = new le(), d = (_) => o(!1, _.fromElement === e);
    u.add(H(e, $.MOUSE_LEAVE, d, !0));
    const f = () => o(!0, !0);
    u.add(H(e, $.MOUSE_DOWN, f, !0));
    const m = {
      targetElements: [e],
      dispose: () => {
      }
    };
    if (s.placement === void 0 || s.placement === "mouse") {
      const _ = (b) => {
        m.x = b.x + 10, b.target instanceof HTMLElement && b.target.classList.contains("action-label") && o(!0, !0);
      };
      u.add(H(e, $.MOUSE_MOVE, _, !0));
    }
    u.add(a(s.delay, !1, m)), n = u;
  }, c = H(e, $.MOUSE_OVER, l, !0);
  return {
    show: (u) => {
      o(!1, !0), a(0, u);
    },
    hide: () => {
      o(!0, !0);
    },
    update: (u, d) => n0(this, void 0, void 0, function* () {
      t = u, yield r == null ? void 0 : r.update(t, void 0, d);
    }),
    dispose: () => {
      c.dispose(), o(!0, !0);
    }
  };
}
class Lr extends z {
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof as && this._register(t.onDidChange((n) => {
      !this.element || this.handleActionChangeEvent(n);
    }));
  }
  get action() {
    return this._action;
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new qb())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  getAction() {
    return this._action;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(Ne.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, sn && this._register(H(e, $.DRAG_START, (n) => {
      var r;
      return (r = n.dataTransfer) === null || r === void 0 ? void 0 : r.setData(IE.TEXT, this._action.label);
    }))), this._register(H(t, We.Tap, (n) => this.onClick(n, !0))), this._register(H(t, $.MOUSE_DOWN, (n) => {
      i || Oe.stop(n, !0), this._action.enabled && n.button === 0 && t.classList.add("active");
    })), Ie && this._register(H(t, $.CONTEXT_MENU, (n) => {
      n.button === 0 && n.ctrlKey === !0 && this.onClick(n);
    })), this._register(H(t, $.CLICK, (n) => {
      Oe.stop(n, !0), this.options && this.options.isMenu || this.onClick(n);
    })), this._register(H(t, $.DBLCLICK, (n) => {
      Oe.stop(n, !0);
    })), [$.MOUSE_UP, $.MOUSE_OUT].forEach((n) => {
      this._register(H(t, n, (r) => {
        Oe.stop(r), t.classList.remove("active");
      }));
    });
  }
  onClick(e, t = !1) {
    var i;
    Oe.stop(e, !0);
    const n = Ki(this._context) ? !((i = this.options) === null || i === void 0) && i.useEventAsContext ? e : { preserveFocus: t } : this._context;
    this.actionRunner.run(this._action, n);
  }
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  getTooltip() {
    return this.getAction().tooltip;
  }
  updateTooltip() {
    var e;
    if (!this.element)
      return;
    const t = (e = this.getTooltip()) !== null && e !== void 0 ? e : "";
    this.element.setAttribute("aria-label", t), this.options.hoverDelegate ? (this.element.title = "", this.customHover ? this.customHover.update(t) : (this.customHover = WE(this.options.hoverDelegate, this.element, t), this._store.add(this.customHover))) : this.element.title = t;
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), super.dispose();
  }
}
class HE extends Lr {
  constructor(e, t, i = {}) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), this.element && (this.label = Y(this.element, ae("a.action-label"))), this.label && (this._action.id === ls.ID ? this.label.setAttribute("role", "presentation") : this.options.isMenu ? this.label.setAttribute("role", "menuitem") : this.label.setAttribute("role", "button")), this.options.label && this.options.keybinding && this.element && (Y(this.element, ae("span.keybinding")).textContent = this.options.keybinding), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.getAction().label);
  }
  getTooltip() {
    let e = null;
    return this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && (e = this.getAction().label, this.options.keybinding && (e = p({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e != null ? e : void 0;
  }
  updateClass() {
    var e;
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getAction().class, this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : (e = this.label) === null || e === void 0 || e.classList.remove("codicon");
  }
  updateEnabled() {
    var e, t;
    this.getAction().enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), (e = this.element) === null || e === void 0 || e.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), (t = this.element) === null || t === void 0 || t.classList.add("disabled"));
  }
  updateChecked() {
    this.label && (this.getAction().checked ? this.label.classList.add("checked") : this.label.classList.remove("checked"));
  }
}
var gO = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class Yl extends z {
  constructor(e, t = {}) {
    var i, n, r, o, a, l;
    super(), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new A()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new A({ onFirstListenerAdd: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new A()), this.onDidRun = this._onDidRun.event, this._onBeforeRun = this._register(new A()), this.onBeforeRun = this._onBeforeRun.event, this.options = t, this._context = (i = t.context) !== null && i !== void 0 ? i : null, this._orientation = (n = this.options.orientation) !== null && n !== void 0 ? n : 0, this._triggerKeys = {
      keyDown: (o = (r = this.options.triggerKeys) === null || r === void 0 ? void 0 : r.keyDown) !== null && o !== void 0 ? o : !1,
      keys: (l = (a = this.options.triggerKeys) === null || a === void 0 ? void 0 : a.keys) !== null && l !== void 0 ? l : [3, 10]
    }, this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new qb(), this._register(this._actionRunner)), this._register(this._actionRunner.onDidRun((u) => this._onDidRun.fire(u))), this._register(this._actionRunner.onBeforeRun((u) => this._onBeforeRun.fire(u))), this._actionIds = [], this.viewItems = [], this.viewItemDisposables = /* @__PURE__ */ new Map(), this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar", t.animated !== !1 && this.domNode.classList.add("animated");
    let c, h;
    switch (this._orientation) {
      case 0:
        c = [15], h = [17];
        break;
      case 1:
        c = [16], h = [18], this.domNode.className += " vertical";
        break;
    }
    this._register(H(this.domNode, $.KEY_DOWN, (u) => {
      const d = new nt(u);
      let f = !0;
      const m = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      c && (d.equals(c[0]) || d.equals(c[1])) ? f = this.focusPrevious() : h && (d.equals(h[0]) || d.equals(h[1])) ? f = this.focusNext() : d.equals(9) && this.cancelHasListener ? this._onDidCancel.fire() : d.equals(14) ? f = this.focusFirst() : d.equals(13) ? f = this.focusLast() : d.equals(2) && m instanceof Lr && m.trapsArrowNavigation ? f = this.focusNext() : this.isTriggerKeyEvent(d) ? this._triggerKeys.keyDown ? this.doTrigger(d) : this.triggerKeyDown = !0 : f = !1, f && (d.preventDefault(), d.stopPropagation());
    })), this._register(H(this.domNode, $.KEY_UP, (u) => {
      const d = new nt(u);
      this.isTriggerKeyEvent(d) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(d)), d.preventDefault(), d.stopPropagation()) : (d.equals(2) || d.equals(1026)) && this.updateFocusedItem();
    })), this.focusTracker = this._register(Hg(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (ml() === this.domNode || !ir(ml(), this.domNode)) && (this._onDidBlur.fire(), this.focusedItem = void 0, this.previouslyFocusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  refreshRole() {
    this.length() >= 2 ? this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar") : this.actionsList.setAttribute("role", "presentation");
  }
  setFocusable(e) {
    if (this.focusable = e, this.focusable) {
      const t = this.viewItems.find((i) => i instanceof Lr && i.isEnabled());
      t instanceof Lr && t.setFocusable(!0);
    } else
      this.viewItems.forEach((t) => {
        t instanceof Lr && t.setFocusable(!1);
      });
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    for (let e = 0; e < this.actionsList.children.length; e++) {
      const t = this.actionsList.children[e];
      if (ir(ml(), t)) {
        this.focusedItem = e;
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    e && (this._actionRunner = e, this.viewItems.forEach((t) => t.actionRunner = e));
  }
  getContainer() {
    return this.domNode;
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let n = oc(t.index) ? t.index : null;
    i.forEach((r) => {
      const o = document.createElement("li");
      o.className = "action-item", o.setAttribute("role", "presentation");
      let a;
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(r)), a || (a = new HE(this.context, r, Object.assign({ hoverDelegate: this.options.hoverDelegate }, t))), this.options.allowContextMenu || this.viewItemDisposables.set(a, H(o, $.CONTEXT_MENU, (l) => {
        Oe.stop(l, !0);
      })), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(o), this.focusable && a instanceof Lr && this.viewItems.length === 0 && a.setFocusable(!0), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(o), this.viewItems.push(a), this._actionIds.push(r.id)) : (this.actionsList.insertBefore(o, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), this._actionIds.splice(n, 0, r.id), n++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
  }
  clear() {
    je(this.viewItems), this.viewItemDisposables.forEach((e) => e.dispose()), this.viewItemDisposables.clear(), this.viewItems = [], this._actionIds = [], rn(this.actionsList), this.refreshRole();
  }
  length() {
    return this.viewItems.length;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const n = this.viewItems.findIndex((r) => r.isEnabled());
      this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, !0);
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, !0);
  }
  focusFirst() {
    return this.focusedItem = this.length() - 1, this.focusNext(!0);
  }
  focusLast() {
    return this.focusedItem = 0, this.focusPrevious(!0);
  }
  focusNext(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = t, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === ls.ID));
    return this.updateFocus(), !0;
  }
  focusPrevious(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (!e && this.options.preventLoopNavigation)
          return this.focusedItem = t, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === ls.ID));
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t, i = !1) {
    var n;
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && ((n = this.viewItems[this.previouslyFocusedItem]) === null || n === void 0 || n.blur());
    const r = this.focusedItem !== void 0 && this.viewItems[this.focusedItem];
    if (r) {
      let o = !0;
      lf(r.focus) || (o = !1), this.options.focusOnlyEnabledItems && lf(r.isEnabled) && !r.isEnabled() && (o = !1), r.action.id === ls.ID && (o = !1), o ? (i || this.previouslyFocusedItem !== this.focusedItem) && (r.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem = void 0);
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof Lr) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  run(e, t) {
    return gO(this, void 0, void 0, function* () {
      yield this._actionRunner.run(e, t);
    });
  }
  dispose() {
    je(this.viewItems), this.viewItems = [], this._actionIds = [], this.getContainer().remove(), super.dispose();
  }
}
const mO = {
  IconContribution: "base.contributions.icons"
};
var cy;
(function(s) {
  function e(t, i) {
    let n = t.defaults;
    for (; ri.isThemeIcon(n); ) {
      const r = fa.getIcon(n.id);
      if (!r)
        return;
      n = r.defaults;
    }
    return n;
  }
  s.getDefinition = e;
})(cy || (cy = {}));
var hy;
(function(s) {
  function e(i) {
    return {
      weight: i.weight,
      style: i.style,
      src: i.src.map((n) => ({ format: n.format, location: n.location.toString() }))
    };
  }
  s.toJSONObject = e;
  function t(i) {
    const n = (r) => Fi(r) ? r : void 0;
    if (i && Array.isArray(i.src) && i.src.every((r) => Fi(r.format) && Fi(r.location)))
      return {
        weight: n(i.weight),
        style: n(i.style),
        src: i.src.map((r) => ({ format: r.format, location: Le.parse(r.location) }))
      };
  }
  s.fromJSONObject = t;
})(hy || (hy = {}));
class pO {
  constructor() {
    this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: p("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: p("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${Di.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, n) {
    const r = this.iconsById[e];
    if (r) {
      if (i && !r.description) {
        r.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return r;
    }
    const o = { id: e, description: i, defaults: t, deprecationMessage: n };
    this.iconsById[e] = o;
    const a = { $ref: "#/definitions/icons" };
    return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const e = (r, o) => r.id.localeCompare(o.id), t = (r) => {
      for (; ri.isThemeIcon(r.defaults); )
        r = this.iconsById[r.defaults.id];
      return `codicon codicon-${r ? r.id : ""}`;
    }, i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const n = Object.keys(this.iconsById).map((r) => this.iconsById[r]);
    for (const r of n.filter((o) => !!o.description).sort(e))
      i.push(`|<i class="${t(r)}"></i>|${r.id}|${ri.isThemeIcon(r.defaults) ? r.defaults.id : r.id}|${r.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const r of n.filter((o) => !ri.isThemeIcon(o.defaults)).sort(e))
      i.push(`|<i class="${t(r)}"></i>|${r.id}|`);
    return i.join(`
`);
  }
}
const fa = new pO();
Ft.add(mO.IconContribution, fa);
function lo(s, e, t, i) {
  return fa.registerIcon(s, e, t, i);
}
function zE() {
  return fa;
}
function _O() {
  for (const s of g.getAll())
    fa.registerIcon(s.id, s.definition, s.description);
}
_O();
const UE = "vscode://schemas/icons", $E = Ft.as(Pg.JSONContribution);
$E.registerSchema(UE, fa.getIconSchema());
const uy = new oi(() => $E.notifySchemaChanged(UE), 200);
fa.onDidChange(() => {
  uy.isScheduled() || uy.schedule();
});
lo("widget-close", g.close, p("widgetClose", "Icon for the close action in widgets."));
lo("goto-previous-location", g.arrowUp, p("previousChangeIcon", "Icon for goto previous editor location."));
lo("goto-next-location", g.arrowDown, p("nextChangeIcon", "Icon for goto next editor location."));
ri.modify(g.sync, "spin");
ri.modify(g.loading, "spin");
var bO = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, CO = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, vO = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
}, Fp;
const Dd = 3;
class Vc {
  constructor(e, t, i, n) {
    this.originalLineStart = e, this.originalLineEnd = t, this.modifiedLineStart = i, this.modifiedLineEnd = n;
  }
  getType() {
    return this.originalLineStart === 0 ? 1 : this.modifiedLineStart === 0 ? 2 : 0;
  }
}
class Bp {
  constructor(e) {
    this.entries = e;
  }
}
const wO = lo("diff-review-insert", g.add, p("diffReviewInsertIcon", "Icon for 'Insert' in diff review.")), SO = lo("diff-review-remove", g.remove, p("diffReviewRemoveIcon", "Icon for 'Remove' in diff review.")), yO = lo("diff-review-close", g.close, p("diffReviewCloseIcon", "Icon for 'Close' in diff review."));
let Qf = class wo extends z {
  constructor(e, t) {
    super(), this._languageService = t, this._width = 0, this._diffEditor = e, this._isVisible = !1, this.shadow = me(document.createElement("div")), this.shadow.setClassName("diff-review-shadow"), this.actionBarContainer = me(document.createElement("div")), this.actionBarContainer.setClassName("diff-review-actions"), this._actionBar = this._register(new Yl(this.actionBarContainer.domNode)), this._actionBar.push(new as("diffreview.close", p("label.close", "Close"), "close-diff-review " + ri.asClassName(yO), !0, () => vO(this, void 0, void 0, function* () {
      return this.hide();
    })), { label: !1, icon: !0 }), this.domNode = me(document.createElement("div")), this.domNode.setClassName("diff-review monaco-editor-background"), this._content = me(document.createElement("div")), this._content.setClassName("diff-review-content"), this._content.setAttribute("role", "code"), this.scrollbar = this._register(new aE(this._content.domNode, {})), this.domNode.domNode.appendChild(this.scrollbar.getDomNode()), this._register(e.onDidUpdateDiff(() => {
      !this._isVisible || (this._diffs = this._compute(), this._render());
    })), this._register(e.getModifiedEditor().onDidChangeCursorPosition(() => {
      !this._isVisible || this._render();
    })), this._register(pi(this.domNode.domNode, "click", (i) => {
      i.preventDefault();
      const n = eD(i.target, "diff-review-row");
      n && this._goToRow(n);
    })), this._register(pi(this.domNode.domNode, "keydown", (i) => {
      (i.equals(18) || i.equals(2066) || i.equals(530)) && (i.preventDefault(), this._goToRow(this._getNextRow())), (i.equals(16) || i.equals(2064) || i.equals(528)) && (i.preventDefault(), this._goToRow(this._getPrevRow())), (i.equals(9) || i.equals(2057) || i.equals(521) || i.equals(1033)) && (i.preventDefault(), this.hide()), (i.equals(10) || i.equals(3)) && (i.preventDefault(), this.accept());
    })), this._diffs = [], this._currentDiff = null;
  }
  prev() {
    let e = 0;
    if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
      let i = -1;
      for (let n = 0, r = this._diffs.length; n < r; n++)
        if (this._diffs[n] === this._currentDiff) {
          i = n;
          break;
        }
      e = this._diffs.length + i - 1;
    } else
      e = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs.length === 0)
      return;
    e = e % this._diffs.length;
    const t = this._diffs[e].entries;
    this._diffEditor.setPosition(new O(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
  }
  next() {
    let e = 0;
    if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
      let i = -1;
      for (let n = 0, r = this._diffs.length; n < r; n++)
        if (this._diffs[n] === this._currentDiff) {
          i = n;
          break;
        }
      e = i + 1;
    } else
      e = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs.length === 0)
      return;
    e = e % this._diffs.length;
    const t = this._diffs[e].entries;
    this._diffEditor.setPosition(new O(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
  }
  accept() {
    let e = -1;
    const t = this._getCurrentFocusedRow();
    if (t) {
      const i = parseInt(t.getAttribute("data-line"), 10);
      isNaN(i) || (e = i);
    }
    this.hide(), e !== -1 && (this._diffEditor.setPosition(new O(e, 1)), this._diffEditor.revealPosition(new O(e, 1), 1));
  }
  hide() {
    this._isVisible = !1, this._diffEditor.updateOptions({ readOnly: !1 }), this._diffEditor.focus(), this._diffEditor.doLayout(), this._render();
  }
  _getPrevRow() {
    const e = this._getCurrentFocusedRow();
    return e ? e.previousElementSibling ? e.previousElementSibling : e : this._getFirstRow();
  }
  _getNextRow() {
    const e = this._getCurrentFocusedRow();
    return e ? e.nextElementSibling ? e.nextElementSibling : e : this._getFirstRow();
  }
  _getFirstRow() {
    return this.domNode.domNode.querySelector(".diff-review-row");
  }
  _getCurrentFocusedRow() {
    const e = document.activeElement;
    return e && /diff-review-row/.test(e.className) ? e : null;
  }
  _goToRow(e) {
    const t = this._getCurrentFocusedRow();
    e.tabIndex = 0, e.focus(), t && t !== e && (t.tabIndex = -1), this.scrollbar.scanDomNode();
  }
  isVisible() {
    return this._isVisible;
  }
  layout(e, t, i) {
    this._width = t, this.shadow.setTop(e - 6), this.shadow.setWidth(t), this.shadow.setHeight(this._isVisible ? 6 : 0), this.domNode.setTop(e), this.domNode.setWidth(t), this.domNode.setHeight(i), this._content.setHeight(i), this._content.setWidth(t), this._isVisible ? (this.actionBarContainer.setAttribute("aria-hidden", "false"), this.actionBarContainer.setDisplay("block")) : (this.actionBarContainer.setAttribute("aria-hidden", "true"), this.actionBarContainer.setDisplay("none"));
  }
  _compute() {
    const e = this._diffEditor.getLineChanges();
    if (!e || e.length === 0)
      return [];
    const t = this._diffEditor.getOriginalEditor().getModel(), i = this._diffEditor.getModifiedEditor().getModel();
    return !t || !i ? [] : wo._mergeAdjacent(e, t.getLineCount(), i.getLineCount());
  }
  static _mergeAdjacent(e, t, i) {
    if (!e || e.length === 0)
      return [];
    const n = [];
    let r = 0;
    for (let c = 0, h = e.length; c < h; c++) {
      const u = e[c], d = u.originalStartLineNumber, f = u.originalEndLineNumber, m = u.modifiedStartLineNumber, _ = u.modifiedEndLineNumber, b = [];
      let v = 0;
      {
        const C = f === 0 ? d : d - 1, w = _ === 0 ? m : m - 1;
        let L = 1, E = 1;
        if (c > 0) {
          const S = e[c - 1];
          S.originalEndLineNumber === 0 ? L = S.originalStartLineNumber + 1 : L = S.originalEndLineNumber + 1, S.modifiedEndLineNumber === 0 ? E = S.modifiedStartLineNumber + 1 : E = S.modifiedEndLineNumber + 1;
        }
        let k = C - Dd + 1, y = w - Dd + 1;
        if (k < L) {
          const S = L - k;
          k = k + S, y = y + S;
        }
        if (y < E) {
          const S = E - y;
          k = k + S, y = y + S;
        }
        b[v++] = new Vc(k, C, y, w);
      }
      f !== 0 && (b[v++] = new Vc(d, f, 0, 0)), _ !== 0 && (b[v++] = new Vc(0, 0, m, _));
      {
        const C = f === 0 ? d + 1 : f + 1, w = _ === 0 ? m + 1 : _ + 1;
        let L = t, E = i;
        if (c + 1 < h) {
          const S = e[c + 1];
          S.originalEndLineNumber === 0 ? L = S.originalStartLineNumber : L = S.originalStartLineNumber - 1, S.modifiedEndLineNumber === 0 ? E = S.modifiedStartLineNumber : E = S.modifiedStartLineNumber - 1;
        }
        let k = C + Dd - 1, y = w + Dd - 1;
        if (k > L) {
          const S = L - k;
          k = k + S, y = y + S;
        }
        if (y > E) {
          const S = E - y;
          k = k + S, y = y + S;
        }
        b[v++] = new Vc(C, k, w, y);
      }
      n[r++] = new Bp(b);
    }
    let o = n[0].entries;
    const a = [];
    let l = 0;
    for (let c = 1, h = n.length; c < h; c++) {
      const u = n[c].entries, d = o[o.length - 1], f = u[0];
      if (d.getType() === 0 && f.getType() === 0 && f.originalLineStart <= d.originalLineEnd) {
        o[o.length - 1] = new Vc(d.originalLineStart, f.originalLineEnd, d.modifiedLineStart, f.modifiedLineEnd), o = o.concat(u.slice(1));
        continue;
      }
      a[l++] = new Bp(o), o = u;
    }
    return a[l++] = new Bp(o), a;
  }
  _findDiffIndex(e) {
    const t = e.lineNumber;
    for (let i = 0, n = this._diffs.length; i < n; i++) {
      const r = this._diffs[i].entries, o = r[r.length - 1].modifiedLineEnd;
      if (t <= o)
        return i;
    }
    return 0;
  }
  _render() {
    const e = this._diffEditor.getOriginalEditor().getOptions(), t = this._diffEditor.getModifiedEditor().getOptions(), i = this._diffEditor.getOriginalEditor().getModel(), n = this._diffEditor.getModifiedEditor().getModel(), r = i.getOptions(), o = n.getOptions();
    if (!this._isVisible || !i || !n) {
      rn(this._content.domNode), this._currentDiff = null, this.scrollbar.scanDomNode();
      return;
    }
    this._diffEditor.updateOptions({ readOnly: !0 });
    const a = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs[a] === this._currentDiff)
      return;
    this._currentDiff = this._diffs[a];
    const l = this._diffs[a].entries, c = document.createElement("div");
    c.className = "diff-review-table", c.setAttribute("role", "list"), c.setAttribute("aria-label", 'Difference review. Use "Stage | Unstage | Revert Selected Ranges" commands'), mi(c, t.get(46));
    let h = 0, u = 0, d = 0, f = 0;
    for (let y = 0, S = l.length; y < S; y++) {
      const D = l[y], T = D.originalLineStart, M = D.originalLineEnd, P = D.modifiedLineStart, V = D.modifiedLineEnd;
      T !== 0 && (h === 0 || T < h) && (h = T), M !== 0 && (u === 0 || M > u) && (u = M), P !== 0 && (d === 0 || P < d) && (d = P), V !== 0 && (f === 0 || V > f) && (f = V);
    }
    const m = document.createElement("div");
    m.className = "diff-review-row";
    const _ = document.createElement("div");
    _.className = "diff-review-cell diff-review-summary";
    const b = u - h + 1, v = f - d + 1;
    _.appendChild(document.createTextNode(`${a + 1}/${this._diffs.length}: @@ -${h},${b} +${d},${v} @@`)), m.setAttribute("data-line", String(d));
    const C = (y) => y === 0 ? p("no_lines_changed", "no lines changed") : y === 1 ? p("one_line_changed", "1 line changed") : p("more_lines_changed", "{0} lines changed", y), w = C(b), L = C(v);
    m.setAttribute("aria-label", p({
      key: "header",
      comment: [
        "This is the ARIA label for a git diff header.",
        "A git diff header looks like this: @@ -154,12 +159,39 @@.",
        "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
        "Variables 0 and 1 refer to the diff index out of total number of diffs.",
        "Variables 2 and 4 will be numbers (a line number).",
        'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
      ]
    }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", a + 1, this._diffs.length, h, w, d, L)), m.appendChild(_), m.setAttribute("role", "listitem"), c.appendChild(m);
    const E = t.get(61);
    let k = d;
    for (let y = 0, S = l.length; y < S; y++) {
      const D = l[y];
      wo._renderSection(c, D, k, E, this._width, e, i, r, t, n, o, this._languageService.languageIdCodec), D.modifiedLineStart !== 0 && (k = D.modifiedLineEnd);
    }
    rn(this._content.domNode), this._content.domNode.appendChild(c), this.scrollbar.scanDomNode();
  }
  static _renderSection(e, t, i, n, r, o, a, l, c, h, u, d) {
    const f = t.getType();
    let m = "diff-review-row", _ = "";
    const b = "diff-review-spacer";
    let v = null;
    switch (f) {
      case 1:
        m = "diff-review-row line-insert", _ = " char-insert", v = wO;
        break;
      case 2:
        m = "diff-review-row line-delete", _ = " char-delete", v = SO;
        break;
    }
    const C = t.originalLineStart, w = t.originalLineEnd, L = t.modifiedLineStart, E = t.modifiedLineEnd, k = Math.max(E - L, w - C), y = o.get(133), S = y.glyphMarginWidth + y.lineNumbersWidth, D = c.get(133), T = 10 + D.glyphMarginWidth + D.lineNumbersWidth;
    for (let M = 0; M <= k; M++) {
      const P = C === 0 ? 0 : C + M, V = L === 0 ? 0 : L + M, U = document.createElement("div");
      U.style.minWidth = r + "px", U.className = m, U.setAttribute("role", "listitem"), V !== 0 && (i = V), U.setAttribute("data-line", String(i));
      const K = document.createElement("div");
      K.className = "diff-review-cell", K.style.height = `${n}px`, U.appendChild(K);
      const J = document.createElement("span");
      J.style.width = S + "px", J.style.minWidth = S + "px", J.className = "diff-review-line-number" + _, P !== 0 ? J.appendChild(document.createTextNode(String(P))) : J.innerText = "\xA0", K.appendChild(J);
      const ee = document.createElement("span");
      ee.style.width = T + "px", ee.style.minWidth = T + "px", ee.style.paddingRight = "10px", ee.className = "diff-review-line-number" + _, V !== 0 ? ee.appendChild(document.createTextNode(String(V))) : ee.innerText = "\xA0", K.appendChild(ee);
      const ne = document.createElement("span");
      if (ne.className = b, v) {
        const Ue = document.createElement("span");
        Ue.className = ri.asClassName(v), Ue.innerText = "\xA0\xA0", ne.appendChild(Ue);
      } else
        ne.innerText = "\xA0\xA0";
      K.appendChild(ne);
      let ue;
      if (V !== 0) {
        let Ue = this._renderLine(h, c, u.tabSize, V, d);
        wo._ttPolicy && (Ue = wo._ttPolicy.createHTML(Ue)), K.insertAdjacentHTML("beforeend", Ue), ue = h.getLineContent(V);
      } else {
        let Ue = this._renderLine(a, o, l.tabSize, P, d);
        wo._ttPolicy && (Ue = wo._ttPolicy.createHTML(Ue)), K.insertAdjacentHTML("beforeend", Ue), ue = a.getLineContent(P);
      }
      ue.length === 0 && (ue = p("blankLine", "blank"));
      let He = "";
      switch (f) {
        case 0:
          P === V ? He = p({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", ue, P) : He = p("equalLine", "{0} original line {1} modified line {2}", ue, P, V);
          break;
        case 1:
          He = p("insertLine", "+ {0} modified line {1}", ue, V);
          break;
        case 2:
          He = p("deleteLine", "- {0} original line {1}", ue, P);
          break;
      }
      U.setAttribute("aria-label", He), e.appendChild(U);
    }
  }
  static _renderLine(e, t, i, n, r) {
    const o = e.getLineContent(n), a = t.get(46), l = Pt.createEmpty(o, r), c = Wi.isBasicASCII(o, e.mightContainNonBasicASCII()), h = Wi.containsRTL(o, c, e.mightContainRTL());
    return Wg(new dc(a.isMonospace && !t.get(29), a.canUseHalfwidthRightwardsArrow, o, !1, c, h, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(107), t.get(90), t.get(85), t.get(47) !== qi.OFF, null)).html;
  }
};
Qf._ttPolicy = (Fp = window.trustedTypes) === null || Fp === void 0 ? void 0 : Fp.createPolicy("diffReview", { createHTML: (s) => s });
Qf = bO([
  CO(1, Xt)
], Qf);
zi((s, e) => {
  const t = s.getColor(qD);
  t && e.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${t}; }`);
  const i = s.getColor(gc);
  i && e.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${i} 0 -6px 6px -6px inset; }`);
});
class LO extends tm {
  constructor() {
    super({
      id: "editor.action.diffReview.next",
      label: p("editor.action.diffReview.next", "Go to Next Difference"),
      alias: "Go to Next Difference",
      precondition: Ut.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 65,
        weight: 100
      }
    });
  }
  run(e, t) {
    const i = jE(e);
    i && i.diffReviewNext();
  }
}
class kO extends tm {
  constructor() {
    super({
      id: "editor.action.diffReview.prev",
      label: p("editor.action.diffReview.prev", "Go to Previous Difference"),
      alias: "Go to Previous Difference",
      precondition: Ut.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 1089,
        weight: 100
      }
    });
  }
  run(e, t) {
    const i = jE(e);
    i && i.diffReviewPrev();
  }
}
function jE(s) {
  const e = s.get(Ct), t = e.listDiffEditors(), i = e.getActiveCodeEditor();
  if (!i)
    return null;
  for (let n = 0, r = t.length; n < r; n++) {
    const o = t[n];
    if (o.getModifiedEditor().getId() === i.getId() || o.getOriginalEditor().getId() === i.getId())
      return o;
  }
  return null;
}
pD(LO);
pD(kO);
const DO = "editorWorkerService", Cc = Se(DO), um = Se("contextViewService"), MC = Se("contextMenuService");
var Vp = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class EO extends z {
  constructor(e, t, i, n, r, o) {
    super(), this._viewZoneId = e, this._marginDomNode = t, this.editor = i, this.diff = n, this._contextMenuService = r, this._clipboardService = o, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = g.lightBulb.classNames + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const a = i.getOption(61), l = i.getModel().getEOL();
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${a}px`, this._diffActions.style.lineHeight = `${a}px`, this._marginDomNode.appendChild(this._diffActions);
    const c = [], h = n.modifiedEndLineNumber === 0;
    c.push(new as("diff.clipboard.copyDeletedContent", h ? n.originalEndLineNumber > n.modifiedStartLineNumber ? p("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : p("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.originalEndLineNumber > n.modifiedStartLineNumber ? p("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : p("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, !0, () => Vp(this, void 0, void 0, function* () {
      const _ = new N(n.originalStartLineNumber, 1, n.originalEndLineNumber + 1, 1), b = n.originalModel.getValueInRange(_);
      yield this._clipboardService.writeText(b);
    })));
    let u = 0, d;
    n.originalEndLineNumber > n.modifiedStartLineNumber && (d = new as("diff.clipboard.copyDeletedLineContent", h ? p("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.originalStartLineNumber) : p("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.originalStartLineNumber), void 0, !0, () => Vp(this, void 0, void 0, function* () {
      const _ = n.originalModel.getLineContent(n.originalStartLineNumber + u);
      if (_ === "") {
        const b = n.originalModel.getEndOfLineSequence();
        yield this._clipboardService.writeText(b === 0 ? `
` : `\r
`);
      } else
        yield this._clipboardService.writeText(_);
    })), c.push(d)), i.getOption(83) || c.push(new as("diff.inline.revertChange", p("diff.inline.revertChange.label", "Revert this change"), void 0, !0, () => Vp(this, void 0, void 0, function* () {
      const _ = new N(n.originalStartLineNumber, 1, n.originalEndLineNumber, n.originalModel.getLineMaxColumn(n.originalEndLineNumber)), b = n.originalModel.getValueInRange(_);
      if (n.modifiedEndLineNumber === 0) {
        const v = i.getModel().getLineMaxColumn(n.modifiedStartLineNumber);
        i.executeEdits("diffEditor", [
          {
            range: new N(n.modifiedStartLineNumber, v, n.modifiedStartLineNumber, v),
            text: l + b
          }
        ]);
      } else {
        const v = i.getModel().getLineMaxColumn(n.modifiedEndLineNumber);
        i.executeEdits("diffEditor", [
          {
            range: new N(n.modifiedStartLineNumber, 1, n.modifiedEndLineNumber, v),
            text: b
          }
        ]);
      }
    })));
    const m = (_, b) => {
      this._contextMenuService.showContextMenu({
        getAnchor: () => ({
          x: _,
          y: b
        }),
        getActions: () => (d && (d.label = h ? p("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.originalStartLineNumber + u) : p("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.originalStartLineNumber + u)), c),
        autoSelectFirstItem: !0
      });
    };
    this._register(pi(this._diffActions, "mousedown", (_) => {
      const { top: b, height: v } = is(this._diffActions), C = Math.floor(a / 3);
      _.preventDefault(), m(_.posx, b + v + C);
    })), this._register(i.onMouseMove((_) => {
      _.target.type === 8 || _.target.type === 5 ? _.target.detail.viewZoneId === this._viewZoneId ? (this.visibility = !0, u = this._updateLightBulbPosition(this._marginDomNode, _.event.browserEvent.y, a)) : this.visibility = !1 : this.visibility = !1;
    })), this._register(i.onMouseDown((_) => {
      !_.event.rightButton || (_.target.type === 8 || _.target.type === 5) && _.target.detail.viewZoneId === this._viewZoneId && (_.event.preventDefault(), u = this._updateLightBulbPosition(this._marginDomNode, _.event.browserEvent.y, a), m(_.event.posx, _.event.posy + a));
    }));
  }
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, e ? this._diffActions.style.visibility = "visible" : this._diffActions.style.visibility = "hidden");
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: n } = is(e), r = t - n, o = Math.floor(r / i), a = o * i;
    if (this._diffActions.style.top = `${a}px`, this.diff.viewLineCounts) {
      let l = 0;
      for (let c = 0; c < this.diff.viewLineCounts.length; c++)
        if (l += this.diff.viewLineCounts[c], o < l)
          return c;
    }
    return o;
  }
}
const AC = Se("clipboardService"), xO = Se("progressService");
Object.freeze({
  total() {
  },
  worked() {
  },
  done() {
  }
});
Object.freeze({ report() {
} });
const RC = Se("editorProgressService");
var IO = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Ms = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Wp;
class dy {
  constructor(e, t) {
    this._contextMenuService = e, this._clipboardService = t, this._zones = [], this._inlineDiffMargins = [], this._zonesMap = {}, this._decorations = [];
  }
  getForeignViewZones(e) {
    return e.filter((t) => !this._zonesMap[String(t.id)]);
  }
  clean(e) {
    this._zones.length > 0 && e.changeViewZones((t) => {
      for (const i of this._zones)
        t.removeZone(i);
    }), this._zones = [], this._zonesMap = {}, e.changeDecorations((t) => {
      this._decorations = t.deltaDecorations(this._decorations, []);
    });
  }
  apply(e, t, i, n) {
    const r = n ? kC.capture(e) : null;
    e.changeViewZones((o) => {
      var a;
      for (const l of this._zones)
        o.removeZone(l);
      for (const l of this._inlineDiffMargins)
        l.dispose();
      this._zones = [], this._zonesMap = {}, this._inlineDiffMargins = [];
      for (let l = 0, c = i.zones.length; l < c; l++) {
        const h = i.zones[l];
        h.suppressMouseDown = !0;
        const u = o.addZone(h);
        this._zones.push(u), this._zonesMap[String(u)] = !0, i.zones[l].diff && h.marginDomNode && (h.suppressMouseDown = !1, ((a = i.zones[l].diff) === null || a === void 0 ? void 0 : a.originalModel.getValueLength()) !== 0 && this._inlineDiffMargins.push(new EO(u, h.marginDomNode, e, i.zones[l].diff, this._contextMenuService, this._clipboardService)));
      }
    }), r == null || r.restore(e), e.changeDecorations((o) => {
      this._decorations = o.deltaDecorations(this._decorations, i.decorations);
    }), t == null || t.setZones(i.overviewZones);
  }
}
let NO = 0;
const TO = lo("diff-insert", g.add, p("diffInsertIcon", "Line decoration for inserts in the diff editor.")), KE = lo("diff-remove", g.remove, p("diffRemoveIcon", "Line decoration for removals in the diff editor.")), fy = (Wp = window.trustedTypes) === null || Wp === void 0 ? void 0 : Wp.createPolicy("diffEditorWidget", { createHTML: (s) => s });
let so = class Vt extends z {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d) {
    super(), this._editorProgressService = d, this._onDidDispose = this._register(new A()), this.onDidDispose = this._onDidDispose.event, this._onDidUpdateDiff = this._register(new A()), this.onDidUpdateDiff = this._onDidUpdateDiff.event, this._onDidContentSizeChange = this._register(new A()), this._lastOriginalWarning = null, this._lastModifiedWarning = null, this._editorWorkerService = r, this._codeEditorService = l, this._contextKeyService = this._register(o.createScoped(e)), this._instantiationService = a.createChild(new cm([Qe, this._contextKeyService])), this._contextKeyService.createKey("isInDiffEditor", !0), this._themeService = c, this._notificationService = h, this._id = ++NO, this._state = 0, this._updatingDiffProgress = null, this._domElement = e, t = t || {}, this._options = py(t, {
      enableSplitViewResizing: !0,
      renderSideBySide: !0,
      renderMarginRevertIcon: !0,
      maxComputationTime: 5e3,
      maxFileSize: 50,
      ignoreTrimWhitespace: !0,
      renderIndicators: !0,
      originalEditable: !1,
      diffCodeLens: !1,
      renderOverviewRuler: !0,
      diffWordWrap: "inherit"
    }), typeof t.isInEmbeddedEditor < "u" ? this._contextKeyService.createKey("isInEmbeddedDiffEditor", t.isInEmbeddedEditor) : this._contextKeyService.createKey("isInEmbeddedDiffEditor", !1), this._updateDecorationsRunner = this._register(new oi(() => this._updateDecorations(), 0)), this._containerDomElement = document.createElement("div"), this._containerDomElement.className = Vt._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide), this._containerDomElement.style.position = "relative", this._containerDomElement.style.height = "100%", this._domElement.appendChild(this._containerDomElement), this._overviewViewportDomElement = me(document.createElement("div")), this._overviewViewportDomElement.setClassName("diffViewport"), this._overviewViewportDomElement.setPosition("absolute"), this._overviewDomElement = document.createElement("div"), this._overviewDomElement.className = "diffOverview", this._overviewDomElement.style.position = "absolute", this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode), this._register(pi(this._overviewDomElement, $.POINTER_DOWN, (m) => {
      this._modifiedEditor.delegateVerticalScrollbarPointerDown(m);
    })), this._options.renderOverviewRuler && this._containerDomElement.appendChild(this._overviewDomElement), this._originalDomNode = document.createElement("div"), this._originalDomNode.className = "editor original", this._originalDomNode.style.position = "absolute", this._originalDomNode.style.height = "100%", this._containerDomElement.appendChild(this._originalDomNode), this._modifiedDomNode = document.createElement("div"), this._modifiedDomNode.className = "editor modified", this._modifiedDomNode.style.position = "absolute", this._modifiedDomNode.style.height = "100%", this._containerDomElement.appendChild(this._modifiedDomNode), this._beginUpdateDecorationsTimeout = -1, this._currentlyChangingViewZones = !1, this._diffComputationToken = 0, this._originalEditorState = new dy(u, n), this._modifiedEditorState = new dy(u, n), this._isVisible = !0, this._isHandlingScrollEvent = !1, this._elementSizeObserver = this._register(new vD(this._containerDomElement, t.dimension)), this._register(this._elementSizeObserver.onDidChange(() => this._onDidContainerSizeChanged())), t.automaticLayout && this._elementSizeObserver.startObserving(), this._diffComputationResult = null, this._originalEditor = this._createLeftHandSideEditor(t, i.originalEditor || {}), this._modifiedEditor = this._createRightHandSideEditor(t, i.modifiedEditor || {}), this._originalOverviewRuler = null, this._modifiedOverviewRuler = null, this._reviewPane = a.createInstance(Qf, this), this._containerDomElement.appendChild(this._reviewPane.domNode.domNode), this._containerDomElement.appendChild(this._reviewPane.shadow.domNode), this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode), this._options.renderSideBySide ? this._setStrategy(new Ks(this._createDataSource(), this._options.enableSplitViewResizing)) : this._setStrategy(new my(this._createDataSource(), this._options.enableSplitViewResizing)), this._register(c.onDidColorThemeChange((m) => {
      this._strategy && this._strategy.applyColors(m) && this._updateDecorationsRunner.schedule(), this._containerDomElement.className = Vt._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);
    }));
    const f = bl.getDiffEditorContributions();
    for (const m of f)
      try {
        this._register(a.createInstance(m.ctor, this));
      } catch (_) {
        ct(_);
      }
    this._codeEditorService.addDiffEditor(this);
  }
  _setState(e) {
    this._state !== e && (this._state = e, this._updatingDiffProgress && (this._updatingDiffProgress.done(), this._updatingDiffProgress = null), this._state === 1 && (this._updatingDiffProgress = this._editorProgressService.show(!0, 1e3)));
  }
  diffReviewNext() {
    this._reviewPane.next();
  }
  diffReviewPrev() {
    this._reviewPane.prev();
  }
  static _getClassName(e, t) {
    let i = "monaco-diff-editor monaco-editor-background ";
    return t && (i += "side-by-side "), i += Tf(e.type), i;
  }
  _disposeOverviewRulers() {
    this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose(), this._originalOverviewRuler = null), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose(), this._modifiedOverviewRuler = null);
  }
  _createOverviewRulers() {
    !this._options.renderOverviewRuler || (oh(!this._originalOverviewRuler && !this._modifiedOverviewRuler), this._originalEditor.hasModel() && (this._originalOverviewRuler = this._originalEditor.createOverviewRuler("original diffOverviewRuler"), this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode())), this._modifiedEditor.hasModel() && (this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler("modified diffOverviewRuler"), this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode())), this._layoutOverviewRulers());
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(e), t);
    this._register(i.onDidScrollChange((r) => {
      this._isHandlingScrollEvent || !r.scrollTopChanged && !r.scrollLeftChanged && !r.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._modifiedEditor.setScrollPosition({
        scrollLeft: r.scrollLeft,
        scrollTop: r.scrollTop
      }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
    })), this._register(i.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    })), this._register(i.onDidChangeConfiguration((r) => {
      !i.getModel() || (r.hasChanged(46) && this._updateDecorationsRunner.schedule(), r.hasChanged(134) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
    })), this._register(i.onDidChangeHiddenAreas(() => {
      this._updateDecorationsRunner.cancel(), this._updateDecorations();
    })), this._register(i.onDidChangeModelContent(() => {
      this._isVisible && this._beginUpdateDecorationsSoon();
    }));
    const n = this._contextKeyService.createKey("isInDiffLeftEditor", i.hasWidgetFocus());
    return this._register(i.onDidFocusEditorWidget(() => n.set(!0))), this._register(i.onDidBlurEditorWidget(() => n.set(!1))), this._register(i.onDidContentSizeChange((r) => {
      const o = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + Vt.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: a,
        contentWidth: o,
        contentHeightChanged: r.contentHeightChanged,
        contentWidthChanged: r.contentWidthChanged
      });
    })), i;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(e), t);
    this._register(i.onDidScrollChange((r) => {
      this._isHandlingScrollEvent || !r.scrollTopChanged && !r.scrollLeftChanged && !r.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._originalEditor.setScrollPosition({
        scrollLeft: r.scrollLeft,
        scrollTop: r.scrollTop
      }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
    })), this._register(i.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    })), this._register(i.onDidChangeConfiguration((r) => {
      !i.getModel() || (r.hasChanged(46) && this._updateDecorationsRunner.schedule(), r.hasChanged(134) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
    })), this._register(i.onDidChangeHiddenAreas(() => {
      this._updateDecorationsRunner.cancel(), this._updateDecorations();
    })), this._register(i.onDidChangeModelContent(() => {
      this._isVisible && this._beginUpdateDecorationsSoon();
    })), this._register(i.onDidChangeModelOptions((r) => {
      r.tabSize && this._updateDecorationsRunner.schedule();
    }));
    const n = this._contextKeyService.createKey("isInDiffRightEditor", i.hasWidgetFocus());
    return this._register(i.onDidFocusEditorWidget(() => n.set(!0))), this._register(i.onDidBlurEditorWidget(() => n.set(!1))), this._register(i.onDidContentSizeChange((r) => {
      const o = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + Vt.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: a,
        contentWidth: o,
        contentHeightChanged: r.contentHeightChanged,
        contentWidthChanged: r.contentWidthChanged
      });
    })), this._register(i.onMouseDown((r) => {
      var o, a;
      if (!r.event.rightButton && r.target.position && ((o = r.target.element) === null || o === void 0 ? void 0 : o.className.includes("arrow-revert-change"))) {
        const l = r.target.position.lineNumber, c = (a = this._diffComputationResult) === null || a === void 0 ? void 0 : a.changes.find((h) => h.modifiedStartLineNumber === l - 1 || h.modifiedStartLineNumber === l);
        c && this.revertChange(c), r.event.stopPropagation(), this._updateDecorations();
        return;
      }
    })), i;
  }
  revertChange(e) {
    const t = this._modifiedEditor, i = this._originalEditor.getModel(), n = this._modifiedEditor.getModel();
    if (!i || !n || !t)
      return;
    const r = e.originalEndLineNumber > 0 ? new N(e.originalStartLineNumber, 1, e.originalEndLineNumber, i.getLineMaxColumn(e.originalEndLineNumber)) : null, o = r ? i.getValueInRange(r) : null, a = e.modifiedEndLineNumber > 0 ? new N(e.modifiedStartLineNumber, 1, e.modifiedEndLineNumber, n.getLineMaxColumn(e.modifiedEndLineNumber)) : null, l = n.getEOL();
    if (e.originalEndLineNumber === 0 && a) {
      let c = a;
      e.modifiedStartLineNumber > 1 ? c = a.setStartPosition(e.modifiedStartLineNumber - 1, n.getLineMaxColumn(e.modifiedStartLineNumber - 1)) : e.modifiedEndLineNumber < n.getLineCount() && (c = a.setEndPosition(e.modifiedEndLineNumber + 1, 1)), t.executeEdits("diffEditor", [{
        range: c,
        text: ""
      }]);
    } else if (e.modifiedEndLineNumber === 0 && o !== null) {
      const c = e.modifiedStartLineNumber < n.getLineCount() ? new O(e.modifiedStartLineNumber + 1, 1) : new O(e.modifiedStartLineNumber, n.getLineMaxColumn(e.modifiedStartLineNumber));
      t.executeEdits("diffEditor", [{
        range: N.fromPositions(c, c),
        text: e.modifiedStartLineNumber < n.getLineCount() ? o + l : l + o
      }]);
    } else
      a && o !== null && t.executeEdits("diffEditor", [{
        range: a,
        text: o
      }]);
  }
  _createInnerEditor(e, t, i, n) {
    return e.createInstance(ru, t, i, n);
  }
  dispose() {
    this._codeEditorService.removeDiffEditor(this), this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._cleanViewZonesAndDecorations(), this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode), this._options.renderOverviewRuler && this._containerDomElement.removeChild(this._overviewDomElement), this._containerDomElement.removeChild(this._originalDomNode), this._originalEditor.dispose(), this._containerDomElement.removeChild(this._modifiedDomNode), this._modifiedEditor.dispose(), this._strategy.dispose(), this._containerDomElement.removeChild(this._reviewPane.domNode.domNode), this._containerDomElement.removeChild(this._reviewPane.shadow.domNode), this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode), this._reviewPane.dispose(), this._domElement.removeChild(this._containerDomElement), this._onDidDispose.fire(), super.dispose();
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return Rb.IDiffEditor;
  }
  getLineChanges() {
    return this._diffComputationResult ? this._diffComputationResult.changes : null;
  }
  getOriginalEditor() {
    return this._originalEditor;
  }
  getModifiedEditor() {
    return this._modifiedEditor;
  }
  updateOptions(e) {
    const t = py(e, this._options), i = OO(this._options, t);
    this._options = t;
    const n = i.ignoreTrimWhitespace || i.renderIndicators || i.renderMarginRevertIcon, r = this._isVisible && (i.maxComputationTime || i.maxFileSize);
    n ? this._beginUpdateDecorations() : r && this._beginUpdateDecorationsSoon(), this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(e)), this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(e)), this._strategy.setEnableSplitViewResizing(this._options.enableSplitViewResizing), i.renderSideBySide && (this._options.renderSideBySide ? this._setStrategy(new Ks(this._createDataSource(), this._options.enableSplitViewResizing)) : this._setStrategy(new my(this._createDataSource(), this._options.enableSplitViewResizing)), this._containerDomElement.className = Vt._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide)), i.renderOverviewRuler && (this._options.renderOverviewRuler ? this._containerDomElement.appendChild(this._overviewDomElement) : this._containerDomElement.removeChild(this._overviewDomElement));
  }
  getModel() {
    return {
      original: this._originalEditor.getModel(),
      modified: this._modifiedEditor.getModel()
    };
  }
  setModel(e) {
    if (e && (!e.original || !e.modified))
      throw new Error(e.original ? "DiffEditorWidget.setModel: Modified model is null" : "DiffEditorWidget.setModel: Original model is null");
    this._cleanViewZonesAndDecorations(), this._disposeOverviewRulers(), this._originalEditor.setModel(e ? e.original : null), this._modifiedEditor.setModel(e ? e.modified : null), this._updateDecorationsRunner.cancel(), e && (this._originalEditor.setScrollTop(0), this._modifiedEditor.setScrollTop(0)), this._diffComputationResult = null, this._diffComputationToken++, this._setState(0), e && (this._createOverviewRulers(), this._beginUpdateDecorations()), this._layoutOverviewViewport();
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getVisibleColumnFromPosition(e) {
    return this._modifiedEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._modifiedEditor.getPosition();
  }
  setPosition(e, t = "api") {
    this._modifiedEditor.setPosition(e, t);
  }
  revealLine(e, t = 0) {
    this._modifiedEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._modifiedEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._modifiedEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._modifiedEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._modifiedEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._modifiedEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._modifiedEditor.getSelection();
  }
  getSelections() {
    return this._modifiedEditor.getSelections();
  }
  setSelection(e, t = "api") {
    this._modifiedEditor.setSelection(e, t);
  }
  setSelections(e, t = "api") {
    this._modifiedEditor.setSelections(e, t);
  }
  revealLines(e, t, i = 0) {
    this._modifiedEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._modifiedEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._modifiedEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._modifiedEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._modifiedEditor.revealRange(e, t, i, n);
  }
  revealRangeInCenter(e, t = 0) {
    this._modifiedEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._modifiedEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._modifiedEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._modifiedEditor.getSupportedActions();
  }
  saveViewState() {
    const e = this._originalEditor.saveViewState(), t = this._modifiedEditor.saveViewState();
    return {
      original: e,
      modified: t
    };
  }
  restoreViewState(e) {
    if (e && e.original && e.modified) {
      const t = e;
      this._originalEditor.restoreViewState(t.original), this._modifiedEditor.restoreViewState(t.modified);
    }
  }
  layout(e) {
    this._elementSizeObserver.observe(e);
  }
  focus() {
    this._modifiedEditor.focus();
  }
  hasTextFocus() {
    return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();
  }
  trigger(e, t, i) {
    this._modifiedEditor.trigger(e, t, i);
  }
  createDecorationsCollection(e) {
    return this._modifiedEditor.createDecorationsCollection(e);
  }
  changeDecorations(e) {
    return this._modifiedEditor.changeDecorations(e);
  }
  _onDidContainerSizeChanged() {
    this._doLayout();
  }
  _getReviewHeight() {
    return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;
  }
  _layoutOverviewRulers() {
    if (!this._options.renderOverviewRuler || !this._originalOverviewRuler || !this._modifiedOverviewRuler)
      return;
    const e = this._elementSizeObserver.getHeight(), t = this._getReviewHeight(), i = Vt.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * Vt.ONE_OVERVIEW_WIDTH;
    this._modifiedEditor.getLayoutInfo() && (this._originalOverviewRuler.setLayout({
      top: 0,
      width: Vt.ONE_OVERVIEW_WIDTH,
      right: i + Vt.ONE_OVERVIEW_WIDTH,
      height: e - t
    }), this._modifiedOverviewRuler.setLayout({
      top: 0,
      right: 0,
      width: Vt.ONE_OVERVIEW_WIDTH,
      height: e - t
    }));
  }
  _onViewZonesChanged() {
    this._currentlyChangingViewZones || this._updateDecorationsRunner.schedule();
  }
  _beginUpdateDecorationsSoon() {
    this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), Vt.UPDATE_DIFF_DECORATIONS_DELAY);
  }
  static _equals(e, t) {
    return !e && !t ? !0 : !e || !t ? !1 : e.toString() === t.toString();
  }
  _beginUpdateDecorations() {
    this._beginUpdateDecorationsTimeout = -1;
    const e = this._originalEditor.getModel(), t = this._modifiedEditor.getModel();
    if (!e || !t)
      return;
    this._diffComputationToken++;
    const i = this._diffComputationToken, n = this._options.maxFileSize * 1024 * 1024, r = (o) => {
      const a = o.getValueLength();
      return n === 0 || a <= n;
    };
    if (!r(e) || !r(t)) {
      (!Vt._equals(e.uri, this._lastOriginalWarning) || !Vt._equals(t.uri, this._lastModifiedWarning)) && (this._lastOriginalWarning = e.uri, this._lastModifiedWarning = t.uri, this._notificationService.warn(p("diff.tooLarge", "Cannot compare files because one file is too large.")));
      return;
    }
    this._setState(1), this._editorWorkerService.computeDiff(e.uri, t.uri, this._options.ignoreTrimWhitespace, this._options.maxComputationTime).then((o) => {
      i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(2), this._diffComputationResult = o, this._updateDecorationsRunner.schedule(), this._onDidUpdateDiff.fire());
    }, (o) => {
      i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(2), this._diffComputationResult = null, this._updateDecorationsRunner.schedule());
    });
  }
  _cleanViewZonesAndDecorations() {
    this._originalEditorState.clean(this._originalEditor), this._modifiedEditorState.clean(this._modifiedEditor);
  }
  _updateDecorations() {
    if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel())
      return;
    const e = this._diffComputationResult ? this._diffComputationResult.changes : [], t = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces()), i = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces()), n = this._strategy.getEditorsDiffDecorations(e, this._options.ignoreTrimWhitespace, this._options.renderIndicators, this._options.renderMarginRevertIcon, t, i);
    try {
      this._currentlyChangingViewZones = !0, this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, n.original, !1), this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, n.modified, !0);
    } finally {
      this._currentlyChangingViewZones = !1;
    }
  }
  _adjustOptionsForSubEditor(e) {
    const t = Object.assign({}, e);
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = Object.assign({}, t.scrollbar || {}), t.scrollbar.vertical = "visible", t.folding = !1, t.codeLens = this._options.diffCodeLens, t.fixedOverflowWidgets = !0, t.minimap = Object.assign({}, t.minimap || {}), t.minimap.enabled = !1, t;
  }
  _adjustOptionsForLeftHandSide(e) {
    const t = this._adjustOptionsForSubEditor(e);
    return this._options.renderSideBySide ? t.wordWrapOverride1 = this._options.diffWordWrap : (t.wordWrapOverride1 = "off", t.wordWrapOverride2 = "off"), e.originalAriaLabel && (t.ariaLabel = e.originalAriaLabel), t.readOnly = !this._options.originalEditable, t.dropIntoEditor = { enabled: !t.readOnly }, t.extraEditorClassName = "original-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
      height: 0,
      width: 0
    } });
  }
  _adjustOptionsForRightHandSide(e) {
    const t = this._adjustOptionsForSubEditor(e);
    return e.modifiedAriaLabel && (t.ariaLabel = e.modifiedAriaLabel), t.wordWrapOverride1 = this._options.diffWordWrap, t.revealHorizontalRightPadding = oa.revealHorizontalRightPadding.defaultValue + Vt.ENTIRE_DIFF_OVERVIEW_WIDTH, t.scrollbar.verticalHasArrows = !1, t.extraEditorClassName = "modified-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
      height: 0,
      width: 0
    } });
  }
  doLayout() {
    this._elementSizeObserver.observe(), this._doLayout();
  }
  _doLayout() {
    const e = this._elementSizeObserver.getWidth(), t = this._elementSizeObserver.getHeight(), i = this._getReviewHeight(), n = this._strategy.layout();
    this._originalDomNode.style.width = n + "px", this._originalDomNode.style.left = "0px", this._modifiedDomNode.style.width = e - n + "px", this._modifiedDomNode.style.left = n + "px", this._overviewDomElement.style.top = "0px", this._overviewDomElement.style.height = t - i + "px", this._overviewDomElement.style.width = Vt.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewDomElement.style.left = e - Vt.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewViewportDomElement.setWidth(Vt.ENTIRE_DIFF_OVERVIEW_WIDTH), this._overviewViewportDomElement.setHeight(30), this._originalEditor.layout({ width: n, height: t - i }), this._modifiedEditor.layout({ width: e - n - (this._options.renderOverviewRuler ? Vt.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: t - i }), (this._originalOverviewRuler || this._modifiedOverviewRuler) && this._layoutOverviewRulers(), this._reviewPane.layout(t - i, e, i), this._layoutOverviewViewport();
  }
  _layoutOverviewViewport() {
    const e = this._computeOverviewViewport();
    e ? (this._overviewViewportDomElement.setTop(e.top), this._overviewViewportDomElement.setHeight(e.height)) : (this._overviewViewportDomElement.setTop(0), this._overviewViewportDomElement.setHeight(0));
  }
  _computeOverviewViewport() {
    const e = this._modifiedEditor.getLayoutInfo();
    if (!e)
      return null;
    const t = this._modifiedEditor.getScrollTop(), i = this._modifiedEditor.getScrollHeight(), n = Math.max(0, e.height), r = Math.max(0, n - 2 * 0), o = i > 0 ? r / i : 0, a = Math.max(0, Math.floor(e.height * o)), l = Math.floor(t * o);
    return {
      height: a,
      top: l
    };
  }
  _createDataSource() {
    return {
      getWidth: () => this._elementSizeObserver.getWidth(),
      getHeight: () => this._elementSizeObserver.getHeight() - this._getReviewHeight(),
      getOptions: () => ({
        renderOverviewRuler: this._options.renderOverviewRuler
      }),
      getContainerDomNode: () => this._containerDomElement,
      relayoutEditors: () => {
        this._doLayout();
      },
      getOriginalEditor: () => this._originalEditor,
      getModifiedEditor: () => this._modifiedEditor
    };
  }
  _setStrategy(e) {
    this._strategy && this._strategy.dispose(), this._strategy = e, e.applyColors(this._themeService.getColorTheme()), this._diffComputationResult && this._updateDecorations(), this._doLayout();
  }
  _getLineChangeAtOrBeforeLineNumber(e, t) {
    const i = this._diffComputationResult ? this._diffComputationResult.changes : [];
    if (i.length === 0 || e < t(i[0]))
      return null;
    let n = 0, r = i.length - 1;
    for (; n < r; ) {
      const o = Math.floor((n + r) / 2), a = t(i[o]), l = o + 1 <= r ? t(i[o + 1]) : 1073741824;
      e < a ? r = o - 1 : e >= l ? n = o + 1 : (n = o, r = o);
    }
    return i[n];
  }
  _getEquivalentLineForOriginalLineNumber(e) {
    const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.originalStartLineNumber);
    if (!t)
      return e;
    const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), n = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), r = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, o = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - i;
    return a <= r ? n + Math.min(a, o) : n + o - r + a;
  }
  _getEquivalentLineForModifiedLineNumber(e) {
    const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.modifiedStartLineNumber);
    if (!t)
      return e;
    const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), n = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), r = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, o = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - n;
    return a <= o ? i + Math.min(a, r) : i + r - o + a;
  }
  getDiffLineInformationForOriginal(e) {
    return this._diffComputationResult ? {
      equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(e)
    } : null;
  }
  getDiffLineInformationForModified(e) {
    return this._diffComputationResult ? {
      equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(e)
    } : null;
  }
};
so.ONE_OVERVIEW_WIDTH = 15;
so.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
so.UPDATE_DIFF_DECORATIONS_DELAY = 200;
so = IO([
  Ms(3, AC),
  Ms(4, Cc),
  Ms(5, Qe),
  Ms(6, It),
  Ms(7, Ct),
  Ms(8, vt),
  Ms(9, vs),
  Ms(10, MC),
  Ms(11, RC)
], so);
class qE extends z {
  constructor(e) {
    super(), this._dataSource = e, this._insertColor = null, this._removeColor = null;
  }
  applyColors(e) {
    const t = e.getColor(YA) || (e.getColor(PD) || R1).transparent(2), i = e.getColor(QA) || (e.getColor(OD) || P1).transparent(2), n = !t.equals(this._insertColor) || !i.equals(this._removeColor);
    return this._insertColor = t, this._removeColor = i, n;
  }
  getEditorsDiffDecorations(e, t, i, n, r, o) {
    o = o.sort((h, u) => h.afterLineNumber - u.afterLineNumber), r = r.sort((h, u) => h.afterLineNumber - u.afterLineNumber);
    const a = this._getViewZones(e, r, o, i), l = this._getOriginalEditorDecorations(a, e, t, i), c = this._getModifiedEditorDecorations(a, e, t, i, n);
    return {
      original: {
        decorations: l.decorations,
        overviewZones: l.overviewZones,
        zones: a.original
      },
      modified: {
        decorations: c.decorations,
        overviewZones: c.overviewZones,
        zones: a.modified
      }
    };
  }
}
class gy {
  constructor(e) {
    this._source = e, this._index = -1, this.current = null, this.advance();
  }
  advance() {
    this._index++, this._index < this._source.length ? this.current = this._source[this._index] : this.current = null;
  }
}
class Ho {
  constructor(e, t, i, n, r) {
    this._lineChanges = e, this._originalForeignVZ = t, this._modifiedForeignVZ = i, this._originalEditor = n, this._modifiedEditor = r;
  }
  static _getViewLineCount(e, t, i) {
    const n = e.getModel(), r = e._getViewModel();
    if (n && r) {
      const o = ou(n, r, t, i);
      return o.endLineNumber - o.startLineNumber + 1;
    }
    return i - t + 1;
  }
  getViewZones() {
    const e = this._originalEditor.getOption(61), t = this._modifiedEditor.getOption(61), i = this._originalEditor.getOption(134).wrappingColumn !== -1, n = this._modifiedEditor.getOption(134).wrappingColumn !== -1, r = i || n, o = this._originalEditor.getModel(), a = this._originalEditor._getViewModel().coordinatesConverter, l = this._modifiedEditor._getViewModel().coordinatesConverter, c = {
      original: [],
      modified: []
    };
    let h = 0, u = 0, d = 0, f = 0, m = 0, _ = 0;
    const b = (k, y) => k.afterLineNumber - y.afterLineNumber, v = (k, y) => {
      if (y.domNode === null && k.length > 0) {
        const S = k[k.length - 1];
        if (S.afterLineNumber === y.afterLineNumber && S.domNode === null) {
          S.heightInLines += y.heightInLines;
          return;
        }
      }
      k.push(y);
    }, C = new gy(this._modifiedForeignVZ), w = new gy(this._originalForeignVZ);
    let L = 1, E = 1;
    for (let k = 0, y = this._lineChanges.length; k <= y; k++) {
      const S = k < y ? this._lineChanges[k] : null;
      S !== null ? (d = S.originalStartLineNumber + (S.originalEndLineNumber > 0 ? -1 : 0), f = S.modifiedStartLineNumber + (S.modifiedEndLineNumber > 0 ? -1 : 0), u = S.originalEndLineNumber > 0 ? Ho._getViewLineCount(this._originalEditor, S.originalStartLineNumber, S.originalEndLineNumber) : 0, h = S.modifiedEndLineNumber > 0 ? Ho._getViewLineCount(this._modifiedEditor, S.modifiedStartLineNumber, S.modifiedEndLineNumber) : 0, m = Math.max(S.originalStartLineNumber, S.originalEndLineNumber), _ = Math.max(S.modifiedStartLineNumber, S.modifiedEndLineNumber)) : (d += 1e7 + u, f += 1e7 + h, m = d, _ = f);
      let D = [], T = [];
      if (r) {
        let V;
        S ? S.originalEndLineNumber > 0 ? V = S.originalStartLineNumber - L : V = S.modifiedStartLineNumber - E : V = o.getLineCount() - L + 1;
        for (let U = 0; U < V; U++) {
          const K = L + U, J = E + U, ee = a.getModelLineViewLineCount(K), ne = l.getModelLineViewLineCount(J);
          ee < ne ? D.push({
            afterLineNumber: K,
            heightInLines: ne - ee,
            domNode: null,
            marginDomNode: null
          }) : ee > ne && T.push({
            afterLineNumber: J,
            heightInLines: ee - ne,
            domNode: null,
            marginDomNode: null
          });
        }
        S && (L = (S.originalEndLineNumber > 0 ? S.originalEndLineNumber : S.originalStartLineNumber) + 1, E = (S.modifiedEndLineNumber > 0 ? S.modifiedEndLineNumber : S.modifiedStartLineNumber) + 1);
      }
      for (; C.current && C.current.afterLineNumber <= _; ) {
        let V;
        C.current.afterLineNumber <= f ? V = d - f + C.current.afterLineNumber : V = m;
        let U = null;
        S && S.modifiedStartLineNumber <= C.current.afterLineNumber && C.current.afterLineNumber <= S.modifiedEndLineNumber && (U = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion()), D.push({
          afterLineNumber: V,
          heightInLines: C.current.height / t,
          domNode: null,
          marginDomNode: U
        }), C.advance();
      }
      for (; w.current && w.current.afterLineNumber <= m; ) {
        let V;
        w.current.afterLineNumber <= d ? V = f - d + w.current.afterLineNumber : V = _, T.push({
          afterLineNumber: V,
          heightInLines: w.current.height / e,
          domNode: null
        }), w.advance();
      }
      if (S !== null && Xf(S)) {
        const V = this._produceOriginalFromDiff(S, u, h);
        V && D.push(V);
      }
      if (S !== null && Jf(S)) {
        const V = this._produceModifiedFromDiff(S, u, h);
        V && T.push(V);
      }
      let M = 0, P = 0;
      for (D = D.sort(b), T = T.sort(b); M < D.length && P < T.length; ) {
        const V = D[M], U = T[P], K = V.afterLineNumber - d, J = U.afterLineNumber - f;
        K < J ? (v(c.original, V), M++) : J < K ? (v(c.modified, U), P++) : V.shouldNotShrink ? (v(c.original, V), M++) : U.shouldNotShrink ? (v(c.modified, U), P++) : V.heightInLines >= U.heightInLines ? (V.heightInLines -= U.heightInLines, P++) : (U.heightInLines -= V.heightInLines, M++);
      }
      for (; M < D.length; )
        v(c.original, D[M]), M++;
      for (; P < T.length; )
        v(c.modified, T[P]), P++;
    }
    return {
      original: Ho._ensureDomNodes(c.original),
      modified: Ho._ensureDomNodes(c.modified)
    };
  }
  static _ensureDomNodes(e) {
    return e.map((t) => (t.domNode || (t.domNode = YE()), t));
  }
}
function Ws(s, e, t, i, n) {
  return {
    range: new N(s, e, t, i),
    options: n
  };
}
const ei = {
  arrowRevertChange: mt.register({
    description: "diff-editor-arrow-revert-change",
    glyphMarginClassName: "arrow-revert-change " + ri.asClassName(g.arrowRight)
  }),
  charDelete: mt.register({
    description: "diff-editor-char-delete",
    className: "char-delete"
  }),
  charDeleteWholeLine: mt.register({
    description: "diff-editor-char-delete-whole-line",
    className: "char-delete",
    isWholeLine: !0
  }),
  charInsert: mt.register({
    description: "diff-editor-char-insert",
    className: "char-insert"
  }),
  charInsertWholeLine: mt.register({
    description: "diff-editor-char-insert-whole-line",
    className: "char-insert",
    isWholeLine: !0
  }),
  lineInsert: mt.register({
    description: "diff-editor-line-insert",
    className: "line-insert",
    marginClassName: "gutter-insert",
    isWholeLine: !0
  }),
  lineInsertWithSign: mt.register({
    description: "diff-editor-line-insert-with-sign",
    className: "line-insert",
    linesDecorationsClassName: "insert-sign " + ri.asClassName(TO),
    marginClassName: "gutter-insert",
    isWholeLine: !0
  }),
  lineDelete: mt.register({
    description: "diff-editor-line-delete",
    className: "line-delete",
    marginClassName: "gutter-delete",
    isWholeLine: !0
  }),
  lineDeleteWithSign: mt.register({
    description: "diff-editor-line-delete-with-sign",
    className: "line-delete",
    linesDecorationsClassName: "delete-sign " + ri.asClassName(KE),
    marginClassName: "gutter-delete",
    isWholeLine: !0
  }),
  lineDeleteMargin: mt.register({
    description: "diff-editor-line-delete-margin",
    marginClassName: "gutter-delete"
  })
};
class Ks extends qE {
  constructor(e, t) {
    super(e), this._disableSash = t === !1, this._sashRatio = null, this._sashPosition = null, this._startSashPosition = null, this._sash = this._register(new ji(this._dataSource.getContainerDomNode(), this, { orientation: 0 })), this._disableSash && (this._sash.state = 0), this._sash.onDidStart(() => this._onSashDragStart()), this._sash.onDidChange((i) => this._onSashDrag(i)), this._sash.onDidEnd(() => this._onSashDragEnd()), this._sash.onDidReset(() => this._onSashReset());
  }
  setEnableSplitViewResizing(e) {
    const t = e === !1;
    this._disableSash !== t && (this._disableSash = t, this._sash.state = this._disableSash ? 0 : 3);
  }
  layout(e = this._sashRatio) {
    const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? so.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
    let n = Math.floor((e || 0.5) * i);
    const r = Math.floor(0.5 * i);
    return n = this._disableSash ? r : n || r, i > Ks.MINIMUM_EDITOR_WIDTH * 2 ? (n < Ks.MINIMUM_EDITOR_WIDTH && (n = Ks.MINIMUM_EDITOR_WIDTH), n > i - Ks.MINIMUM_EDITOR_WIDTH && (n = i - Ks.MINIMUM_EDITOR_WIDTH)) : n = r, this._sashPosition !== n && (this._sashPosition = n), this._sash.layout(), this._sashPosition;
  }
  _onSashDragStart() {
    this._startSashPosition = this._sashPosition;
  }
  _onSashDrag(e) {
    const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? so.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), n = this.layout((this._startSashPosition + (e.currentX - e.startX)) / i);
    this._sashRatio = n / i, this._dataSource.relayoutEditors();
  }
  _onSashDragEnd() {
    this._sash.layout();
  }
  _onSashReset() {
    this._sashRatio = 0.5, this._dataSource.relayoutEditors(), this._sash.layout();
  }
  getVerticalSashTop(e) {
    return 0;
  }
  getVerticalSashLeft(e) {
    return this._sashPosition;
  }
  getVerticalSashHeight(e) {
    return this._dataSource.getHeight();
  }
  _getViewZones(e, t, i) {
    const n = this._dataSource.getOriginalEditor(), r = this._dataSource.getModifiedEditor();
    return new MO(e, t, i, n, r).getViewZones();
  }
  _getOriginalEditorDecorations(e, t, i, n) {
    const r = this._dataSource.getOriginalEditor(), o = String(this._removeColor), a = {
      decorations: [],
      overviewZones: []
    }, l = r.getModel(), c = r._getViewModel();
    for (const h of t)
      if (Jf(h)) {
        a.decorations.push({
          range: new N(h.originalStartLineNumber, 1, h.originalEndLineNumber, 1073741824),
          options: n ? ei.lineDeleteWithSign : ei.lineDelete
        }), (!Xf(h) || !h.charChanges) && a.decorations.push(Ws(h.originalStartLineNumber, 1, h.originalEndLineNumber, 1073741824, ei.charDeleteWholeLine));
        const u = ou(l, c, h.originalStartLineNumber, h.originalEndLineNumber);
        if (a.overviewZones.push(new Xh(u.startLineNumber, u.endLineNumber, 0, o)), h.charChanges) {
          for (const d of h.charChanges)
            if (ZE(d))
              if (i)
                for (let f = d.originalStartLineNumber; f <= d.originalEndLineNumber; f++) {
                  let m, _;
                  f === d.originalStartLineNumber ? m = d.originalStartColumn : m = l.getLineFirstNonWhitespaceColumn(f), f === d.originalEndLineNumber ? _ = d.originalEndColumn : _ = l.getLineLastNonWhitespaceColumn(f), a.decorations.push(Ws(f, m, f, _, ei.charDelete));
                }
              else
                a.decorations.push(Ws(d.originalStartLineNumber, d.originalStartColumn, d.originalEndLineNumber, d.originalEndColumn, ei.charDelete));
        }
      }
    return a;
  }
  _getModifiedEditorDecorations(e, t, i, n, r) {
    const o = this._dataSource.getModifiedEditor(), a = String(this._insertColor), l = {
      decorations: [],
      overviewZones: []
    }, c = o.getModel(), h = o._getViewModel();
    for (const u of t) {
      if (r)
        if (u.modifiedEndLineNumber > 0)
          l.decorations.push({
            range: new N(u.modifiedStartLineNumber, 1, u.modifiedStartLineNumber, 1),
            options: ei.arrowRevertChange
          });
        else {
          const d = e.modified.find((f) => f.afterLineNumber === u.modifiedStartLineNumber);
          d && (d.marginDomNode = PO());
        }
      if (Xf(u)) {
        l.decorations.push({
          range: new N(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824),
          options: n ? ei.lineInsertWithSign : ei.lineInsert
        }), (!Jf(u) || !u.charChanges) && l.decorations.push(Ws(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824, ei.charInsertWholeLine));
        const d = ou(c, h, u.modifiedStartLineNumber, u.modifiedEndLineNumber);
        if (l.overviewZones.push(new Xh(d.startLineNumber, d.endLineNumber, 0, a)), u.charChanges) {
          for (const f of u.charChanges)
            if (GE(f))
              if (i)
                for (let m = f.modifiedStartLineNumber; m <= f.modifiedEndLineNumber; m++) {
                  let _, b;
                  m === f.modifiedStartLineNumber ? _ = f.modifiedStartColumn : _ = c.getLineFirstNonWhitespaceColumn(m), m === f.modifiedEndLineNumber ? b = f.modifiedEndColumn : b = c.getLineLastNonWhitespaceColumn(m), l.decorations.push(Ws(m, _, m, b, ei.charInsert));
                }
              else
                l.decorations.push(Ws(f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn, ei.charInsert));
        }
      }
    }
    return l;
  }
}
Ks.MINIMUM_EDITOR_WIDTH = 100;
class MO extends Ho {
  constructor(e, t, i, n, r) {
    super(e, t, i, n, r);
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    return null;
  }
  _produceOriginalFromDiff(e, t, i) {
    return i > t ? {
      afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
      heightInLines: i - t,
      domNode: null
    } : null;
  }
  _produceModifiedFromDiff(e, t, i) {
    return t > i ? {
      afterLineNumber: Math.max(e.modifiedStartLineNumber, e.modifiedEndLineNumber),
      heightInLines: t - i,
      domNode: null
    } : null;
  }
}
class my extends qE {
  constructor(e, t) {
    super(e), this._decorationsLeft = e.getOriginalEditor().getLayoutInfo().decorationsLeft, this._register(e.getOriginalEditor().onDidLayoutChange((i) => {
      this._decorationsLeft !== i.decorationsLeft && (this._decorationsLeft = i.decorationsLeft, e.relayoutEditors());
    }));
  }
  setEnableSplitViewResizing(e) {
  }
  _getViewZones(e, t, i, n) {
    const r = this._dataSource.getOriginalEditor(), o = this._dataSource.getModifiedEditor();
    return new AO(e, t, i, r, o, n).getViewZones();
  }
  _getOriginalEditorDecorations(e, t, i, n) {
    const r = String(this._removeColor), o = {
      decorations: [],
      overviewZones: []
    }, a = this._dataSource.getOriginalEditor(), l = a.getModel(), c = a._getViewModel();
    let h = 0;
    for (const u of t)
      if (Jf(u)) {
        for (o.decorations.push({
          range: new N(u.originalStartLineNumber, 1, u.originalEndLineNumber, 1073741824),
          options: ei.lineDeleteMargin
        }); h < e.modified.length; ) {
          const m = e.modified[h];
          if (m.diff && m.diff.originalStartLineNumber >= u.originalStartLineNumber)
            break;
          h++;
        }
        let d = 0;
        if (h < e.modified.length) {
          const m = e.modified[h];
          m.diff && m.diff.originalStartLineNumber === u.originalStartLineNumber && m.diff.originalEndLineNumber === u.originalEndLineNumber && m.diff.modifiedStartLineNumber === u.modifiedStartLineNumber && m.diff.modifiedEndLineNumber === u.modifiedEndLineNumber && (d = m.heightInLines);
        }
        const f = ou(l, c, u.originalStartLineNumber, u.originalEndLineNumber);
        o.overviewZones.push(new Xh(f.startLineNumber, f.endLineNumber, d, r));
      }
    return o;
  }
  _getModifiedEditorDecorations(e, t, i, n, r) {
    const o = this._dataSource.getModifiedEditor(), a = String(this._insertColor), l = {
      decorations: [],
      overviewZones: []
    }, c = o.getModel(), h = o._getViewModel();
    for (const u of t)
      if (Xf(u)) {
        l.decorations.push({
          range: new N(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824),
          options: n ? ei.lineInsertWithSign : ei.lineInsert
        });
        const d = ou(c, h, u.modifiedStartLineNumber, u.modifiedEndLineNumber);
        if (l.overviewZones.push(new Xh(d.startLineNumber, d.endLineNumber, 0, a)), u.charChanges) {
          for (const f of u.charChanges)
            if (GE(f))
              if (i)
                for (let m = f.modifiedStartLineNumber; m <= f.modifiedEndLineNumber; m++) {
                  let _, b;
                  m === f.modifiedStartLineNumber ? _ = f.modifiedStartColumn : _ = c.getLineFirstNonWhitespaceColumn(m), m === f.modifiedEndLineNumber ? b = f.modifiedEndColumn : b = c.getLineLastNonWhitespaceColumn(m), l.decorations.push(Ws(m, _, m, b, ei.charInsert));
                }
              else
                l.decorations.push(Ws(f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn, ei.charInsert));
        } else
          l.decorations.push(Ws(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824, ei.charInsertWholeLine));
      }
    return l;
  }
  layout() {
    return Math.max(5, this._decorationsLeft);
  }
}
class AO extends Ho {
  constructor(e, t, i, n, r, o) {
    super(e, t, i, n, r), this._originalModel = n.getModel(), this._renderIndicators = o, this._pendingLineChange = [], this._pendingViewZones = [], this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();
  }
  getViewZones() {
    const e = super.getViewZones();
    return this._finalize(e), e;
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    const e = document.createElement("div");
    return e.className = "inline-added-margin-view-zone", e;
  }
  _produceOriginalFromDiff(e, t, i) {
    const n = document.createElement("div");
    return n.className = "inline-added-margin-view-zone", {
      afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
      heightInLines: i,
      domNode: document.createElement("div"),
      marginDomNode: n
    };
  }
  _produceModifiedFromDiff(e, t, i) {
    const n = document.createElement("div");
    n.className = `view-lines line-delete ${Ko}`;
    const r = document.createElement("div");
    r.className = "inline-deleted-margin-view-zone";
    const o = {
      shouldNotShrink: !0,
      afterLineNumber: e.modifiedEndLineNumber === 0 ? e.modifiedStartLineNumber : e.modifiedStartLineNumber - 1,
      heightInLines: t,
      minWidthInPx: 0,
      domNode: n,
      marginDomNode: r,
      diff: {
        originalStartLineNumber: e.originalStartLineNumber,
        originalEndLineNumber: e.originalEndLineNumber,
        modifiedStartLineNumber: e.modifiedStartLineNumber,
        modifiedEndLineNumber: e.modifiedEndLineNumber,
        originalModel: this._originalModel,
        viewLineCounts: null
      }
    };
    for (let a = e.originalStartLineNumber; a <= e.originalEndLineNumber; a++)
      this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(a), null, null);
    return this._pendingLineChange.push(e), this._pendingViewZones.push(o), o;
  }
  _finalize(e) {
    const t = this._modifiedEditor.getOptions(), i = this._modifiedEditor.getModel().getOptions().tabSize, n = t.get(46), r = t.get(29), o = n.typicalHalfwidthCharacterWidth, a = t.get(95), l = this._originalModel.mightContainNonBasicASCII(), c = this._originalModel.mightContainRTL(), h = t.get(61), d = t.get(133).decorationsWidth, f = t.get(107), m = t.get(90), _ = t.get(85), b = t.get(47), v = this._lineBreaksComputer.finalize();
    let C = 0;
    for (let w = 0; w < this._pendingLineChange.length; w++) {
      const L = this._pendingLineChange[w], E = this._pendingViewZones[w], k = E.domNode;
      mi(k, n);
      const y = E.marginDomNode;
      mi(y, n);
      const S = [];
      if (L.charChanges)
        for (const J of L.charChanges)
          ZE(J) && S.push(new lh(new N(J.originalStartLineNumber, J.originalStartColumn, J.originalEndLineNumber, J.originalEndColumn), "char-delete", 0));
      const D = S.length > 0, T = Ol(1e4);
      let M = 0, P = 0, V = null;
      for (let J = L.originalStartLineNumber; J <= L.originalEndLineNumber; J++) {
        const ee = J - L.originalStartLineNumber, ne = this._originalModel.tokenization.getLineTokens(J), ue = ne.getLineContent(), He = v[C++], Ue = gn.filter(S, J, 1, ue.length + 1);
        if (He) {
          let rt = 0;
          for (const Be of He.breakOffsets) {
            const qt = ne.sliceAndInflate(rt, Be, 0), lr = ue.substring(rt, Be);
            M = Math.max(M, this._renderOriginalLine(P++, lr, qt, gn.extractWrapped(Ue, rt, Be), D, l, c, n, r, h, d, f, m, _, b, i, T, y)), rt = Be;
          }
          for (V || (V = []); V.length < ee; )
            V[V.length] = 1;
          V[ee] = He.breakOffsets.length, E.heightInLines += He.breakOffsets.length - 1;
          const bi = document.createElement("div");
          bi.className = "gutter-delete", e.original.push({
            afterLineNumber: J,
            afterColumn: 0,
            heightInLines: He.breakOffsets.length - 1,
            domNode: YE(),
            marginDomNode: bi
          });
        } else
          M = Math.max(M, this._renderOriginalLine(P++, ue, ne, Ue, D, l, c, n, r, h, d, f, m, _, b, i, T, y));
      }
      M += a;
      const U = T.build(), K = fy ? fy.createHTML(U) : U;
      if (k.innerHTML = K, E.minWidthInPx = M * o, V) {
        const J = L.originalEndLineNumber - L.originalStartLineNumber;
        for (; V.length <= J; )
          V[V.length] = 1;
      }
      E.diff.viewLineCounts = V;
    }
    e.original.sort((w, L) => w.afterLineNumber - L.afterLineNumber);
  }
  _renderOriginalLine(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, b, v, C) {
    v.appendASCIIString('<div class="view-line'), r || v.appendASCIIString(" char-delete"), v.appendASCIIString('" style="top:'), v.appendASCIIString(String(e * h)), v.appendASCIIString('px;width:1000000px;">');
    const w = Wi.isBasicASCII(t, o), L = Wi.containsRTL(t, w, a), E = zb(new dc(
      l.isMonospace && !c,
      l.canUseHalfwidthRightwardsArrow,
      t,
      !1,
      w,
      L,
      0,
      i,
      n,
      b,
      0,
      l.spaceWidth,
      l.middotWidth,
      l.wsmiddotWidth,
      d,
      f,
      m,
      _ !== qi.OFF,
      null
    ), v);
    if (v.appendASCIIString("</div>"), this._renderIndicators) {
      const k = document.createElement("div");
      k.className = `delete-sign ${ri.asClassName(KE)}`, k.setAttribute("style", `position:absolute;top:${e * h}px;width:${u}px;height:${h}px;right:0;`), C.appendChild(k);
    }
    return E.characterMapping.getHorizontalOffset(E.characterMapping.length);
  }
}
function RO(s, e) {
  return Rt(s, e, ["off", "on", "inherit"]);
}
function Xf(s) {
  return s.modifiedEndLineNumber > 0;
}
function Jf(s) {
  return s.originalEndLineNumber > 0;
}
function GE(s) {
  return s.modifiedStartLineNumber === s.modifiedEndLineNumber ? s.modifiedEndColumn - s.modifiedStartColumn > 0 : s.modifiedEndLineNumber - s.modifiedStartLineNumber > 0;
}
function ZE(s) {
  return s.originalStartLineNumber === s.originalEndLineNumber ? s.originalEndColumn - s.originalStartColumn > 0 : s.originalEndLineNumber - s.originalStartLineNumber > 0;
}
function YE() {
  const s = document.createElement("div");
  return s.className = "diagonal-fill", s;
}
function PO() {
  const s = document.createElement("div");
  return s.className = "arrow-revert-change " + ri.asClassName(g.arrowRight), ae("div", {}, s);
}
function ou(s, e, t, i) {
  const n = s.getLineCount();
  return t = Math.min(n, Math.max(1, t)), i = Math.min(n, Math.max(1, i)), e.coordinatesConverter.convertModelRangeToViewRange(new N(t, s.getLineMinColumn(t), i, s.getLineMaxColumn(i)));
}
function py(s, e) {
  return {
    enableSplitViewResizing: G(s.enableSplitViewResizing, e.enableSplitViewResizing),
    renderSideBySide: G(s.renderSideBySide, e.renderSideBySide),
    renderMarginRevertIcon: G(s.renderMarginRevertIcon, e.renderMarginRevertIcon),
    maxComputationTime: c_(s.maxComputationTime, e.maxComputationTime, 0, 1073741824),
    maxFileSize: c_(s.maxFileSize, e.maxFileSize, 0, 1073741824),
    ignoreTrimWhitespace: G(s.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
    renderIndicators: G(s.renderIndicators, e.renderIndicators),
    originalEditable: G(s.originalEditable, e.originalEditable),
    diffCodeLens: G(s.diffCodeLens, e.diffCodeLens),
    renderOverviewRuler: G(s.renderOverviewRuler, e.renderOverviewRuler),
    diffWordWrap: RO(s.diffWordWrap, e.diffWordWrap)
  };
}
function OO(s, e) {
  return {
    enableSplitViewResizing: s.enableSplitViewResizing !== e.enableSplitViewResizing,
    renderSideBySide: s.renderSideBySide !== e.renderSideBySide,
    renderMarginRevertIcon: s.renderMarginRevertIcon !== e.renderMarginRevertIcon,
    maxComputationTime: s.maxComputationTime !== e.maxComputationTime,
    maxFileSize: s.maxFileSize !== e.maxFileSize,
    ignoreTrimWhitespace: s.ignoreTrimWhitespace !== e.ignoreTrimWhitespace,
    renderIndicators: s.renderIndicators !== e.renderIndicators,
    originalEditable: s.originalEditable !== e.originalEditable,
    diffCodeLens: s.diffCodeLens !== e.diffCodeLens,
    renderOverviewRuler: s.renderOverviewRuler !== e.renderOverviewRuler,
    diffWordWrap: s.diffWordWrap !== e.diffWordWrap
  };
}
zi((s, e) => {
  const t = s.getColor(PD);
  t && e.addRule(`.monaco-editor .char-insert, .monaco-diff-editor .char-insert { background-color: ${t}; }`);
  const i = s.getColor(KA) || t;
  i && e.addRule(`.monaco-editor .line-insert, .monaco-diff-editor .line-insert { background-color: ${i}; }`);
  const n = s.getColor(GA) || i;
  n && (e.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${n}; }`), e.addRule(`.monaco-editor .gutter-insert, .monaco-diff-editor .gutter-insert { background-color: ${n}; }`));
  const r = s.getColor(OD);
  r && e.addRule(`.monaco-editor .char-delete, .monaco-diff-editor .char-delete { background-color: ${r}; }`);
  const o = s.getColor(qA) || r;
  o && e.addRule(`.monaco-editor .line-delete, .monaco-diff-editor .line-delete { background-color: ${o}; }`);
  const a = s.getColor(ZA) || o;
  a && (e.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${a}; }`), e.addRule(`.monaco-editor .gutter-delete, .monaco-diff-editor .gutter-delete { background-color: ${a}; }`));
  const l = s.getColor(XA);
  l && e.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${cs(s.type) ? "dashed" : "solid"} ${l}; }`);
  const c = s.getColor(JA);
  c && e.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${cs(s.type) ? "dashed" : "solid"} ${c}; }`);
  const h = s.getColor(gc);
  h && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${h}; }`);
  const u = s.getColor(e7);
  u && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${u}; }`);
  const d = s.getColor(Po);
  d && e.addRule(`
			.monaco-diff-editor .diffViewport {
				background: ${d};
			}
		`);
  const f = s.getColor(Oo);
  f && e.addRule(`
			.monaco-diff-editor .diffViewport:hover {
				background: ${f};
			}
		`);
  const m = s.getColor(Fo);
  m && e.addRule(`
			.monaco-diff-editor .diffViewport:active {
				background: ${m};
			}
		`);
  const _ = s.getColor(t7);
  e.addRule(`
	.monaco-editor .diagonal-fill {
		background-image: linear-gradient(
			-45deg,
			${_} 12.5%,
			#0000 12.5%, #0000 50%,
			${_} 50%, ${_} 62.5%,
			#0000 62.5%, #0000 100%
		);
		background-size: 8px 8px;
	}
	`);
});
var FO = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, BO = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, VO = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
let s0 = class extends z {
  constructor(e) {
    super(), this._themeService = e, this._onCodeEditorAdd = this._register(new A()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new A()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onDiffEditorAdd = this._register(new A()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new A()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._codeEditorOpenHandlers = new Ei(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  removeDiffEditor(e) {
    delete this._diffEditors[e.getId()] && this._onDiffEditorRemove.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorationsByType(e))));
  }
  setModelProperty(e, t, i) {
    const n = e.toString();
    let r;
    this._modelProperties.has(n) ? r = this._modelProperties.get(n) : (r = /* @__PURE__ */ new Map(), this._modelProperties.set(n, r)), r.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
  openCodeEditor(e, t, i) {
    return VO(this, void 0, void 0, function* () {
      for (const n of this._codeEditorOpenHandlers) {
        const r = yield n(e, t, i);
        if (r !== null)
          return r;
      }
      return null;
    });
  }
  registerCodeEditorOpenHandler(e) {
    const t = this._codeEditorOpenHandlers.unshift(e);
    return ze(t);
  }
};
s0 = FO([
  BO(0, vt)
], s0);
var WO = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, _y = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, HO = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
let eg = class extends s0 {
  constructor(e, t) {
    super(t), this.onCodeEditorAdd(() => this._checkContextKey()), this.onCodeEditorRemove(() => this._checkContextKey()), this._editorIsOpen = e.createKey("editorIsOpen", !1), this._activeCodeEditor = null, this.registerCodeEditorOpenHandler((i, n, r) => HO(this, void 0, void 0, function* () {
      return n ? this.doOpenEditor(n, i) : null;
    }));
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const r = t.resource.scheme;
        if (r === we.http || r === we.https)
          return rD(t.resource.toString()), e;
      }
      return null;
    }
    const n = t.options ? t.options.selection : null;
    if (n)
      if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number")
        e.setSelection(n), e.revealRangeInCenter(n, 1);
      else {
        const r = {
          lineNumber: n.startLineNumber,
          column: n.startColumn
        };
        e.setPosition(r), e.revealPositionInCenter(r, 1);
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
eg = WO([
  _y(0, Qe),
  _y(1, vt)
], eg);
Ee(Ct, eg);
const vc = Se("layoutService");
var QE = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, XE = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let tg = class {
  constructor(e) {
    this._codeEditorService = e, this.onDidLayout = Q.None, this.offset = { top: 0, quickPickTop: 0 };
  }
  get dimension() {
    return this._dimension || (this._dimension = J2(window.document.body)), this._dimension;
  }
  get hasContainer() {
    return !1;
  }
  get container() {
    throw new Error("ILayoutService.container is not available in the standalone editor!");
  }
  focus() {
    var e;
    (e = this._codeEditorService.getFocusedCodeEditor()) === null || e === void 0 || e.focus();
  }
};
tg = QE([
  XE(0, Ct)
], tg);
let r0 = class extends tg {
  constructor(e, t) {
    super(t), this._container = e;
  }
  get hasContainer() {
    return !1;
  }
  get container() {
    return this._container;
  }
};
r0 = QE([
  XE(1, Ct)
], r0);
Ee(vc, tg);
const JE = Se("dialogService");
var zO = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, by = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Ed = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
function xd(s) {
  return s.scheme === we.file ? s.fsPath : s.path;
}
let ex = 0;
class Id {
  constructor(e, t, i, n, r, o, a) {
    this.id = ++ex, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = n, this.groupOrder = r, this.sourceId = o, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class Cy {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class vy {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, n] of this.elements)
      (n.reason === 0 ? e : t).push(n.resourceLabel);
    const i = [];
    return e.length > 0 && i.push(p({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(p({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class UO {
  constructor(e, t, i, n, r, o, a) {
    this.id = ++ex, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = r, this.sourceId = o, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new vy()), this.removedResources.has(t) || this.removedResources.set(t, new Cy(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new vy()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new Cy(e, 0)));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class tx {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(this.resourceLabel, this.strResource, 0);
    for (const e of this._future)
      e.type === 1 && e.removeResource(this.resourceLabel, this.strResource, 0);
    this.versionId++;
  }
  toString() {
    const e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(this.resourceLabel, this.strResource, 1);
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, n = this._past.length; i < n; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new kE(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, n = 0, r = -1;
    for (let a = 0, l = this._past.length; a < l; a++, n++) {
      const c = this._past[a];
      i && (n >= t || c.id !== e.elements[n]) && (i = !1, r = 0), !i && c.type === 1 && c.removeResource(this.resourceLabel, this.strResource, 0);
    }
    let o = -1;
    for (let a = this._future.length - 1; a >= 0; a--, n++) {
      const l = this._future[a];
      i && (n >= t || l.id !== e.elements[n]) && (i = !1, o = a), !i && l.type === 1 && l.removeResource(this.resourceLabel, this.strResource, 0);
    }
    r !== -1 && (this._past = this._past.slice(0, r)), o !== -1 && (this._future = this._future.slice(o + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class Hp {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const ix = new tx("", "");
ix.locked = !0;
let o0 = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    const t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = Zl.None, i = es.None) {
    if (e.type === 0) {
      const n = xd(e.resource), r = this.getUriComparisonKey(e.resource);
      this._pushElement(new Id(e, n, r, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const n = /* @__PURE__ */ new Set(), r = [], o = [];
      for (const a of e.resources) {
        const l = xd(a), c = this.getUriComparisonKey(a);
        n.has(c) || (n.add(c), r.push(l), o.push(c));
      }
      r.length === 1 ? this._pushElement(new Id(e, r[0], o[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new UO(e, r, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const n = e.resourceLabels[t], r = e.strResources[t];
      let o;
      this._editStacks.has(r) ? o = this._editStacks.get(r) : (o = new tx(n, r), this._editStacks.set(r, o)), o.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const n = i.getClosestPastElement();
      return n ? n.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const r of i) {
      const o = xd(r.resource), a = this.getUriComparisonKey(r.resource), l = new Id(r, o, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const r of e.strResources) {
      if (t && t.has(r))
        continue;
      this._editStacks.get(r).splitPastWorkspaceElement(e, n);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const r of i) {
      const o = xd(r.resource), a = this.getUriComparisonKey(r.resource), l = new Id(r, o, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const r of e.strResources) {
      if (t && t.has(r))
        continue;
      this._editStacks.get(r).splitFutureWorkspaceElement(e, n);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const n = this.getUriComparisonKey(e);
    this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new kE(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, r] of this._editStacks) {
      const o = r.getClosestPastElement();
      !o || o.sourceId === e && (!t || o.sourceOrder > t.sourceOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof es) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    ct(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, n, r) {
    const o = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return o(), n.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (o(), n.dispose(), r()), (l) => (o(), n.dispose(), this._onError(l, e))) : (o(), n.dispose(), r());
  }
  _invokeWorkspacePrepare(e) {
    return Ed(this, void 0, void 0, function* () {
      if (typeof e.actual.prepareUndoRedo > "u")
        return z.None;
      const t = e.actual.prepareUndoRedo();
      return typeof t > "u" ? z.None : t;
    });
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(z.None);
    const i = e.actual.prepareUndoRedo();
    return i ? UN(i) ? t(i) : i.then((n) => t(n)) : t(z.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || ix);
    return new Hp(t);
  }
  _tryToSplitAndUndo(e, t, i, n) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new Nd(this._undo(e, 0, !0));
    for (const r of t.strResources)
      this.removeElements(r);
    return this._notificationService.warn(n), new Nd();
  }
  _checkWorkspaceUndo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, p({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, p({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const r = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && r.push(a.resourceLabel);
    if (r.length > 0)
      return this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, r.join(", ")));
    const o = [];
    for (const a of i.editStacks)
      a.locked && o.push(a.resourceLabel);
    return o.length > 0 ? this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, o.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const n = this._getAffectedEditStacks(t), r = this._checkWorkspaceUndo(e, t, n, !1);
    return r ? r.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (!!i) {
        if (i === e) {
          const n = t.getSecondClosestPastElement();
          if (n && n.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
    return Ed(this, void 0, void 0, function* () {
      if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
        const a = yield this._dialogService.show(pt.Info, p("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label), [
          p({ key: "ok", comment: ["{0} denotes a number that is > 1"] }, "Undo in {0} Files", i.editStacks.length),
          p("nok", "Undo this File"),
          p("cancel", "Cancel")
        ], {
          cancelId: 2
        });
        if (a.choice === 2)
          return;
        if (a.choice === 1)
          return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
        const l = this._checkWorkspaceUndo(e, t, i, !1);
        if (l)
          return l.returnValue;
        n = !0;
      }
      let r;
      try {
        r = yield this._invokeWorkspacePrepare(t);
      } catch (a) {
        return this._onError(a, t);
      }
      const o = this._checkWorkspaceUndo(e, t, i, !0);
      if (o)
        return r.dispose(), o.returnValue;
      for (const a of i.editStacks)
        a.moveBackward(t);
      return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, r, () => this._continueUndoInGroup(t.groupId, n));
    });
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const n = p({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(n);
      return;
    }
    return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new Hp([e]), n, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, r] of this._editStacks) {
      const o = r.getClosestPastElement();
      !o || o.groupId === e && (!t || o.groupOrder > t.groupOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof es) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const n = this._editStacks.get(e), r = n.getClosestPastElement();
    if (!r)
      return;
    if (r.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(r.groupId);
      if (r !== a && l)
        return this._undo(l, t, i);
    }
    if ((r.sourceId !== t || r.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, r);
    try {
      return r.type === 1 ? this._workspaceUndo(e, r, i) : this._resourceUndo(n, r, i);
    } finally {
    }
  }
  _confirmAndContinueUndo(e, t, i) {
    return Ed(this, void 0, void 0, function* () {
      if ((yield this._dialogService.show(pt.Info, p("confirmDifferentSource", "Would you like to undo '{0}'?", i.label), [
        p("confirmDifferentSource.yes", "Yes"),
        p("confirmDifferentSource.no", "No")
      ], {
        cancelId: 1
      })).choice !== 1)
        return this._undo(e, t, !0);
    });
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, r] of this._editStacks) {
      const o = r.getClosestFutureElement();
      !o || o.sourceId === e && (!t || o.sourceOrder < t.sourceOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof es) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, n) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new Nd(this._redo(e));
    for (const r of t.strResources)
      this.removeElements(r);
    return this._notificationService.warn(n), new Nd();
  }
  _checkWorkspaceRedo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, p({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, p({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const r = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && r.push(a.resourceLabel);
    if (r.length > 0)
      return this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, r.join(", ")));
    const o = [];
    for (const a of i.editStacks)
      a.locked && o.push(a.resourceLabel);
    return o.length > 0 ? this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, o.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(e, t, i, !1);
    return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  _executeWorkspaceRedo(e, t, i) {
    return Ed(this, void 0, void 0, function* () {
      let n;
      try {
        n = yield this._invokeWorkspacePrepare(t);
      } catch (o) {
        return this._onError(o, t);
      }
      const r = this._checkWorkspaceRedo(e, t, i, !0);
      if (r)
        return n.dispose(), r.returnValue;
      for (const o of i.editStacks)
        o.moveForward(t);
      return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
    });
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = p({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new Hp([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, r] of this._editStacks) {
      const o = r.getClosestFutureElement();
      !o || o.groupId === e && (!t || o.groupOrder < t.groupOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof es) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (!!i) {
      if (i.groupId) {
        const [n, r] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== n && r)
          return this._redo(r);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
o0 = zO([
  by(0, JE),
  by(1, vs)
], o0);
class Nd {
  constructor(e) {
    this.returnValue = e;
  }
}
Ee(CC, o0);
function Ri(s, e, t) {
  return Math.min(Math.max(s, e), t);
}
class nx {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
  }
  get value() {
    return this._val;
  }
}
class $O {
  constructor(e) {
    this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
  }
  update(e) {
    const t = this._values[this._index];
    return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
  }
  get value() {
    return this._val;
  }
}
var wy = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
const jO = Se("openerService");
Object.freeze({
  _serviceBrand: void 0,
  registerOpener() {
    return z.None;
  },
  registerValidator() {
    return z.None;
  },
  registerExternalUriResolver() {
    return z.None;
  },
  setDefaultExternalOpener() {
  },
  registerExternalOpener() {
    return z.None;
  },
  open() {
    return wy(this, void 0, void 0, function* () {
      return !1;
    });
  },
  resolveExternalUri(s) {
    return wy(this, void 0, void 0, function* () {
      return { resolved: s, dispose() {
      } };
    });
  }
});
function PC(s, e) {
  return Le.isUri(s) ? Ka(s.scheme, e) : yb(s, e + ":");
}
function Sy(s, ...e) {
  return e.some((t) => PC(s, t));
}
function KO(s) {
  let e;
  const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(s.fragment);
  return t && (e = {
    startLineNumber: parseInt(t[1]),
    startColumn: t[2] ? parseInt(t[2]) : 1,
    endLineNumber: t[4] ? parseInt(t[4]) : void 0,
    endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
  }, s = s.with({ fragment: "" })), { selection: e, uri: s };
}
var qO = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, GO = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const dm = Se("ILanguageFeatureDebounceService");
var ig;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  let t = 0;
  function i(n) {
    let r = e.get(n);
    return r === void 0 && (r = ++t, e.set(n, r)), r;
  }
  s.of = i;
})(ig || (ig = {}));
class ZO {
  constructor(e, t, i, n, r, o) {
    this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = r, this._max = o, this._cache = new DC(50, 0.7);
  }
  _key(e) {
    return e.id + this._registry.all(e).reduce((t, i) => Fb(ig.of(i), t), 0);
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return i ? Ri(i.value, this._min, this._max) : this.default();
  }
  update(e, t) {
    const i = this._key(e);
    let n = this._cache.get(i);
    n || (n = new $O(6), this._cache.set(i, n));
    const r = Ri(n.update(t), this._min, this._max);
    return PC(e.uri, "output") || this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${r}ms`), r;
  }
  _overall() {
    const e = new nx();
    for (const [, t] of this._cache)
      e.update(t.value);
    return e.value;
  }
  default() {
    const e = this._overall() | 0 || this._default;
    return Ri(e, this._min, this._max);
  }
}
let a0 = class {
  constructor(e) {
    this._logService = e, this._data = /* @__PURE__ */ new Map();
  }
  for(e, t, i) {
    var n, r, o;
    const a = (n = i == null ? void 0 : i.min) !== null && n !== void 0 ? n : 50, l = (r = i == null ? void 0 : i.max) !== null && r !== void 0 ? r : Math.pow(a, 2), c = (o = i == null ? void 0 : i.key) !== null && o !== void 0 ? o : void 0, h = `${ig.of(e)},${a}${c ? "," + c : ""}`;
    let u = this._data.get(h);
    return u || (u = new ZO(
      this._logService,
      t,
      e,
      this._overallAverage() | 0 || a * 1.5,
      a,
      l
    ), this._data.set(h, u)), u;
  }
  _overallAverage() {
    const e = new nx();
    for (const t of this._data.values())
      e.update(t.default());
    return e.value;
  }
};
a0 = qO([
  GO(0, ao)
], a0);
Ee(dm, a0, !0);
const YO = Se("IWorkspaceEditService");
class sx {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (Zo.is(t))
        return Zo.lift(t);
      if (kl.is(t))
        return kl.lift(t);
      throw new Error("Unsupported edit");
    });
  }
}
class Zo extends sx {
  constructor(e, t, i = void 0, n) {
    super(n), this.resource = e, this.textEdit = t, this.versionId = i;
  }
  static is(e) {
    return e instanceof Zo ? !0 : Pi(e) && Le.isUri(e.resource) && Pi(e.textEdit);
  }
  static lift(e) {
    return e instanceof Zo ? e : new Zo(e.resource, e.textEdit, e.versionId, e.metadata);
  }
}
class kl extends sx {
  constructor(e, t, i = {}, n) {
    super(n), this.oldResource = e, this.newResource = t, this.options = i;
  }
  static is(e) {
    return e instanceof kl ? !0 : Pi(e) && (Boolean(e.newResource) || Boolean(e.oldResource));
  }
  static lift(e) {
    return e instanceof kl ? e : new kl(e.oldResource, e.newResource, e.options, e.metadata);
  }
}
const QO = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: p("editorConfigurationTitle", "Editor"),
  scope: 5
}), ng = Object.assign(Object.assign({}, QO), { properties: {
  "editor.tabSize": {
    type: "number",
    default: zt.tabSize,
    minimum: 1,
    markdownDescription: p("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  "editor.insertSpaces": {
    type: "boolean",
    default: zt.insertSpaces,
    markdownDescription: p("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  "editor.detectIndentation": {
    type: "boolean",
    default: zt.detectIndentation,
    markdownDescription: p("detectIndentation", "Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents.")
  },
  "editor.trimAutoWhitespace": {
    type: "boolean",
    default: zt.trimAutoWhitespace,
    description: p("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
  },
  "editor.largeFileOptimizations": {
    type: "boolean",
    default: zt.largeFileOptimizations,
    description: p("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
  },
  "editor.wordBasedSuggestions": {
    type: "boolean",
    default: !0,
    description: p("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document.")
  },
  "editor.wordBasedSuggestionsMode": {
    enum: ["currentDocument", "matchingDocuments", "allDocuments"],
    default: "matchingDocuments",
    enumDescriptions: [
      p("wordBasedSuggestionsMode.currentDocument", "Only suggest words from the active document."),
      p("wordBasedSuggestionsMode.matchingDocuments", "Suggest words from all open documents of the same language."),
      p("wordBasedSuggestionsMode.allDocuments", "Suggest words from all open documents.")
    ],
    description: p("wordBasedSuggestionsMode", "Controls from which documents word based completions are computed.")
  },
  "editor.semanticHighlighting.enabled": {
    enum: [!0, !1, "configuredByTheme"],
    enumDescriptions: [
      p("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
      p("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
      p("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
    ],
    default: "configuredByTheme",
    description: p("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
  },
  "editor.stablePeek": {
    type: "boolean",
    default: !1,
    markdownDescription: p("stablePeek", "Keep peek editors open even when double clicking their content or when hitting `Escape`.")
  },
  "editor.maxTokenizationLineLength": {
    type: "integer",
    default: 2e4,
    description: p("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
  },
  "editor.language.brackets": {
    type: ["array", "null"],
    default: null,
    description: p("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
    items: {
      type: "array",
      items: [
        {
          type: "string",
          description: p("schema.openBracket", "The opening bracket character or string sequence.")
        },
        {
          type: "string",
          description: p("schema.closeBracket", "The closing bracket character or string sequence.")
        }
      ]
    }
  },
  "editor.language.colorizedBracketPairs": {
    type: ["array", "null"],
    default: null,
    description: p("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
    items: {
      type: "array",
      items: [
        {
          type: "string",
          description: p("schema.openBracket", "The opening bracket character or string sequence.")
        },
        {
          type: "string",
          description: p("schema.closeBracket", "The closing bracket character or string sequence.")
        }
      ]
    }
  },
  "diffEditor.maxComputationTime": {
    type: "number",
    default: 5e3,
    description: p("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
  },
  "diffEditor.maxFileSize": {
    type: "number",
    default: 50,
    description: p("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
  },
  "diffEditor.renderSideBySide": {
    type: "boolean",
    default: !0,
    description: p("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
  },
  "diffEditor.renderMarginRevertIcon": {
    type: "boolean",
    default: !0,
    description: p("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
  },
  "diffEditor.ignoreTrimWhitespace": {
    type: "boolean",
    default: !0,
    description: p("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
  },
  "diffEditor.renderIndicators": {
    type: "boolean",
    default: !0,
    description: p("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
  },
  "diffEditor.codeLens": {
    type: "boolean",
    default: !1,
    description: p("codeLens", "Controls whether the editor shows CodeLens.")
  },
  "diffEditor.wordWrap": {
    type: "string",
    enum: ["off", "on", "inherit"],
    default: "inherit",
    markdownEnumDescriptions: [
      p("wordWrap.off", "Lines will never wrap."),
      p("wordWrap.on", "Lines will wrap at the viewport width."),
      p("wordWrap.inherit", "Lines will wrap according to the `#editor.wordWrap#` setting.")
    ]
  }
} });
function XO(s) {
  return typeof s.type < "u" || typeof s.anyOf < "u";
}
for (const s of $a) {
  const e = s.schema;
  if (typeof e < "u")
    if (XO(e))
      ng.properties[`editor.${s.name}`] = e;
    else
      for (const t in e)
        Object.hasOwnProperty.call(e, t) && (ng.properties[t] = e[t]);
}
let Td = null;
function rx() {
  return Td === null && (Td = /* @__PURE__ */ Object.create(null), Object.keys(ng.properties).forEach((s) => {
    Td[s] = !0;
  })), Td;
}
function JO(s) {
  return rx()[`editor.${s}`] || !1;
}
function e6(s) {
  return rx()[`diffEditor.${s}`] || !1;
}
const t6 = Ft.as(uc.Configuration);
t6.registerConfiguration(ng);
class i6 {
  static insert(e, t) {
    return {
      range: new N(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
class Li {
  constructor(e = {}, t = [], i = []) {
    this._contents = e, this._keys = t, this._overrides = i, this.frozen = !1, this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get contents() {
    return this.checkAndFreeze(this._contents);
  }
  get overrides() {
    return this.checkAndFreeze(this._overrides);
  }
  get keys() {
    return this.checkAndFreeze(this._keys);
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? tw(this.contents, e) : this.contents;
  }
  getOverrideValue(e, t) {
    const i = this.getContentsForOverrideIdentifer(t);
    return i ? e ? tw(i, e) : i : void 0;
  }
  override(e) {
    let t = this.overrideConfigurations.get(e);
    return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
  }
  merge(...e) {
    const t = Sr(this.contents), i = Sr(this.overrides), n = [...this.keys];
    for (const r of e)
      if (!r.isEmpty()) {
        this.mergeContents(t, r.contents);
        for (const o of r.overrides) {
          const [a] = i.filter((l) => rs(l.identifiers, o.identifiers));
          a ? (this.mergeContents(a.contents, o.contents), a.keys.push(...o.keys), a.keys = Xr(a.keys)) : i.push(Sr(o));
        }
        for (const o of r.keys)
          n.indexOf(o) === -1 && n.push(o);
      }
    return new Li(t, n, i);
  }
  freeze() {
    return this.frozen = !0, this;
  }
  createOverrideConfigurationModel(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    const i = {};
    for (const n of Xr([...Object.keys(this.contents), ...Object.keys(t)])) {
      let r = this.contents[n];
      const o = t[n];
      o && (typeof r == "object" && typeof o == "object" ? (r = Sr(r), this.mergeContents(r, o)) : r = o), i[n] = r;
    }
    return new Li(i, this.keys, this.overrides);
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && Pi(e[i]) && Pi(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = Sr(t[i]);
    }
  }
  checkAndFreeze(e) {
    return this.frozen && !Object.isFrozen(e) ? XI(e) : e;
  }
  getContentsForOverrideIdentifer(e) {
    let t = null, i = null;
    const n = (r) => {
      r && (i ? this.mergeContents(i, r) : i = Sr(r));
    };
    for (const r of this.overrides)
      rs(r.identifiers, [e]) ? t = r.contents : r.identifiers.includes(e) && n(r.contents);
    return n(t), i;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  setValue(e, t) {
    this.addKey(e), Ob(this.contents, e, t, (i) => {
      throw new Error(i);
    });
  }
  removeValue(e) {
    this.removeKey(e) && p4(this.contents, e);
  }
  addKey(e) {
    let t = this.keys.length;
    for (let i = 0; i < t; i++)
      e.indexOf(this.keys[i]) === 0 && (t = i);
    this.keys.splice(t, 1, e);
  }
  removeKey(e) {
    const t = this.keys.indexOf(e);
    return t !== -1 ? (this.keys.splice(t, 1), !0) : !1;
  }
}
class fm {
  constructor(e, t, i, n, r = new Li(), o = new Li(), a = new si(), l = new Li(), c = new si(), h = !0) {
    this._defaultConfiguration = e, this._policyConfiguration = t, this._applicationConfiguration = i, this._localUserConfiguration = n, this._remoteUserConfiguration = r, this._workspaceConfiguration = o, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = c, this._freeze = h, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new si(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidatedConfigurationModel(e, t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let n;
    i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = new Li(), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  inspect(e, t, i) {
    const n = this.getConsolidatedConfigurationModel(e, t, i), r = this.getFolderConfigurationModelForResource(t.resource, i), o = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = t.overrideIdentifier ? this._defaultConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this._defaultConfiguration.freeze().getValue(e), l = this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration.freeze().getValue(e), c = this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration.freeze().getValue(e), h = t.overrideIdentifier ? this.userConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this.userConfiguration.freeze().getValue(e), u = t.overrideIdentifier ? this.localUserConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this.localUserConfiguration.freeze().getValue(e), d = t.overrideIdentifier ? this.remoteUserConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this.remoteUserConfiguration.freeze().getValue(e), f = i ? t.overrideIdentifier ? this._workspaceConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this._workspaceConfiguration.freeze().getValue(e) : void 0, m = r ? t.overrideIdentifier ? r.freeze().override(t.overrideIdentifier).getValue(e) : r.freeze().getValue(e) : void 0, _ = t.overrideIdentifier ? o.override(t.overrideIdentifier).getValue(e) : o.getValue(e), b = n.getValue(e), v = Xr(n.overrides.map((C) => C.identifiers).flat()).filter((C) => n.getOverrideValue(e, C) !== void 0);
    return {
      defaultValue: a,
      policyValue: l,
      applicationValue: c,
      userValue: h,
      userLocalValue: u,
      userRemoteValue: d,
      workspaceValue: f,
      workspaceFolderValue: m,
      memoryValue: _,
      value: b,
      default: a !== void 0 ? { value: this._defaultConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this._defaultConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      policy: l !== void 0 ? { value: l } : void 0,
      application: c !== void 0 ? { value: c, override: t.overrideIdentifier ? this.applicationConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      user: h !== void 0 ? { value: this.userConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this.userConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      userLocal: u !== void 0 ? { value: this.localUserConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this.localUserConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      userRemote: d !== void 0 ? { value: this.remoteUserConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this.remoteUserConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      workspace: f !== void 0 ? { value: this._workspaceConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this._workspaceConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      workspaceFolder: m !== void 0 ? { value: r == null ? void 0 : r.freeze().getValue(e), override: t.overrideIdentifier ? r == null ? void 0 : r.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      memory: _ !== void 0 ? { value: o.getValue(e), override: t.overrideIdentifier ? o.getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
      overrideIdentifiers: v.length ? v : void 0
    };
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration), this._freeze && this._userConfiguration.freeze()), this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(e, t, i) {
    let n = this.getConsolidatedConfigurationModelForResource(t, i);
    return t.overrideIdentifier && (n = n.override(t.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0 && (n = n.merge(this._policyConfiguration)), n;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const n = t.getFolder(e);
      n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
      const r = this._memoryConfigurationByResource.get(e);
      r && (i = i.merge(r));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration), this._freeze && (this._workspaceConfiguration = this._workspaceConfiguration.freeze())), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
      n ? (t = i.merge(n), this._freeze && (t = t.freeze()), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  getFolderConfigurationModelForResource(e, t) {
    if (t && e) {
      const i = t.getFolder(e);
      if (i)
        return this._folderConfigurations.get(i.uri);
    }
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: n, keys: r } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: n, keys: r }]), e;
      }, [])
    };
  }
  static parse(e) {
    const t = this.parseConfigurationModel(e.defaults), i = this.parseConfigurationModel(e.policy), n = this.parseConfigurationModel(e.application), r = this.parseConfigurationModel(e.user), o = this.parseConfigurationModel(e.workspace), a = e.folders.reduce((l, c) => (l.set(Le.revive(c[0]), this.parseConfigurationModel(c[1])), l), new si());
    return new fm(t, i, n, r, new Li(), o, a, new Li(), new si(), !1);
  }
  static parseConfigurationModel(e) {
    return new Li(e.contents, e.keys, e.overrides).freeze();
  }
}
class n6 {
  constructor(e, t, i, n) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this._previousConfiguration = void 0;
    const r = /* @__PURE__ */ new Set();
    e.keys.forEach((a) => r.add(a)), e.overrides.forEach(([, a]) => a.forEach((l) => r.add(l))), this.affectedKeys = [...r.values()];
    const o = new Li();
    this.affectedKeys.forEach((a) => o.setValue(a, {})), this.affectedKeysTree = o.contents;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = fm.parse(this.previous.data)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    var i;
    if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, e)) {
      if (t) {
        const n = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (i = this.previous) === null || i === void 0 ? void 0 : i.workspace) : void 0, r = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
        return !en(n, r);
      }
      return !0;
    }
    return !1;
  }
  doesAffectedKeysTreeContains(e, t) {
    let i = C2({ [t]: !0 }, () => {
    }), n;
    for (; typeof i == "object" && (n = Object.keys(i)[0]); ) {
      if (e = e[n], !e)
        return !1;
      i = i[n];
    }
    return !0;
  }
}
const s6 = /^(cursor|delete)/;
class r6 extends z {
  constructor(e, t, i, n, r) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = r, this._onDidUpdateKeybindings = this._register(new A()), this._currentChord = null, this._currentChordChecker = new Nu(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = sl.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new oo(), this._logging = !1;
  }
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Q.None;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
    if (!!i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  softDispatch(e, t) {
    this._log("/ Soft dispatching keyboard event");
    const i = this.resolveKeyboardEvent(e);
    if (i.isChord())
      return console.warn("Unexpected keyboard event mapped to a chord"), null;
    const [n] = i.getDispatchParts();
    if (n === null)
      return this._log("\\ Keyboard event cannot be dispatched"), null;
    const r = this._contextKeyService.getContext(t), o = this._currentChord ? this._currentChord.keypress : null;
    return this._getResolver().resolve(r, o, n);
  }
  _enterChordMode(e, t) {
    this._currentChord = {
      keypress: e,
      label: t
    }, this._currentChordStatusMessage = this._notificationService.status(p("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
    const i = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - i > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChord = null;
  }
  _dispatch(e, t) {
    return this._doDispatch(this.resolveKeyboardEvent(e), t, !1);
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchParts();
    if (n)
      return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = sl.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1) : (this._ignoreSingleModifiers = sl.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
        this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
      }, 300), !1) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(i, t, !0)) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1));
    const [r] = i.getParts();
    return this._ignoreSingleModifiers = new sl(r), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
  }
  _doDispatch(e, t, i = !1) {
    let n = !1;
    if (e.isChord())
      return console.warn("Unexpected keyboard event mapped to a chord"), !1;
    let r = null, o = null;
    if (i) {
      const [h] = e.getSingleModifierDispatchParts();
      r = h, o = h;
    } else
      [r] = e.getDispatchParts(), o = this._currentChord ? this._currentChord.keypress : null;
    if (r === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), n;
    const a = this._contextKeyService.getContext(t), l = e.getLabel(), c = this._getResolver().resolve(a, o, r);
    return this._logService.trace("KeybindingService#dispatch", l, c == null ? void 0 : c.commandId), c && c.enterChord ? (n = !0, this._enterChordMode(r, l), this._log("+ Entering chord mode..."), n) : (this._currentChord && (!c || !c.commandId) && (this._log(`+ Leaving chord mode: Nothing bound to "${this._currentChord.label} ${l}".`), this._notificationService.status(p("missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, l), { hideAfter: 10 * 1e3 }), n = !0), this._leaveChordMode(), c && c.commandId && (c.bubble || (n = !0), this._log(`+ Invoking command ${c.commandId}.`), typeof c.commandArgs > "u" ? this._commandService.executeCommand(c.commandId).then(void 0, (h) => this._notificationService.warn(h)) : this._commandService.executeCommand(c.commandId, c.commandArgs).then(void 0, (h) => this._notificationService.warn(h)), s6.test(c.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", { id: c.commandId, from: "keybinding" })), n);
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
class sl {
  constructor(e) {
    this._ctrlKey = e ? e.ctrlKey : !1, this._shiftKey = e ? e.shiftKey : !1, this._altKey = e ? e.altKey : !1, this._metaKey = e ? e.metaKey : !1;
  }
  has(e) {
    switch (e) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
}
sl.EMPTY = new sl(null);
const co = Se("keybindingService");
class yh {
  constructor(e, t, i) {
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const n of e) {
      const r = n.command;
      r && r.charAt(0) !== "-" && this._defaultBoundCommands.set(r, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = yh.handleRemovals([].concat(e).concat(t));
    for (let n = 0, r = this._keybindings.length; n < r; n++) {
      const o = this._keybindings[n];
      o.keypressParts.length !== 0 && (o.when && o.when.type === 0 || this._addKeyPress(o.keypressParts[0], o));
    }
  }
  static _isTargetedForRemoval(e, t, i, n) {
    return !(t && e.keypressParts[0] !== t || i && e.keypressParts[1] !== i || n && (!e.when || !JM(n, e.when)));
  }
  static handleRemovals(e) {
    const t = /* @__PURE__ */ new Map();
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n];
      if (o.command && o.command.charAt(0) === "-") {
        const a = o.command.substring(1);
        t.has(a) ? t.get(a).push(o) : t.set(a, [o]);
      }
    }
    if (t.size === 0)
      return e;
    const i = [];
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n];
      if (!o.command || o.command.length === 0) {
        i.push(o);
        continue;
      }
      if (o.command.charAt(0) === "-")
        continue;
      const a = t.get(o.command);
      if (!a || !o.isDefault) {
        i.push(o);
        continue;
      }
      let l = !1;
      for (const c of a) {
        const h = c.keypressParts[0], u = c.keypressParts[1], d = c.when;
        if (this._isTargetedForRemoval(o, h, u, d)) {
          l = !0;
          break;
        }
      }
      if (!l) {
        i.push(o);
        continue;
      }
    }
    return i;
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      const r = i[n];
      if (r.command === t.command)
        continue;
      const o = r.keypressParts.length > 1, a = t.keypressParts.length > 1;
      o && a && r.keypressParts[1] !== t.keypressParts[1] || yh.whenIsEntirelyIncluded(r.when, t.when) && this._removeFromLookupMap(r);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    const t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, n = t.length; i < n; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  static whenIsEntirelyIncluded(e, t) {
    return !t || t.type === 1 ? !0 : !e || e.type === 1 ? !1 : hD(e, t);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    const i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    if (i.length === 1)
      return i[0];
    for (let n = i.length - 1; n >= 0; n--) {
      const r = i[n];
      if (t.contextMatchesRules(r.when))
        return r;
    }
    return i[i.length - 1];
  }
  resolve(e, t, i) {
    this._log(`| Resolving ${i}${t ? ` chorded from ${t}` : ""}`);
    let n = null;
    if (t !== null) {
      const o = this._map.get(t);
      if (typeof o > "u")
        return this._log("\\ No keybinding entries."), null;
      n = [];
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a];
        c.keypressParts[1] === i && n.push(c);
      }
    } else {
      const o = this._map.get(i);
      if (typeof o > "u")
        return this._log("\\ No keybinding entries."), null;
      n = o;
    }
    const r = this._findCommand(e, n);
    return r ? t === null && r.keypressParts.length > 1 && r.keypressParts[1] !== null ? (this._log(`\\ From ${n.length} keybinding entries, matched chord, when: ${yy(r.when)}, source: ${Ly(r)}.`), {
      enterChord: !0,
      leaveChord: !1,
      commandId: null,
      commandArgs: null,
      bubble: !1
    }) : (this._log(`\\ From ${n.length} keybinding entries, matched ${r.command}, when: ${yy(r.when)}, source: ${Ly(r)}.`), {
      enterChord: !1,
      leaveChord: r.keypressParts.length > 1,
      commandId: r.command,
      commandArgs: r.commandArgs,
      bubble: r.bubble
    }) : (this._log(`\\ From ${n.length} keybinding entries, no when clauses matched the context.`), null);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      if (!!yh._contextMatchesRules(e, n.when))
        return n;
    }
    return null;
  }
  static _contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function yy(s) {
  return s ? `${s.serialize()}` : "no when condition";
}
function Ly(s) {
  return s.extensionId ? s.isBuiltinExtension ? `built-in extension ${s.extensionId}` : `user extension ${s.extensionId}` : s.isDefault ? "built-in" : "user";
}
class ky {
  constructor(e, t, i, n, r, o, a) {
    this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.keypressParts = e ? l0(e.getDispatchParts()) : [], e && this.keypressParts.length === 0 && (this.keypressParts = l0(e.getSingleModifierDispatchParts())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = r, this.extensionId = o, this.isBuiltinExtension = a;
  }
}
function l0(s) {
  const e = [];
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t];
    if (!n)
      return e;
    e.push(n);
  }
  return e;
}
class gm {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[2] = e, this.modifierLabels[1] = t, this.modifierLabels[3] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const n = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const a = t[r], l = i(a);
      if (l === null)
        return null;
      n[r] = l6(a, l, this.modifierLabels[e]);
    }
    return n.join(" ");
  }
}
const ox = new gm({
  ctrlKey: "\u2303",
  shiftKey: "\u21E7",
  altKey: "\u2325",
  metaKey: "\u2318",
  separator: ""
}, {
  ctrlKey: p({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: p({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: p({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), o6 = new gm({
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
  metaKey: p({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), a6 = new gm({
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Cmd",
  separator: "+"
}, {
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Super",
  separator: "+"
});
new gm({
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "cmd",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "win",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "meta",
  separator: "+"
});
function l6(s, e, t) {
  if (e === null)
    return "";
  const i = [];
  return s.ctrlKey && i.push(t.ctrlKey), s.shiftKey && i.push(t.shiftKey), s.altKey && i.push(t.altKey), s.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
class c6 extends rM {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw gb("parts");
    this._os = e, this._parts = t;
  }
  getLabel() {
    return ox.toLabel(this._os, this._parts, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return o6.toLabel(this._os, this._parts, (e) => this._getAriaLabel(e));
  }
  getElectronAccelerator() {
    return this._parts.length > 1 || this._parts[0].isDuplicateModifierCase() ? null : a6.toLabel(this._os, this._parts, (e) => this._getElectronAccelerator(e));
  }
  isChord() {
    return this._parts.length > 1;
  }
  getParts() {
    return this._parts.map((e) => this._getPart(e));
  }
  _getPart(e) {
    return new sM(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchParts() {
    return this._parts.map((e) => this._getDispatchPart(e));
  }
  getSingleModifierDispatchParts() {
    return this._parts.map((e) => this._getSingleModifierDispatchPart(e));
  }
}
class au extends c6 {
  constructor(e, t) {
    super(t, e.parts);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "\u2190";
        case 16:
          return "\u2191";
        case 17:
          return "\u2192";
        case 18:
          return "\u2193";
      }
    return Mo.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : Mo.toString(e.keyCode);
  }
  _getElectronAccelerator(e) {
    return Mo.toElectronAccelerator(e.keyCode);
  }
  _getDispatchPart(e) {
    return au.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += Mo.toString(e.keyCode), t;
  }
  _getSingleModifierDispatchPart(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
  static _scanCodeToKeyCode(e) {
    const t = Cb[e];
    if (t !== -1)
      return t;
    switch (e) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 83;
      case 52:
        return 81;
      case 53:
        return 87;
      case 54:
        return 89;
      case 55:
        return 88;
      case 56:
        return 0;
      case 57:
        return 80;
      case 58:
        return 90;
      case 59:
        return 86;
      case 60:
        return 82;
      case 61:
        return 84;
      case 62:
        return 85;
      case 106:
        return 92;
    }
    return 0;
  }
  static _resolveSimpleUserBinding(e) {
    if (!e)
      return null;
    if (e instanceof Wh)
      return e;
    const t = this._scanCodeToKeyCode(e.scanCode);
    return t === 0 ? null : new Wh(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
  }
  static resolveUserBinding(e, t) {
    const i = l0(e.map((n) => this._resolveSimpleUserBinding(n)));
    return i.length > 0 ? [new au(new kf(i), t)] : [];
  }
}
const h6 = Se("labelService"), u6 = Se("contextService");
class d6 {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
const f6 = "code-workspace";
p("codeWorkspace", "Code Workspace");
var Dy;
(function(s) {
  s.noSelection = p("noSelection", "No selection"), s.singleSelectionRange = p("singleSelectionRange", "Line {0}, Column {1} ({2} selected)"), s.singleSelection = p("singleSelection", "Line {0}, Column {1}"), s.multiSelectionRange = p("multiSelectionRange", "{0} selections ({1} characters selected)"), s.multiSelection = p("multiSelection", "{0} selections"), s.emergencyConfOn = p("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'."), s.openingDocs = p("openingDocs", "Now opening the Editor Accessibility documentation page."), s.readonlyDiffEditor = p("readonlyDiffEditor", " in a read-only pane of a diff editor."), s.editableDiffEditor = p("editableDiffEditor", " in a pane of a diff editor."), s.readonlyEditor = p("readonlyEditor", " in a read-only code editor"), s.editableEditor = p("editableEditor", " in a code editor"), s.changeConfigToOnMac = p("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now."), s.changeConfigToOnWinLinux = p("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now."), s.auto_on = p("auto_on", "The editor is configured to be optimized for usage with a Screen Reader."), s.auto_off = p("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time."), s.tabFocusModeOnMsg = p("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}."), s.tabFocusModeOnMsgNoKb = p("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding."), s.tabFocusModeOffMsg = p("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}."), s.tabFocusModeOffMsgNoKb = p("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding."), s.openDocMac = p("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility."), s.openDocWinLinux = p("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility."), s.outroMsg = p("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape."), s.showAccessibilityHelpAction = p("showAccessibilityHelpAction", "Show Accessibility Help");
})(Dy || (Dy = {}));
var Ey;
(function(s) {
  s.inspectTokensAction = p("inspectTokens", "Developer: Inspect Tokens");
})(Ey || (Ey = {}));
var xy;
(function(s) {
  s.gotoLineActionLabel = p("gotoLineActionLabel", "Go to Line/Column...");
})(xy || (xy = {}));
var Iy;
(function(s) {
  s.helpQuickAccessActionLabel = p("helpQuickAccess", "Show all Quick Access Providers");
})(Iy || (Iy = {}));
var Ny;
(function(s) {
  s.quickCommandActionLabel = p("quickCommandActionLabel", "Command Palette"), s.quickCommandHelp = p("quickCommandActionHelp", "Show And Run Commands");
})(Ny || (Ny = {}));
var Ty;
(function(s) {
  s.quickOutlineActionLabel = p("quickOutlineActionLabel", "Go to Symbol..."), s.quickOutlineByCategoryActionLabel = p("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(Ty || (Ty = {}));
var sg;
(function(s) {
  s.editorViewAccessibleLabel = p("editorViewAccessibleLabel", "Editor content"), s.accessibilityHelpMessage = p("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(sg || (sg = {}));
var My;
(function(s) {
  s.toggleHighContrast = p("toggleHighContrast", "Toggle High Contrast Theme");
})(My || (My = {}));
var c0;
(function(s) {
  s.bulkEditServiceSummary = p("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(c0 || (c0 = {}));
const g6 = Se("workspaceTrustManagementService");
var Ht;
(function(s) {
  function e(r, o) {
    if (r.start >= o.end || o.start >= r.end)
      return { start: 0, end: 0 };
    const a = Math.max(r.start, o.start), l = Math.min(r.end, o.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  s.intersect = e;
  function t(r) {
    return r.end - r.start <= 0;
  }
  s.isEmpty = t;
  function i(r, o) {
    return !t(e(r, o));
  }
  s.intersects = i;
  function n(r, o) {
    const a = [], l = { start: r.start, end: Math.min(o.start, r.end) }, c = { start: Math.max(o.end, r.start), end: r.end };
    return t(l) || a.push(l), t(c) || a.push(c), a;
  }
  s.relativeComplement = n;
})(Ht || (Ht = {}));
var Hr;
(function(s) {
  s[s.AVOID = 0] = "AVOID", s[s.ALIGN = 1] = "ALIGN";
})(Hr || (Hr = {}));
function rl(s, e, t) {
  const i = t.mode === Hr.ALIGN ? t.offset : t.offset + t.size, n = t.mode === Hr.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= s - i ? i : e <= n ? n - e : Math.max(s - e, 0) : e <= n ? n - e : e <= s - i ? i : 0;
}
class Ql extends z {
  constructor(e, t) {
    super(), this.container = null, this.delegate = null, this.toDisposeOnClean = z.None, this.toDisposeOnSetContainer = z.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = ae(".context-view"), this.useFixedPosition = !1, this.useShadowDOM = !1, Vw(this.view), this.setContainer(e, t), this._register(ze(() => this.setContainer(null, 1)));
  }
  setContainer(e, t) {
    var i;
    if (this.container && (this.toDisposeOnSetContainer.dispose(), this.shadowRoot ? (this.shadowRoot.removeChild(this.view), this.shadowRoot = null, (i = this.shadowRootHostElement) === null || i === void 0 || i.remove(), this.shadowRootHostElement = null) : this.container.removeChild(this.view), this.container = null), e) {
      if (this.container = e, this.useFixedPosition = t !== 1, this.useShadowDOM = t === 3, this.useShadowDOM) {
        this.shadowRootHostElement = ae(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const r = document.createElement("style");
        r.textContent = m6, this.shadowRoot.appendChild(r), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(ae("slot"));
      } else
        this.container.appendChild(this.view);
      const n = new le();
      Ql.BUBBLE_UP_EVENTS.forEach((r) => {
        n.add(pi(this.container, r, (o) => {
          this.onDOMEvent(o, !1);
        }));
      }), Ql.BUBBLE_DOWN_EVENTS.forEach((r) => {
        n.add(pi(this.container, r, (o) => {
          this.onDOMEvent(o, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = n;
    }
  }
  show(e) {
    var t, i;
    this.isVisible() && this.hide(), rn(this.view), this.view.className = "context-view", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = "2575", this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", sD(this.view), this.toDisposeOnClean = e.render(this.view) || z.None, this.delegate = e, this.doLayout(), (i = (t = this.delegate).focus) === null || i === void 0 || i.call(t);
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (!!this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(Ml && K2.pointerEvents)) {
        this.hide();
        return;
      }
      this.delegate.layout && this.delegate.layout(), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    const e = this.delegate.getAnchor();
    let t;
    if (iD(e)) {
      const u = is(e), d = HM(e);
      t = {
        top: u.top * d,
        left: u.left * d,
        width: u.width * d,
        height: u.height * d
      };
    } else
      t = {
        top: e.y,
        left: e.x,
        width: e.width || 1,
        height: e.height || 2
      };
    const i = y1(this.view), n = L1(this.view), r = this.delegate.anchorPosition || 0, o = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, c;
    if (a === 0) {
      const u = { offset: t.top - window.pageYOffset, size: t.height, position: r === 0 ? 0 : 1 }, d = { offset: t.left, size: t.width, position: o === 0 ? 0 : 1, mode: Hr.ALIGN };
      l = rl(window.innerHeight, n, u) + window.pageYOffset, Ht.intersects({ start: l, end: l + n }, { start: u.offset, end: u.offset + u.size }) && (d.mode = Hr.AVOID), c = rl(window.innerWidth, i, d);
    } else {
      const u = { offset: t.left, size: t.width, position: o === 0 ? 0 : 1 }, d = { offset: t.top, size: t.height, position: r === 0 ? 0 : 1, mode: Hr.ALIGN };
      c = rl(window.innerWidth, i, u), Ht.intersects({ start: c, end: c + i }, { start: u.offset, end: u.offset + u.size }) && (d.mode = Hr.AVOID), l = rl(window.innerHeight, n, d) + window.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(r === 0 ? "bottom" : "top"), this.view.classList.add(o === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const h = is(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? is(this.view).top : h.top)}px`, this.view.style.left = `${c - (this.useFixedPosition ? is(this.view).left : h.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t != null && t.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), Vw(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, document.activeElement) : t && !ir(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
}
Ql.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
Ql.BUBBLE_DOWN_EVENTS = ["click"];
const m6 = `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		font-display: block;
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`;
var p6 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, _6 = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let h0 = class extends z {
  constructor(e) {
    super(), this.layoutService = e, this.currentViewDisposable = z.None, this.container = e.hasContainer ? e.container : null, this.contextView = this._register(new Ql(this.container, 1)), this.layout(), this._register(e.onDidLayout(() => this.layout()));
  }
  setContainer(e, t) {
    this.contextView.setContainer(e, t || 1);
  }
  showContextView(e, t, i) {
    t ? (t !== this.container || this.shadowRoot !== i) && (this.container = t, this.setContainer(t, i ? 3 : 2)) : this.layoutService.hasContainer && this.container !== this.layoutService.container && (this.container = this.layoutService.container, this.setContainer(this.container, 1)), this.shadowRoot = i, this.contextView.show(e);
    const n = ze(() => {
      this.currentViewDisposable === n && this.hideContextView();
    });
    return this.currentViewDisposable = n, n;
  }
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e);
  }
};
h0 = p6([
  _6(0, vc)
], h0);
var Ay = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
const Md = "**", Ry = "/", Xd = "[/\\\\]", Jd = "[^/\\\\]", b6 = /\//g;
function Py(s, e) {
  switch (s) {
    case 0:
      return "";
    case 1:
      return `${Jd}*?`;
    default:
      return `(?:${Xd}|${Jd}+${Xd}${e ? `|${Xd}${Jd}+` : ""})*?`;
  }
}
function Oy(s, e) {
  if (!s)
    return [];
  const t = [];
  let i = !1, n = !1, r = "";
  for (const o of s) {
    switch (o) {
      case e:
        if (!i && !n) {
          t.push(r), r = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        n = !0;
        break;
      case "]":
        n = !1;
        break;
    }
    r += o;
  }
  return r && t.push(r), t;
}
function ax(s) {
  if (!s)
    return "";
  let e = "";
  const t = Oy(s, Ry);
  if (t.every((i) => i === Md))
    e = ".*";
  else {
    let i = !1;
    t.forEach((n, r) => {
      if (n === Md) {
        if (i)
          return;
        e += Py(2, r === t.length - 1);
      } else {
        let o = !1, a = "", l = !1, c = "";
        for (const h of n) {
          if (h !== "}" && o) {
            a += h;
            continue;
          }
          if (l && (h !== "]" || !c)) {
            let u;
            h === "-" ? u = h : (h === "^" || h === "!") && !c ? u = "^" : h === Ry ? u = "" : u = sr(h), c += u;
            continue;
          }
          switch (h) {
            case "{":
              o = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              const d = `(?:${Oy(a, ",").map((f) => ax(f)).join("|")})`;
              e += d, o = !1, a = "";
              break;
            }
            case "]": {
              e += "[" + c + "]", l = !1, c = "";
              break;
            }
            case "?":
              e += Jd;
              continue;
            case "*":
              e += Py(1);
              continue;
            default:
              e += sr(h);
          }
        }
        r < t.length - 1 && (t[r + 1] !== Md || r + 2 < t.length) && (e += Xd);
      }
      i = n === Md;
    });
  }
  return e;
}
const C6 = /^\*\*\/\*\.[\w\.-]+$/, v6 = /^\*\*\/([\w\.-]+)\/?$/, w6 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, S6 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, y6 = /^\*\*((\/[\w\.-]+)+)\/?$/, L6 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, Fy = new DC(1e4), By = function() {
  return !1;
}, hs = function() {
  return null;
};
function OC(s, e) {
  if (!s)
    return hs;
  let t;
  typeof s != "string" ? t = s.pattern : t = s, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let n = Fy.get(i);
  if (n)
    return Vy(n, s);
  let r;
  return C6.test(t) ? n = k6(t.substr(4), t) : (r = v6.exec(zp(t, e))) ? n = D6(r[1], t) : (e.trimForExclusions ? S6 : w6).test(t) ? n = E6(t, e) : (r = y6.exec(zp(t, e))) ? n = Wy(r[1].substr(1), t, !0) : (r = L6.exec(zp(t, e))) ? n = Wy(r[1], t, !1) : n = x6(t), Fy.set(i, n), Vy(n, s);
}
function Vy(s, e) {
  if (typeof e == "string")
    return s;
  const t = function(i, n) {
    return K1(i, e.base, !_i) ? s(i.substr(e.base.length + 1), n) : null;
  };
  return t.allBasenames = s.allBasenames, t.allPaths = s.allPaths, t.basenames = s.basenames, t.patterns = s.patterns, t;
}
function zp(s, e) {
  return e.trimForExclusions && s.endsWith("/**") ? s.substr(0, s.length - 2) : s;
}
function k6(s, e) {
  return function(t, i) {
    return typeof t == "string" && t.endsWith(s) ? e : null;
  };
}
function D6(s, e) {
  const t = `/${s}`, i = `\\${s}`, n = function(o, a) {
    return typeof o != "string" ? null : a ? a === s ? e : null : o === s || o.endsWith(t) || o.endsWith(i) ? e : null;
  }, r = [s];
  return n.basenames = r, n.patterns = [e], n.allBasenames = r, n;
}
function E6(s, e) {
  const t = cx(s.slice(1, -1).split(",").map((a) => OC(a, e)).filter((a) => a !== hs), s), i = t.length;
  if (!i)
    return hs;
  if (i === 1)
    return t[0];
  const n = function(a, l) {
    for (let c = 0, h = t.length; c < h; c++)
      if (t[c](a, l))
        return s;
    return null;
  }, r = t.find((a) => !!a.allBasenames);
  r && (n.allBasenames = r.allBasenames);
  const o = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return o.length && (n.allPaths = o), n;
}
function Wy(s, e, t) {
  const i = Uo === lt.sep, n = i ? s : s.replace(b6, Uo), r = Uo + n, o = lt.sep + s;
  let a;
  return t ? a = function(l, c) {
    return typeof l == "string" && (l === n || l.endsWith(r) || !i && (l === s || l.endsWith(o))) ? e : null;
  } : a = function(l, c) {
    return typeof l == "string" && (l === n || !i && l === s) ? e : null;
  }, a.allPaths = [(t ? "*/" : "./") + s], a;
}
function x6(s) {
  try {
    const e = new RegExp(`^${ax(s)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? s : null;
    };
  } catch {
    return hs;
  }
}
function I6(s, e, t) {
  return !s || typeof e != "string" ? !1 : lx(s)(e, void 0, t);
}
function lx(s, e = {}) {
  if (!s)
    return By;
  if (typeof s == "string" || N6(s)) {
    const t = OC(s, e);
    if (t === hs)
      return By;
    const i = function(n, r) {
      return !!t(n, r);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return T6(s, e);
}
function N6(s) {
  const e = s;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function T6(s, e) {
  const t = cx(Object.getOwnPropertyNames(s).map((a) => M6(a, s[a], e)).filter((a) => a !== hs)), i = t.length;
  if (!i)
    return hs;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(h, u) {
      let d;
      for (let f = 0, m = t.length; f < m; f++) {
        const _ = t[f](h, u);
        if (typeof _ == "string")
          return _;
        u1(_) && (d || (d = []), d.push(_));
      }
      return d ? (() => Ay(this, void 0, void 0, function* () {
        for (const f of d) {
          const m = yield f;
          if (typeof m == "string")
            return m;
        }
        return null;
      }))() : null;
    }, l = t.find((h) => !!h.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const c = t.reduce((h, u) => u.allPaths ? h.concat(u.allPaths) : h, []);
    return c.length && (a.allPaths = c), a;
  }
  const n = function(a, l, c) {
    let h, u;
    for (let d = 0, f = t.length; d < f; d++) {
      const m = t[d];
      m.requiresSiblings && c && (l || (l = Qk(a)), h || (h = l.substr(0, l.length - cT(a).length)));
      const _ = m(a, l, h, c);
      if (typeof _ == "string")
        return _;
      u1(_) && (u || (u = []), u.push(_));
    }
    return u ? (() => Ay(this, void 0, void 0, function* () {
      for (const d of u) {
        const f = yield d;
        if (typeof f == "string")
          return f;
      }
      return null;
    }))() : null;
  }, r = t.find((a) => !!a.allBasenames);
  r && (n.allBasenames = r.allBasenames);
  const o = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return o.length && (n.allPaths = o), n;
}
function M6(s, e, t) {
  if (e === !1)
    return hs;
  const i = OC(s, t);
  if (i === hs)
    return hs;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const n = e.when;
    if (typeof n == "string") {
      const r = (o, a, l, c) => {
        if (!c || !i(o, a))
          return null;
        const h = n.replace("$(basename)", l), u = c(h);
        return u1(u) ? u.then((d) => d ? s : null) : u ? s : null;
      };
      return r.requiresSiblings = !0, r;
    }
  }
  return i;
}
function cx(s, e) {
  const t = s.filter((a) => !!a.basenames);
  if (t.length < 2)
    return s;
  const i = t.reduce((a, l) => {
    const c = l.basenames;
    return c ? a.concat(c) : a;
  }, []);
  let n;
  if (e) {
    n = [];
    for (let a = 0, l = i.length; a < l; a++)
      n.push(e);
  } else
    n = t.reduce((a, l) => {
      const c = l.patterns;
      return c ? a.concat(c) : a;
    }, []);
  const r = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let h;
      for (h = a.length; h > 0; h--) {
        const u = a.charCodeAt(h - 1);
        if (u === 47 || u === 92)
          break;
      }
      l = a.substr(h);
    }
    const c = i.indexOf(l);
    return c !== -1 ? n[c] : null;
  };
  r.basenames = i, r.patterns = n, r.allBasenames = i;
  const o = s.filter((a) => !a.basenames);
  return o.push(r), o;
}
let Xl = [], FC = [], hx = [];
function Ad(s, e = !1) {
  A6(s, !1, e);
}
function A6(s, e, t) {
  const i = R6(s, e);
  Xl.push(i), i.userConfigured ? hx.push(i) : FC.push(i), t && !i.userConfigured && Xl.forEach((n) => {
    n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
  });
}
function R6(s, e) {
  return {
    id: s.id,
    mime: s.mime,
    filename: s.filename,
    extension: s.extension,
    filepattern: s.filepattern,
    firstline: s.firstline,
    userConfigured: e,
    filenameLowercase: s.filename ? s.filename.toLowerCase() : void 0,
    extensionLowercase: s.extension ? s.extension.toLowerCase() : void 0,
    filepatternLowercase: s.filepattern ? lx(s.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: s.filepattern ? s.filepattern.indexOf(lt.sep) >= 0 : !1
  };
}
function P6() {
  Xl = Xl.filter((s) => s.userConfigured), FC = [];
}
function O6(s, e) {
  return F6(s, e).map((t) => t.id);
}
function F6(s, e) {
  let t;
  if (s)
    switch (s.scheme) {
      case we.file:
        t = s.fsPath;
        break;
      case we.data: {
        t = jf.parseMetaData(s).get(jf.META_DATA_LABEL);
        break;
      }
      case we.vscodeNotebookCell:
        t = void 0;
        break;
      default:
        t = s.path;
    }
  if (!t)
    return [{ id: "unknown", mime: zs.unknown }];
  t = t.toLowerCase();
  const i = Qk(t), n = Hy(t, i, hx);
  if (n)
    return [n, { id: os, mime: zs.text }];
  const r = Hy(t, i, FC);
  if (r)
    return [r, { id: os, mime: zs.text }];
  if (e) {
    const o = B6(e);
    if (o)
      return [o, { id: os, mime: zs.text }];
  }
  return [{ id: "unknown", mime: zs.unknown }];
}
function Hy(s, e, t) {
  var i;
  let n, r, o;
  for (let a = t.length - 1; a >= 0; a--) {
    const l = t[a];
    if (e === l.filenameLowercase) {
      n = l;
      break;
    }
    if (l.filepattern && (!r || l.filepattern.length > r.filepattern.length)) {
      const c = l.filepatternOnPath ? s : e;
      !((i = l.filepatternLowercase) === null || i === void 0) && i.call(l, c) && (r = l);
    }
    l.extension && (!o || l.extension.length > o.extension.length) && e.endsWith(l.extensionLowercase) && (o = l);
  }
  if (n)
    return n;
  if (r)
    return r;
  if (o)
    return o;
}
function B6(s) {
  if (Ib(s) && (s = s.substr(1)), s.length > 0)
    for (let e = Xl.length - 1; e >= 0; e--) {
      const t = Xl[e];
      if (!t.firstline)
        continue;
      const i = s.match(t.firstline);
      if (i && i.length > 0)
        return t;
    }
}
const Rd = Object.prototype.hasOwnProperty, zy = "vs.editor.nullLanguage";
class V6 {
  constructor() {
    this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(zy, 0), this._register(os, 1), this._nextLanguageId = 2;
  }
  _register(e, t) {
    this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
  }
  register(e) {
    if (this._languageToLanguageId.has(e))
      return;
    const t = this._nextLanguageId++;
    this._register(e, t);
  }
  encodeLanguageId(e) {
    return this._languageToLanguageId.get(e) || 0;
  }
  decodeLanguageId(e) {
    return this._languageIdToLanguage[e] || zy;
  }
}
class lu extends z {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, lu.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new V6(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(Fl.onDidChangeLanguages((i) => {
      this._initializeFromRegistry();
    })));
  }
  dispose() {
    lu.instanceCount--, super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, P6();
    const e = [].concat(Fl.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      const i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
        this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((n) => {
        this._mimeTypesMap[n] = i.identifier;
      });
    }), Ft.as(uc.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    Rd.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
      identifier: t,
      name: null,
      mimetypes: [],
      aliases: [],
      extensions: [],
      filenames: [],
      configurationFiles: [],
      icons: []
    }, this._languages[t] = i), this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let n = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (const a of t.extensions)
        Ad({ id: i, mime: n, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (const a of t.filenames)
        Ad({ id: i, mime: n, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (const a of t.filenamePatterns)
        Ad({ id: i, mime: n, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        const l = new RegExp(a);
        DT(l) || Ad({ id: i, mime: n, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        ct(l);
      }
    }
    e.aliases.push(i);
    let r = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? r = [null] : r = t.aliases), r !== null)
      for (const a of r)
        !a || a.length === 0 || e.aliases.push(a);
    const o = r !== null && r.length > 0;
    if (!(o && r[0] === null)) {
      const a = (o ? r[0] : null) || i;
      (o || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
  }
  isRegisteredLanguageId(e) {
    return e ? Rd.call(this._languages, e) : !1;
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(e) {
    const t = e.toLowerCase();
    return Rd.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
  }
  getLanguageIdByMimeType(e) {
    return e && Rd.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    return !e && !t ? [] : O6(e, t);
  }
}
lu.instanceCount = 0;
class cu extends z {
  constructor(e = !1) {
    super(), this._onDidEncounterLanguage = this._register(new A()), this.onDidEncounterLanguage = this._onDidEncounterLanguage.event, this._onDidChange = this._register(new A({ leakWarningThreshold: 200 })), this.onDidChange = this._onDidChange.event, cu.instanceCount++, this._encounteredLanguages = /* @__PURE__ */ new Set(), this._registry = this._register(new lu(!0, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    cu.instanceCount--, super.dispose();
  }
  isRegisteredLanguageId(e) {
    return this._registry.isRegisteredLanguageId(e);
  }
  getLanguageIdByLanguageName(e) {
    return this._registry.getLanguageIdByLanguageName(e);
  }
  getLanguageIdByMimeType(e) {
    return this._registry.getLanguageIdByMimeType(e);
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
    return Ok(i, null);
  }
  createById(e) {
    return new Uy(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
  }
  createByFilepathOrFirstLine(e, t) {
    return new Uy(this.onDidChange, () => {
      const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
      return this._createAndGetLanguageIdentifier(i);
    });
  }
  _createAndGetLanguageIdentifier(e) {
    return (!e || !this.isRegisteredLanguageId(e)) && (e = os), this._encounteredLanguages.has(e) || (this._encounteredLanguages.add(e), at.getOrCreate(e), this._onDidEncounterLanguage.fire(e)), e;
  }
}
cu.instanceCount = 0;
class Uy {
  constructor(e, t) {
    this._onDidChangeLanguages = e, this._selector = t, this._listener = null, this._emitter = null, this.languageId = this._selector();
  }
  _dispose() {
    this._listener && (this._listener.dispose(), this._listener = null), this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
  get onDidChange() {
    return this._listener || (this._listener = this._onDidChangeLanguages(() => this._evaluate())), this._emitter || (this._emitter = new A({
      onLastListenerRemove: () => {
        this._dispose();
      }
    })), this._emitter.event;
  }
  _evaluate() {
    var e;
    const t = this._selector();
    t !== this.languageId && (this.languageId = t, (e = this._emitter) === null || e === void 0 || e.fire(this.languageId));
  }
}
function $y(s) {
  let e = s.definition;
  for (; e instanceof g; )
    e = e.definition;
  return `.codicon-${s.id}:before { content: '${e.fontCharacter}'; }`;
}
const u0 = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, Up = /(&amp;)?(&amp;)([^\s&])/g;
var rg;
(function(s) {
  s[s.Right = 0] = "Right", s[s.Left = 1] = "Left";
})(rg || (rg = {}));
class Dl extends Yl {
  constructor(e, t, i = {}) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const n = document.createElement("div");
    n.classList.add("monaco-menu"), n.setAttribute("role", "presentation"), super(n, {
      orientation: 1,
      actionViewItemProvider: (a) => this.doGetActionViewItem(a, i, r),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...Ie || _i ? [10] : []], keyDown: !0 }
    }), this.menuElement = n, this.actionsList.tabIndex = 0, this.menuDisposables = this._register(new le()), this.initializeOrUpdateStyleSheet(e, {}), this._register(Ne.addTarget(n)), H(n, $.KEY_DOWN, (a) => {
      new nt(a).equals(2) && a.preventDefault();
    }), i.enableMnemonics && this.menuDisposables.add(H(n, $.KEY_DOWN, (a) => {
      const l = a.key.toLocaleLowerCase();
      if (this.mnemonics.has(l)) {
        Oe.stop(a, !0);
        const c = this.mnemonics.get(l);
        if (c.length === 1 && (c[0] instanceof jy && c[0].container && this.focusItemByElement(c[0].container), c[0].onClick(a)), c.length > 1) {
          const h = c.shift();
          h && h.container && (this.focusItemByElement(h.container), c.push(h)), this.mnemonics.set(l, c);
        }
      }
    })), _i && this._register(H(n, $.KEY_DOWN, (a) => {
      const l = new nt(a);
      l.equals(14) || l.equals(11) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), Oe.stop(a, !0)) : (l.equals(13) || l.equals(12)) && (this.focusedItem = 0, this.focusPrevious(), Oe.stop(a, !0));
    })), this._register(H(this.domNode, $.MOUSE_OUT, (a) => {
      const l = a.relatedTarget;
      ir(l, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), a.stopPropagation());
    })), this._register(H(this.actionsList, $.MOUSE_OVER, (a) => {
      let l = a.target;
      if (!(!l || !ir(l, this.actionsList) || l === this.actionsList)) {
        for (; l.parentElement !== this.actionsList && l.parentElement !== null; )
          l = l.parentElement;
        if (l.classList.contains("action-item")) {
          const c = this.focusedItem;
          this.setFocusedItem(l), c !== this.focusedItem && this.updateFocus();
        }
      }
    })), this._register(Ne.addTarget(this.actionsList)), this._register(H(this.actionsList, We.Tap, (a) => {
      let l = a.initialTarget;
      if (!(!l || !ir(l, this.actionsList) || l === this.actionsList)) {
        for (; l.parentElement !== this.actionsList && l.parentElement !== null; )
          l = l.parentElement;
        if (l.classList.contains("action-item")) {
          const c = this.focusedItem;
          this.setFocusedItem(l), c !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    const r = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new aE(n, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const o = this.scrollableElement.getDomNode();
    o.style.position = "", this._register(H(n, We.Change, (a) => {
      Oe.stop(a, !0);
      const l = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: l - a.translationY });
    })), this._register(H(o, $.MOUSE_UP, (a) => {
      a.preventDefault();
    })), n.style.maxHeight = `${Math.max(10, window.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((a) => {
      var l;
      return !((l = i.submenuIds) === null || l === void 0) && l.has(a.id) ? (console.warn(`Found submenu cycle: ${a.id}`), !1) : !0;
    }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((a) => !(a instanceof $p)).forEach((a, l, c) => {
      a.updatePositionInSet(l + 1, c.length);
    });
  }
  initializeOrUpdateStyleSheet(e, t) {
    this.styleSheet || (k1(e) ? this.styleSheet = Vn(e) : (Dl.globalStyleSheet || (Dl.globalStyleSheet = Vn()), this.styleSheet = Dl.globalStyleSheet)), this.styleSheet.textContent = H6(t, k1(e));
  }
  style(e) {
    const t = this.getContainer();
    this.initializeOrUpdateStyleSheet(t, e);
    const i = e.foregroundColor ? `${e.foregroundColor}` : "", n = e.backgroundColor ? `${e.backgroundColor}` : "", r = e.borderColor ? `1px solid ${e.borderColor}` : "", o = "5px", a = e.shadowColor ? `0 2px 8px ${e.shadowColor}` : "";
    t.style.outline = r, t.style.borderRadius = o, t.style.color = i, t.style.backgroundColor = n, t.style.boxShadow = a, this.viewItems && this.viewItems.forEach((l) => {
      (l instanceof d0 || l instanceof $p) && l.style(e);
    });
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      const i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof ls)
      return new $p(t.context, e, { icon: !0 });
    if (e instanceof aD) {
      const n = new jy(e, e.actions, i, Object.assign(Object.assign({}, t), { submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }));
      if (t.enableMnemonics) {
        const r = n.getMnemonic();
        if (r && n.isEnabled()) {
          let o = [];
          this.mnemonics.has(r) && (o = this.mnemonics.get(r)), o.push(n), this.mnemonics.set(r, o);
        }
      }
      return n;
    } else {
      const n = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const o = t.getKeyBinding(e);
        if (o) {
          const a = o.getLabel();
          a && (n.keybinding = a);
        }
      }
      const r = new d0(t.context, e, n);
      if (t.enableMnemonics) {
        const o = r.getMnemonic();
        if (o && r.isEnabled()) {
          let a = [];
          this.mnemonics.has(o) && (a = this.mnemonics.get(o)), a.push(r), this.mnemonics.set(o, a);
        }
      }
      return r;
    }
  }
}
class d0 extends Lr {
  constructor(e, t, i = {}) {
    if (i.isMenu = !0, super(t, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      const n = this.getAction().label;
      if (n) {
        const r = u0.exec(n);
        r && (this.mnemonic = (r[1] ? r[1] : r[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new oi(() => {
      !this.element || (this._register(H(this.element, $.MOUSE_UP, (n) => {
        if (Oe.stop(n, !0), sn) {
          if (new Gs(n).rightButton)
            return;
          this.onClick(n);
        } else
          setTimeout(() => {
            this.onClick(n);
          }, 0);
      })), this._register(H(this.element, $.CONTEXT_MENU, (n) => {
        Oe.stop(n, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = Y(this.element, ae("a.action-menu-item")), this._action.id === ls.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = Y(this.item, ae("span.menu-item-check" + g.menuSelection.cssSelector)), this.check.setAttribute("role", "none"), this.label = Y(this.item, ae("span.action-label")), this.options.label && this.options.keybinding && (Y(this.item, ae("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    super.focus(), this.item && this.item.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    var e;
    if (!!this.label && this.options.label) {
      rn(this.label);
      let t = VE(this.getAction().label);
      if (t) {
        const i = W6(t);
        this.options.enableMnemonics || (t = i), this.label.setAttribute("aria-label", i.replace(/&&/g, "&"));
        const n = u0.exec(t);
        if (n) {
          t = yT(t), Up.lastIndex = 0;
          let r = Up.exec(t);
          for (; r && r[1]; )
            r = Up.exec(t);
          const o = (a) => a.replace(/&amp;&amp;/g, "&amp;");
          r ? this.label.append(wb(o(t.substr(0, r.index)), " "), ae("u", { "aria-hidden": "true" }, r[3]), LT(o(t.substr(r.index + r[0].length)), " ")) : this.label.innerText = o(t).trim(), (e = this.item) === null || e === void 0 || e.setAttribute("aria-keyshortcuts", (n[1] ? n[1] : n[3]).toLocaleLowerCase());
        } else
          this.label.innerText = t.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.getAction().class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.getAction().enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    if (!this.item)
      return;
    const e = this.getAction().checked;
    this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    if (!this.menuStyle)
      return;
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "", r = e && this.menuStyle.selectionBorderColor ? "-1px" : "";
    this.item && (this.item.style.color = t ? t.toString() : "", this.item.style.backgroundColor = i ? i.toString() : "", this.item.style.outline = n, this.item.style.outlineOffset = r), this.check && (this.check.style.color = t ? t.toString() : "");
  }
  style(e) {
    this.menuStyle = e, this.applyStyle();
  }
}
class jy extends d0 {
  constructor(e, t, i, n) {
    super(e, e, n), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new le()), this.mouseOver = !1, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : rg.Right, this.showScheduler = new oi(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new oi(() => {
      this.element && !ir(ml(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = Y(this.item, ae("span.submenu-indicator" + g.menuSubmenu.cssSelector)), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(H(this.element, $.KEY_UP, (t) => {
      const i = new nt(t);
      (i.equals(17) || i.equals(3)) && (Oe.stop(t, !0), this.createSubmenu(!0));
    })), this._register(H(this.element, $.KEY_DOWN, (t) => {
      const i = new nt(t);
      ml() === this.item && (i.equals(17) || i.equals(3)) && Oe.stop(t, !0);
    })), this._register(H(this.element, $.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register(H(this.element, $.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register(H(this.element, $.FOCUS_OUT, (t) => {
      this.element && !ir(ml(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    Oe.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, n) {
    const r = { top: 0, left: 0 };
    return r.left = rl(e.width, t.width, { position: n === rg.Right ? 0 : 1, offset: i.left, size: i.width }), r.left >= i.left && r.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (r.left = i.left + 10), i.top += 10, i.height = 0), r.top = rl(e.height, t.height, { position: 0, offset: i.top, size: 0 }), r.top + t.height === i.top && r.top + i.height + t.height <= e.height && (r.top += i.height), r;
  }
  createSubmenu(e = !0) {
    if (!!this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = Y(this.element, ae("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new Dl(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new $g()], this.submenuOptions), this.menuStyle && this.parentData.submenu.style(this.menuStyle);
        const n = this.element.getBoundingClientRect(), r = {
          top: n.top - i,
          left: n.left,
          height: n.height + 2 * i,
          width: n.width
        }, o = this.submenuContainer.getBoundingClientRect(), { top: a, left: l } = this.calculateSubmenuMenuLayout(new Gi(window.innerWidth, window.innerHeight), Gi.lift(o), r, this.expandDirection);
        this.submenuContainer.style.left = `${l - o.left}px`, this.submenuContainer.style.top = `${a - o.top}px`, this.submenuDisposables.add(H(this.submenuContainer, $.KEY_UP, (c) => {
          new nt(c).equals(15) && (Oe.stop(c, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add(H(this.submenuContainer, $.KEY_DOWN, (c) => {
          new nt(c).equals(15) && Oe.stop(c, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    var t;
    this.item && ((t = this.item) === null || t === void 0 || t.setAttribute("aria-expanded", e));
  }
  applyStyle() {
    var e;
    if (super.applyStyle(), !this.menuStyle)
      return;
    const i = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = i ? `${i}` : ""), (e = this.parentData.submenu) === null || e === void 0 || e.style(this.menuStyle);
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class $p extends HE {
  style(e) {
    this.label && (this.label.style.borderBottomColor = e.separatorColor ? `${e.separatorColor}` : "");
  }
}
function W6(s) {
  const e = u0, t = e.exec(s);
  if (!t)
    return s;
  const i = !t[1];
  return s.replace(e, i ? "$2$3" : "").trim();
}
function H6(s, e) {
  let t = `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${$y(g.menuSelection)}
${$y(g.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 = \u221A\u03C6 */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: .6em 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`;
  if (e) {
    t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const i = s.scrollbarShadow;
    i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
    const n = s.scrollbarSliderBackground;
    n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
    const r = s.scrollbarSliderHoverBackground;
    r && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${r};
				}
			`);
    const o = s.scrollbarSliderActiveBackground;
    o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${o};
				}
			`);
  }
  return t;
}
function kn(s, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i in e) {
    const n = e[i];
    n && (t[i] = Rs(n, s));
  }
  return t;
}
function ux(s, e, t) {
  function i() {
    const n = kn(s.getColorTheme(), e);
    typeof t == "function" ? t(n) : t.style(n);
  }
  return i(), s.onDidColorThemeChange(i);
}
function Jl(s, e, t) {
  return ux(e, Object.assign(Object.assign({}, mm), t || {}), s);
}
const mm = {
  listFocusBackground: i7,
  listFocusForeground: n7,
  listFocusOutline: s7,
  listActiveSelectionBackground: Xs,
  listActiveSelectionForeground: ns,
  listActiveSelectionIconForeground: Zc,
  listFocusAndSelectionOutline: r7,
  listFocusAndSelectionBackground: Xs,
  listFocusAndSelectionForeground: ns,
  listInactiveSelectionBackground: o7,
  listInactiveSelectionIconForeground: l7,
  listInactiveSelectionForeground: a7,
  listInactiveFocusBackground: c7,
  listInactiveFocusOutline: h7,
  listHoverBackground: u7,
  listHoverForeground: d7,
  listDropBackground: f7,
  listSelectionOutline: ht,
  listHoverOutline: ht,
  listFilterWidgetBackground: g7,
  listFilterWidgetOutline: m7,
  listFilterWidgetNoMatchesOutline: p7,
  listFilterWidgetShadow: _7,
  treeIndentGuidesStroke: b7,
  tableColumnsBorder: C7,
  tableOddRowsBackgroundColor: v7,
  inputActiveOptionBorder: DA,
  inputActiveOptionForeground: xA,
  inputActiveOptionBackground: EA,
  inputBackground: SD,
  inputForeground: yD,
  inputBorder: LD,
  inputValidationInfoBackground: kD,
  inputValidationInfoForeground: DD,
  inputValidationInfoBorder: ED,
  inputValidationWarningBackground: xD,
  inputValidationWarningForeground: ID,
  inputValidationWarningBorder: ND,
  inputValidationErrorBackground: TD,
  inputValidationErrorForeground: MD,
  inputValidationErrorBorder: AD
}, z6 = {
  shadowColor: Ao,
  borderColor: L7,
  foregroundColor: k7,
  backgroundColor: D7,
  selectionForegroundColor: E7,
  selectionBackgroundColor: x7,
  selectionBorderColor: I7,
  separatorColor: N7,
  scrollbarShadow: gc,
  scrollbarSliderBackground: Po,
  scrollbarSliderHoverBackground: Oo,
  scrollbarSliderActiveBackground: Fo
};
function U6(s, e, t) {
  return ux(e, Object.assign(Object.assign({}, z6), t), s);
}
class $6 {
  constructor(e, t, i, n, r) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.themeService = r, this.focusToReturn = null, this.block = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = document.activeElement;
    let i;
    const n = iD(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (r) => {
        const o = e.getMenuClassName ? e.getMenuClassName() : "";
        o && (r.className += " " + o), this.options.blockMouse && (this.block = r.appendChild(ae(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", H(this.block, $.MOUSE_DOWN, (c) => c.stopPropagation()));
        const a = new le(), l = e.actionRunner || new qb();
        return l.onBeforeRun(this.onActionRun, this, a), l.onDidRun(this.onDidActionRun, this, a), i = new Dl(r, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: l,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (c) => this.keybindingService.lookupKeybinding(c.id)
        }), a.add(U6(i, this.themeService)), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a), a.add(H(window, $.BLUR, () => this.contextViewService.hideContextView(!0))), a.add(H(window, $.MOUSE_DOWN, (c) => {
          if (c.defaultPrevented)
            return;
          const h = new Gs(c);
          let u = h.target;
          if (!h.rightButton) {
            for (; u; ) {
              if (u === r)
                return;
              u = u.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        })), zr(a, i);
      },
      focus: () => {
        i == null || i.focus(!!e.autoSelectFirstItem);
      },
      onHide: (r) => {
        var o;
        (o = e.onHide) === null || o === void 0 || o.call(e, !!r), this.block && (this.block.remove(), this.block = null), this.focusToReturn && this.focusToReturn.focus();
      }
    }, n, !!n);
  }
  onActionRun(e) {
    this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1), this.focusToReturn && this.focusToReturn.focus();
  }
  onDidActionRun(e) {
    e.error && !ku(e.error) && this.notificationService.error(e.error);
  }
}
var j6 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Wc = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let f0 = class extends z {
  constructor(e, t, i, n, r) {
    super(), this._onDidShowContextMenu = new A(), this._onDidHideContextMenu = new A(), this.contextMenuHandler = new $6(i, e, t, n, r);
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  showContextMenu(e) {
    this.contextMenuHandler.showContextMenu(Object.assign(Object.assign({}, e), { onHide: (t) => {
      var i;
      (i = e.onHide) === null || i === void 0 || i.call(e, t), this._onDidHideContextMenu.fire();
    } })), Ya.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
  }
};
f0 = j6([
  Wc(0, Mu),
  Wc(1, vs),
  Wc(2, um),
  Wc(3, co),
  Wc(4, vt)
], f0);
function Ky(s) {
  let e = JSON.parse(s);
  return e = g0(e), e;
}
function g0(s, e = 0) {
  if (!s || e > 200)
    return s;
  if (typeof s == "object") {
    switch (s.$mid) {
      case 1:
        return Le.revive(s);
      case 2:
        return new RegExp(s.source, s.flags);
      case 14:
        return new Date(s.source);
    }
    if (s instanceof Mg || s instanceof Uint8Array)
      return s;
    if (Array.isArray(s))
      for (let t = 0; t < s.length; ++t)
        s[t] = g0(s[t], e + 1);
    else
      for (const t in s)
        Object.hasOwnProperty.call(s, t) && (s[t] = g0(s[t], e + 1));
  }
  return s;
}
var og;
(function(s) {
  s[s.API = 0] = "API", s[s.USER = 1] = "USER";
})(og || (og = {}));
var BC = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, ag = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, No = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
let m0 = class {
  constructor(e) {
    this._commandService = e;
  }
  open(e, t) {
    return No(this, void 0, void 0, function* () {
      if (!PC(e, we.command))
        return !1;
      if (!(t != null && t.allowCommands))
        return !0;
      typeof e == "string" && (e = Le.parse(e));
      let i = [];
      try {
        i = Ky(decodeURIComponent(e.query));
      } catch {
        try {
          i = Ky(e.query);
        } catch {
        }
      }
      return Array.isArray(i) || (i = [i]), yield this._commandService.executeCommand(e.path, ...i), !0;
    });
  }
};
m0 = BC([
  ag(0, an)
], m0);
let p0 = class {
  constructor(e) {
    this._editorService = e;
  }
  open(e, t) {
    return No(this, void 0, void 0, function* () {
      typeof e == "string" && (e = Le.parse(e));
      const { selection: i, uri: n } = KO(e);
      return e = n, e.scheme === we.file && (e = h8(e)), yield this._editorService.openCodeEditor({
        resource: e,
        options: Object.assign({ selection: i, source: t != null && t.fromUserGesture ? og.USER : og.API }, t == null ? void 0 : t.editorOptions)
      }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), !0;
    });
  }
};
p0 = BC([
  ag(0, Ct)
], p0);
let _0 = class {
  constructor(e, t) {
    this._openers = new Ei(), this._validators = new Ei(), this._resolvers = new Ei(), this._resolvedUriTargets = new si((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new Ei(), this._defaultExternalOpener = {
      openExternal: (i) => No(this, void 0, void 0, function* () {
        return Sy(i, we.http, we.https) ? rD(i) : window.location.href = i, !0;
      })
    }, this._openers.push({
      open: (i, n) => No(this, void 0, void 0, function* () {
        return (n == null ? void 0 : n.openExternal) || Sy(i, we.mailto, we.http, we.https, we.vsls) ? (yield this._doOpenExternal(i, n), !0) : !1;
      })
    }), this._openers.push(new m0(t)), this._openers.push(new p0(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  registerValidator(e) {
    return { dispose: this._validators.push(e) };
  }
  registerExternalUriResolver(e) {
    return { dispose: this._resolvers.push(e) };
  }
  setDefaultExternalOpener(e) {
    this._defaultExternalOpener = e;
  }
  registerExternalOpener(e) {
    return { dispose: this._externalOpeners.push(e) };
  }
  open(e, t) {
    var i;
    return No(this, void 0, void 0, function* () {
      const n = typeof e == "string" ? Le.parse(e) : e, r = (i = this._resolvedUriTargets.get(n)) !== null && i !== void 0 ? i : e;
      for (const o of this._validators)
        if (!(yield o.shouldOpen(r, t)))
          return !1;
      for (const o of this._openers)
        if (yield o.open(e, t))
          return !0;
      return !1;
    });
  }
  resolveExternalUri(e, t) {
    return No(this, void 0, void 0, function* () {
      for (const i of this._resolvers)
        try {
          const n = yield i.resolveExternalUri(e, t);
          if (n)
            return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
        } catch {
        }
      throw new Error("Could not resolve external URI: " + e.toString());
    });
  }
  _doOpenExternal(e, t) {
    return No(this, void 0, void 0, function* () {
      const i = typeof e == "string" ? Le.parse(e) : e;
      let n;
      try {
        n = (yield this.resolveExternalUri(i, t)).resolved;
      } catch {
        n = i;
      }
      let r;
      if (typeof e == "string" && i.toString() === n.toString() ? r = e : r = encodeURI(n.toString(!0)), t != null && t.allowContributedOpeners) {
        const o = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
        for (const a of this._externalOpeners)
          if (yield a.openExternal(r, {
            sourceUri: i,
            preferredOpenerId: o
          }, Ii.None))
            return !0;
      }
      return this._defaultExternalOpener.openExternal(r, { sourceUri: i }, Ii.None);
    });
  }
  dispose() {
    this._validators.clear();
  }
};
_0 = BC([
  ag(0, Ct),
  ag(1, an)
], _0);
var Zi;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(Zi || (Zi = {}));
(function(s) {
  function e(o, a) {
    return a - o;
  }
  s.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[s.Error] = p("sev.error", "Error"), t[s.Warning] = p("sev.warning", "Warning"), t[s.Info] = p("sev.info", "Info");
  function i(o) {
    return t[o] || "";
  }
  s.toString = i;
  function n(o) {
    switch (o) {
      case pt.Error:
        return s.Error;
      case pt.Warning:
        return s.Warning;
      case pt.Info:
        return s.Info;
      case pt.Ignore:
        return s.Hint;
    }
  }
  s.fromSeverity = n;
  function r(o) {
    switch (o) {
      case s.Error:
        return pt.Error;
      case s.Warning:
        return pt.Warning;
      case s.Info:
        return pt.Info;
      case s.Hint:
        return pt.Ignore;
    }
  }
  s.toSeverity = r;
})(Zi || (Zi = {}));
var qy;
(function(s) {
  const e = "";
  function t(n) {
    return i(n, !0);
  }
  s.makeKey = t;
  function i(n, r) {
    const o = [e];
    return n.source ? o.push(n.source.replace("\xA6", "\\\xA6")) : o.push(e), n.code ? typeof n.code == "string" ? o.push(n.code.replace("\xA6", "\\\xA6")) : o.push(n.code.value.replace("\xA6", "\\\xA6")) : o.push(e), n.severity !== void 0 && n.severity !== null ? o.push(Zi.toString(n.severity)) : o.push(e), n.message && r ? o.push(n.message.replace("\xA6", "\\\xA6")) : o.push(e), n.startLineNumber !== void 0 && n.startLineNumber !== null ? o.push(n.startLineNumber.toString()) : o.push(e), n.startColumn !== void 0 && n.startColumn !== null ? o.push(n.startColumn.toString()) : o.push(e), n.endLineNumber !== void 0 && n.endLineNumber !== null ? o.push(n.endLineNumber.toString()) : o.push(e), n.endColumn !== void 0 && n.endColumn !== null ? o.push(n.endColumn.toString()) : o.push(e), o.push(e), o.join("\xA6");
  }
  s.makeKeyOptionalMessage = i;
})(qy || (qy = {}));
const ga = Se("markerService");
var K6 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Gy = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class q6 extends z {
  constructor(e) {
    super(), this.model = e, this._markersData = /* @__PURE__ */ new Map(), this._register(ze(() => {
      this.model.deltaDecorations([...this._markersData.keys()], []), this._markersData.clear();
    }));
  }
  update(e, t) {
    const i = [...this._markersData.keys()];
    this._markersData.clear();
    const n = this.model.deltaDecorations(i, t);
    for (let r = 0; r < n.length; r++)
      this._markersData.set(n[r], e[r]);
    return i.length !== 0 || n.length !== 0;
  }
  getMarker(e) {
    return this._markersData.get(e.id);
  }
}
let b0 = class extends z {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new A()), this._markerDecorations = new si(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get(e);
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get(t);
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new q6(e);
    this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    var t;
    const i = this._markerDecorations.get(e.uri);
    i && (i.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === we.inMemory || e.uri.scheme === we.internal || e.uri.scheme === we.vscode) && ((t = this._markerService) === null || t === void 0 || t.read({ resource: e.uri }).map((n) => n.owner).forEach((n) => this._markerService.remove(n, [e.uri])));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 }), i = t.map((n) => ({
      range: this._createDecorationRange(e.model, n),
      options: this._createDecorationOption(n)
    }));
    e.update(t, i) && this._onDidChangeMarker.fire(e.model);
  }
  _createDecorationRange(e, t) {
    let i = N.lift(t);
    if (t.severity === Zi.Hint && !this._hasMarkerTag(t, 1) && !this._hasMarkerTag(t, 2) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
      if (n === 1 || i.endColumn >= n)
        return i;
      const r = e.getWordAtPosition(i.getStartPosition());
      r && (i = new N(i.startLineNumber, r.startColumn, i.endLineNumber, r.endColumn));
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      const n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      n < i.endColumn && (i = new N(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, n, r, o;
    switch (e.severity) {
      case Zi.Hint:
        this._hasMarkerTag(e, 2) ? t = void 0 : this._hasMarkerTag(e, 1) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
        break;
      case Zi.Warning:
        t = "squiggly-warning", i = Va(yR), n = 20, o = {
          color: Va(M7),
          position: jo.Inline
        };
        break;
      case Zi.Info:
        t = "squiggly-info", i = Va(LR), n = 10;
        break;
      case Zi.Error:
      default:
        t = "squiggly-error", i = Va(SR), n = 30, o = {
          color: Va(T7),
          position: jo.Inline
        };
        break;
    }
    return e.tags && (e.tags.indexOf(1) !== -1 && (r = "squiggly-inline-unnecessary"), e.tags.indexOf(2) !== -1 && (r = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: _f.Right
      },
      minimap: o,
      zIndex: n,
      inlineClassName: r
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
};
b0 = K6([
  Gy(0, Kt),
  Gy(1, ga)
], b0);
class Lh {
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t, this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
  }
  static create(e, t) {
    return new Lh(e, new lg(t));
  }
  get startLineNumber() {
    return this._startLineNumber;
  }
  get endLineNumber() {
    return this._endLineNumber;
  }
  toString() {
    return this._tokens.toString(this._startLineNumber);
  }
  _updateEndLineNumber() {
    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
  }
  isEmpty() {
    return this._tokens.isEmpty();
  }
  getLineTokens(e) {
    return this._startLineNumber <= e && e <= this._endLineNumber ? this._tokens.getLineTokens(e - this._startLineNumber) : null;
  }
  getRange() {
    const e = this._tokens.getRange();
    return e && new N(this._startLineNumber + e.startLineNumber, e.startColumn, this._startLineNumber + e.endLineNumber, e.endColumn);
  }
  removeTokens(e) {
    const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber;
    this._startLineNumber += this._tokens.removeTokens(t, e.startColumn - 1, i, e.endColumn - 1), this._updateEndLineNumber();
  }
  split(e) {
    const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber, [n, r, o] = this._tokens.split(t, e.startColumn - 1, i, e.endColumn - 1);
    return [new Lh(this._startLineNumber, n), new Lh(this._startLineNumber + o, r)];
  }
  applyEdit(e, t) {
    const [i, n, r] = Gl(t);
    this.acceptEdit(e, i, n, r, t.length > 0 ? t.charCodeAt(0) : 0);
  }
  acceptEdit(e, t, i, n, r) {
    this._acceptDeleteRange(e), this._acceptInsertText(new O(e.startLineNumber, e.startColumn), t, i, n, r), this._updateEndLineNumber();
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return;
    const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber;
    if (i < 0) {
      const r = i - t;
      this._startLineNumber -= r;
      return;
    }
    const n = this._tokens.getMaxDeltaLine();
    if (!(t >= n + 1)) {
      if (t < 0 && i >= n + 1) {
        this._startLineNumber = 0, this._tokens.clear();
        return;
      }
      if (t < 0) {
        const r = -t;
        this._startLineNumber -= r, this._tokens.acceptDeleteRange(e.startColumn - 1, 0, 0, i, e.endColumn - 1);
      } else
        this._tokens.acceptDeleteRange(0, t, e.startColumn - 1, i, e.endColumn - 1);
    }
  }
  _acceptInsertText(e, t, i, n, r) {
    if (t === 0 && i === 0)
      return;
    const o = e.lineNumber - this._startLineNumber;
    if (o < 0) {
      this._startLineNumber += t;
      return;
    }
    const a = this._tokens.getMaxDeltaLine();
    o >= a + 1 || this._tokens.acceptInsertText(o, e.column - 1, t, i, n, r);
  }
}
class lg {
  constructor(e) {
    this._tokens = e, this._tokenCount = e.length / 4;
  }
  toString(e) {
    const t = [];
    for (let i = 0; i < this._tokenCount; i++)
      t.push(`(${this._getDeltaLine(i) + e},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
    return `[${t.join(",")}]`;
  }
  getMaxDeltaLine() {
    const e = this._getTokenCount();
    return e === 0 ? -1 : this._getDeltaLine(e - 1);
  }
  getRange() {
    const e = this._getTokenCount();
    if (e === 0)
      return null;
    const t = this._getStartCharacter(0), i = this._getDeltaLine(e - 1), n = this._getEndCharacter(e - 1);
    return new N(0, t + 1, i, n + 1);
  }
  _getTokenCount() {
    return this._tokenCount;
  }
  _getDeltaLine(e) {
    return this._tokens[4 * e];
  }
  _getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  _getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  isEmpty() {
    return this._getTokenCount() === 0;
  }
  getLineTokens(e) {
    let t = 0, i = this._getTokenCount() - 1;
    for (; t < i; ) {
      const n = t + Math.floor((i - t) / 2), r = this._getDeltaLine(n);
      if (r < e)
        t = n + 1;
      else if (r > e)
        i = n - 1;
      else {
        let o = n;
        for (; o > t && this._getDeltaLine(o - 1) === e; )
          o--;
        let a = n;
        for (; a < i && this._getDeltaLine(a + 1) === e; )
          a++;
        return new Zy(this._tokens.subarray(4 * o, 4 * a + 4));
      }
    }
    return this._getDeltaLine(t) === e ? new Zy(this._tokens.subarray(4 * t, 4 * t + 4)) : null;
  }
  clear() {
    this._tokenCount = 0;
  }
  removeTokens(e, t, i, n) {
    const r = this._tokens, o = this._tokenCount;
    let a = 0, l = !1, c = 0;
    for (let h = 0; h < o; h++) {
      const u = 4 * h, d = r[u], f = r[u + 1], m = r[u + 2], _ = r[u + 3];
      if ((d > e || d === e && m >= t) && (d < i || d === i && f <= n))
        l = !0;
      else {
        if (a === 0 && (c = d), l) {
          const b = 4 * a;
          r[b] = d - c, r[b + 1] = f, r[b + 2] = m, r[b + 3] = _;
        }
        a++;
      }
    }
    return this._tokenCount = a, c;
  }
  split(e, t, i, n) {
    const r = this._tokens, o = this._tokenCount, a = [], l = [];
    let c = a, h = 0, u = 0;
    for (let d = 0; d < o; d++) {
      const f = 4 * d, m = r[f], _ = r[f + 1], b = r[f + 2], v = r[f + 3];
      if (m > e || m === e && b >= t) {
        if (m < i || m === i && _ <= n)
          continue;
        c !== l && (c = l, h = 0, u = m);
      }
      c[h++] = m - u, c[h++] = _, c[h++] = b, c[h++] = v;
    }
    return [new lg(new Uint32Array(a)), new lg(new Uint32Array(l)), u];
  }
  acceptDeleteRange(e, t, i, n, r) {
    const o = this._tokens, a = this._tokenCount, l = n - t;
    let c = 0, h = !1;
    for (let u = 0; u < a; u++) {
      const d = 4 * u;
      let f = o[d], m = o[d + 1], _ = o[d + 2];
      const b = o[d + 3];
      if (f < t || f === t && _ <= i) {
        c++;
        continue;
      } else if (f === t && m < i)
        f === n && _ > r ? _ -= r - i : _ = i;
      else if (f === t && m === i)
        if (f === n && _ > r)
          _ -= r - i;
        else {
          h = !0;
          continue;
        }
      else if (f < n || f === n && m < r)
        if (f === n && _ > r)
          f === t ? (m = i, _ = m + (_ - r)) : (m = 0, _ = m + (_ - r));
        else {
          h = !0;
          continue;
        }
      else if (f > n) {
        if (l === 0 && !h) {
          c = a;
          break;
        }
        f -= l;
      } else if (f === n && m >= r)
        e && f === 0 && (m += e, _ += e), f -= l, m -= r - i, _ -= r - i;
      else
        throw new Error("Not possible!");
      const v = 4 * c;
      o[v] = f, o[v + 1] = m, o[v + 2] = _, o[v + 3] = b, c++;
    }
    this._tokenCount = c;
  }
  acceptInsertText(e, t, i, n, r, o) {
    const a = i === 0 && n === 1 && (o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122), l = this._tokens, c = this._tokenCount;
    for (let h = 0; h < c; h++) {
      const u = 4 * h;
      let d = l[u], f = l[u + 1], m = l[u + 2];
      if (!(d < e || d === e && m < t)) {
        if (d === e && m === t)
          if (a)
            m += 1;
          else
            continue;
        else if (d === e && f < t && t < m)
          i === 0 ? m += n : m = t;
        else {
          if (d === e && f === t && a)
            continue;
          if (d === e)
            if (d += i, i === 0)
              f += n, m += n;
            else {
              const _ = m - f;
              f = r + (f - t), m = f + _;
            }
          else
            d += i;
        }
        l[u] = d, l[u + 1] = f, l[u + 2] = m;
      }
    }
  }
}
class Zy {
  constructor(e) {
    this._tokens = e;
  }
  getCount() {
    return this._tokens.length / 4;
  }
  getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  getMetadata(e) {
    return this._tokens[4 * e + 3];
  }
}
var G6 = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, jp = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let C0 = class {
  constructor(e, t, i, n) {
    this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hasWarnedOverlappingTokens = !1, this._hasWarnedInvalidLengthTokens = !1, this._hasWarnedInvalidEditStart = !1, this._hashTable = new Hs();
  }
  getMetadata(e, t, i) {
    const n = this._languageService.languageIdCodec.encodeLanguageId(i), r = this._hashTable.get(e, t, n);
    let o;
    if (r)
      o = r.metadata, this._logService.getLevel() === Tn.Trace && this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${e} / ${t}: foreground ${ki.getForeground(o)}, fontStyle ${ki.getFontStyle(o).toString(2)}`);
    else {
      let a = this._legend.tokenTypes[e];
      const l = [];
      if (a) {
        let c = t;
        for (let u = 0; c > 0 && u < this._legend.tokenModifiers.length; u++)
          c & 1 && l.push(this._legend.tokenModifiers[u]), c = c >> 1;
        c > 0 && this._logService.getLevel() === Tn.Trace && (this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${t.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`), l.push("not-in-legend"));
        const h = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
        if (typeof h > "u")
          o = 2147483647;
        else {
          if (o = 0, typeof h.italic < "u") {
            const u = (h.italic ? 1 : 0) << 11;
            o |= u | 1;
          }
          if (typeof h.bold < "u") {
            const u = (h.bold ? 2 : 0) << 11;
            o |= u | 2;
          }
          if (typeof h.underline < "u") {
            const u = (h.underline ? 4 : 0) << 11;
            o |= u | 4;
          }
          if (typeof h.strikethrough < "u") {
            const u = (h.strikethrough ? 8 : 0) << 11;
            o |= u | 8;
          }
          if (h.foreground) {
            const u = h.foreground << 15;
            o |= u | 16;
          }
          o === 0 && (o = 2147483647);
        }
      } else
        this._logService.getLevel() === Tn.Trace && this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${e} for legend: ${JSON.stringify(this._legend.tokenTypes)}`), o = 2147483647, a = "not-in-legend";
      this._hashTable.add(e, t, n, o), this._logService.getLevel() === Tn.Trace && this._logService.trace(`SemanticTokensProviderStyling ${e} (${a}) / ${t} (${l.join(" ")}): foreground ${ki.getForeground(o)}, fontStyle ${ki.getFontStyle(o).toString(2)}`);
    }
    return o;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, console.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidLengthSemanticTokens(e, t) {
    this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = !0, console.warn(`Semantic token with invalid length detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidEditStart(e, t, i, n, r) {
    this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = !0, console.warn(`Invalid semantic tokens edit detected (previousResultId: ${e}, resultId: ${t}) at edit #${i}: The provided start offset ${n} is outside the previous data (length ${r}).`));
  }
};
C0 = G6([
  jp(1, vt),
  jp(2, Xt),
  jp(3, ao)
], C0);
function Z6(s, e, t) {
  const i = s.data, n = s.data.length / 5 | 0, r = Math.max(Math.ceil(n / 1024), 400), o = [];
  let a = 0, l = 1, c = 0;
  for (; a < n; ) {
    const h = a;
    let u = Math.min(h + r, n);
    if (u < n) {
      let C = u;
      for (; C - 1 > h && i[5 * C] === 0; )
        C--;
      if (C - 1 === h) {
        let w = u;
        for (; w + 1 < n && i[5 * w] === 0; )
          w++;
        u = w;
      } else
        u = C;
    }
    let d = new Uint32Array((u - h) * 4), f = 0, m = 0, _ = 0, b = 0;
    for (; a < u; ) {
      const C = 5 * a, w = i[C], L = i[C + 1], E = l + w | 0, k = w === 0 ? c + L | 0 : L, y = i[C + 2], S = k + y | 0, D = i[C + 3], T = i[C + 4];
      if (S <= k)
        e.warnInvalidLengthSemanticTokens(E, k + 1);
      else if (_ === E && b > k)
        e.warnOverlappingSemanticTokens(E, k + 1);
      else {
        const M = e.getMetadata(D, T, t);
        M !== 2147483647 && (m === 0 && (m = E), d[f] = E - m, d[f + 1] = k, d[f + 2] = S, d[f + 3] = M, f += 4, _ = E, b = S);
      }
      l = E, c = k, a++;
    }
    f !== d.length && (d = d.subarray(0, f));
    const v = Lh.create(m, d);
    o.push(v);
  }
  return o;
}
class Y6 {
  constructor(e, t, i, n) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
  }
}
class Hs {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = Hs._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Hs._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Hs._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const n = this._hashFunc(e, t, i);
    let r = this._elements[n];
    for (; r; ) {
      if (r.tokenTypeIndex === e && r.tokenModifierSet === t && r.languageId === i)
        return r;
      r = r.next;
    }
    return null;
  }
  add(e, t, i, n) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const r = this._elements;
      this._currentLengthIndex++, this._currentLength = Hs._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Hs._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Hs._nullOutEntries(this._elements, this._currentLength);
      for (const o of r) {
        let a = o;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new Y6(e, t, i, n));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
}
Hs._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
function Q6(s) {
  for (let e = 0, t = s.length; e < t; e += 4) {
    const i = s[e + 0], n = s[e + 1], r = s[e + 2], o = s[e + 3];
    s[e + 0] = o, s[e + 1] = r, s[e + 2] = n, s[e + 3] = i;
  }
}
function X6(s) {
  const e = new Uint8Array(s.buffer, s.byteOffset, s.length * 4);
  return Tk() || Q6(e), Mg.wrap(e);
}
function dx(s) {
  const e = new Uint32Array(J6(s));
  let t = 0;
  if (e[t++] = s.id, s.type === "full")
    e[t++] = 1, e[t++] = s.data.length, e.set(s.data, t), t += s.data.length;
  else {
    e[t++] = 2, e[t++] = s.deltas.length;
    for (const i of s.deltas)
      e[t++] = i.start, e[t++] = i.deleteCount, i.data ? (e[t++] = i.data.length, e.set(i.data, t), t += i.data.length) : e[t++] = 0;
  }
  return X6(e);
}
function J6(s) {
  let e = 0;
  if (e += 1 + 1, s.type === "full")
    e += 1 + s.data.length;
  else {
    e += 1, e += (1 + 1 + 1) * s.deltas.length;
    for (const t of s.deltas)
      t.data && (e += t.data.length);
  }
  return e;
}
var ro = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
function pm(s) {
  return s && !!s.data;
}
function fx(s) {
  return s && Array.isArray(s.edits);
}
class eF {
  constructor(e, t, i) {
    this.provider = e, this.tokens = t, this.error = i;
  }
}
function gx(s, e) {
  return s.has(e);
}
function tF(s, e) {
  const t = s.orderedGroups(e);
  return t.length > 0 ? t[0] : [];
}
function mx(s, e, t, i, n) {
  return ro(this, void 0, void 0, function* () {
    const r = tF(s, e), o = yield Promise.all(r.map((a) => ro(this, void 0, void 0, function* () {
      let l, c = null;
      try {
        l = yield a.provideDocumentSemanticTokens(e, a === t ? i : null, n);
      } catch (h) {
        c = h, l = null;
      }
      return (!l || !pm(l) && !fx(l)) && (l = null), new eF(a, l, c);
    })));
    for (const a of o) {
      if (a.error)
        throw a.error;
      if (a.tokens)
        return a;
    }
    return o.length > 0 ? o[0] : null;
  });
}
function iF(s, e) {
  const t = s.orderedGroups(e);
  return t.length > 0 ? t[0] : null;
}
class nF {
  constructor(e, t) {
    this.provider = e, this.tokens = t;
  }
}
function px(s, e) {
  const t = s.orderedGroups(e);
  return t.length > 0 ? t[0] : [];
}
function _x(s, e, t, i) {
  return ro(this, void 0, void 0, function* () {
    const n = px(s, e), r = yield Promise.all(n.map((o) => ro(this, void 0, void 0, function* () {
      let a;
      try {
        a = yield o.provideDocumentRangeSemanticTokens(e, t, i);
      } catch (l) {
        Eg(l), a = null;
      }
      return (!a || !pm(a)) && (a = null), new nF(o, a);
    })));
    for (const o of r)
      if (o.tokens)
        return o;
    return r.length > 0 ? r[0] : null;
  });
}
Bt.registerCommand("_provideDocumentSemanticTokensLegend", (s, ...e) => ro(void 0, void 0, void 0, function* () {
  const [t] = e;
  Pn(t instanceof Le);
  const i = s.get(Kt).getModel(t);
  if (!i)
    return;
  const { documentSemanticTokensProvider: n } = s.get(De), r = iF(n, i);
  return r ? r[0].getLegend() : s.get(an).executeCommand("_provideDocumentRangeSemanticTokensLegend", t);
}));
Bt.registerCommand("_provideDocumentSemanticTokens", (s, ...e) => ro(void 0, void 0, void 0, function* () {
  const [t] = e;
  Pn(t instanceof Le);
  const i = s.get(Kt).getModel(t);
  if (!i)
    return;
  const { documentSemanticTokensProvider: n } = s.get(De);
  if (!gx(n, i))
    return s.get(an).executeCommand("_provideDocumentRangeSemanticTokens", t, i.getFullModelRange());
  const r = yield mx(n, i, null, null, Ii.None);
  if (!r)
    return;
  const { provider: o, tokens: a } = r;
  if (!a || !pm(a))
    return;
  const l = dx({
    id: 0,
    type: "full",
    data: a.data
  });
  return a.resultId && o.releaseDocumentSemanticTokens(a.resultId), l;
}));
Bt.registerCommand("_provideDocumentRangeSemanticTokensLegend", (s, ...e) => ro(void 0, void 0, void 0, function* () {
  const [t, i] = e;
  Pn(t instanceof Le);
  const n = s.get(Kt).getModel(t);
  if (!n)
    return;
  const { documentRangeSemanticTokensProvider: r } = s.get(De), o = px(r, n);
  if (o.length === 0)
    return;
  if (o.length === 1)
    return o[0].getLegend();
  if (!i || !N.isIRange(i))
    return console.warn("provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in"), o[0].getLegend();
  const a = yield _x(r, n, N.lift(i), Ii.None);
  if (!!a)
    return a.provider.getLegend();
}));
Bt.registerCommand("_provideDocumentRangeSemanticTokens", (s, ...e) => ro(void 0, void 0, void 0, function* () {
  const [t, i] = e;
  Pn(t instanceof Le), Pn(N.isIRange(i));
  const n = s.get(Kt).getModel(t);
  if (!n)
    return;
  const { documentRangeSemanticTokensProvider: r } = s.get(De), o = yield _x(r, n, N.lift(i), Ii.None);
  if (!(!o || !o.tokens))
    return dx({
      id: 0,
      type: "full",
      data: o.tokens.data
    });
}));
var VC = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, ii = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function gr(s) {
  return s.toString();
}
function Yy(s) {
  const e = new Vg(), t = s.createSnapshot();
  let i;
  for (; i = t.read(); )
    e.update(i);
  return e.digest();
}
class sF {
  constructor(e, t, i) {
    this._modelEventListeners = new le(), this.model = e, this._languageSelection = null, this._languageSelectionListener = null, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
  }
  _disposeLanguageSelection() {
    this._languageSelectionListener && (this._languageSelectionListener.dispose(), this._languageSelectionListener = null);
  }
  dispose() {
    this._modelEventListeners.dispose(), this._disposeLanguageSelection();
  }
  setLanguage(e) {
    this._disposeLanguageSelection(), this._languageSelection = e, this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(e.languageId)), this.model.setMode(e.languageId);
  }
}
const rF = _i || Ie ? 1 : 2;
class oF {
  constructor(e, t, i, n, r, o, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = r, this.sha1 = o, this.versionId = a, this.alternativeVersionId = l;
  }
}
let cg = class eh extends z {
  constructor(e, t, i, n, r, o, a, l, c) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._themeService = i, this._logService = n, this._undoRedoService = r, this._languageService = o, this._languageConfigurationService = a, this._languageFeatureDebounceService = l, this._onModelAdded = this._register(new A()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new A()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new A()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._semanticStyling = this._register(new aF(this._themeService, this._languageService, this._logService)), this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions())), this._updateModelOptions(), this._register(new v0(this._semanticStyling, this, this._themeService, this._configurationService, this._languageFeatureDebounceService, c));
  }
  static _readModelOptions(e, t) {
    var i;
    let n = zt.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const f = parseInt(e.editor.tabSize, 10);
      isNaN(f) || (n = f), n < 1 && (n = 1);
    }
    let r = n;
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const f = parseInt(e.editor.indentSize, 10);
      isNaN(f) || (r = f), r < 1 && (r = 1);
    }
    let o = zt.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : Boolean(e.editor.insertSpaces));
    let a = rF;
    const l = e.eol;
    l === `\r
` ? a = 2 : l === `
` && (a = 1);
    let c = zt.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (c = e.editor.trimAutoWhitespace === "false" ? !1 : Boolean(e.editor.trimAutoWhitespace));
    let h = zt.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (h = e.editor.detectIndentation === "false" ? !1 : Boolean(e.editor.detectIndentation));
    let u = zt.largeFileOptimizations;
    e.editor && typeof e.editor.largeFileOptimizations < "u" && (u = e.editor.largeFileOptimizations === "false" ? !1 : Boolean(e.editor.largeFileOptimizations));
    let d = zt.bracketPairColorizationOptions;
    return ((i = e.editor) === null || i === void 0 ? void 0 : i.bracketPairColorization) && typeof e.editor.bracketPairColorization == "object" && (d = {
      enabled: !!e.editor.bracketPairColorization.enabled,
      independentColorPoolPerBracketType: !!e.editor.bracketPairColorization.independentColorPoolPerBracketType
    }), {
      isForSimpleWidget: t,
      tabSize: n,
      indentSize: r,
      insertSpaces: o,
      detectIndentation: h,
      defaultEOL: a,
      trimAutoWhitespace: c,
      largeFileOptimizations: u,
      bracketPairColorizationOptions: d
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && typeof i == "string" && i !== "auto" ? i : dn === 3 || dn === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    let n = this._modelCreationOptionsByLanguageAndResource[e + t];
    if (!n) {
      const r = this._configurationService.getValue("editor", { overrideIdentifier: e, resource: t }), o = this._getEOL(t, e);
      n = eh._readModelOptions({ editor: r, eol: o }, i), this._modelCreationOptionsByLanguageAndResource[e + t] = n;
    }
    return n;
  }
  _updateModelOptions() {
    const e = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const t = Object.keys(this._models);
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i], o = this._models[r], a = o.model.getLanguageId(), l = o.model.uri, c = e[a + l], h = this.getCreationOptions(a, l, o.model.isForSimpleWidget);
      eh._setModelOptionsForModel(o.model, h, c);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(t.defaultEOL === 1 ? 0 : 1), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && en(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    }));
  }
  _insertDisposedModel(e) {
    this._disposedModels.set(gr(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(gr(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(gr(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, n) {
    const r = this.getCreationOptions(t, i, n), o = new ta(e, t, r, i, this._undoRedoService, this._languageService, this._languageConfigurationService);
    if (i && this._disposedModels.has(gr(i))) {
      const c = this._removeDisposedModel(i), h = this._undoRedoService.getElements(i), u = Yy(o) === c.sha1;
      if (u || c.sharesUndoRedoStack) {
        for (const d of h.past)
          Vs(d) && d.matchesResource(i) && d.setModel(o);
        for (const d of h.future)
          Vs(d) && d.matchesResource(i) && d.setModel(o);
        this._undoRedoService.setElementsValidFlag(i, !0, (d) => Vs(d) && d.matchesResource(i)), u && (o._overwriteVersionId(c.versionId), o._overwriteAlternativeVersionId(c.alternativeVersionId), o._overwriteInitialUndoRedoSnapshot(c.initialUndoRedoSnapshot));
      } else
        c.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(c.initialUndoRedoSnapshot);
    }
    const a = gr(o.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new sF(o, (c) => this._onWillDispose(c), (c, h) => this._onDidChangeLanguage(c, h));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, n = !1) {
    let r;
    return t ? (r = this._createModelData(e, t.languageId, i, n), this.setMode(r.model, t)) : r = this._createModelData(e, os, i, n), this._onModelAdded.fire(r.model), r.model;
  }
  setMode(e, t) {
    if (!t)
      return;
    const i = this._models[gr(e.uri)];
    !i || i.setLanguage(t);
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      e.push(this._models[r].model);
    }
    return e;
  }
  getModel(e) {
    const t = gr(e), i = this._models[t];
    return i ? i.model : null;
  }
  getSemanticTokensProviderStyling(e) {
    return this._semanticStyling.get(e);
  }
  _schemaShouldMaintainUndoRedoElements(e) {
    return e.scheme === we.file || e.scheme === we.vscodeRemote || e.scheme === we.vscodeUserData || e.scheme === we.vscodeNotebookCell || e.scheme === "fake-fs";
  }
  _onWillDispose(e) {
    const t = gr(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let r = !1, o = 0;
    if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
      const l = this._undoRedoService.getElements(e.uri);
      if (l.past.length > 0 || l.future.length > 0) {
        for (const c of l.past)
          Vs(c) && c.matchesResource(e.uri) && (r = !0, o += c.heapSize(e.uri), c.setModel(e.uri));
        for (const c of l.future)
          Vs(c) && c.matchesResource(e.uri) && (r = !0, o += c.heapSize(e.uri), c.setModel(e.uri));
      }
    }
    const a = eh.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
    if (r)
      if (!n && o > a) {
        const l = i.model.getInitialUndoRedoSnapshot();
        l !== null && this._undoRedoService.restoreSnapshot(l);
      } else
        this._ensureDisposedModelsHeapSize(a - o), this._undoRedoService.setElementsValidFlag(e.uri, !1, (l) => Vs(l) && l.matchesResource(e.uri)), this._insertDisposedModel(new oF(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, o, Yy(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!n) {
      const l = i.model.getInitialUndoRedoSnapshot();
      l !== null && this._undoRedoService.restoreSnapshot(l);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, n = e.getLanguageId(), r = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), o = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
    eh._setModelOptionsForModel(e, o, r), this._onModelModeChanged.fire({ model: e, oldLanguageId: i });
  }
};
cg.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
cg = VC([
  ii(0, gt),
  ii(1, F2),
  ii(2, vt),
  ii(3, ao),
  ii(4, CC),
  ii(5, Xt),
  ii(6, bs),
  ii(7, dm),
  ii(8, De)
], cg);
const bx = "editor.semanticHighlighting";
function Qy(s, e, t) {
  var i;
  const n = (i = t.getValue(bx, { overrideIdentifier: s.getLanguageId(), resource: s.uri })) === null || i === void 0 ? void 0 : i.enabled;
  return typeof n == "boolean" ? n : e.getColorTheme().semanticHighlighting;
}
let v0 = class extends z {
  constructor(e, t, i, n, r, o) {
    super(), this._watchers = /* @__PURE__ */ Object.create(null), this._semanticStyling = e;
    const a = (h) => {
      this._watchers[h.uri.toString()] = new hu(h, this._semanticStyling, i, r, o);
    }, l = (h, u) => {
      u.dispose(), delete this._watchers[h.uri.toString()];
    }, c = () => {
      for (const h of t.getModels()) {
        const u = this._watchers[h.uri.toString()];
        Qy(h, i, n) ? u || a(h) : u && l(h, u);
      }
    };
    this._register(t.onModelAdded((h) => {
      Qy(h, i, n) && a(h);
    })), this._register(t.onModelRemoved((h) => {
      const u = this._watchers[h.uri.toString()];
      u && l(h, u);
    })), this._register(n.onDidChangeConfiguration((h) => {
      h.affectsConfiguration(bx) && c();
    })), this._register(i.onDidColorThemeChange(c));
  }
  dispose() {
    for (const e of Object.values(this._watchers))
      e.dispose();
    super.dispose();
  }
};
v0 = VC([
  ii(1, Kt),
  ii(2, vt),
  ii(3, gt),
  ii(4, dm),
  ii(5, De)
], v0);
class aF extends z {
  constructor(e, t, i) {
    super(), this._themeService = e, this._languageService = t, this._logService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  get(e) {
    return this._caches.has(e) || this._caches.set(e, new C0(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
  }
}
class lF {
  constructor(e, t, i) {
    this.provider = e, this.resultId = t, this.data = i;
  }
  dispose() {
    this.provider.releaseDocumentSemanticTokens(this.resultId);
  }
}
let hu = class So extends z {
  constructor(e, t, i, n, r) {
    super(), this._isDisposed = !1, this._model = e, this._semanticStyling = t, this._provider = r.documentSemanticTokensProvider, this._debounceInformation = n.for(this._provider, "DocumentSemanticTokens", { min: So.REQUEST_MIN_DELAY, max: So.REQUEST_MAX_DELAY }), this._fetchDocumentSemanticTokens = this._register(new oi(() => this._fetchDocumentSemanticTokensNow(), So.REQUEST_MIN_DELAY)), this._currentDocumentResponse = null, this._currentDocumentRequestCancellationTokenSource = null, this._documentProvidersChangeListeners = [], this._register(this._model.onDidChangeContent(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(this._model.onDidChangeLanguage(() => {
      this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const o = () => {
      je(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [];
      for (const a of this._provider.all(e))
        typeof a.onDidChange == "function" && this._documentProvidersChangeListeners.push(a.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));
    };
    o(), this._register(this._provider.onDidChange(() => {
      o(), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(i.onDidColorThemeChange((a) => {
      this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._isDisposed = !0, super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource)
      return;
    if (!gx(this._provider, this._model)) {
      this._currentDocumentResponse && this._model.tokenization.setSemanticTokens(null, !1);
      return;
    }
    const e = new lc(), t = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null, i = this._currentDocumentResponse && this._currentDocumentResponse.resultId || null, n = mx(this._provider, this._model, t, i, e.token);
    this._currentDocumentRequestCancellationTokenSource = e;
    const r = [], o = this._model.onDidChangeContent((l) => {
      r.push(l);
    }), a = new aa(!1);
    n.then((l) => {
      if (this._debounceInformation.update(this._model, a.elapsed()), this._currentDocumentRequestCancellationTokenSource = null, o.dispose(), !l)
        this._setDocumentSemanticTokens(null, null, null, r);
      else {
        const { provider: c, tokens: h } = l, u = this._semanticStyling.get(c);
        this._setDocumentSemanticTokens(c, h || null, u, r);
      }
    }, (l) => {
      l && (ku(l) || typeof l.message == "string" && l.message.indexOf("busy") !== -1) || ct(l), this._currentDocumentRequestCancellationTokenSource = null, o.dispose(), r.length > 0 && (this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model)));
    });
  }
  static _copy(e, t, i, n, r) {
    r = Math.min(r, i.length - n, e.length - t);
    for (let o = 0; o < r; o++)
      i[n + o] = e[t + o];
  }
  _setDocumentSemanticTokens(e, t, i, n) {
    const r = this._currentDocumentResponse, o = () => {
      n.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled() && this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    };
    if (this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._isDisposed) {
      e && t && e.releaseDocumentSemanticTokens(t.resultId);
      return;
    }
    if (!e || !i) {
      this._model.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!t) {
      this._model.tokenization.setSemanticTokens(null, !0), o();
      return;
    }
    if (fx(t)) {
      if (!r) {
        this._model.tokenization.setSemanticTokens(null, !0);
        return;
      }
      if (t.edits.length === 0)
        t = {
          resultId: t.resultId,
          data: r.data
        };
      else {
        let a = 0;
        for (const d of t.edits)
          a += (d.data ? d.data.length : 0) - d.deleteCount;
        const l = r.data, c = new Uint32Array(l.length + a);
        let h = l.length, u = c.length;
        for (let d = t.edits.length - 1; d >= 0; d--) {
          const f = t.edits[d];
          if (f.start > l.length) {
            i.warnInvalidEditStart(r.resultId, t.resultId, d, f.start, l.length), this._model.tokenization.setSemanticTokens(null, !0);
            return;
          }
          const m = h - (f.start + f.deleteCount);
          m > 0 && (So._copy(l, h - m, c, u - m, m), u -= m), f.data && (So._copy(f.data, 0, c, u - f.data.length, f.data.length), u -= f.data.length), h = f.start;
        }
        h > 0 && So._copy(l, 0, c, 0, h), t = {
          resultId: t.resultId,
          data: c
        };
      }
    }
    if (pm(t)) {
      this._currentDocumentResponse = new lF(e, t.resultId, t.data);
      const a = Z6(t, i, this._model.getLanguageId());
      if (n.length > 0)
        for (const l of n)
          for (const c of a)
            for (const h of l.changes)
              c.applyEdit(h.range, h.text);
      this._model.tokenization.setSemanticTokens(a, !0);
    } else
      this._model.tokenization.setSemanticTokens(null, !0);
    o();
  }
};
hu.REQUEST_MIN_DELAY = 300;
hu.REQUEST_MAX_DELAY = 2e3;
hu = VC([
  ii(2, vt),
  ii(3, dm),
  ii(4, De)
], hu);
const cF = new RegExp(`(\\\\)?\\$\\((${Di.iconNameExpression}(?:${Di.iconModifierExpression})?)\\)`, "g");
function kh(s) {
  const e = new Array();
  let t, i = 0, n = 0;
  for (; (t = cF.exec(s)) !== null; ) {
    n = t.index || 0, e.push(s.substring(i, n)), i = (t.index || 0) + t[0].length;
    const [, r, o] = t;
    e.push(r ? `$(${o})` : hF({ id: o }));
  }
  return i < s.length && e.push(s.substring(i)), e;
}
function hF(s) {
  const e = ae("span");
  return e.classList.add(...Di.asClassNameArray(s)), e;
}
const uF = {
  buttonBackground: R.fromHex("#0E639C"),
  buttonHoverBackground: R.fromHex("#006BB3"),
  buttonSeparator: R.white,
  buttonForeground: R.white
};
class Xy extends z {
  constructor(e, t) {
    super(), this._onDidClick = this._register(new A()), this.options = t || /* @__PURE__ */ Object.create(null), sa(this.options, uF, !1), this.buttonForeground = this.options.buttonForeground, this.buttonBackground = this.options.buttonBackground, this.buttonHoverBackground = this.options.buttonHoverBackground, this.buttonSecondaryForeground = this.options.buttonSecondaryForeground, this.buttonSecondaryBackground = this.options.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground, this.buttonBorder = this.options.buttonBorder, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), e.appendChild(this._element), this._register(Ne.addTarget(this._element)), [$.CLICK, We.Tap].forEach((i) => {
      this._register(H(this._element, i, (n) => {
        if (!this.enabled) {
          Oe.stop(n);
          return;
        }
        this._onDidClick.fire(n);
      }));
    }), this._register(H(this._element, $.KEY_DOWN, (i) => {
      const n = new nt(i);
      let r = !1;
      this.enabled && (n.equals(3) || n.equals(10)) ? (this._onDidClick.fire(i), r = !0) : n.equals(9) && (this._element.blur(), r = !0), r && Oe.stop(n, !0);
    })), this._register(H(this._element, $.MOUSE_OVER, (i) => {
      this._element.classList.contains("disabled") || this.setHoverBackground();
    })), this._register(H(this._element, $.MOUSE_OUT, (i) => {
      this.applyStyles();
    })), this.focusTracker = this._register(Hg(this._element)), this._register(this.focusTracker.onDidFocus(() => {
      this.enabled && this.setHoverBackground();
    })), this._register(this.focusTracker.onDidBlur(() => {
      this.enabled && this.applyStyles();
    })), this.applyStyles();
  }
  get onDidClick() {
    return this._onDidClick.event;
  }
  setHoverBackground() {
    let e;
    this.options.secondary ? e = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null : e = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null, e && (this._element.style.backgroundColor = e);
  }
  style(e) {
    this.buttonForeground = e.buttonForeground, this.buttonBackground = e.buttonBackground, this.buttonHoverBackground = e.buttonHoverBackground, this.buttonSecondaryForeground = e.buttonSecondaryForeground, this.buttonSecondaryBackground = e.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = e.buttonSecondaryHoverBackground, this.buttonBorder = e.buttonBorder, this.applyStyles();
  }
  applyStyles() {
    if (this._element) {
      let e, t;
      this.options.secondary ? (t = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : "", e = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : "") : (t = this.buttonForeground ? this.buttonForeground.toString() : "", e = this.buttonBackground ? this.buttonBackground.toString() : "");
      const i = this.buttonBorder ? this.buttonBorder.toString() : "";
      this._element.style.color = t, this._element.style.backgroundColor = e, this._element.style.borderWidth = i ? "1px" : "", this._element.style.borderStyle = i ? "solid" : "", this._element.style.borderColor = i;
    }
  }
  get element() {
    return this._element;
  }
  set label(e) {
    this._element.classList.add("monaco-text-button"), this.options.supportIcons ? zg(this._element, ...kh(e)) : this._element.textContent = e, typeof this.options.title == "string" ? this._element.title = this.options.title : this.options.title && (this._element.title = e);
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
}
const dF = {
  badgeBackground: R.fromHex("#4D4D4D"),
  badgeForeground: R.fromHex("#FFFFFF")
};
class Jy {
  constructor(e, t) {
    this.count = 0, this.options = t || /* @__PURE__ */ Object.create(null), sa(this.options, dF, !1), this.badgeBackground = this.options.badgeBackground, this.badgeForeground = this.options.badgeForeground, this.badgeBorder = this.options.badgeBorder, this.element = Y(e, ae(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    this.element.textContent = e1(this.countFormat, this.count), this.element.title = e1(this.titleFormat, this.count), this.applyStyles();
  }
  style(e) {
    this.badgeBackground = e.badgeBackground, this.badgeForeground = e.badgeForeground, this.badgeBorder = e.badgeBorder, this.applyStyles();
  }
  applyStyles() {
    if (this.element) {
      const e = this.badgeBackground ? this.badgeBackground.toString() : "", t = this.badgeForeground ? this.badgeForeground.toString() : "", i = this.badgeBorder ? this.badgeBorder.toString() : "";
      this.element.style.backgroundColor = e, this.element.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
    }
  }
}
const eL = "done", tL = "active", Kp = "infinite", qp = "infinite-long-running", iL = "discrete", fF = {
  progressBarBackground: R.fromHex("#0E70C0")
};
class _m extends z {
  constructor(e, t) {
    super(), this.options = t || /* @__PURE__ */ Object.create(null), sa(this.options, fF, !1), this.workedVal = 0, this.progressBarBackground = this.options.progressBarBackground, this.showDelayedScheduler = this._register(new oi(() => sD(this.element), 0)), this.longRunningScheduler = this._register(new oi(() => this.infiniteLongRunning(), _m.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e);
  }
  create(e) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.element.appendChild(this.bit), this.applyStyles();
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(tL, Kp, qp, iL), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel();
  }
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(eL), this.element.classList.contains(Kp) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(iL, eL, qp), this.element.classList.add(tL, Kp), this.longRunningScheduler.schedule(), this;
  }
  infiniteLongRunning() {
    this.element.classList.add(qp);
  }
  getContainer() {
    return this.element;
  }
  style(e) {
    this.progressBarBackground = e.progressBarBackground, this.applyStyles();
  }
  applyStyles() {
    if (this.bit) {
      const e = this.progressBarBackground ? this.progressBarBackground.toString() : "";
      this.bit.style.backgroundColor = e;
    }
  }
}
_m.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
class Cx {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
new Cx("id#");
const Gp = {}, gF = new Cx("quick-input-button-icon-");
function w0(s) {
  if (!s)
    return;
  let e;
  const t = s.dark.toString();
  return Gp[t] ? e = Gp[t] : (e = gF.nextId(), Bw(`.${e}, .hc-light .${e}`, `background-image: ${D1(s.light || s.dark)}`), Bw(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${D1(s.dark)}`), Gp[t] = e), e;
}
const mF = { ctrlCmd: !1, alt: !1 };
var uu;
(function(s) {
  s[s.Blur = 1] = "Blur", s[s.Gesture = 2] = "Gesture", s[s.Other = 3] = "Other";
})(uu || (uu = {}));
var Ln;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.FIRST = 1] = "FIRST", s[s.SECOND = 2] = "SECOND", s[s.LAST = 3] = "LAST";
})(Ln || (Ln = {}));
function pF(s, e = {}) {
  const t = vx(e);
  return t.textContent = s, t;
}
function _F(s, e = {}) {
  const t = vx(e);
  return wx(t, CF(s, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
}
function vx(s) {
  const e = s.inline ? "span" : "div", t = document.createElement(e);
  return s.className && (t.className = s.className), t;
}
class bF {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function wx(s, e, t, i) {
  let n;
  if (e.type === 2)
    n = document.createTextNode(e.content || "");
  else if (e.type === 3)
    n = document.createElement("b");
  else if (e.type === 4)
    n = document.createElement("i");
  else if (e.type === 7 && i)
    n = document.createElement("code");
  else if (e.type === 5 && t) {
    const r = document.createElement("a");
    t.disposables.add(pi(r, "click", (o) => {
      t.callback(String(e.index), o);
    })), n = r;
  } else
    e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = s);
  n && s !== n && s.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((r) => {
    wx(n, r, t, i);
  });
}
function CF(s, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, n = t;
  const r = [], o = new bF(s);
  for (; !o.eos(); ) {
    let a = o.next();
    const l = a === "\\" && S0(o.peek(), e) !== 0;
    if (l && (a = o.next()), !l && vF(a, e) && a === o.peek()) {
      o.advance(), n.type === 2 && (n = r.pop());
      const c = S0(a, e);
      if (n.type === c || n.type === 5 && c === 6)
        n = r.pop();
      else {
        const h = {
          type: c,
          children: []
        };
        c === 5 && (h.index = i, i++), n.children.push(h), r.push(n), n = h;
      }
    } else if (a === `
`)
      n.type === 2 && (n = r.pop()), n.children.push({
        type: 8
      });
    else if (n.type !== 2) {
      const c = {
        type: 2,
        content: a
      };
      n.children.push(c), r.push(n), n = c;
    } else
      n.content += a;
  }
  return n.type === 2 && (n = r.pop()), t;
}
function vF(s, e) {
  return S0(s, e) !== 0;
}
function S0(s, e) {
  switch (s) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
const Hc = ae, wF = {
  inputBackground: R.fromHex("#3C3C3C"),
  inputForeground: R.fromHex("#CCCCCC"),
  inputValidationInfoBorder: R.fromHex("#55AAFF"),
  inputValidationInfoBackground: R.fromHex("#063B49"),
  inputValidationWarningBorder: R.fromHex("#B89500"),
  inputValidationWarningBackground: R.fromHex("#352A05"),
  inputValidationErrorBorder: R.fromHex("#BE1100"),
  inputValidationErrorBackground: R.fromHex("#5A1D1D")
};
class SF extends am {
  constructor(e, t, i) {
    var n;
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new A()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i || /* @__PURE__ */ Object.create(null), sa(this.options, wF, !1), this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = (n = this.options.tooltip) !== null && n !== void 0 ? n : this.placeholder || "", this.ariaLabel = this.options.ariaLabel || "", this.inputBackground = this.options.inputBackground, this.inputForeground = this.options.inputForeground, this.inputBorder = this.options.inputBorder, this.inputValidationInfoBorder = this.options.inputValidationInfoBorder, this.inputValidationInfoBackground = this.options.inputValidationInfoBackground, this.inputValidationInfoForeground = this.options.inputValidationInfoForeground, this.inputValidationWarningBorder = this.options.inputValidationWarningBorder, this.inputValidationWarningBackground = this.options.inputValidationWarningBackground, this.inputValidationWarningForeground = this.options.inputValidationWarningForeground, this.inputValidationErrorBorder = this.options.inputValidationErrorBorder, this.inputValidationErrorBackground = this.options.inputValidationErrorBackground, this.inputValidationErrorForeground = this.options.inputValidationErrorForeground, this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = Y(e, Hc(".monaco-inputbox.idle"));
    const r = this.options.flexibleHeight ? "textarea" : "input", o = Y(this.element, Hc(".ibwrapper"));
    if (this.input = Y(o, Hc(r + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = Y(o, Hc("div.mirror")), this.mirror.innerText = "\xA0", this.scrollableElement = new y9(this.element, { vertical: 1 }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), Y(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((c) => this.input.scrollTop = c.scrollTop));
      const a = this._register(new Ve(document, "selectionchange")), l = Q.filter(a.event, () => {
        const c = document.getSelection();
        return (c == null ? void 0 : c.anchorNode) === o;
      });
      this._register(l(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this.ignoreGesture(this.input), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new Yl(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
  }
  onFocus() {
    this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.input.title = e;
  }
  setAriaLabel(e) {
    this.ariaLabel = e, e ? this.input.setAttribute("aria-label", this.ariaLabel) : this.input.removeAttribute("aria-label");
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : L1(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return document.activeElement === this.input;
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  get width() {
    return y1(this.input);
  }
  set width(e) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      let t = 0;
      if (this.mirror) {
        const i = parseFloat(this.mirror.style.paddingLeft || "") || 0, n = parseFloat(this.mirror.style.paddingRight || "") || 0;
        t = i + n;
      }
      this.input.style.width = e - t + "px";
    } else
      this.input.style.width = e + "px";
    this.mirror && (this.mirror.style.width = e + "px");
  }
  set paddingRight(e) {
    this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = i.border ? `1px solid ${i.border}` : "", (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
  }
  stylesForType(e) {
    switch (e) {
      case 1:
        return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };
      case 2:
        return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };
      default:
        return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e;
    const t = () => e.style.width = y1(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (n) => {
        if (!this.message)
          return null;
        e = Y(n, Hc(".monaco-inputbox-container")), t();
        const r = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, o = this.message.formatContent ? _F(this.message.content, r) : pF(this.message.content, r);
        o.classList.add(this.classForType(this.message.type));
        const a = this.stylesForType(this.message.type);
        return o.style.backgroundColor = a.background ? a.background.toString() : "", o.style.color = a.foreground ? a.foreground.toString() : "", o.style.border = a.border ? `1px solid ${a.border}` : "", Y(e, o), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = p("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = p("alertWarningMessage", "Warning: {0}", this.message.content) : i = p("alertInfoMessage", "Info: {0}", this.message.content), Kb(i), this.state = "open";
  }
  _hideMessage() {
    !this.contextViewProvider || (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = "\xA0", this.layout();
  }
  style(e) {
    this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoForeground = e.inputValidationInfoForeground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningForeground = e.inputValidationWarningForeground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorForeground = e.inputValidationErrorForeground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles();
  }
  applyStyles() {
    const e = this.inputBackground ? this.inputBackground.toString() : "", t = this.inputForeground ? this.inputForeground.toString() : "", i = this.inputBorder ? this.inputBorder.toString() : "";
    this.element.style.backgroundColor = e, this.element.style.color = t, this.input.style.backgroundColor = "inherit", this.input.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = L1(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, r = t.value;
    i !== null && n !== null && (this.value = r.substr(0, i) + e + r.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    this._hideMessage(), this.message = null, this.actionbar && this.actionbar.dispose(), super.dispose();
  }
}
const yF = ae;
class LF extends z {
  constructor(e) {
    super(), this.parent = e, this.onKeyDown = (t) => H(this.inputBox.inputElement, $.KEY_DOWN, (i) => {
      t(new nt(i));
    }), this.onMouseDown = (t) => H(this.inputBox.inputElement, $.MOUSE_DOWN, (i) => {
      t(new Gs(i));
    }), this.onDidChange = (t) => this.inputBox.onDidChange(t), this.container = Y(this.parent, yF(".quick-input-box")), this.inputBox = this._register(new SF(this.container, void 0));
  }
  get value() {
    return this.inputBox.value;
  }
  set value(e) {
    this.inputBox.value = e;
  }
  select(e = null) {
    this.inputBox.select(e);
  }
  isSelectionAtEnd() {
    return this.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.inputBox.setPlaceHolder(e);
  }
  get ariaLabel() {
    return this.inputBox.getAriaLabel();
  }
  set ariaLabel(e) {
    this.inputBox.setAriaLabel(e);
  }
  get password() {
    return this.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.inputBox.inputElement.type = e ? "password" : "text";
  }
  setAttribute(e, t) {
    this.inputBox.inputElement.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.inputBox.inputElement.removeAttribute(e);
  }
  showDecoration(e) {
    e === pt.Ignore ? this.inputBox.hideMessage() : this.inputBox.showMessage({ type: e === pt.Info ? 1 : e === pt.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.inputBox.stylesForType(e === pt.Info ? 1 : e === pt.Warning ? 2 : 3);
  }
  setFocus() {
    this.inputBox.focus();
  }
  layout() {
    this.inputBox.layout();
  }
  style(e) {
    this.inputBox.style(e);
  }
}
class ec {
  constructor(e, t) {
    var i;
    this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.supportIcons = (i = t == null ? void 0 : t.supportIcons) !== null && i !== void 0 ? i : !1, this.domNode = Y(e, ae("span.monaco-highlighted-label"));
  }
  get element() {
    return this.domNode;
  }
  set(e, t = [], i = "", n) {
    e || (e = ""), n && (e = ec.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && en(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    const e = [];
    let t = 0;
    for (const i of this.highlights) {
      if (i.end === i.start)
        continue;
      if (t < i.start) {
        const o = this.text.substring(t, i.start);
        e.push(ae("span", void 0, ...this.supportIcons ? kh(o) : [o])), t = i.end;
      }
      const n = this.text.substring(i.start, i.end), r = ae("span.highlight", void 0, ...this.supportIcons ? kh(n) : [n]);
      i.extraClasses && r.classList.add(...i.extraClasses), e.push(r), t = i.end;
    }
    if (t < this.text.length) {
      const i = this.text.substring(t);
      e.push(ae("span", void 0, ...this.supportIcons ? kh(i) : [i]));
    }
    zg(this.domNode, ...e), this.title ? this.domNode.title = this.title : this.domNode.removeAttribute("title"), this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, n = 0;
    return e.replace(/\r\n|\r|\n/g, (r, o) => {
      n = r === `\r
` ? -1 : 0, o += i;
      for (const a of t)
        a.end <= o || (a.start >= o && (a.start += n), a.end >= o && (a.end += n));
      return i += n, "\u23CE";
    });
  }
}
class Zp {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set className(e) {
    this.disposed || e === this._className || (this._className = e, this._element.className = e);
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class nL extends z {
  constructor(e, t) {
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.domNode = this._register(new Zp(Y(e, ae(".monaco-icon-label")))), this.labelContainer = Y(this.domNode.element, ae(".monaco-icon-label-container"));
    const i = Y(this.labelContainer, ae("span.monaco-icon-name-container"));
    this.descriptionContainer = this._register(new Zp(Y(this.labelContainer, ae("span.monaco-icon-description-container")))), (t == null ? void 0 : t.supportHighlights) || (t == null ? void 0 : t.supportIcons) ? this.nameNode = new EF(i, !!t.supportIcons) : this.nameNode = new kF(i), t != null && t.supportDescriptionHighlights ? this.descriptionNodeFactory = () => new ec(Y(this.descriptionContainer.element, ae("span.label-description")), { supportIcons: !!t.supportIcons }) : this.descriptionNodeFactory = () => this._register(new Zp(Y(this.descriptionContainer.element, ae("span.label-description")))), this.hoverDelegate = t == null ? void 0 : t.hoverDelegate;
  }
  get element() {
    return this.domNode.element;
  }
  setLabel(e, t, i) {
    const n = ["monaco-icon-label"];
    i && (i.extraClasses && n.push(...i.extraClasses), i.italic && n.push("italic"), i.strikethrough && n.push("strikethrough")), this.domNode.className = n.join(" "), this.setupHover(i != null && i.descriptionTitle ? this.labelContainer : this.element, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), (t || this.descriptionNode) && (this.descriptionNode || (this.descriptionNode = this.descriptionNodeFactory()), this.descriptionNode instanceof ec ? (this.descriptionNode.set(t || "", i ? i.descriptionMatches : void 0), this.setupHover(this.descriptionNode.element, i == null ? void 0 : i.descriptionTitle)) : (this.descriptionNode.textContent = t || "", this.setupHover(this.descriptionNode.element, (i == null ? void 0 : i.descriptionTitle) || ""), this.descriptionNode.empty = !t));
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (!this.hoverDelegate)
      dO(e, t);
    else {
      const n = WE(this.hoverDelegate, e, t);
      n && this.customHovers.set(e, n);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
}
class kF {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && en(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = Y(this.container, ae("a.label-name", { id: t == null ? void 0 : t.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const n = e[i], r = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
          Y(this.container, ae("a.label-name", { id: r, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, n)), i < e.length - 1 && Y(this.container, ae("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
        }
      }
  }
}
function DF(s, e, t) {
  if (!t)
    return;
  let i = 0;
  return s.map((n) => {
    const r = { start: i, end: i + n.length }, o = t.map((a) => Ht.intersect(r, a)).filter((a) => !Ht.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = r.end + e.length, o;
  });
}
class EF {
  constructor(e, t) {
    this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && en(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = new ec(Y(this.container, ae("a.label-name", { id: t == null ? void 0 : t.domId })), { supportIcons: this.supportIcons })), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = (t == null ? void 0 : t.separator) || "/", n = DF(e, i, t == null ? void 0 : t.matches);
        for (let r = 0; r < e.length; r++) {
          const o = e[r], a = n ? n[r] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${r}`, c = ae("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": r, role: "treeitem" });
          new ec(Y(this.container, c), { supportIcons: this.supportIcons }).set(o, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), r < e.length - 1 && Y(c, ae("span.label-separator", void 0, i));
        }
      }
  }
}
const Pd = ae;
class WC {
  constructor(e, t, i) {
    this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null), this.labelBackground = this.options.keybindingLabelBackground, this.labelForeground = this.options.keybindingLabelForeground, this.labelBorder = this.options.keybindingLabelBorder, this.labelBottomBorder = this.options.keybindingLabelBottomBorder, this.labelShadow = this.options.keybindingLabelShadow, this.domNode = Y(e, Pd(".monaco-keybinding")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && WC.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    if (this.clear(), this.keybinding) {
      const [e, t] = this.keybinding.getParts();
      e && this.renderPart(this.domNode, e, this.matches ? this.matches.firstPart : null), t && (Y(this.domNode, Pd("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderPart(this.domNode, t, this.matches ? this.matches.chordPart : null)), this.domNode.title = this.keybinding.getAriaLabel() || "";
    } else
      this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.applyStyles(), this.didEverRender = !0;
  }
  clear() {
    rn(this.domNode), this.keyElements.clear();
  }
  renderPart(e, t, i) {
    const n = ox.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, n.ctrlKey, Boolean(i == null ? void 0 : i.ctrlKey), n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, Boolean(i == null ? void 0 : i.shiftKey), n.separator), t.altKey && this.renderKey(e, n.altKey, Boolean(i == null ? void 0 : i.altKey), n.separator), t.metaKey && this.renderKey(e, n.metaKey, Boolean(i == null ? void 0 : i.metaKey), n.separator);
    const r = t.keyLabel;
    r && this.renderKey(e, r, Boolean(i == null ? void 0 : i.keyCode), "");
  }
  renderKey(e, t, i, n) {
    Y(e, this.createKeyElement(t, i ? ".highlight" : "")), n && Y(e, Pd("span.monaco-keybinding-key-separator", void 0, n));
  }
  renderUnbound(e) {
    Y(e, this.createKeyElement(p("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = Pd("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), i;
  }
  style(e) {
    this.labelBackground = e.keybindingLabelBackground, this.labelForeground = e.keybindingLabelForeground, this.labelBorder = e.keybindingLabelBorder, this.labelBottomBorder = e.keybindingLabelBottomBorder, this.labelShadow = e.keybindingLabelShadow, this.applyStyles();
  }
  applyStyles() {
    var e;
    if (this.element) {
      for (const t of this.keyElements)
        this.labelBackground && (t.style.backgroundColor = (e = this.labelBackground) === null || e === void 0 ? void 0 : e.toString()), this.labelBorder && (t.style.borderColor = this.labelBorder.toString()), this.labelBottomBorder && (t.style.borderBottomColor = this.labelBottomBorder.toString()), this.labelShadow && (t.style.boxShadow = `inset 0 -1px 0 ${this.labelShadow}`);
      this.labelForeground && (this.element.style.color = this.labelForeground.toString());
    }
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && en(e.firstPart, t.firstPart) && en(e.chordPart, t.chordPart);
  }
}
const sL = new Fg(() => {
  const s = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: s,
    collatorIsNumeric: s.resolvedOptions().numeric
  };
});
new Fg(() => ({
  collator: new Intl.Collator(void 0, { numeric: !0 })
}));
new Fg(() => ({
  collator: new Intl.Collator(void 0, { numeric: !0, sensitivity: "accent" })
}));
function xF(s, e, t = !1) {
  const i = s || "", n = e || "", r = sL.value.collator.compare(i, n);
  return sL.value.collatorIsNumeric && r === 0 && i !== n ? i < n ? -1 : 1 : r;
}
function IF(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), r = NF(s, e, t);
  if (r)
    return r;
  const o = i.endsWith(t), a = n.endsWith(t);
  if (o !== a)
    return o ? -1 : 1;
  const l = xF(i, n);
  return l !== 0 ? l : i.localeCompare(n);
}
function NF(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), r = i.startsWith(t), o = n.startsWith(t);
  if (r !== o)
    return r ? -1 : 1;
  if (r && o) {
    if (i.length < n.length)
      return -1;
    if (i.length > n.length)
      return 1;
  }
  return 0;
}
var Sx = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, TF = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
const qn = ae;
class MF {
  constructor(e) {
    this.hidden = !1, this._onChecked = new A(), this.onChecked = this._onChecked.event, Object.assign(this, e);
  }
  get checked() {
    return !!this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire(e));
  }
  dispose() {
    this._onChecked.dispose();
  }
}
class Vu {
  get templateId() {
    return Vu.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = [], t.toDisposeTemplate = [], t.entry = Y(e, qn(".quick-input-list-entry"));
    const i = Y(t.entry, qn("label.quick-input-list-label"));
    t.toDisposeTemplate.push(pi(i, $.CLICK, (c) => {
      t.checkbox.offsetParent || c.preventDefault();
    })), t.checkbox = Y(i, qn("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox", t.toDisposeTemplate.push(pi(t.checkbox, $.CHANGE, (c) => {
      t.element.checked = t.checkbox.checked;
    }));
    const n = Y(i, qn(".quick-input-list-rows")), r = Y(n, qn(".quick-input-list-row")), o = Y(n, qn(".quick-input-list-row"));
    t.label = new nL(r, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0 });
    const a = Y(r, qn(".quick-input-list-entry-keybinding"));
    t.keybinding = new WC(a, dn);
    const l = Y(o, qn(".quick-input-list-label-meta"));
    return t.detail = new nL(l, { supportHighlights: !0, supportIcons: !0 }), t.separator = Y(t.entry, qn(".quick-input-list-separator")), t.actionBar = new Yl(t.entry), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.push(t.actionBar), t;
  }
  renderElement(e, t, i) {
    i.toDisposeElement = je(i.toDisposeElement), i.element = e, i.checkbox.checked = e.checked, i.toDisposeElement.push(e.onChecked((c) => i.checkbox.checked = c));
    const { labelHighlights: n, descriptionHighlights: r, detailHighlights: o } = e, a = /* @__PURE__ */ Object.create(null);
    a.matches = n || [], a.descriptionTitle = e.saneDescription, a.descriptionMatches = r || [], a.extraClasses = e.item.iconClasses, a.italic = e.item.italic, a.strikethrough = e.item.strikethrough, i.label.setLabel(e.saneLabel, e.saneDescription, a), i.keybinding.set(e.item.keybinding), e.saneDetail && i.detail.setLabel(e.saneDetail, void 0, {
      matches: o,
      title: e.saneDetail
    }), e.separator && e.separator.label ? (i.separator.textContent = e.separator.label, i.separator.style.display = "") : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!e.separator), i.actionBar.clear();
    const l = e.item.buttons;
    l && l.length ? (i.actionBar.push(l.map((c, h) => {
      let u = c.iconClass || (c.iconPath ? w0(c.iconPath) : void 0);
      c.alwaysVisible && (u = u ? `${u} always-visible` : "always-visible");
      const d = new as(`id-${h}`, "", u, !0, () => TF(this, void 0, void 0, function* () {
        e.fireButtonTriggered({
          button: c,
          item: e.item
        });
      }));
      return d.tooltip = c.tooltip || "", d;
    }), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    i.toDisposeElement = je(i.toDisposeElement);
  }
  disposeTemplate(e) {
    e.toDisposeElement = je(e.toDisposeElement), e.toDisposeTemplate = je(e.toDisposeTemplate);
  }
}
Vu.ID = "listelement";
class AF {
  getHeight(e) {
    return e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return Vu.ID;
  }
}
var st;
(function(s) {
  s[s.First = 1] = "First", s[s.Second = 2] = "Second", s[s.Last = 3] = "Last", s[s.Next = 4] = "Next", s[s.Previous = 5] = "Previous", s[s.NextPage = 6] = "NextPage", s[s.PreviousPage = 7] = "PreviousPage";
})(st || (st = {}));
class HC {
  constructor(e, t, i) {
    this.parent = e, this.inputElements = [], this.elements = [], this.elementsToIndexes = /* @__PURE__ */ new Map(), this.matchOnDescription = !1, this.matchOnDetail = !1, this.matchOnLabel = !0, this.matchOnLabelMode = "fuzzy", this.matchOnMeta = !0, this.sortByLabel = !0, this._onChangedAllVisibleChecked = new A(), this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event, this._onChangedCheckedCount = new A(), this.onChangedCheckedCount = this._onChangedCheckedCount.event, this._onChangedVisibleCount = new A(), this.onChangedVisibleCount = this._onChangedVisibleCount.event, this._onChangedCheckedElements = new A(), this.onChangedCheckedElements = this._onChangedCheckedElements.event, this._onButtonTriggered = new A(), this.onButtonTriggered = this._onButtonTriggered.event, this._onKeyDown = new A(), this.onKeyDown = this._onKeyDown.event, this._onLeave = new A(), this.onLeave = this._onLeave.event, this._fireCheckedEvents = !0, this.elementDisposables = [], this.disposables = [], this.id = t, this.container = Y(this.parent, qn(".quick-input-list"));
    const n = new AF(), r = new OF();
    this.list = i.createList("QuickInput", this.container, n, [new Vu()], {
      identityProvider: { getId: (o) => o.saneLabel },
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      horizontalScrolling: !1,
      accessibilityProvider: r
    }), this.list.getHTMLElement().id = t, this.disposables.push(this.list), this.disposables.push(this.list.onKeyDown((o) => {
      const a = new nt(o);
      switch (a.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          (Ie ? o.metaKey : o.ctrlKey) && this.list.setFocus(Jt(this.list.length));
          break;
        case 16: {
          const l = this.list.getFocus();
          l.length === 1 && l[0] === 0 && this._onLeave.fire();
          break;
        }
        case 18: {
          const l = this.list.getFocus();
          l.length === 1 && l[0] === this.list.length - 1 && this._onLeave.fire();
          break;
        }
      }
      this._onKeyDown.fire(a);
    })), this.disposables.push(this.list.onMouseDown((o) => {
      o.browserEvent.button !== 2 && o.browserEvent.preventDefault();
    })), this.disposables.push(H(this.container, $.CLICK, (o) => {
      (o.x || o.y) && this._onLeave.fire();
    })), this.disposables.push(this.list.onMouseMiddleClick((o) => {
      this._onLeave.fire();
    })), this.disposables.push(this.list.onContextMenu((o) => {
      typeof o.index == "number" && (o.browserEvent.preventDefault(), this.list.setSelection([o.index]));
    })), this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return Q.map(this.list.onDidChangeFocus, (e) => e.elements.map((t) => t.item));
  }
  get onDidChangeSelection() {
    return Q.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((t) => t.item), event: e.browserEvent }));
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(e) {
    this.list.scrollTop = e;
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, !1);
  }
  allVisibleChecked(e, t = !0) {
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      if (!r.hidden)
        if (r.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  getCheckedCount() {
    let e = 0;
    const t = this.elements;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].checked && e++;
    return e;
  }
  getVisibleCount() {
    let e = 0;
    const t = this.elements;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].hidden || e++;
    return e;
  }
  setAllVisibleChecked(e) {
    try {
      this._fireCheckedEvents = !1, this.elements.forEach((t) => {
        t.hidden || (t.checked = e);
      });
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  setElements(e) {
    this.elementDisposables = je(this.elementDisposables);
    const t = (i) => this.fireButtonTriggered(i);
    this.inputElements = e, this.elements = e.reduce((i, n, r) => {
      var o, a, l;
      if (n.type !== "separator") {
        const c = r && e[r - 1], h = n.label && n.label.replace(/\r?\n/g, " "), u = Pa(h).text.trim(), d = n.meta && n.meta.replace(/\r?\n/g, " "), f = n.description && n.description.replace(/\r?\n/g, " "), m = n.detail && n.detail.replace(/\r?\n/g, " "), _ = n.ariaLabel || [h, f, m].map((v) => _T(v)).filter((v) => !!v).join(", "), b = this.parent.classList.contains("show-checkboxes");
        i.push(new MF({
          hasCheckbox: b,
          index: r,
          item: n,
          saneLabel: h,
          saneSortLabel: u,
          saneMeta: d,
          saneAriaLabel: _,
          saneDescription: f,
          saneDetail: m,
          labelHighlights: (o = n.highlights) === null || o === void 0 ? void 0 : o.label,
          descriptionHighlights: (a = n.highlights) === null || a === void 0 ? void 0 : a.description,
          detailHighlights: (l = n.highlights) === null || l === void 0 ? void 0 : l.detail,
          checked: !1,
          separator: c && c.type === "separator" ? c : void 0,
          fireButtonTriggered: t
        }));
      }
      return i;
    }, []), this.elementDisposables.push(...this.elements), this.elementDisposables.push(...this.elements.map((i) => i.onChecked(() => this.fireCheckedEvents()))), this.elementsToIndexes = this.elements.reduce((i, n, r) => (i.set(n.item, r), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length), this.list.splice(0, this.list.length, this.elements), this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(e) {
    if (this.list.setFocus(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t))), e.length > 0) {
      const t = this.list.getFocus()[0];
      typeof t == "number" && this.list.reveal(t);
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    this.list.setSelection(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    try {
      this._fireCheckedEvents = !1;
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this.elements)
        i.checked = t.has(i.item);
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  set enabled(e) {
    this.list.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  focus(e) {
    if (!this.list.length)
      return;
    switch (e === st.Next && this.list.getFocus()[0] === this.list.length - 1 && (e = st.First), e === st.Previous && this.list.getFocus()[0] === 0 && (e = st.Last), e === st.Second && this.list.length < 2 && (e = st.First), e) {
      case st.First:
        this.list.focusFirst();
        break;
      case st.Second:
        this.list.focusNth(1);
        break;
      case st.Last:
        this.list.focusLast();
        break;
      case st.Next:
        this.list.focusNext();
        break;
      case st.Previous:
        this.list.focusPrevious();
        break;
      case st.NextPage:
        this.list.focusNextPage();
        break;
      case st.PreviousPage:
        this.list.focusPreviousPage();
        break;
    }
    const t = this.list.getFocus()[0];
    typeof t == "number" && this.list.reveal(t);
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  layout(e) {
    this.list.getHTMLElement().style.maxHeight = e ? `calc(${Math.floor(e / 44) * 44}px)` : "", this.list.layout();
  }
  filter(e) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      return this.list.layout(), !1;
    const t = e;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this.elements.forEach((n) => {
        n.labelHighlights = void 0, n.descriptionHighlights = void 0, n.detailHighlights = void 0, n.hidden = !1;
        const r = n.index && this.inputElements[n.index - 1];
        n.separator = r && r.type === "separator" ? r : void 0;
      });
    else {
      let n;
      this.elements.forEach((r) => {
        let o;
        this.matchOnLabelMode === "fuzzy" ? o = this.matchOnLabel ? Er(kd(e, Pa(r.saneLabel))) : void 0 : o = this.matchOnLabel ? Er(RF(t, Pa(r.saneLabel))) : void 0;
        const a = this.matchOnDescription ? Er(kd(e, Pa(r.saneDescription || ""))) : void 0, l = this.matchOnDetail ? Er(kd(e, Pa(r.saneDetail || ""))) : void 0, c = this.matchOnMeta ? Er(kd(e, Pa(r.saneMeta || ""))) : void 0;
        if (o || a || l || c ? (r.labelHighlights = o, r.descriptionHighlights = a, r.detailHighlights = l, r.hidden = !1) : (r.labelHighlights = void 0, r.descriptionHighlights = void 0, r.detailHighlights = void 0, r.hidden = !r.item.alwaysShow), r.separator = void 0, !this.sortByLabel) {
          const h = r.index && this.inputElements[r.index - 1];
          n = h && h.type === "separator" ? h : n, n && !r.hidden && (r.separator = n, n = void 0);
        }
      });
    }
    const i = this.elements.filter((n) => !n.hidden);
    if (this.sortByLabel && e) {
      const n = e.toLowerCase();
      i.sort((r, o) => PF(r, o, n));
    }
    return this.elementsToIndexes = i.reduce((n, r, o) => (n.set(r.item, o), n), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length, i), this.list.setFocus([]), this.list.layout(), this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedVisibleCount.fire(i.length), !0;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = !1;
      const e = this.list.getFocusedElements(), t = this.allVisibleChecked(e);
      for (const i of e)
        i.checked = !t;
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  display(e) {
    this.container.style.display = e ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = je(this.elementDisposables), this.disposables = je(this.disposables);
  }
  fireCheckedEvents() {
    this._fireCheckedEvents && (this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedCheckedCount.fire(this.getCheckedCount()), this._onChangedCheckedElements.fire(this.getCheckedElements()));
  }
  fireButtonTriggered(e) {
    this._onButtonTriggered.fire(e);
  }
  style(e) {
    this.list.style(e);
  }
}
Sx([
  dt
], HC.prototype, "onDidChangeFocus", null);
Sx([
  dt
], HC.prototype, "onDidChangeSelection", null);
function RF(s, e) {
  const { text: t, iconOffsets: i } = e;
  if (!i || i.length === 0)
    return rL(s, t);
  const n = wb(t, " "), r = t.length - n.length, o = rL(s, n);
  if (o)
    for (const a of o) {
      const l = i[a.start + r] + r;
      a.start += l, a.end += l;
    }
  return o;
}
function rL(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t !== -1 ? [{ start: t, end: t + s.length }] : null;
}
function PF(s, e, t) {
  const i = s.labelHighlights || [], n = e.labelHighlights || [];
  return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : IF(s.saneSortLabel, e.saneSortLabel, t);
}
class OF {
  getWidgetAriaLabel() {
    return p("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    var t;
    return !((t = e.separator) === null || t === void 0) && t.label ? `${e.saneAriaLabel}, ${e.separator.label}` : e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(e) {
    return e.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(e) {
    if (!!e.hasCheckbox)
      return {
        value: e.checked,
        onDidChange: e.onChecked
      };
  }
}
var oL = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
const Ti = ae, y0 = {
  iconClass: g.quickInputBack.classNames,
  tooltip: p("quickInput.back", "Back"),
  handle: -1
};
class bm extends z {
  constructor(e) {
    super(), this.ui = e, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._buttons = [], this.noValidationMessage = bm.noPromptMessage, this._severity = pt.Ignore, this.buttonsUpdated = !1, this.onDidTriggerButtonEmitter = this._register(new A()), this.onDidHideEmitter = this._register(new A()), this.onDisposeEmitter = this._register(new A()), this.visibleDisposables = this._register(new le()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    const t = this._ignoreFocusOut !== e && !Ml;
    this._ignoreFocusOut = e && !Ml, t && this.update();
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(e) {
    this._buttons = e, this.buttonsUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = !0), this.update());
  }
  hide() {
    !this.visible || this.ui.hide();
  }
  didHide(e = uu.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.getTitle();
    e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = "\xA0");
    const t = this.getDescription();
    if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this.busy && !this.busyDelay && (this.busyDelay = new oo(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const n = this.buttons.filter((o) => o === y0);
      this.ui.leftActionBar.push(n.map((o, a) => {
        const l = new as(`id-${a}`, "", o.iconClass || w0(o.iconPath), !0, () => oL(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(o);
        }));
        return l.tooltip = o.tooltip || "", l;
      }), { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const r = this.buttons.filter((o) => o !== y0);
      this.ui.rightActionBar.push(r.map((o, a) => {
        const l = new as(`id-${a}`, "", o.iconClass || w0(o.iconPath), !0, () => oL(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(o);
        }));
        return l.tooltip = o.tooltip || "", l;
      }), { icon: !0, label: !1 });
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const i = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== i && (this._lastValidationMessage = i, zg(this.ui.message, ...kh(i))), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? p("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== pt.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
}
bm.noPromptMessage = p("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
class du extends bm {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new A()), this.onWillAcceptEmitter = this._register(new A()), this.onDidAcceptEmitter = this._register(new A()), this.onDidCustomEmitter = this._register(new A()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._autoFocusOnList = !0, this._keepScrollPosition = !1, this._itemActivation = this.ui.isScreenReaderOptimized() ? Ln.NONE : Ln.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new A()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new A()), this.onDidTriggerItemButtonEmitter = this._register(new A()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this.doSetValue(e);
  }
  doSetValue(e, t) {
    this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(e) {
    this.ui.list.scrollTop = e;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get autoFocusOnList() {
    return this._autoFocusOnList;
  }
  set autoFocusOnList(e) {
    this._autoFocusOnList = e, this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(e) {
    this._keepScrollPosition = e;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? mF : this.ui.keyMods;
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.autoFocusOnList && (this.canSelectMany || this.ui.list.focus(st.First));
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      this.doSetValue(e, !0);
    })), this.visibleDisposables.add(this.ui.inputBox.onMouseDown((e) => {
      this.autoFocusOnList || this.ui.list.clearFocus();
    })), this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((e) => {
      switch (e.keyCode) {
        case 18:
          this.ui.list.focus(st.Next), this.canSelectMany && this.ui.list.domFocus(), Oe.stop(e, !0);
          break;
        case 16:
          this.ui.list.getFocusedElements().length ? this.ui.list.focus(st.Previous) : this.ui.list.focus(st.Last), this.canSelectMany && this.ui.list.domFocus(), Oe.stop(e, !0);
          break;
        case 12:
          this.ui.list.focus(st.NextPage), this.canSelectMany && this.ui.list.domFocus(), Oe.stop(e, !0);
          break;
        case 11:
          this.ui.list.focus(st.PreviousPage), this.canSelectMany && this.ui.list.domFocus(), Oe.stop(e, !0);
          break;
        case 17:
          if (!this._canAcceptInBackground || !this.ui.inputBox.isSelectionAtEnd())
            return;
          this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!0));
          break;
        case 14:
          (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus(st.First), Oe.stop(e, !0));
          break;
        case 13:
          (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus(st.Last), Oe.stop(e, !0));
          break;
      }
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this.ui.list.onDidChangeFocus((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && rs(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && rs(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(t instanceof MouseEvent && t.button === 1));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      !this.canSelectMany || this.selectedItemsToConfirm !== this._selectedItems && rs(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return H(this.ui.container, $.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new nt(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((o) => {
        const [a, l] = o.getParts();
        return l ? !1 : a.shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a.altKey && i === 6 || a.ctrlKey && i === 5 || a.metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this._hideInput && this._items.length > 0;
    this.ui.container.classList.toggle("hidden-input", t && !this.description);
    const i = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !t,
      progressBar: !t,
      visibleCount: !0,
      count: this.canSelectMany,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    let n = this.ariaLabel;
    if (n || (n = this.placeholder || du.DEFAULT_ARIA_LABEL, this.title && (n += ` - ${this.title}`)), this.ui.inputBox.ariaLabel !== n && (this.ui.inputBox.ariaLabel = n), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.matchOnLabelMode = this.matchOnLabelMode, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated)
      switch (this.itemsUpdated = !1, this.ui.list.setElements(this.items), this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked(), this.ui.visibleCount.setCount(this.ui.list.getVisibleCount()), this.ui.count.setCount(this.ui.list.getCheckedCount()), this._itemActivation) {
        case Ln.NONE:
          this._itemActivation = Ln.FIRST;
          break;
        case Ln.SECOND:
          this.ui.list.focus(st.Second), this._itemActivation = Ln.FIRST;
          break;
        case Ln.LAST:
          this.ui.list.focus(st.Last), this._itemActivation = Ln.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", this.ui.setComboboxAccessibility(!0), i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(st.First)), this.keepScrollPosition && (this.scrollTop = e);
  }
}
du.DEFAULT_ARIA_LABEL = p("quickInputBox.ariaLabel", "Type to narrow down results.");
class Cm extends z {
  constructor(e) {
    super(), this.options = e, this.comboboxAccessibility = !1, this.enabled = !0, this.onDidAcceptEmitter = this._register(new A()), this.onDidCustomEmitter = this._register(new A()), this.onDidTriggerButtonEmitter = this._register(new A()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new A()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new A()), this.onHide = this.onHideEmitter.event, this.idPrefix = e.idPrefix, this.parentElement = e.container, this.styles = e.styles, this.registerKeyModsListeners();
  }
  registerKeyModsListeners() {
    const e = (t) => {
      this.keyMods.ctrlCmd = t.ctrlKey || t.metaKey, this.keyMods.alt = t.altKey;
    };
    this._register(H(window, $.KEY_DOWN, e, !0)), this._register(H(window, $.KEY_UP, e, !0)), this._register(H(window, $.MOUSE_DOWN, e, !0));
  }
  getUI() {
    if (this.ui)
      return this.ui;
    const e = Y(this.parentElement, Ti(".quick-input-widget.show-file-icons"));
    e.tabIndex = -1, e.style.display = "none";
    const t = Vn(e), i = Y(e, Ti(".quick-input-titlebar")), n = this._register(new Yl(i));
    n.domNode.classList.add("quick-input-left-action-bar");
    const r = Y(i, Ti(".quick-input-title")), o = this._register(new Yl(i));
    o.domNode.classList.add("quick-input-right-action-bar");
    const a = Y(e, Ti(".quick-input-description")), l = Y(e, Ti(".quick-input-header")), c = Y(l, Ti("input.quick-input-check-all"));
    c.type = "checkbox", c.setAttribute("aria-label", p("quickInput.checkAll", "Toggle all checkboxes")), this._register(pi(c, $.CHANGE, (T) => {
      const M = c.checked;
      y.setAllVisibleChecked(M);
    })), this._register(H(c, $.CLICK, (T) => {
      (T.x || T.y) && f.setFocus();
    }));
    const h = Y(l, Ti(".quick-input-description")), u = Y(l, Ti(".quick-input-and-message")), d = Y(u, Ti(".quick-input-filter")), f = this._register(new LF(d));
    f.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const m = Y(d, Ti(".quick-input-visible-count"));
    m.setAttribute("aria-live", "polite"), m.setAttribute("aria-atomic", "true");
    const _ = new Jy(m, { countFormat: p({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }), b = Y(d, Ti(".quick-input-count"));
    b.setAttribute("aria-live", "polite");
    const v = new Jy(b, { countFormat: p({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }), C = Y(l, Ti(".quick-input-action")), w = new Xy(C);
    w.label = p("ok", "OK"), this._register(w.onDidClick((T) => {
      this.onDidAcceptEmitter.fire();
    }));
    const L = Y(l, Ti(".quick-input-action")), E = new Xy(L);
    E.label = p("custom", "Custom"), this._register(E.onDidClick((T) => {
      this.onDidCustomEmitter.fire();
    }));
    const k = Y(u, Ti(`#${this.idPrefix}message.quick-input-message`)), y = this._register(new HC(e, this.idPrefix + "list", this.options));
    this._register(y.onChangedAllVisibleChecked((T) => {
      c.checked = T;
    })), this._register(y.onChangedVisibleCount((T) => {
      _.setCount(T);
    })), this._register(y.onChangedCheckedCount((T) => {
      v.setCount(T);
    })), this._register(y.onLeave(() => {
      setTimeout(() => {
        f.setFocus(), this.controller instanceof du && this.controller.canSelectMany && y.clearFocus();
      }, 0);
    })), this._register(y.onDidChangeFocus(() => {
      this.comboboxAccessibility && this.getUI().inputBox.setAttribute("aria-activedescendant", this.getUI().list.getActiveDescendant() || "");
    }));
    const S = new _m(e);
    S.getContainer().classList.add("quick-input-progress");
    const D = Hg(e);
    return this._register(D), this._register(H(e, $.FOCUS, (T) => {
      this.previousFocusElement = T.relatedTarget instanceof HTMLElement ? T.relatedTarget : void 0;
    }, !0)), this._register(D.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(uu.Blur), this.previousFocusElement = void 0;
    })), this._register(H(e, $.FOCUS, (T) => {
      f.setFocus();
    })), this._register(H(e, $.KEY_DOWN, (T) => {
      const M = new nt(T);
      switch (M.keyCode) {
        case 3:
          Oe.stop(T, !0), this.onDidAcceptEmitter.fire();
          break;
        case 9:
          Oe.stop(T, !0), this.hide(uu.Gesture);
          break;
        case 2:
          if (!M.altKey && !M.ctrlKey && !M.metaKey) {
            const P = [".action-label.codicon"];
            e.classList.contains("show-checkboxes") ? P.push("input") : P.push("input[type=text]"), this.getUI().list.isDisplayed() && P.push(".monaco-list");
            const V = e.querySelectorAll(P.join(", "));
            M.shiftKey && M.target === V[0] ? (Oe.stop(T, !0), V[V.length - 1].focus()) : !M.shiftKey && M.target === V[V.length - 1] && (Oe.stop(T, !0), V[0].focus());
          }
          break;
      }
    })), this.ui = {
      container: e,
      styleSheet: t,
      leftActionBar: n,
      titleBar: i,
      title: r,
      description1: a,
      description2: h,
      rightActionBar: o,
      checkAll: c,
      filterContainer: d,
      inputBox: f,
      visibleCountContainer: m,
      visibleCount: _,
      countContainer: b,
      count: v,
      okContainer: C,
      ok: w,
      message: k,
      customButtonContainer: L,
      customButton: E,
      list: y,
      progressBar: S,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),
      show: (T) => this.show(T),
      hide: () => this.hide(),
      setVisibilities: (T) => this.setVisibilities(T),
      setComboboxAccessibility: (T) => this.setComboboxAccessibility(T),
      setEnabled: (T) => this.setEnabled(T),
      setContextKey: (T) => this.options.setContextKey(T)
    }, this.updateStyles(), this.ui;
  }
  pick(e, t = {}, i = Ii.None) {
    return new Promise((n, r) => {
      let o = (h) => {
        var u;
        o = n, (u = t.onKeyMods) === null || u === void 0 || u.call(t, a.keyMods), n(h);
      };
      if (i.isCancellationRequested) {
        o(void 0);
        return;
      }
      const a = this.createQuickPick();
      let l;
      const c = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            o(a.selectedItems.slice()), a.hide();
          else {
            const h = a.activeItems[0];
            h && (o(h), a.hide());
          }
        }),
        a.onDidChangeActive((h) => {
          const u = h[0];
          u && t.onDidFocus && t.onDidFocus(u);
        }),
        a.onDidChangeSelection((h) => {
          if (!a.canSelectMany) {
            const u = h[0];
            u && (o(u), a.hide());
          }
        }),
        a.onDidTriggerItemButton((h) => t.onDidTriggerItemButton && t.onDidTriggerItemButton(Object.assign(Object.assign({}, h), { removeItem: () => {
          const u = a.items.indexOf(h.item);
          if (u !== -1) {
            const d = a.items.slice(), f = d.splice(u, 1), m = a.activeItems.filter((b) => b !== f[0]), _ = a.keepScrollPosition;
            a.keepScrollPosition = !0, a.items = d, m && (a.activeItems = m), a.keepScrollPosition = _;
          }
        } }))),
        a.onDidChangeValue((h) => {
          l && !h && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          je(c), o(void 0);
        })
      ];
      a.title = t.title, a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.autoFocusOnList = t.autoFocusOnList === void 0 || t.autoFocusOnList, a.quickNavigate = t.quickNavigate, a.hideInput = !!t.hideInput, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([h, u]) => {
        l = u, a.busy = !1, a.items = h, a.canSelectMany && (a.selectedItems = h.filter((d) => d.type !== "separator" && d.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (h) => {
        r(h), a.hide();
      });
    });
  }
  createQuickPick() {
    const e = this.getUI();
    return new du(e);
  }
  show(e) {
    const t = this.getUI();
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i && i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", t.rightActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(pt.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), zg(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, this.setComboboxAccessibility(!1), t.inputBox.ariaLabel = "";
    const n = this.options.backKeybindingLabel();
    y0.tooltip = n ? p("quickInput.backWithKeybinding", "Back ({0})", n) : p("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus();
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.display(!!e.list), t.container.classList[e.checkBox ? "add" : "remove"]("show-checkboxes"), this.updateLayout();
  }
  setComboboxAccessibility(e) {
    if (e !== this.comboboxAccessibility) {
      const t = this.getUI();
      this.comboboxAccessibility = e, this.comboboxAccessibility ? (t.inputBox.setAttribute("role", "combobox"), t.inputBox.setAttribute("aria-haspopup", "true"), t.inputBox.setAttribute("aria-autocomplete", "list"), t.inputBox.setAttribute("aria-activedescendant", t.list.getActiveDescendant() || "")) : (t.inputBox.removeAttribute("role"), t.inputBox.removeAttribute("aria-haspopup"), t.inputBox.removeAttribute("aria-autocomplete"), t.inputBox.removeAttribute("aria-activedescendant"));
    }
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.getAction().enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.getAction().enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    var t;
    const i = this.controller;
    if (i) {
      const n = !(!((t = this.ui) === null || t === void 0) && t.container.contains(document.activeElement));
      if (this.controller = null, this.onHideEmitter.fire(), this.getUI().container.style.display = "none", !n) {
        let r = this.previousFocusElement;
        for (; r && !r.offsetParent; )
          r = Er(r.parentElement);
        r != null && r.offsetParent ? (r.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
      }
      i.didHide(e);
    }
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, Cm.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, contrastBorder: n, widgetShadow: r } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ? e.toString() : "", this.ui.container.style.backgroundColor = t ? t.toString() : "", this.ui.container.style.color = i ? i.toString() : "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = r ? `0 0 8px 2px ${r}` : "", this.ui.inputBox.style(this.styles.inputBox), this.ui.count.style(this.styles.countBadge), this.ui.ok.style(this.styles.button), this.ui.customButton.style(this.styles.button), this.ui.progressBar.style(this.styles.progressBar), this.ui.list.style(this.styles.list);
      const o = [];
      this.styles.list.pickerGroupBorder && o.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`), this.styles.list.pickerGroupForeground && o.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (o.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && o.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && o.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && o.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && o.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && o.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), o.push("}"));
      const a = o.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
}
Cm.MAX_WIDTH = 600;
class FF {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((n) => n.splice(e, t, i));
  }
}
class Oa extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
function aL(s, e) {
  const t = [];
  for (const i of e) {
    if (s.start >= i.range.end)
      continue;
    if (s.end < i.range.start)
      break;
    const n = Ht.intersect(s, i.range);
    Ht.isEmpty(n) || t.push({
      range: n,
      size: i.size
    });
  }
  return t;
}
function L0({ start: s, end: e }, t) {
  return { start: s + t, end: e + t };
}
function BF(s) {
  const e = [];
  let t = null;
  for (const i of s) {
    const n = i.range.start, r = i.range.end, o = i.size;
    if (t && o === t.size) {
      t.range.end = r;
      continue;
    }
    t = { range: { start: n, end: r }, size: o }, e.push(t);
  }
  return e;
}
function VF(...s) {
  return BF(s.reduce((e, t) => e.concat(t), []));
}
class lL {
  constructor() {
    this.groups = [], this._size = 0;
  }
  splice(e, t, i = []) {
    const n = i.length - t, r = aL({ start: 0, end: e }, this.groups), o = aL({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: L0(l.range, n), size: l.size })), a = i.map((l, c) => ({
      range: { start: e + c, end: e + c + 1 },
      size: l.size
    }));
    this.groups = VF(r, a, o), this._size = this.groups.reduce((l, c) => l + c.size * (c.range.end - c.range.start), 0);
  }
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  get size() {
    return this._size;
  }
  indexAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (const n of this.groups) {
      const r = n.range.end - n.range.start, o = i + r * n.size;
      if (e < o)
        return t + Math.floor((e - i) / n.size);
      t += r, i = o;
    }
    return t;
  }
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (const n of this.groups) {
      const r = n.range.end - n.range.start, o = i + r;
      if (e < o)
        return t + (e - i) * n.size;
      t += r * n.size, i = o;
    }
    return -1;
  }
}
function WF(s) {
  var e;
  try {
    (e = s.parentElement) === null || e === void 0 || e.removeChild(s);
  } catch {
  }
}
class HF {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map();
  }
  alloc(e) {
    let t = this.getTemplateCache(e).pop();
    if (!t) {
      const i = ae(".monaco-list-row"), r = this.getRenderer(e).renderTemplate(i);
      t = { domNode: i, templateId: e, templateData: r };
    }
    return t;
  }
  release(e) {
    !e || this.releaseRow(e);
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (t.classList.remove("scrolling"), WF(t)), this.getTemplateCache(i).push(e);
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var ho = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
};
const jn = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(s) {
      return [s];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class Wu {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class zF {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class UF {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function $F(s, e) {
  return Array.isArray(s) && Array.isArray(e) ? rs(s, e) : s === e;
}
class jF {
  constructor(e) {
    e != null && e.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, e != null && e.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e != null && e.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e != null && e.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
class bn {
  constructor(e, t, i, n = jn) {
    var r, o, a, l, c, h, u, d, f, m;
    if (this.virtualDelegate = t, this.domId = `list_id_${++bn.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new Og(50), this.splicing = !1, this.dragOverAnimationStopDisposable = z.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = z.None, this.onDragLeaveTimeout = z.None, this.disposables = new le(), this._onDidChangeContentHeight = new A(), this._horizontalScrolling = !1, n.horizontalScrolling && n.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = new lL();
    for (const b of i)
      this.renderers.set(b.templateId, b);
    this.cache = this.disposables.add(new HF(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : !0), this._horizontalScrolling = (r = n.horizontalScrolling) !== null && r !== void 0 ? r : jn.horizontalScrolling, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.additionalScrollHeight = typeof n.additionalScrollHeight > "u" ? 0 : n.additionalScrollHeight, this.accessibilityProvider = new jF(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", ((o = n.transformOptimization) !== null && o !== void 0 ? o : jn.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)"), this.disposables.add(Ne.addTarget(this.rowsContainer)), this.scrollable = new Fu({
      forceIntegerValues: !0,
      smoothScrollDuration: (a = n.smoothScrolling) !== null && a !== void 0 && a ? 125 : 0,
      scheduleAtNextAnimationFrame: (b) => Bn(b)
    }), this.scrollableElement = this.disposables.add(new iC(this.rowsContainer, {
      alwaysConsumeMouseWheel: (l = n.alwaysConsumeMouseWheel) !== null && l !== void 0 ? l : jn.alwaysConsumeMouseWheel,
      horizontal: 1,
      vertical: (c = n.verticalScrollMode) !== null && c !== void 0 ? c : jn.verticalScrollMode,
      useShadows: (h = n.useShadows) !== null && h !== void 0 ? h : jn.useShadows,
      mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
      fastScrollSensitivity: n.fastScrollSensitivity
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add(H(this.rowsContainer, We.Change, (b) => this.onTouchChange(b))), this.disposables.add(H(this.scrollableElement.getDomNode(), "scroll", (b) => b.target.scrollTop = 0)), this.disposables.add(H(this.domNode, "dragover", (b) => this.onDragOver(this.toDragEvent(b)))), this.disposables.add(H(this.domNode, "drop", (b) => this.onDrop(this.toDragEvent(b)))), this.disposables.add(H(this.domNode, "dragleave", (b) => this.onDragLeave(this.toDragEvent(b)))), this.disposables.add(H(this.domNode, "dragend", (b) => this.onDragEnd(b))), this.setRowLineHeight = (u = n.setRowLineHeight) !== null && u !== void 0 ? u : jn.setRowLineHeight, this.setRowHeight = (d = n.setRowHeight) !== null && d !== void 0 ? d : jn.setRowHeight, this.supportDynamicHeights = (f = n.supportDynamicHeights) !== null && f !== void 0 ? f : jn.supportDynamicHeights, this.dnd = (m = n.dnd) !== null && m !== void 0 ? m : jn.dnd, this.layout();
  }
  get contentHeight() {
    return this.rangeMap.size;
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: cp(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  updateOptions(e) {
    e.additionalScrollHeight !== void 0 && (this.additionalScrollHeight = e.additionalScrollHeight, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling), e.mouseWheelScrollSensitivity !== void 0 && this.scrollableElement.updateOptions({ mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity }), e.fastScrollSensitivity !== void 0 && this.scrollableElement.updateOptions({ fastScrollSensitivity: e.fastScrollSensitivity });
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), r = { start: e, end: e + t }, o = Ht.intersect(n, r), a = /* @__PURE__ */ new Map();
    for (let k = o.end - 1; k >= o.start; k--) {
      const y = this.items[k];
      if (y.dragStartDisposable.dispose(), y.checkedDisposable.dispose(), y.row) {
        let S = a.get(y.templateId);
        S || (S = [], a.set(y.templateId, S));
        const D = this.renderers.get(y.templateId);
        D && D.disposeElement && D.disposeElement(y.element, k, y.row.templateData, y.size), S.push(y.row);
      }
      y.row = null;
    }
    const l = { start: e + t, end: this.items.length }, c = Ht.intersect(l, n), h = Ht.relativeComplement(l, n), u = i.map((k) => ({
      id: String(this.itemId++),
      element: k,
      templateId: this.virtualDelegate.getTemplateId(k),
      size: this.virtualDelegate.getHeight(k),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(k),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: z.None,
      checkedDisposable: z.None
    }));
    let d;
    e === 0 && t >= this.items.length ? (this.rangeMap = new lL(), this.rangeMap.splice(0, 0, u), d = this.items, this.items = u) : (this.rangeMap.splice(e, t, u), d = this.items.splice(e, t, ...u));
    const f = i.length - t, m = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), _ = L0(c, f), b = Ht.intersect(m, _);
    for (let k = b.start; k < b.end; k++)
      this.updateItemInDOM(this.items[k], k);
    const v = Ht.relativeComplement(_, m);
    for (const k of v)
      for (let y = k.start; y < k.end; y++)
        this.removeItemFromDOM(y);
    const C = h.map((k) => L0(k, f)), L = [{ start: e, end: e + i.length }, ...C].map((k) => Ht.intersect(m, k)), E = this.getNextToLastElement(L);
    for (const k of L)
      for (let y = k.start; y < k.end; y++) {
        const S = this.items[y], D = a.get(S.templateId), T = D == null ? void 0 : D.pop();
        this.insertItemInDOM(y, E, T);
      }
    for (const k of a.values())
      for (const y of k)
        this.cache.release(y);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), d.map((k) => k.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = Bn(() => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 });
  }
  rerender() {
    if (!!this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  element(e) {
    return this.items[e].element;
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    const i = {
      height: typeof e == "number" ? e : zM(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : cp(this.domNode)
    });
  }
  render(e, t, i, n, r, o = !1) {
    const a = this.getRenderRange(t, i), l = Ht.relativeComplement(a, e), c = Ht.relativeComplement(e, a), h = this.getNextToLastElement(l);
    if (o) {
      const u = Ht.intersect(e, a);
      for (let d = u.start; d < u.end; d++)
        this.updateItemInDOM(this.items[d], d);
    }
    for (const u of l)
      for (let d = u.start; d < u.end; d++)
        this.insertItemInDOM(d, h);
    for (const u of c)
      for (let d = u.start; d < u.end; d++)
        this.removeItemFromDOM(d);
    n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && r !== void 0 && (this.rowsContainer.style.width = `${Math.max(r, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  insertItemInDOM(e, t, i) {
    const n = this.items[e];
    n.row || (n.row = i != null ? i : this.cache.alloc(n.templateId));
    const r = this.accessibilityProvider.getRole(n.element) || "listitem";
    n.row.domNode.setAttribute("role", r);
    const o = this.accessibilityProvider.isChecked(n.element);
    if (typeof o == "boolean")
      n.row.domNode.setAttribute("aria-checked", String(!!o));
    else if (o) {
      const c = (h) => n.row.domNode.setAttribute("aria-checked", String(!!h));
      c(o.value), n.checkedDisposable = o.onDidChange(c);
    }
    n.row.domNode.parentElement || (t ? this.rowsContainer.insertBefore(n.row.domNode, t) : this.rowsContainer.appendChild(n.row.domNode)), this.updateItemInDOM(n, e);
    const a = this.renderers.get(n.templateId);
    if (!a)
      throw new Error(`No renderer found for template id ${n.templateId}`);
    a == null || a.renderElement(n.element, e, n.row.templateData, n.size);
    const l = this.dnd.getDragURI(n.element);
    n.dragStartDisposable.dispose(), n.row.domNode.draggable = !!l, l && (n.dragStartDisposable = H(n.row.domNode, "dragstart", (c) => this.onDragStart(n.element, l, c))), this.horizontalScrolling && (this.measureItemWidth(n), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = sn ? "-moz-fit-content" : "fit-content", e.width = cp(e.row.domNode);
    const t = window.getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;
  }
  get onMouseClick() {
    return Q.map(this.disposables.add(new Ve(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseDblClick() {
    return Q.map(this.disposables.add(new Ve(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseMiddleClick() {
    return Q.filter(Q.map(this.disposables.add(new Ve(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
  }
  get onMouseDown() {
    return Q.map(this.disposables.add(new Ve(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOver() {
    return Q.map(this.disposables.add(new Ve(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onContextMenu() {
    return Q.any(Q.map(this.disposables.add(new Ve(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), Q.map(this.disposables.add(new Ve(this.domNode, We.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
  }
  get onTouchStart() {
    return Q.map(this.disposables.add(new Ve(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
  }
  get onTap() {
    return Q.map(this.disposables.add(new Ve(this.rowsContainer, We.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  onDragStart(e, t, i) {
    var n, r;
    if (!i.dataTransfer)
      return;
    const o = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(IE.TEXT, t), i.dataTransfer.setDragImage) {
      let a;
      this.dnd.getDragLabel && (a = this.dnd.getDragLabel(o, i)), typeof a > "u" && (a = String(o.length));
      const l = ae(".monaco-drag-image");
      l.textContent = a, document.body.appendChild(l), i.dataTransfer.setDragImage(l, -10, -10), setTimeout(() => document.body.removeChild(l), 0);
    }
    this.currentDragData = new Wu(o), bo.CurrentDragAndDropData = new zF(o), (r = (n = this.dnd).onDragStart) === null || r === void 0 || r.call(n, this.currentDragData, i);
  }
  onDragOver(e) {
    var t;
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), bo.CurrentDragAndDropData && bo.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (bo.CurrentDragAndDropData)
        this.currentDragData = bo.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new UF();
      }
    const i = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.browserEvent);
    if (this.canDrop = typeof i == "boolean" ? i : i.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof i != "boolean" && i.effect === 0 ? "copy" : "move";
    let n;
    if (typeof i != "boolean" && i.feedback ? n = i.feedback : typeof e.index > "u" ? n = [-1] : n = [e.index], n = Xr(n).filter((r) => r >= -1 && r < this.length).sort((r, o) => r - o), n = n[0] === -1 ? [-1] : n, $F(this.currentDragFeedback, n))
      return !0;
    if (this.currentDragFeedback = n, this.currentDragFeedbackDisposable.dispose(), n[0] === -1)
      this.domNode.classList.add("drop-target"), this.rowsContainer.classList.add("drop-target"), this.currentDragFeedbackDisposable = ze(() => {
        this.domNode.classList.remove("drop-target"), this.rowsContainer.classList.remove("drop-target");
      });
    else {
      for (const r of n) {
        const o = this.items[r];
        o.dropTarget = !0, (t = o.row) === null || t === void 0 || t.domNode.classList.add("drop-target");
      }
      this.currentDragFeedbackDisposable = ze(() => {
        var r;
        for (const o of n) {
          const a = this.items[o];
          a.dropTarget = !1, (r = a.row) === null || r === void 0 || r.domNode.classList.remove("drop-target");
        }
      });
    }
    return !0;
  }
  onDragLeave(e) {
    var t, i;
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = d1(() => this.clearDragOverFeedback(), 100), this.currentDragData && ((i = (t = this.dnd).onDragLeave) === null || i === void 0 || i.call(t, this.currentDragData, e.element, e.index, e.browserEvent));
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, bo.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.browserEvent));
  }
  onDragEnd(e) {
    var t, i;
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, bo.CurrentDragAndDropData = void 0, (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = z.None;
  }
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = WM(this.domNode).top;
      this.dragOverAnimationDisposable = GM(this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = d1(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; i instanceof HTMLElement && i !== this.rowsContainer && t.contains(i); ) {
      const n = i.getAttribute("data-index");
      if (n) {
        const r = Number(n);
        if (!isNaN(r))
          return r;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  _rerender(e, t, i) {
    const n = this.getRenderRange(e, t);
    let r, o;
    e === this.elementTop(n.start) ? (r = n.start, o = 0) : n.end - n.start > 1 && (r = n.start + 1, o = this.elementTop(r) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let c = !1;
      for (let h = l.start; h < l.end; h++) {
        const u = this.probeDynamicHeight(h);
        u !== 0 && this.rangeMap.splice(h, 1, [this.items[h]]), a += u, c = c || u !== 0;
      }
      if (!c) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const h = Ht.relativeComplement(n, l);
        for (const d of h)
          for (let f = d.start; f < d.end; f++)
            this.items[f].row && this.removeItemFromDOM(f);
        const u = Ht.relativeComplement(l, n);
        for (const d of u)
          for (let f = d.start; f < d.end; f++) {
            const m = f + 1, _ = m < this.items.length ? this.items[m].row : null, b = _ ? _.domNode : null;
            this.insertItemInDOM(f, b);
          }
        for (let d = l.start; d < l.end; d++)
          this.items[d].row && this.updateItemInDOM(this.items[d], d);
        if (typeof r == "number") {
          const d = this.scrollable.getFutureScrollPosition().scrollTop - e, f = this.elementTop(r) - o + d;
          this.setScrollTop(f, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    var t, i, n;
    const r = this.items[e];
    if (this.virtualDelegate.getDynamicHeight) {
      const c = this.virtualDelegate.getDynamicHeight(r.element);
      if (c !== null) {
        const h = r.size;
        return r.size = c, r.lastDynamicHeightWidth = this.renderWidth, c - h;
      }
    }
    if (!r.hasDynamicHeight || r.lastDynamicHeightWidth === this.renderWidth || !!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(r.element))
      return 0;
    const o = r.size;
    if (!this.setRowHeight && r.row) {
      const c = r.row.domNode.offsetHeight;
      return r.size = c, r.lastDynamicHeightWidth = this.renderWidth, c - o;
    }
    const a = this.cache.alloc(r.templateId);
    a.domNode.style.height = "", this.rowsContainer.appendChild(a.domNode);
    const l = this.renderers.get(r.templateId);
    return l && (l.renderElement(r.element, e, a.templateData, void 0), (t = l.disposeElement) === null || t === void 0 || t.call(l, r.element, e, a.templateData, void 0)), r.size = a.domNode.offsetHeight, (n = (i = this.virtualDelegate).setDynamicHeight) === null || n === void 0 || n.call(i, r.element, r.size), r.lastDynamicHeightWidth = this.renderWidth, this.rowsContainer.removeChild(a.domNode), this.cache.release(a), r.size - o;
  }
  getNextToLastElement(e) {
    const t = e[e.length - 1];
    if (!t)
      return null;
    const i = this.items[t.end];
    return !i || !i.row ? null : i.row.domNode;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  dispose() {
    var e;
    if (this.items) {
      for (const t of this.items)
        if (t.row) {
          const i = this.renderers.get(t.row.templateId);
          i && ((e = i.disposeElement) === null || e === void 0 || e.call(i, t.element, -1, t.row.templateData, void 0), i.disposeTemplate(t.row.templateData));
        }
      this.items = [];
    }
    this.domNode && this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), je(this.disposables);
  }
}
bn.InstanceCount = 0;
ho([
  dt
], bn.prototype, "onMouseClick", null);
ho([
  dt
], bn.prototype, "onMouseDblClick", null);
ho([
  dt
], bn.prototype, "onMouseMiddleClick", null);
ho([
  dt
], bn.prototype, "onMouseDown", null);
ho([
  dt
], bn.prototype, "onMouseOver", null);
ho([
  dt
], bn.prototype, "onContextMenu", null);
ho([
  dt
], bn.prototype, "onTouchStart", null);
ho([
  dt
], bn.prototype, "onTap", null);
var ma = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, cL = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class KF {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.name}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const n = this.renderedElements.findIndex((r) => r.templateData === i);
    if (n >= 0) {
      const r = this.renderedElements[n];
      this.trait.unrender(i), r.index = t;
    } else {
      const r = { index: t, templateData: i };
      this.renderedElements.push(r);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const n = [];
    for (const r of this.renderedElements)
      r.index < e ? n.push(r) : r.index >= e + t && n.push({
        index: r.index + i - t,
        templateData: r.templateData
      });
    this.renderedElements = n;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
class hg {
  constructor(e) {
    this._trait = e, this.length = 0, this.indexes = [], this.sortedIndexes = [], this._onChange = new A(), this.onChange = this._onChange.event;
  }
  get name() {
    return this._trait;
  }
  get renderer() {
    return new KF(this);
  }
  splice(e, t, i) {
    var n;
    t = Math.max(0, Math.min(t, this.length - e));
    const r = i.length - t, o = e + t, a = [
      ...this.sortedIndexes.filter((c) => c < e),
      ...i.map((c, h) => c ? h + e : -1).filter((c) => c !== -1),
      ...this.sortedIndexes.filter((c) => c >= o).map((c) => c + r)
    ], l = this.length + r;
    if (this.sortedIndexes.length > 0 && a.length === 0 && l > 0) {
      const c = (n = this.sortedIndexes.find((h) => h >= e)) !== null && n !== void 0 ? n : l - 1;
      a.push(Math.min(c, l - 1));
    }
    this.renderer.splice(e, t, i.length), this._set(a, a), this.length = l;
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  set(e, t) {
    return this._set(e, [...e].sort(uL), t);
  }
  _set(e, t, i) {
    const n = this.indexes, r = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const o = k0(r, e);
    return this.renderer.renderIndexes(o), this._onChange.fire({ indexes: e, browserEvent: i }), n;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return FI(this.sortedIndexes, e, uL) >= 0;
  }
  dispose() {
    je(this._onChange);
  }
}
ma([
  dt
], hg.prototype, "renderer", null);
class qF extends hg {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class Yp {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, i.map(() => !1));
    const n = this.trait.get().map((o) => this.identityProvider.getId(this.view.element(o)).toString()), r = i.map((o) => n.indexOf(this.identityProvider.getId(o).toString()) > -1);
    this.trait.splice(e, t, r);
  }
}
function ia(s) {
  return s.tagName === "INPUT" || s.tagName === "TEXTAREA";
}
function ol(s) {
  return s.classList.contains("monaco-editor") ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : ol(s.parentElement);
}
function yx(s) {
  return s.tagName === "A" && s.classList.contains("monaco-button") || s.tagName === "DIV" && s.classList.contains("monaco-button-dropdown") ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : yx(s.parentElement);
}
class Lx {
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new le(), this.multipleSelectionDisposables = new le(), this.onKeyDown.filter((n) => n.keyCode === 3).on(this.onEnter, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 16).on(this.onUpArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 18).on(this.onDownArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 11).on(this.onPageUpArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 12).on(this.onPageDownArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 9).on(this.onEscape, this, this.disposables), i.multipleSelectionSupport !== !1 && this.onKeyDown.filter((n) => (Ie ? n.metaKey : n.ctrlKey) && n.keyCode === 31).on(this.onCtrlA, this, this.multipleSelectionDisposables);
  }
  get onKeyDown() {
    return this.disposables.add(Q.chain(this.disposables.add(new Ve(this.view.domNode, "keydown")).event).filter((e) => !ia(e.target)).map((e) => new nt(e)));
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionDisposables.clear(), e.multipleSelectionSupport && this.onKeyDown.filter((t) => (Ie ? t.metaKey : t.ctrlKey) && t.keyCode === 31).on(this.onCtrlA, this, this.multipleSelectionDisposables));
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(Jt(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
  }
}
ma([
  dt
], Lx.prototype, "onKeyDown", null);
var Qr;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Trigger = 1] = "Trigger";
})(Qr || (Qr = {}));
var al;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Typing = 1] = "Typing";
})(al || (al = {}));
const GF = new class {
  mightProducePrintableCharacter(s) {
    return s.ctrlKey || s.metaKey || s.altKey ? !1 : s.keyCode >= 31 && s.keyCode <= 56 || s.keyCode >= 21 && s.keyCode <= 30 || s.keyCode >= 93 && s.keyCode <= 102 || s.keyCode >= 80 && s.keyCode <= 90;
  }
}();
class ZF {
  constructor(e, t, i, n, r) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.keyboardNavigationEventFilter = n, this.delegate = r, this.enabled = !1, this.state = al.Idle, this.mode = Qr.Automatic, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new le(), this.disposables = new le(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    var t, i;
    !((t = e.typeNavigationEnabled) !== null && t !== void 0) || t ? this.enable() : this.disable(), this.mode = (i = e.typeNavigationMode) !== null && i !== void 0 ? i : Qr.Automatic;
  }
  enable() {
    if (this.enabled)
      return;
    let e = !1;
    const t = this.enabledDisposables.add(Q.chain(this.enabledDisposables.add(new Ve(this.view.domNode, "keydown")).event)).filter((r) => !ia(r.target)).filter(() => this.mode === Qr.Automatic || this.triggered).map((r) => new nt(r)).filter((r) => e || this.keyboardNavigationEventFilter(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach(J1).map((r) => r.browserEvent.key).event, i = Q.debounce(t, () => null, 800, void 0, void 0, this.enabledDisposables);
    Q.reduce(Q.any(t, i), (r, o) => o === null ? null : (r || "") + o, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables), i(this.onClear, this, this.enabledDisposables), t(() => e = !0, void 0, this.enabledDisposables), i(() => e = !1, void 0, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    !this.enabled || (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    var e;
    const t = this.list.getFocus();
    if (t.length > 0 && t[0] === this.previouslyFocused) {
      const i = (e = this.list.options.accessibilityProvider) === null || e === void 0 ? void 0 : e.getAriaLabel(this.list.element(t[0]));
      i && Kb(i);
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = al.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === al.Idle ? 1 : 0;
    this.state = al.Typing;
    for (let r = 0; r < this.list.length; r++) {
      const o = (i + r + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(o)), l = a && a.toString();
      if (typeof l > "u" || EC(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([o]), this.list.reveal(o);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class YF {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new le(), this.disposables.add(Q.chain(this.disposables.add(new Ve(t.domNode, "keydown")).event)).filter((n) => !ia(n.target)).map((n) => new nt(n)).filter((n) => n.keyCode === 2 && !n.ctrlKey && !n.metaKey && !n.shiftKey && !n.altKey).on(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const n = i.querySelector("[tabIndex]");
    if (!n || !(n instanceof HTMLElement) || n.tabIndex === -1)
      return;
    const r = window.getComputedStyle(n);
    r.visibility === "hidden" || r.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function kx(s) {
  return Ie ? s.browserEvent.metaKey : s.browserEvent.ctrlKey;
}
function Dx(s) {
  return s.browserEvent.shiftKey;
}
function QF(s) {
  return s instanceof MouseEvent && s.button === 2;
}
const hL = {
  isSelectionSingleChangeEvent: kx,
  isSelectionRangeChangeEvent: Dx
};
class Ex {
  constructor(e) {
    this.list = e, this.disposables = new le(), this._onPointer = new A(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || hL), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(Ne.addTarget(e.getHTMLElement()))), Q.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || hL));
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : !1;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : !1;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    ol(e.browserEvent.target) || document.activeElement !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (ol(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || ia(e.browserEvent.target) || ol(e.browserEvent.target))
      return;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.isSelectionRangeChangeEvent(e))
      return this.changeSelection(e);
    if (this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), QF(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (ia(e.browserEvent.target) || ol(e.browserEvent.target) || this.isSelectionChangeEvent(e))
      return;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      if (typeof i > "u") {
        const h = this.list.getFocus()[0];
        i = h != null ? h : t, this.list.setAnchor(i);
      }
      const n = Math.min(i, t), r = Math.max(i, t), o = Jt(n, r + 1), a = this.list.getSelection(), l = eB(k0(a, [i]), i);
      if (l.length === 0)
        return;
      const c = k0(o, tB(a, l));
      this.list.setSelection(c, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const n = this.list.getSelection(), r = n.filter((o) => o !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), n.length === r.length ? this.list.setSelection([...r, t], e.browserEvent) : this.list.setSelection(r, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class xx {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
    e.listBackground && (e.listBackground.isOpaque() ? i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`) : Ie || console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`)), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionOutline && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { outline-color: ${e.listFocusAndSelectionOutline} !important; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && i.push(`.monaco-list${t} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropBackground} !important; color: inherit !important; }
			`), e.tableColumnsBorder && i.push(`
				.monaco-table:hover > .monaco-split-view2,
				.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
			}`), e.tableOddRowsBackgroundColor && i.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = i.join(`
`);
  }
}
const XF = {
  listFocusBackground: R.fromHex("#7FB0D0"),
  listActiveSelectionBackground: R.fromHex("#0E639C"),
  listActiveSelectionForeground: R.fromHex("#FFFFFF"),
  listActiveSelectionIconForeground: R.fromHex("#FFFFFF"),
  listFocusAndSelectionOutline: R.fromHex("#90C2F9"),
  listFocusAndSelectionBackground: R.fromHex("#094771"),
  listFocusAndSelectionForeground: R.fromHex("#FFFFFF"),
  listInactiveSelectionBackground: R.fromHex("#3F3F46"),
  listInactiveSelectionIconForeground: R.fromHex("#FFFFFF"),
  listHoverBackground: R.fromHex("#2A2D2E"),
  listDropBackground: R.fromHex("#383B3D"),
  treeIndentGuidesStroke: R.fromHex("#a9a9a9"),
  tableColumnsBorder: R.fromHex("#cccccc").transparent(0.2),
  tableOddRowsBackgroundColor: R.fromHex("#cccccc").transparent(0.04)
}, JF = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    }
  }
};
function eB(s, e) {
  const t = s.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let n = t - 1;
  for (; n >= 0 && s[n] === e - (t - n); )
    i.push(s[n--]);
  for (i.reverse(), n = t; n < s.length && s[n] === e + (n - t); )
    i.push(s[n++]);
  return i;
}
function k0(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      t.push(s[i]), i++, n++;
      continue;
    } else
      s[i] < e[n] ? t.push(s[i++]) : t.push(e[n++]);
  return t;
}
function tB(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      i++, n++;
      continue;
    } else
      s[i] < e[n] ? t.push(s[i++]) : n++;
  return t;
}
const uL = (s, e) => s - e;
class iB {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, n) {
    let r = 0;
    for (const o of this.renderers)
      o.renderElement(e, t, i[r++], n);
  }
  disposeElement(e, t, i, n) {
    var r;
    let o = 0;
    for (const a of this.renderers)
      (r = a.disposeElement) === null || r === void 0 || r.call(a, e, t, i[o], n), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class nB {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const n = this.accessibilityProvider.getAriaLabel(e);
    n ? i.setAttribute("aria-label", n) : i.removeAttribute("aria-label");
    const r = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof r == "number" ? i.setAttribute("aria-level", `${r}`) : i.removeAttribute("aria-level");
  }
  disposeTemplate(e) {
  }
}
class sB {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) === null || n === void 0 || n.call(i, e, t);
  }
  onDragOver(e, t, i, n) {
    return this.dnd.onDragOver(e, t, i, n);
  }
  onDragLeave(e, t, i, n) {
    var r, o;
    (o = (r = this.dnd).onDragLeave) === null || o === void 0 || o.call(r, e, t, i, n);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
  drop(e, t, i, n) {
    this.dnd.drop(e, t, i, n);
  }
}
class ar {
  constructor(e, t, i, n, r = JF) {
    var o, a, l, c;
    this.user = e, this._options = r, this.focus = new hg("focused"), this.anchor = new hg("anchor"), this.eventBufferer = new _b(), this._ariaLabel = "", this.disposables = new le(), this._onDidDispose = new A(), this.onDidDispose = this._onDidDispose.event;
    const h = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (o = this._options.accessibilityProvider) === null || o === void 0 ? void 0 : o.getWidgetRole() : "list";
    this.selection = new qF(h !== "listbox"), sa(r, XF, !1);
    const u = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = r.accessibilityProvider, this.accessibilityProvider && (u.push(new nB(this.accessibilityProvider)), (l = (a = this.accessibilityProvider).onDidChangeActiveDescendant) === null || l === void 0 || l.call(a, this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((f) => new iB(f.templateId, [...u, f]));
    const d = Object.assign(Object.assign({}, r), { dnd: r.dnd && new sB(this, r.dnd) });
    if (this.view = new bn(t, i, n, d), this.view.domNode.setAttribute("role", h), r.styleController)
      this.styleController = r.styleController(this.view.domId);
    else {
      const f = Vn(this.view.domNode);
      this.styleController = new xx(f, this.view.domId);
    }
    if (this.spliceable = new FF([
      new Yp(this.focus, this.view, r.identityProvider),
      new Yp(this.selection, this.view, r.identityProvider),
      new Yp(this.anchor, this.view, r.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new YF(this, this.view)), (typeof r.keyboardSupport != "boolean" || r.keyboardSupport) && (this.keyboardController = new Lx(this, this.view, r), this.disposables.add(this.keyboardController)), r.keyboardNavigationLabelProvider) {
      const f = r.keyboardNavigationDelegate || GF;
      this.typeNavigationController = new ZF(this, this.view, r.keyboardNavigationLabelProvider, (c = r.keyboardNavigationEventFilter) !== null && c !== void 0 ? c : () => !0, f), this.disposables.add(this.typeNavigationController);
    }
    this.mouseController = this.createMouseController(r), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  get onDidChangeFocus() {
    return Q.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get onDidChangeSelection() {
    return Q.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get domId() {
    return this.view.domId;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onMouseOver() {
    return this.view.onMouseOver;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  get onContextMenu() {
    let e = !1;
    const t = this.disposables.add(Q.chain(this.disposables.add(new Ve(this.view.domNode, "keydown")).event)).map((r) => new nt(r)).filter((r) => e = r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map(J1).filter(() => !1).event, i = this.disposables.add(Q.chain(this.disposables.add(new Ve(this.view.domNode, "keyup")).event)).forEach(() => e = !1).map((r) => new nt(r)).filter((r) => r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map(J1).map(({ browserEvent: r }) => {
      const o = this.getFocus(), a = o.length ? o[0] : void 0, l = typeof a < "u" ? this.view.element(a) : void 0, c = typeof a < "u" ? this.view.domElement(a) : this.view.domNode;
      return { index: a, element: l, anchor: c, browserEvent: r };
    }).event, n = this.disposables.add(Q.chain(this.view.onContextMenu)).filter((r) => !e).map(({ element: r, index: o, browserEvent: a }) => ({ element: r, index: o, anchor: { x: a.pageX + 1, y: a.pageY }, browserEvent: a })).event;
    return Q.any(t, i, n);
  }
  get onKeyDown() {
    return this.disposables.add(new Ve(this.view.domNode, "keydown")).event;
  }
  get onDidFocus() {
    return Q.signal(this.disposables.add(new Ve(this.view.domNode, "focus", !0)).event);
  }
  createMouseController(e) {
    return new Ex(this);
  }
  updateOptions(e = {}) {
    var t, i;
    this._options = Object.assign(Object.assign({}, this._options), e), (t = this.typeNavigationController) === null || t === void 0 || t.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), (i = this.keyboardController) === null || i === void 0 || i.updateOptions(e), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new Oa(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new Oa(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new Oa(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new Oa(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return Ok(this.anchor.get(), void 0);
  }
  getAnchorElement() {
    const e = this.getAnchor();
    return typeof e > "u" ? void 0 : this.element(e);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new Oa(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const r = this.focus.get(), o = this.findNextIndex(r.length > 0 ? r[0] + e : 0, t, n);
    o > -1 && this.setFocus([o], i);
  }
  focusPrevious(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const r = this.focus.get(), o = this.findPreviousIndex(r.length > 0 ? r[0] - e : 0, t, n);
    o > -1 && this.setFocus([o], i);
  }
  focusNextPage(e, t) {
    return cL(this, void 0, void 0, function* () {
      let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
      i = i === 0 ? 0 : i - 1;
      const n = this.getFocus()[0];
      if (n !== i && (n === void 0 || i > n)) {
        const r = this.findPreviousIndex(i, !1, t);
        r > -1 && n !== r ? this.setFocus([r], e) : this.setFocus([i], e);
      } else {
        const r = this.view.getScrollTop();
        let o = r + this.view.renderHeight;
        i > n && (o -= this.view.elementHeight(i)), this.view.setScrollTop(o), this.view.getScrollTop() !== r && (this.setFocus([]), yield Oh(0), yield this.focusNextPage(e, t));
      }
    });
  }
  focusPreviousPage(e, t) {
    return cL(this, void 0, void 0, function* () {
      let i;
      const n = this.view.getScrollTop();
      n === 0 ? i = this.view.indexAt(n) : i = this.view.indexAfter(n - 1);
      const r = this.getFocus()[0];
      if (r !== i && (r === void 0 || r >= i)) {
        const o = this.findNextIndex(i, !1, t);
        o > -1 && r !== o ? this.setFocus([o], e) : this.setFocus([i], e);
      } else {
        const o = n;
        this.view.setScrollTop(n - this.view.renderHeight), this.view.getScrollTop() !== o && (this.setFocus([]), yield Oh(0), yield this.focusPreviousPage(e, t));
      }
    });
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const n = this.findNextIndex(e, !1, i);
    n > -1 && this.setFocus([n], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t) {
    if (e < 0 || e >= this.length)
      throw new Oa(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), n = this.view.elementTop(e), r = this.view.elementHeight(e);
    if (oc(t)) {
      const o = r - this.view.renderHeight;
      this.view.setScrollTop(o * Ri(t, 0, 1) + n);
    } else {
      const o = n + r, a = i + this.view.renderHeight;
      n < i && o >= a || (n < i || o >= a && r >= this.view.renderHeight ? this.view.setScrollTop(n) : o >= a && this.view.setScrollTop(o - this.view.renderHeight));
    }
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  getElementID(e) {
    return this.view.getElementDomId(e);
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var e;
    const t = this.focus.get();
    if (t.length > 0) {
      let i;
      !((e = this.accessibilityProvider) === null || e === void 0) && e.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(t[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(t[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
ma([
  dt
], ar.prototype, "onDidChangeFocus", null);
ma([
  dt
], ar.prototype, "onDidChangeSelection", null);
ma([
  dt
], ar.prototype, "onContextMenu", null);
ma([
  dt
], ar.prototype, "onKeyDown", null);
ma([
  dt
], ar.prototype, "onDidFocus", null);
class rB {
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  get templateId() {
    return this.renderer.templateId;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: z.None };
  }
  renderElement(e, t, i, n) {
    if (i.disposable && i.disposable.dispose(), !i.data)
      return;
    const r = this.modelProvider();
    if (r.isResolved(e))
      return this.renderer.renderElement(r.get(e), e, i.data, n);
    const o = new lc(), a = r.resolve(e, o.token);
    i.disposable = { dispose: () => o.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((l) => this.renderer.renderElement(l, e, i.data, n));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class oB {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function aB(s, e) {
  return Object.assign(Object.assign({}, e), { accessibilityProvider: e.accessibilityProvider && new oB(s, e.accessibilityProvider) });
}
class lB {
  constructor(e, t, i, n, r = {}) {
    const o = () => this.model, a = n.map((l) => new rB(l, o));
    this.list = new ar(e, t, i, a, aB(o, r));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return Q.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return Q.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return Q.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((n) => this._model.get(n)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, Jt(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
const cB = {
  separatorBorder: R.transparent
};
class Ix {
  constructor(e, t, i, n) {
    this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    var i, n;
    e !== this.visible && (e ? (this.size = Ri(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e), (n = (i = this.view).setVisible) === null || n === void 0 || n.call(i, e));
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  layout(e, t) {
    this.layoutContainer(e), this.view.layout(this.size, e, t);
  }
  dispose() {
    return this.disposable.dispose(), this.view;
  }
}
class hB extends Ix {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class uB extends Ix {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var Fs;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Busy = 1] = "Busy";
})(Fs || (Fs = {}));
var dL;
(function(s) {
  s.Distribute = { type: "distribute" };
  function e(i) {
    return { type: "split", index: i };
  }
  s.Split = e;
  function t(i) {
    return { type: "invisible", cachedVisibleSize: i };
  }
  s.Invisible = t;
})(dL || (dL = {}));
class dB extends z {
  constructor(e, t = {}) {
    var i, n, r, o, a;
    super(), this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = Fs.Idle, this._onDidSashChange = this._register(new A()), this._onDidSashReset = this._register(new A()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = (i = t.orientation) !== null && i !== void 0 ? i : 0, this.inverseAltBehavior = (n = t.inverseAltBehavior) !== null && n !== void 0 ? n : !1, this.proportionalLayout = (r = t.proportionalLayout) !== null && r !== void 0 ? r : !0, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = Y(this.el, ae(".sash-container")), this.viewContainer = ae(".split-view-container"), this.scrollable = new Fu({
      forceIntegerValues: !0,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: Bn
    }), this.scrollableElement = this._register(new iC(this.viewContainer, {
      vertical: this.orientation === 0 ? (o = t.scrollbarVisibility) !== null && o !== void 0 ? o : 1 : 2,
      horizontal: this.orientation === 1 ? (a = t.scrollbarVisibility) !== null && a !== void 0 ? a : 1 : 2
    }, this.scrollable)), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((l) => {
      this.viewContainer.scrollTop = l.scrollTop, this.viewContainer.scrollLeft = l.scrollLeft;
    })), Y(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || cB), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((l, c) => {
      const h = Rn(l.visible) || l.visible ? l.size : { type: "invisible", cachedVisibleSize: l.size }, u = l.view;
      this.doAddView(u, h, c, !0);
    }), this.contentSize = this.viewItems.reduce((l, c) => l + c.size, 0), this.saveProportions());
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  addView(e, t, i = this.viewItems.length, n) {
    this.doAddView(e, t, i, n);
  }
  layout(e, t) {
    const i = Math.max(this.size, this.contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions)
      for (let n = 0; n < this.viewItems.length; n++) {
        const r = this.viewItems[n];
        r.size = Ri(Math.round(this.proportions[n] * e), r.minimumSize, r.maximumSize);
      }
    else {
      const n = Jt(this.viewItems.length), r = n.filter((a) => this.viewItems[a].priority === 1), o = n.filter((a) => this.viewItems[a].priority === 2);
      this.resize(this.viewItems.length - 1, e - i, void 0, r, o);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.size / this.contentSize));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const n = this.sashItems.findIndex((a) => a.sash === e), r = zr(H(document.body, "keydown", (a) => o(this.sashDragState.current, a.altKey)), H(document.body, "keyup", () => o(this.sashDragState.current, !1))), o = (a, l) => {
      const c = this.viewItems.map((m) => m.size);
      let h = Number.NEGATIVE_INFINITY, u = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (n === this.sashItems.length - 1) {
          const _ = this.viewItems[n];
          h = (_.minimumSize - _.size) / 2, u = (_.maximumSize - _.size) / 2;
        } else {
          const _ = this.viewItems[n + 1];
          h = (_.size - _.maximumSize) / 2, u = (_.size - _.minimumSize) / 2;
        }
      let d, f;
      if (!l) {
        const m = Jt(n, -1), _ = Jt(n + 1, this.viewItems.length), b = m.reduce((S, D) => S + (this.viewItems[D].minimumSize - c[D]), 0), v = m.reduce((S, D) => S + (this.viewItems[D].viewMaximumSize - c[D]), 0), C = _.length === 0 ? Number.POSITIVE_INFINITY : _.reduce((S, D) => S + (c[D] - this.viewItems[D].minimumSize), 0), w = _.length === 0 ? Number.NEGATIVE_INFINITY : _.reduce((S, D) => S + (c[D] - this.viewItems[D].viewMaximumSize), 0), L = Math.max(b, w), E = Math.min(C, v), k = this.findFirstSnapIndex(m), y = this.findFirstSnapIndex(_);
        if (typeof k == "number") {
          const S = this.viewItems[k], D = Math.floor(S.viewMinimumSize / 2);
          d = {
            index: k,
            limitDelta: S.visible ? L - D : L + D,
            size: S.size
          };
        }
        if (typeof y == "number") {
          const S = this.viewItems[y], D = Math.floor(S.viewMinimumSize / 2);
          f = {
            index: y,
            limitDelta: S.visible ? E + D : E - D,
            size: S.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: n, sizes: c, minDelta: h, maxDelta: u, alt: l, snapBefore: d, snapAfter: f, disposable: r };
    };
    o(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: n, alt: r, minDelta: o, maxDelta: a, snapBefore: l, snapAfter: c } = this.sashDragState;
    this.sashDragState.current = e;
    const h = e - i, u = this.resize(t, h, n, void 0, void 0, o, a, l, c);
    if (r) {
      const d = t === this.sashItems.length - 1, f = this.viewItems.map((w) => w.size), m = d ? t : t + 1, _ = this.viewItems[m], b = _.size - _.maximumSize, v = _.size - _.minimumSize, C = d ? t - 1 : t + 1;
      this.resize(C, -u, f, void 0, void 0, b, v);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = Ri(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  resizeView(e, t) {
    if (this.state !== Fs.Idle)
      throw new Error("Cant modify splitview");
    if (this.state = Fs.Busy, e < 0 || e >= this.viewItems.length)
      return;
    const i = Jt(this.viewItems.length).filter((a) => a !== e), n = [...i.filter((a) => this.viewItems[a].priority === 1), e], r = i.filter((a) => this.viewItems[a].priority === 2), o = this.viewItems[e];
    t = Math.round(t), t = Ri(t, o.minimumSize, Math.min(o.maximumSize, this.size)), o.size = t, this.relayout(n, r), this.state = Fs.Idle;
  }
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = Ri(i, a.minimumSize, a.maximumSize);
    const n = Jt(this.viewItems.length), r = n.filter((a) => this.viewItems[a].priority === 1), o = n.filter((a) => this.viewItems[a].priority === 2);
    this.relayout(r, o);
  }
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, n) {
    if (this.state !== Fs.Idle)
      throw new Error("Cant modify splitview");
    this.state = Fs.Busy;
    const r = ae(".split-view-view");
    i === this.viewItems.length ? this.viewContainer.appendChild(r) : this.viewContainer.insertBefore(r, this.viewContainer.children.item(i));
    const o = e.onDidChange((d) => this.onViewChange(h, d)), a = ze(() => this.viewContainer.removeChild(r)), l = zr(o, a);
    let c;
    typeof t == "number" ? c = t : t.type === "split" ? c = this.getViewSize(t.index) / 2 : t.type === "invisible" ? c = { cachedVisibleSize: t.cachedVisibleSize } : c = e.minimumSize;
    const h = this.orientation === 0 ? new hB(r, e, c, l) : new uB(r, e, c, l);
    if (this.viewItems.splice(i, 0, h), this.viewItems.length > 1) {
      const d = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash }, f = this.orientation === 0 ? new ji(this.sashContainer, { getHorizontalSashTop: (S) => this.getSashPosition(S), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, d), { orientation: 1 })) : new ji(this.sashContainer, { getVerticalSashLeft: (S) => this.getSashPosition(S), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, d), { orientation: 0 })), m = this.orientation === 0 ? (S) => ({ sash: f, start: S.startY, current: S.currentY, alt: S.altKey }) : (S) => ({ sash: f, start: S.startX, current: S.currentX, alt: S.altKey }), b = Q.map(f.onDidStart, m)(this.onSashStart, this), C = Q.map(f.onDidChange, m)(this.onSashChange, this), L = Q.map(f.onDidEnd, () => this.sashItems.findIndex((S) => S.sash === f))(this.onSashEnd, this), E = f.onDidReset(() => {
        const S = this.sashItems.findIndex((V) => V.sash === f), D = Jt(S, -1), T = Jt(S + 1, this.viewItems.length), M = this.findFirstSnapIndex(D), P = this.findFirstSnapIndex(T);
        typeof M == "number" && !this.viewItems[M].visible || typeof P == "number" && !this.viewItems[P].visible || this._onDidSashReset.fire(S);
      }), k = zr(b, C, L, E, f), y = { sash: f, disposable: k };
      this.sashItems.splice(i - 1, 0, y);
    }
    r.appendChild(e.element);
    let u;
    typeof t != "number" && t.type === "split" && (u = [t.index]), n || this.relayout([i], u), this.state = Fs.Idle, !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((n, r) => n + r.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((h) => h.size), n, r, o = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, c) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const h = Jt(e, -1), u = Jt(e + 1, this.viewItems.length);
    if (r)
      for (const y of r)
        Wm(h, y), Wm(u, y);
    if (n)
      for (const y of n)
        Gu(h, y), Gu(u, y);
    const d = h.map((y) => this.viewItems[y]), f = h.map((y) => i[y]), m = u.map((y) => this.viewItems[y]), _ = u.map((y) => i[y]), b = h.reduce((y, S) => y + (this.viewItems[S].minimumSize - i[S]), 0), v = h.reduce((y, S) => y + (this.viewItems[S].maximumSize - i[S]), 0), C = u.length === 0 ? Number.POSITIVE_INFINITY : u.reduce((y, S) => y + (i[S] - this.viewItems[S].minimumSize), 0), w = u.length === 0 ? Number.NEGATIVE_INFINITY : u.reduce((y, S) => y + (i[S] - this.viewItems[S].maximumSize), 0), L = Math.max(b, w, o), E = Math.min(C, v, a);
    let k = !1;
    if (l) {
      const y = this.viewItems[l.index], S = t >= l.limitDelta;
      k = S !== y.visible, y.setVisible(S, l.size);
    }
    if (!k && c) {
      const y = this.viewItems[c.index], S = t < c.limitDelta;
      k = S !== y.visible, y.setVisible(S, c.size);
    }
    if (k)
      return this.resize(e, t, i, n, r, o, a);
    t = Ri(t, L, E);
    for (let y = 0, S = t; y < d.length; y++) {
      const D = d[y], T = Ri(f[y] + S, D.minimumSize, D.maximumSize), M = T - f[y];
      S -= M, D.size = T;
    }
    for (let y = 0, S = t; y < m.length; y++) {
      const D = m[y], T = Ri(_[y] - S, D.minimumSize, D.maximumSize), M = T - _[y];
      S += M, D.size = T;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const n = Jt(this.viewItems.length - 1, -1), r = n.filter((a) => this.viewItems[a].priority === 1), o = n.filter((a) => this.viewItems[a].priority === 2);
    for (const a of o)
      Wm(n, a);
    for (const a of r)
      Gu(n, a);
    typeof e == "number" && Gu(n, e);
    for (let a = 0; i !== 0 && a < n.length; a++) {
      const l = this.viewItems[n[a]], c = Ri(l.size + i, l.minimumSize, l.maximumSize), h = c - l.size;
      i -= h, l.size = c;
    }
  }
  layoutViews() {
    this.contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this.contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this.contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [...this.viewItems].reverse();
    e = !1;
    const r = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const o = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: c } = this.sashItems[l], h = this.viewItems[l];
      a += h.size;
      const u = !(t[l] && o[l + 1]), d = !(i[l] && r[l + 1]);
      if (u && d) {
        const f = Jt(l, -1), m = Jt(l + 1, this.viewItems.length), _ = this.findFirstSnapIndex(f), b = this.findFirstSnapIndex(m), v = typeof _ == "number" && !this.viewItems[_].visible, C = typeof b == "number" && !this.viewItems[b].visible;
        v && r[l] && (a > 0 || this.startSnappingEnabled) ? c.state = 1 : C && t[l] && (a < this.contentSize || this.endSnappingEnabled) ? c.state = 2 : c.state = 0;
      } else
        u && !d ? c.state = 1 : !u && d ? c.state = 2 : c.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (!!i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  dispose() {
    super.dispose(), je(this.viewItems), this.viewItems = [], this.sashItems.forEach((e) => e.disposable.dispose()), this.sashItems = [];
  }
}
class Hu {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = Hu.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const n = new Map(t.map((r) => [r.templateId, r]));
    this.renderers = [];
    for (const r of e) {
      const o = n.get(r.templateId);
      if (!o)
        throw new Error(`Table cell renderer for template id ${r.templateId} not found.`);
      this.renderers.push(o);
    }
  }
  renderTemplate(e) {
    const t = Y(e, ae(".monaco-table-tr")), i = [], n = [];
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.renderers[o], l = Y(t, ae(".monaco-table-td", { "data-col-index": o }));
      l.style.width = `${this.getColumnSize(o)}px`, i.push(l), n.push(a.renderTemplate(l));
    }
    const r = { container: e, cellContainers: i, cellTemplateData: n };
    return this.renderedTemplates.add(r), r;
  }
  renderElement(e, t, i, n) {
    for (let r = 0; r < this.columns.length; r++) {
      const a = this.columns[r].project(e);
      this.renderers[r].renderElement(a, t, i.cellTemplateData[r], n);
    }
  }
  disposeElement(e, t, i, n) {
    for (let r = 0; r < this.columns.length; r++) {
      const o = this.renderers[r];
      if (o.disposeElement) {
        const l = this.columns[r].project(e);
        o.disposeElement(l, t, i.cellTemplateData[r], n);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    rn(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
}
Hu.TemplateId = "row";
function fB(s) {
  return {
    getHeight(e) {
      return s.getHeight(e);
    },
    getTemplateId() {
      return Hu.TemplateId;
    }
  };
}
class gB {
  constructor(e, t) {
    this.column = e, this.index = t, this._onDidLayout = new A(), this.onDidLayout = this._onDidLayout.event, this.element = ae(".monaco-table-th", { "data-col-index": t, title: e.tooltip }, e.label);
  }
  get minimumSize() {
    var e;
    return (e = this.column.minimumWidth) !== null && e !== void 0 ? e : 120;
  }
  get maximumSize() {
    var e;
    return (e = this.column.maximumWidth) !== null && e !== void 0 ? e : Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    var e;
    return (e = this.column.onDidChangeWidthConstraints) !== null && e !== void 0 ? e : Q.None;
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
class vm {
  constructor(e, t, i, n, r, o) {
    this.virtualDelegate = i, this.domId = `table_id_${++vm.InstanceCount}`, this.disposables = new le(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = Y(t, ae(`.monaco-table.${this.domId}`));
    const a = n.map((h, u) => new gB(h, u)), l = {
      size: a.reduce((h, u) => h + u.column.weight, 0),
      views: a.map((h) => ({ size: h.column.weight, view: h }))
    };
    this.splitview = this.disposables.add(new dB(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const c = new Hu(n, r, (h) => this.splitview.getViewSize(h));
    this.list = this.disposables.add(new ar(e, this.domNode, fB(i), [c], o)), Q.any(...a.map((h) => h.onDidLayout))(([h, u]) => c.layoutColumn(h, u), null, this.disposables), this.splitview.onDidSashReset((h) => {
      const u = n.reduce((f, m) => f + m.weight, 0), d = n[h].weight / u * this.cachedWidth;
      this.splitview.resizeView(h, d);
    }, null, this.disposables), this.styleElement = Vn(this.domNode), this.style({});
  }
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.disposables.dispose();
  }
}
vm.InstanceCount = 0;
R.fromHex("#007ACC00"), R.fromHex("#FFFFFF"), R.fromHex("#0E639C50");
p("caseDescription", "Match Case");
p("wordsDescription", "Match Whole Word");
p("regexDescription", "Use Regular Expression");
p("defaultLabel", "input");
var zo;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Twistie = 1] = "Twistie", s[s.Element = 2] = "Element", s[s.Filter = 3] = "Filter";
})(zo || (zo = {}));
class Yi extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class zC {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
function UC(s) {
  return typeof s == "object" && "visibility" in s && "data" in s;
}
function fu(s) {
  switch (s) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return s;
  }
}
function Qp(s) {
  return typeof s.collapsible == "boolean";
}
class mB {
  constructor(e, t, i, n = {}) {
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new _b(), this._onDidChangeCollapseState = new A(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new A(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new A(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new Og(N2), this.collapseByDefault = typeof n.collapseByDefault > "u" ? !1 : n.collapseByDefault, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? !1 : n.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = ge.empty(), n = {}) {
    if (e.length === 0)
      throw new Yi(this.user, "Invalid tree location");
    n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
  }
  spliceSmart(e, t, i, n, r, o) {
    var a;
    n === void 0 && (n = ge.empty()), o === void 0 && (o = (a = r.diffDepth) !== null && a !== void 0 ? a : 0);
    const { parentNode: l } = this.getParentNodeWithListIndex(t);
    if (!l.lastDiffIds)
      return this.spliceSimple(t, i, n, r);
    const c = [...n], h = t[t.length - 1], u = new Us({ getElements: () => l.lastDiffIds }, {
      getElements: () => [
        ...l.children.slice(0, h),
        ...c,
        ...l.children.slice(h + i)
      ].map((b) => e.getId(b.element).toString())
    }).ComputeDiff(!1);
    if (u.quitEarly)
      return l.lastDiffIds = void 0, this.spliceSimple(t, i, c, r);
    const d = t.slice(0, -1), f = (b, v, C) => {
      if (o > 0)
        for (let w = 0; w < C; w++)
          b--, v--, this.spliceSmart(e, [...d, b, 0], Number.MAX_SAFE_INTEGER, c[v].children, r, o - 1);
    };
    let m = Math.min(l.children.length, h + i), _ = c.length;
    for (const b of u.changes.sort((v, C) => C.originalStart - v.originalStart))
      f(m, _, m - (b.originalStart + b.originalLength)), m = b.originalStart, _ = b.modifiedStart - h, this.spliceSimple([...d, m], b.originalLength, ge.slice(c, _, _ + b.modifiedLength), r);
    f(m, _, m);
  }
  spliceSimple(e, t, i = ge.empty(), { onDidCreateNode: n, onDidDeleteNode: r, diffIdentityProvider: o }) {
    const { parentNode: a, listIndex: l, revealed: c, visible: h } = this.getParentNodeWithListIndex(e), u = [], d = ge.map(i, (y) => this.createTreeNode(y, a, a.visible ? 1 : 0, c, u, n)), f = e[e.length - 1], m = a.children.length > 0;
    let _ = 0;
    for (let y = f; y >= 0 && y < a.children.length; y--) {
      const S = a.children[y];
      if (S.visible) {
        _ = S.visibleChildIndex;
        break;
      }
    }
    const b = [];
    let v = 0, C = 0;
    for (const y of d)
      b.push(y), C += y.renderNodeCount, y.visible && (y.visibleChildIndex = _ + v++);
    const w = Mv(a.children, f, t, b);
    o ? a.lastDiffIds ? Mv(a.lastDiffIds, f, t, b.map((y) => o.getId(y.element).toString())) : a.lastDiffIds = a.children.map((y) => o.getId(y.element).toString()) : a.lastDiffIds = void 0;
    let L = 0;
    for (const y of w)
      y.visible && L++;
    if (L !== 0)
      for (let y = f + b.length; y < a.children.length; y++) {
        const S = a.children[y];
        S.visible && (S.visibleChildIndex -= L);
      }
    if (a.visibleChildrenCount += v - L, c && h) {
      const y = w.reduce((S, D) => S + (D.visible ? D.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(a, C - y), this.list.splice(l, y, u);
    }
    if (w.length > 0 && r) {
      const y = (S) => {
        r(S), S.children.forEach(y);
      };
      w.forEach(y);
    }
    this._onDidSplice.fire({ insertedNodes: b, deletedNodes: w });
    const E = a.children.length > 0;
    m !== E && this.setCollapsible(e.slice(0, -1), E);
    let k = a;
    for (; k; ) {
      if (k.visibility === 2) {
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }
      k = k.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new Yi(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    t.visible && n && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    return i && n ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const n = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const n = this.getTreeNode(e);
    typeof t > "u" && (t = !n.collapsed);
    const r = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, r));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: n, revealed: r } = this.getTreeNodeWithListIndex(e), o = this._setListNodeCollapseState(i, n, r, t);
    if (i !== this.root && this.autoExpandSingleChildren && o && !Qp(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return o;
  }
  _setListNodeCollapseState(e, t, i, n) {
    const r = this._setNodeCollapseState(e, n, !1);
    if (!i || !e.visible || !r)
      return r;
    const o = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = o - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), r;
  }
  _setNodeCollapseState(e, t, i) {
    let n;
    if (e === this.root ? n = !1 : (Qp(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = !1, n && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !Qp(t) && t.recursive)
      for (const r of e.children)
        n = this._setNodeCollapseState(r, t, !0) || n;
    return n;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t), this.refilterDelayer.cancel();
  }
  createTreeNode(e, t, i, n, r, o) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, n && r.push(a);
    const c = e.children || ge.empty(), h = n && l !== 0 && !a.collapsed, u = ge.map(c, (m) => this.createTreeNode(m, a, l, h, r, o));
    let d = 0, f = 1;
    for (const m of u)
      a.children.push(m), f += m.renderNodeCount, m.visible && (m.visibleChildIndex = d++);
    return a.collapsible = a.collapsible || a.children.length > 0, a.visibleChildrenCount = d, a.visible = l === 2 ? d > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = f) : (a.renderNodeCount = 0, n && r.pop()), o == null || o(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, n = !0) {
    let r;
    if (e !== this.root) {
      if (r = this._filterNode(e, t), r === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      n && i.push(e);
    }
    const o = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || r !== 0) {
      let l = 0;
      for (const c of e.children)
        a = this._updateNodeAfterFilterChange(c, r, i, n && !e.collapsed) || a, c.visible && (c.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = r === 2 ? a : r === 1, e.visibility = r), e.visible ? e.collapsed || (e.renderNodeCount += i.length - o) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : UC(i) ? (e.filterData = i.data, fu(i.visibility)) : (e.filterData = void 0, fu(i));
  }
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...n] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(n, t.children[i]);
  }
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...n] = e;
    if (i < 0 || i > t.children.length)
      throw new Yi(this.user, "Invalid tree location");
    return this.getTreeNode(n, t.children[i]);
  }
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: n, visible: r } = this.getParentNodeWithListIndex(e), o = e[e.length - 1];
    if (o < 0 || o > t.children.length)
      throw new Yi(this.user, "Invalid tree location");
    const a = t.children[o];
    return { node: a, listIndex: i, revealed: n, visible: r && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, n = !0, r = !0) {
    const [o, ...a] = e;
    if (o < 0 || o > t.children.length)
      throw new Yi(this.user, "Invalid tree location");
    for (let l = 0; l < o; l++)
      i += t.children[l].renderNodeCount;
    return n = n && !t.collapsed, r = r && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: n, visible: r } : this.getParentNodeWithListIndex(a, t.children[o], i + 1, n, r);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : PI(e)[0];
  }
  getFirstElementChild(e) {
    const t = this.getTreeNode(e);
    if (t.children.length !== 0)
      return t.children[0].element;
  }
}
class pB {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
  }
  delete(e, t) {
    const i = this.map.get(e);
    !i || (i.delete(t), i.size === 0 && this.map.delete(e));
  }
  forEach(e, t) {
    const i = this.map.get(e);
    !i || i.forEach(t);
  }
}
globalThis && globalThis.__awaiter;
class _B extends Wu {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function Xp(s) {
  return s instanceof Wu ? new _B(s) : s;
}
class bB {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = z.None;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) === null || n === void 0 || n.call(i, Xp(e), t);
  }
  onDragOver(e, t, i, n, r = !0) {
    const o = this.dnd.onDragOver(Xp(e), t && t.element, i, n), a = this.autoExpandNode !== t;
    if (a && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return o;
    if (a && typeof o != "boolean" && o.autoExpand && (this.autoExpandDisposable = d1(() => {
      const d = this.modelProvider(), f = d.getNodeLocation(t);
      d.isCollapsed(f) && d.setCollapsed(f, !1), this.autoExpandNode = void 0;
    }, 500)), typeof o == "boolean" || !o.accept || typeof o.bubble > "u" || o.feedback) {
      if (!r) {
        const d = typeof o == "boolean" ? o : o.accept, f = typeof o == "boolean" ? void 0 : o.effect;
        return { accept: d, effect: f, feedback: [i] };
      }
      return o;
    }
    if (o.bubble === 1) {
      const d = this.modelProvider(), f = d.getNodeLocation(t), m = d.getParentNodeLocation(f), _ = d.getNode(m), b = m && d.getListIndex(m);
      return this.onDragOver(e, _, b, n, !1);
    }
    const l = this.modelProvider(), c = l.getNodeLocation(t), h = l.getListIndex(c), u = l.getListRenderCount(c);
    return Object.assign(Object.assign({}, o), { feedback: Jt(h, h + u) });
  }
  drop(e, t, i, n) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(Xp(e), t && t.element, i, n);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
}
function CB(s, e) {
  return e && Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
    getId(t) {
      return e.identityProvider.getId(t.element);
    }
  }, dnd: e.dnd && new bB(s, e.dnd), multipleSelectionController: e.multipleSelectionController && {
    isSelectionSingleChangeEvent(t) {
      return e.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
    },
    isSelectionRangeChangeEvent(t) {
      return e.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
    }
  }, accessibilityProvider: e.accessibilityProvider && Object.assign(Object.assign({}, e.accessibilityProvider), {
    getSetSize(t) {
      const i = s(), n = i.getNodeLocation(t), r = i.getParentNodeLocation(n);
      return i.getNode(r).visibleChildrenCount;
    },
    getPosInSet(t) {
      return t.visibleChildIndex + 1;
    },
    isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
    getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
    getAriaLabel(t) {
      return e.accessibilityProvider.getAriaLabel(t.element);
    },
    getWidgetAriaLabel() {
      return e.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
    getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
  }), keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(t) {
    return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
  } }) });
}
class $C {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    var i, n;
    (n = (i = this.delegate).setDynamicHeight) === null || n === void 0 || n.call(i, e.element, t);
  }
}
var gu;
(function(s) {
  s.None = "none", s.OnHover = "onHover", s.Always = "always";
})(gu || (gu = {}));
class vB {
  constructor(e, t = []) {
    this._elements = t, this.disposables = new le(), this.onDidChange = Q.forEach(e, (i) => this._elements = i, this.disposables);
  }
  get elements() {
    return this._elements;
  }
  dispose() {
    this.disposables.dispose();
  }
}
class mu {
  constructor(e, t, i, n, r = {}) {
    var o;
    this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = mu.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.renderedIndentGuides = new pB(), this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = z.None, this.disposables = new le(), this.templateId = e.templateId, this.updateOptions(r), Q.map(i, (a) => a.node)(this.onDidChangeNodeTwistieState, this, this.disposables), (o = e.onDidChangeTwistieState) === null || o === void 0 || o.call(e, this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u" && (this.indent = Ri(e.indent, 0, 40)), typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== gu.None;
      if (t !== this.shouldRenderIndentGuides && (this.shouldRenderIndentGuides = t, this.indentGuidesDisposable.dispose(), t)) {
        const i = new le();
        this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = Y(e, ae(".monaco-tl-row")), i = Y(t, ae(".monaco-tl-indent")), n = Y(t, ae(".monaco-tl-twistie")), r = Y(t, ae(".monaco-tl-contents")), o = this.renderer.renderTemplate(r);
    return { container: e, indent: i, twistie: n, indentGuidesDisposable: z.None, templateData: o };
  }
  renderElement(e, t, i, n) {
    typeof n == "number" && (this.renderedNodes.set(e, { templateData: i, height: n }), this.renderedElements.set(e.element, e));
    const r = mu.DefaultIndent + (e.depth - 1) * this.indent;
    i.twistie.style.paddingLeft = `${r}px`, i.indent.style.width = `${r + this.indent - 16}px`, this.renderTwistie(e, i), typeof n == "number" && this.renderIndentGuides(e, i), this.renderer.renderElement(e, t, i.templateData, n);
  }
  disposeElement(e, t, i, n) {
    var r, o;
    i.indentGuidesDisposable.dispose(), (o = (r = this.renderer).disposeElement) === null || o === void 0 || o.call(r, e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    !t || this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    !t || (this.renderTwistie(e, t.templateData), this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderIndentGuides(e, t.templateData));
  }
  renderTwistie(e, t) {
    t.twistie.classList.remove(...g.treeItemExpanded.classNamesArray);
    let i = !1;
    this.renderer.renderTwistie && (i = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (i || t.twistie.classList.add(...g.treeItemExpanded.classNamesArray), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded");
  }
  renderIndentGuides(e, t) {
    if (rn(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new le(), n = this.modelProvider();
    let r = e;
    for (; ; ) {
      const o = n.getNodeLocation(r), a = n.getParentNodeLocation(o);
      if (!a)
        break;
      const l = n.getNode(a), c = ae(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(l) && c.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(c) : t.indent.insertBefore(c, t.indent.firstElementChild), this.renderedIndentGuides.add(l, c), i.add(ze(() => this.renderedIndentGuides.delete(l, c))), r = l;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((n) => {
      const r = i.getNodeLocation(n);
      try {
        const o = i.getParentNodeLocation(r);
        n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : o && t.add(i.getNode(o));
      } catch {
      }
    }), this.activeIndentNodes.forEach((n) => {
      t.has(n) || this.renderedIndentGuides.forEach(n, (r) => r.classList.remove("active"));
    }), t.forEach((n) => {
      this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (r) => r.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), je(this.disposables);
  }
}
mu.DefaultIndent = 8;
class wB {
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new le(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  filter(e, t) {
    let i = 1;
    if (this._filter) {
      const o = this._filter.filter(e, t);
      if (typeof o == "boolean" ? i = o ? 1 : 0 : UC(o) ? i = fu(o.visibility) : i = o, i === 0)
        return !1;
    }
    if (this._totalCount++, !this._pattern)
      return this._matchCount++, { data: Ll.Default, visibility: i };
    const n = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), r = Array.isArray(n) ? n : [n];
    for (const o of r) {
      const a = o && o.toString();
      if (typeof a > "u")
        return { data: Ll.Default, visibility: i };
      const l = tO(this._pattern, this._lowercasePattern, 0, a, a.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
      if (l)
        return this._matchCount++, r.length === 1 ? { data: l, visibility: i } : { data: { label: a, score: l }, visibility: i };
    }
    return this.tree.findMode === ss.Filter ? 2 : { data: Ll.Default, visibility: i };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    je(this.disposables);
  }
}
var ss;
(function(s) {
  s[s.Highlight = 0] = "Highlight", s[s.Filter = 1] = "Filter";
})(ss || (ss = {}));
class SB {
  constructor(e, t, i, n, r) {
    var o;
    this.tree = e, this.view = i, this.filter = n, this.contextViewProvider = r, this._pattern = "", this.width = 0, this._onDidChangeMode = new A(), this.onDidChangeMode = this._onDidChangeMode.event, this._onDidChangePattern = new A(), this._onDidChangeOpenState = new A(), this.onDidChangeOpenState = this._onDidChangeOpenState.event, this.enabledDisposables = new le(), this.disposables = new le(), this._mode = (o = e.options.defaultFindMode) !== null && o !== void 0 ? o : ss.Highlight, t.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }
  get pattern() {
    return this._pattern;
  }
  get mode() {
    return this._mode;
  }
  set mode(e) {
    e !== this._mode && (this._mode = e, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(e));
  }
  onDidSpliceModel() {
    !this.widget || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  render() {
    var e, t;
    const i = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && i ? (e = this.widget) === null || e === void 0 || e.showMessage({ type: 2, content: p("not found", "No elements found.") }) : (t = this.widget) === null || t === void 0 || t.clearMessage();
  }
  shouldAllowFocus(e) {
    return !this.widget || !this.pattern || this._mode === ss.Filter || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !Ll.isDefault(e.filterData);
  }
  style(e) {
    var t;
    this.styles = e, (t = this.widget) === null || t === void 0 || t.style(e);
  }
  layout(e) {
    var t;
    this.width = e, (t = this.widget) === null || t === void 0 || t.layout(e);
  }
  dispose() {
    this._onDidChangePattern.dispose(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
function fL(s) {
  let e = zo.Unknown;
  return hp(s.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = zo.Twistie : hp(s.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? e = zo.Element : hp(s.browserEvent.target, "monaco-tree-type-filter", "monaco-list") && (e = zo.Filter), {
    browserEvent: s.browserEvent,
    element: s.element ? s.element.element : null,
    target: e
  };
}
function ef(s, e) {
  e(s), s.children.forEach((t) => ef(t, e));
}
class Jp {
  constructor(e, t) {
    this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new A(), this.onDidChange = this._onDidChange.event;
  }
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  set(e, t) {
    !(t != null && t.__forceEvent) && rs(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const n = this;
      this._onDidChange.fire({ get elements() {
        return n.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), c = (h) => l.delete(h);
      t.forEach((h) => ef(h, c)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => ef(l, n));
    const r = /* @__PURE__ */ new Map(), o = (l) => r.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => ef(l, o));
    const a = [];
    for (const l of this.nodes) {
      const c = this.identityProvider.getId(l.element).toString();
      if (!i.has(c))
        a.push(l);
      else {
        const u = r.get(c);
        u && a.push(u);
      }
    }
    if (this.nodes.length > 0 && a.length === 0) {
      const l = this.getFirstViewElementWithTrait();
      l && a.push(l);
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class yB extends Ex {
  constructor(e, t) {
    super(e), this.tree = t;
  }
  onViewPointer(e) {
    if (yx(e.browserEvent.target) || ia(e.browserEvent.target) || ol(e.browserEvent.target))
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
    let r = !1;
    if (typeof this.tree.expandOnlyOnTwistieClick == "function" ? r = this.tree.expandOnlyOnTwistieClick(t.element) : r = !!this.tree.expandOnlyOnTwistieClick, r && !n && e.browserEvent.detail !== 2)
      return super.onViewPointer(e);
    if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
      return super.onViewPointer(e);
    if (t.collapsible) {
      const o = this.tree.model, a = o.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), o.setCollapsed(a, void 0, l), r && n)
        return;
    }
    super.onViewPointer(e);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || super.onDoubleClick(e);
  }
}
class LB extends ar {
  constructor(e, t, i, n, r, o, a, l) {
    super(e, t, i, n, l), this.focusTrait = r, this.selectionTrait = o, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new yB(this, e.tree);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const n = [], r = [];
    let o;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && r.push(e + l), this.anchorTrait.has(a) && (o = e + l);
    }), n.length > 0 && super.setFocus(Xr([...super.getFocus(), ...n])), r.length > 0 && super.setSelection(Xr([...super.getSelection(), ...r])), typeof o == "number" && super.setAnchor(o);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class Nx {
  constructor(e, t, i, n, r = {}) {
    var o;
    this._user = e, this._options = r, this.eventBufferer = new _b(), this.onDidChangeFindOpenState = Q.None, this.disposables = new le(), this._onWillRefilter = new A(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new A();
    const a = new $C(i), l = new Fv(), c = new Fv(), h = this.disposables.add(new vB(c.event));
    this.renderers = n.map((f) => new mu(f, () => this.model, l.event, h, r));
    for (const f of this.renderers)
      this.disposables.add(f);
    let u;
    r.keyboardNavigationLabelProvider && (u = new wB(this, r.keyboardNavigationLabelProvider, r.filter), r = Object.assign(Object.assign({}, r), { filter: u }), this.disposables.add(u)), this.focus = new Jp(() => this.view.getFocusedElements()[0], r.identityProvider), this.selection = new Jp(() => this.view.getSelectedElements()[0], r.identityProvider), this.anchor = new Jp(() => this.view.getAnchorElement(), r.identityProvider), this.view = new LB(e, t, a, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, CB(() => this.model, r)), { tree: this })), this.model = this.createModel(e, this.view, r), l.input = this.model.onDidChangeCollapseState;
    const d = Q.forEach(this.model.onDidSplice, (f) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(f), this.selection.onDidModelSplice(f);
      });
    }, this.disposables);
    if (d(() => null, null, this.disposables), c.input = Q.chain(Q.any(d, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
      const f = /* @__PURE__ */ new Set();
      for (const m of this.focus.getNodes())
        f.add(m);
      for (const m of this.selection.getNodes())
        f.add(m);
      return [...f.values()];
    }).event, r.keyboardSupport !== !1) {
      const f = Q.chain(this.view.onKeyDown).filter((m) => !ia(m.target)).map((m) => new nt(m));
      f.filter((m) => m.keyCode === 15).on(this.onLeftArrow, this, this.disposables), f.filter((m) => m.keyCode === 17).on(this.onRightArrow, this, this.disposables), f.filter((m) => m.keyCode === 10).on(this.onSpace, this, this.disposables);
    }
    ((o = r.findWidgetEnabled) !== null && o !== void 0 ? o : !0) && r.keyboardNavigationLabelProvider && r.contextViewProvider ? (this.findController = new SB(this, this.model, this.view, u, r.contextViewProvider), this.focusNavigationFilter = (f) => this.findController.shouldAllowFocus(f), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode) : this.onDidChangeFindMode = Q.None, this.styleElement = Vn(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === gu.Always);
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return Q.filter(Q.map(this.view.onMouseDblClick, fL), (e) => e.target !== zo.Filter);
  }
  get onPointer() {
    return Q.map(this.view.onPointer, fL);
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeModel() {
    return Q.signal(this.model.onDidSplice);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get findMode() {
    var e, t;
    return (t = (e = this.findController) === null || e === void 0 ? void 0 : e.mode) !== null && t !== void 0 ? t : ss.Highlight;
  }
  set findMode(e) {
    this.findController && (this.findController.mode = e);
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  updateOptions(e = {}) {
    this._options = Object.assign(Object.assign({}, this._options), e);
    for (const t of this.renderers)
      t.updateOptions(e);
    this.view.updateOptions(this._options), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === gu.Always);
  }
  get options() {
    return this._options;
  }
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  domFocus() {
    this.view.domFocus();
  }
  layout(e, t) {
    var i;
    this.view.layout(e, t), oc(t) && ((i = this.findController) === null || i === void 0 || i.layout(t));
  }
  style(e) {
    var t;
    const i = `.${this.view.domId}`, n = [];
    e.treeIndentGuidesStroke && (n.push(`.monaco-list${i}:hover .monaco-tl-indent > .indent-guide, .monaco-list${i}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeIndentGuidesStroke.transparent(0.4)}; }`), n.push(`.monaco-list${i} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`)), this.styleElement.textContent = n.join(`
`), (t = this.findController) === null || t === void 0 || t.style(e), this.view.style(e);
  }
  getParentElement(e) {
    const t = this.model.getParentNodeLocation(e);
    return this.model.getNode(t).element;
  }
  getFirstElementChild(e) {
    return this.model.getFirstElementChild(e);
  }
  getNode(e) {
    return this.model.getNode(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    const i = e.map((r) => this.model.getNode(r));
    this.selection.set(i, t);
    const n = e.map((r) => this.model.getListIndex(r)).filter((r) => r > -1);
    this.view.setSelection(n, t, !0);
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    const i = e.map((r) => this.model.getNode(r));
    this.focus.set(i, t);
    const n = e.map((r) => this.model.getListIndex(r)).filter((r) => r > -1);
    this.view.setFocus(n, t, !0);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    i !== -1 && this.view.reveal(i, t);
  }
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !0)) {
      const o = this.model.getParentNodeLocation(n);
      if (!o)
        return;
      const a = this.model.getListIndex(o);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [o] = this.view.getFocus(), a = o + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i), r = e.browserEvent.altKey;
    this.model.setCollapsed(n, void 0, r);
  }
  dispose() {
    je(this.disposables), this.view.dispose();
  }
}
class jC {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new mB(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(n, r) {
        return i.sorter.compare(n.element, r.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = ge.empty(), i = {}) {
    const n = this.getElementLocation(e);
    this._setChildren(n, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = ge.empty(), i) {
    const n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), o = (l) => {
      var c;
      if (l.element === null)
        return;
      const h = l;
      if (n.add(h.element), this.nodes.set(h.element, h), this.identityProvider) {
        const u = this.identityProvider.getId(h.element).toString();
        r.add(u), this.nodesByIdentity.set(u, h);
      }
      (c = i.onDidCreateNode) === null || c === void 0 || c.call(i, h);
    }, a = (l) => {
      var c;
      if (l.element === null)
        return;
      const h = l;
      if (n.has(h.element) || this.nodes.delete(h.element), this.identityProvider) {
        const u = this.identityProvider.getId(h.element).toString();
        r.has(u) || this.nodesByIdentity.delete(u);
      }
      (c = i.onDidDeleteNode) === null || c === void 0 || c.call(i, h);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, Object.assign(Object.assign({}, i), { onDidCreateNode: o, onDidDeleteNode: a }));
  }
  preserveCollapseState(e = ge.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), ge.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const o = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(o);
      }
      if (!i)
        return Object.assign(Object.assign({}, t), { children: this.preserveCollapseState(t.children) });
      const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible, r = typeof t.collapsed < "u" ? t.collapsed : i.collapsed;
      return Object.assign(Object.assign({}, t), {
        collapsible: n,
        collapsed: r,
        children: this.preserveCollapseState(t.children)
      });
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  getFirstElementChild(e = null) {
    const t = this.getElementLocation(e);
    return this.model.getFirstElementChild(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getElementLocation(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new Yi(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new Yi(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new Yi(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
    return this.model.getNode(n).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new Yi(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function tf(s) {
  const e = [s.element], t = s.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: ge.map(ge.from(s.children), tf),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function nf(s) {
  const e = [s.element], t = s.incompressible || !1;
  let i, n;
  for (; [n, i] = ge.consume(ge.from(s.children), 2), !(n.length !== 1 || n[0].incompressible); )
    s = n[0], e.push(s.element);
  return {
    element: { elements: e, incompressible: t },
    children: ge.map(ge.concat(n, i), nf),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function D0(s, e = 0) {
  let t;
  return e < s.element.elements.length - 1 ? t = [D0(s, e + 1)] : t = ge.map(ge.from(s.children), (i) => D0(i, 0)), e === 0 && s.element.incompressible ? {
    element: s.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  } : {
    element: s.element.elements[e],
    children: t,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function gL(s) {
  return D0(s, 0);
}
function Tx(s, e, t) {
  return s.element === e ? Object.assign(Object.assign({}, s), { children: t }) : Object.assign(Object.assign({}, s), { children: ge.map(ge.from(s.children), (i) => Tx(i, e, t)) });
}
const kB = (s) => ({
  getId(e) {
    return e.elements.map((t) => s.getId(t).toString()).join("\0");
  }
});
class DB {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new jC(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  setChildren(e, t = ge.empty(), i) {
    const n = i.diffIdentityProvider && kB(i.diffIdentityProvider);
    if (e === null) {
      const f = ge.map(t, this.enabled ? nf : tf);
      this._setChildren(null, f, { diffIdentityProvider: n, diffDepth: 1 / 0 });
      return;
    }
    const r = this.nodes.get(e);
    if (!r)
      throw new Error("Unknown compressed tree node");
    const o = this.model.getNode(r), a = this.model.getParentNodeLocation(r), l = this.model.getNode(a), c = gL(o), h = Tx(c, e, t), u = (this.enabled ? nf : tf)(h), d = l.children.map((f) => f === o ? u : f);
    this._setChildren(l.element, d, {
      diffIdentityProvider: n,
      diffDepth: o.depth - l.depth
    });
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, n = ge.map(i, gL), r = ge.map(n, e ? nf : tf);
    this._setChildren(null, r, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const n = /* @__PURE__ */ new Set(), r = (a) => {
      for (const l of a.element.elements)
        n.add(l), this.nodes.set(l, a.element);
    }, o = (a) => {
      for (const l of a.element.elements)
        n.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, Object.assign(Object.assign({}, i), { onDidCreateNode: r, onDidDeleteNode: o }));
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  getFirstElementChild(e) {
    const t = this.getCompressedNode(e);
    return this.model.getFirstElementChild(t);
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getCompressedNode(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new Yi(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const EB = (s) => s[s.length - 1];
class KC {
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new KC(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
function xB(s, e) {
  return {
    splice(t, i, n) {
      e.splice(t, i, n.map((r) => s.map(r)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function IB(s, e) {
  return Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
    getId(t) {
      return e.identityProvider.getId(s(t));
    }
  }, sorter: e.sorter && {
    compare(t, i) {
      return e.sorter.compare(t.elements[0], i.elements[0]);
    }
  }, filter: e.filter && {
    filter(t, i) {
      return e.filter.filter(s(t), i);
    }
  } });
}
class NB {
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || EB;
    const n = (r) => this.elementMapper(r.elements);
    this.nodeMapper = new zC((r) => new KC(n, r)), this.model = new DB(e, xB(this.nodeMapper, t), IB(n, i));
  }
  get onDidSplice() {
    return Q.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return Q.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return Q.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  setChildren(e, t = ge.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  getFirstElementChild(e) {
    const t = this.model.getFirstElementChild(e);
    return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var TB = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
};
class qC extends Nx {
  constructor(e, t, i, n, r = {}) {
    super(e, t, i, n, r), this.user = e;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  setChildren(e, t = ge.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new jC(e, t, i);
  }
}
class Mx {
  constructor(e, t) {
    this._compressedTreeNodeProvider = e, this.renderer = t, this.templateId = t.templateId, t.onDidChangeTwistieState && (this.onDidChangeTwistieState = t.onDidChangeTwistieState);
  }
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    const r = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element);
    r.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = r, this.renderer.renderCompressedElements(r, t, i.data, n));
  }
  disposeElement(e, t, i, n) {
    var r, o, a, l;
    i.compressedTreeNode ? (o = (r = this.renderer).disposeCompressedElements) === null || o === void 0 || o.call(r, i.compressedTreeNode, t, i.data, n) : (l = (a = this.renderer).disposeElement) === null || l === void 0 || l.call(a, e, t, i.data, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
TB([
  dt
], Mx.prototype, "compressedTreeNodeProvider", null);
function MB(s, e) {
  return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
    getKeyboardNavigationLabel(t) {
      let i;
      try {
        i = s().getCompressedTreeNode(t);
      } catch {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
      }
      return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
    }
  } });
}
class Ax extends qC {
  constructor(e, t, i, n, r = {}) {
    const o = () => this, a = n.map((l) => new Mx(o, l));
    super(e, t, i, a, MB(o, r));
  }
  setChildren(e, t = ge.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new NB(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
var mr = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
function e_(s) {
  return Object.assign(Object.assign({}, s), { children: [], refreshPromise: void 0, stale: !0, slow: !1, collapsedByDefault: void 0 });
}
function E0(s, e) {
  return e.parent ? e.parent === s ? !0 : E0(s, e.parent) : !1;
}
function AB(s, e) {
  return s === e || E0(s, e) || E0(e, s);
}
class GC {
  constructor(e) {
    this.node = e;
  }
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new GC(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
class RB {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...g.treeItemLoading.classNamesArray), !0) : (t.classList.remove(...g.treeItemLoading.classNamesArray), !1);
  }
  disposeElement(e, t, i, n) {
    var r, o;
    (o = (r = this.renderer).disposeElement) === null || o === void 0 || o.call(r, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function mL(s) {
  return {
    browserEvent: s.browserEvent,
    elements: s.elements.map((e) => e.element)
  };
}
function pL(s) {
  return {
    browserEvent: s.browserEvent,
    element: s.element && s.element.element,
    target: s.target
  };
}
class PB extends Wu {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function t_(s) {
  return s instanceof Wu ? new PB(s) : s;
}
class OB {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) === null || n === void 0 || n.call(i, t_(e), t);
  }
  onDragOver(e, t, i, n, r = !0) {
    return this.dnd.onDragOver(t_(e), t && t.element, i, n);
  }
  drop(e, t, i, n) {
    this.dnd.drop(t_(e), t && t.element, i, n);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
}
function Rx(s) {
  return s && Object.assign(Object.assign({}, s), { collapseByDefault: !0, identityProvider: s.identityProvider && {
    getId(e) {
      return s.identityProvider.getId(e.element);
    }
  }, dnd: s.dnd && new OB(s.dnd), multipleSelectionController: s.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return s.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    },
    isSelectionRangeChangeEvent(e) {
      return s.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    }
  }, accessibilityProvider: s.accessibilityProvider && Object.assign(Object.assign({}, s.accessibilityProvider), {
    getPosInSet: void 0,
    getSetSize: void 0,
    getRole: s.accessibilityProvider.getRole ? (e) => s.accessibilityProvider.getRole(e.element) : () => "treeitem",
    isChecked: s.accessibilityProvider.isChecked ? (e) => {
      var t;
      return !!(!((t = s.accessibilityProvider) === null || t === void 0) && t.isChecked(e.element));
    } : void 0,
    getAriaLabel(e) {
      return s.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return s.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: s.accessibilityProvider.getWidgetRole ? () => s.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: s.accessibilityProvider.getAriaLevel && ((e) => s.accessibilityProvider.getAriaLevel(e.element)),
    getActiveDescendantId: s.accessibilityProvider.getActiveDescendantId && ((e) => s.accessibilityProvider.getActiveDescendantId(e.element))
  }), filter: s.filter && {
    filter(e, t) {
      return s.filter.filter(e.element, t);
    }
  }, keyboardNavigationLabelProvider: s.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, s.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {
    return s.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
  } }), sorter: void 0, expandOnlyOnTwistieClick: typeof s.expandOnlyOnTwistieClick > "u" ? void 0 : typeof s.expandOnlyOnTwistieClick != "function" ? s.expandOnlyOnTwistieClick : (e) => s.expandOnlyOnTwistieClick(e.element), additionalScrollHeight: s.additionalScrollHeight });
}
function x0(s, e) {
  e(s), s.children.forEach((t) => x0(t, e));
}
class Px {
  constructor(e, t, i, n, r, o = {}) {
    this.user = e, this.dataSource = r, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new A(), this._onDidChangeNodeSlowState = new A(), this.nodeMapper = new zC((a) => new GC(a)), this.disposables = new le(), this.identityProvider = o.identityProvider, this.autoExpandSingleChildren = typeof o.autoExpandSingleChildren > "u" ? !1 : o.autoExpandSingleChildren, this.sorter = o.sorter, this.collapseByDefault = o.collapseByDefault, this.tree = this.createTree(e, t, i, n, o), this.onDidChangeFindMode = this.tree.onDidChangeFindMode, this.root = e_({
      element: void 0,
      parent: null,
      hasChildren: !0
    }), this.identityProvider && (this.root = Object.assign(Object.assign({}, this.root), { id: null })), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  get onDidChangeFocus() {
    return Q.map(this.tree.onDidChangeFocus, mL);
  }
  get onDidChangeSelection() {
    return Q.map(this.tree.onDidChangeSelection, mL);
  }
  get onMouseDblClick() {
    return Q.map(this.tree.onMouseDblClick, pL);
  }
  get onPointer() {
    return Q.map(this.tree.onPointer, pL);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  get onDidChangeModel() {
    return this.tree.onDidChangeModel;
  }
  get onDidChangeCollapseState() {
    return this.tree.onDidChangeCollapseState;
  }
  get onDidChangeFindOpenState() {
    return this.tree.onDidChangeFindOpenState;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  createTree(e, t, i, n, r) {
    const o = new $C(i), a = n.map((c) => new RB(c, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = Rx(r) || {};
    return new qC(e, t, o, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  getInput() {
    return this.root.element;
  }
  setInput(e, t) {
    return mr(this, void 0, void 0, function* () {
      this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
      const i = t && { viewState: t, focus: [], selection: [] };
      yield this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
    });
  }
  _updateChildren(e = this.root.element, t = !0, i = !1, n, r) {
    return mr(this, void 0, void 0, function* () {
      if (typeof this.root.element > "u")
        throw new Yi(this.user, "Tree input not set");
      this.root.refreshPromise && (yield this.root.refreshPromise, yield Q.toPromise(this._onDidRender.event));
      const o = this.getDataNode(e);
      if (yield this.refreshAndRenderNode(o, t, n, r), i)
        try {
          this.tree.rerender(o);
        } catch {
        }
    });
  }
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  getNode(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
    return this.nodeMapper.map(i);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  expand(e, t = !1) {
    return mr(this, void 0, void 0, function* () {
      if (typeof this.root.element > "u")
        throw new Yi(this.user, "Tree input not set");
      this.root.refreshPromise && (yield this.root.refreshPromise, yield Q.toPromise(this._onDidRender.event));
      const i = this.getDataNode(e);
      if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (yield this.root.refreshPromise, yield Q.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
        return !1;
      const n = this.tree.expand(i === this.root ? null : i, t);
      return i.refreshPromise && (yield this.root.refreshPromise, yield Q.toPromise(this._onDidRender.event)), n;
    });
  }
  setSelection(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  getParentElement(e) {
    const t = this.tree.getParentElement(this.getDataNode(e));
    return t && t.element;
  }
  getFirstElementChild(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
    return i && i.element;
  }
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new Yi(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  refreshAndRenderNode(e, t, i, n) {
    return mr(this, void 0, void 0, function* () {
      yield this.refreshNode(e, t, i), this.render(e, i, n);
    });
  }
  refreshNode(e, t, i) {
    return mr(this, void 0, void 0, function* () {
      let n;
      if (this.subTreeRefreshPromises.forEach((r, o) => {
        !n && AB(o, e) && (n = r.then(() => this.refreshNode(e, t, i)));
      }), n)
        return n;
      if (e !== this.root && this.tree.getNode(e).collapsed) {
        e.hasChildren = !!this.dataSource.hasChildren(e.element), e.stale = !0;
        return;
      }
      return this.doRefreshSubTree(e, t, i);
    });
  }
  doRefreshSubTree(e, t, i) {
    return mr(this, void 0, void 0, function* () {
      let n;
      e.refreshPromise = new Promise((r) => n = r), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
        e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
      });
      try {
        const r = yield this.doRefreshNode(e, t, i);
        e.stale = !1, yield f1.settled(r.map((o) => this.doRefreshSubTree(o, t, i)));
      } finally {
        n();
      }
    });
  }
  doRefreshNode(e, t, i) {
    return mr(this, void 0, void 0, function* () {
      e.hasChildren = !!this.dataSource.hasChildren(e.element);
      let n;
      if (!e.hasChildren)
        n = Promise.resolve(ge.empty());
      else {
        const r = this.doGetChildren(e);
        if (Rv(r))
          n = Promise.resolve(r);
        else {
          const o = Oh(800);
          o.then(() => {
            e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
          }, (a) => null), n = r.finally(() => o.cancel());
        }
      }
      try {
        const r = yield n;
        return this.setChildren(e, r, t, i);
      } catch (r) {
        if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), ku(r))
          return [];
        throw r;
      } finally {
        e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
      }
    });
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    if (t)
      return t;
    const i = this.dataSource.getChildren(e.element);
    return Rv(i) ? this.processChildren(i) : (t = I2(() => mr(this, void 0, void 0, function* () {
      return this.processChildren(yield i);
    })), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(ct));
  }
  setChildren(e, t, i, n) {
    const r = [...t];
    if (e.children.length === 0 && r.length === 0)
      return [];
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const h of e.children)
      if (o.set(h.element, h), this.identityProvider) {
        const u = this.tree.isCollapsed(h);
        a.set(h.id, { node: h, collapsed: u });
      }
    const l = [], c = r.map((h) => {
      const u = !!this.dataSource.hasChildren(h);
      if (!this.identityProvider) {
        const _ = e_({ element: h, parent: e, hasChildren: u });
        return u && this.collapseByDefault && !this.collapseByDefault(h) && (_.collapsedByDefault = !1, l.push(_)), _;
      }
      const d = this.identityProvider.getId(h).toString(), f = a.get(d);
      if (f) {
        const _ = f.node;
        return o.delete(_.element), this.nodes.delete(_.element), this.nodes.set(h, _), _.element = h, _.hasChildren = u, i ? f.collapsed ? (_.children.forEach((b) => x0(b, (v) => this.nodes.delete(v.element))), _.children.splice(0, _.children.length), _.stale = !0) : l.push(_) : u && this.collapseByDefault && !this.collapseByDefault(h) && (_.collapsedByDefault = !1, l.push(_)), _;
      }
      const m = e_({ element: h, parent: e, id: d, hasChildren: u });
      return n && n.viewState.focus && n.viewState.focus.indexOf(d) > -1 && n.focus.push(m), n && n.viewState.selection && n.viewState.selection.indexOf(d) > -1 && n.selection.push(m), n && n.viewState.expanded && n.viewState.expanded.indexOf(d) > -1 ? l.push(m) : u && this.collapseByDefault && !this.collapseByDefault(h) && (m.collapsedByDefault = !1, l.push(m)), m;
    });
    for (const h of o.values())
      x0(h, (u) => this.nodes.delete(u.element));
    for (const h of c)
      this.nodes.set(h.element, h);
    return e.children.splice(0, e.children.length, ...c), e !== this.root && this.autoExpandSingleChildren && c.length === 1 && l.length === 0 && (c[0].collapsedByDefault = !1, l.push(c[0])), l;
  }
  render(e, t, i) {
    const n = e.children.map((o) => this.asTreeElement(o, t)), r = i && Object.assign(Object.assign({}, i), { diffIdentityProvider: i.diffIdentityProvider && {
      getId(o) {
        return i.diffIdentityProvider.getId(o.element);
      }
    } });
    this.tree.setChildren(e === this.root ? null : e, n, r), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : i = e.collapsedByDefault, e.collapsedByDefault = void 0, {
      element: e,
      children: e.hasChildren ? ge.map(e.children, (n) => this.asTreeElement(n, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose();
  }
}
class ZC {
  constructor(e) {
    this.node = e;
  }
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new ZC(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
class FB {
  constructor(e, t, i, n) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderCompressedElements(e, t, i, n) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...g.treeItemLoading.classNamesArray), !0) : (t.classList.remove(...g.treeItemLoading.classNamesArray), !1);
  }
  disposeElement(e, t, i, n) {
    var r, o;
    (o = (r = this.renderer).disposeElement) === null || o === void 0 || o.call(r, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeCompressedElements(e, t, i, n) {
    var r, o;
    (o = (r = this.renderer).disposeCompressedElements) === null || o === void 0 || o.call(r, this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = je(this.disposables);
  }
}
function BB(s) {
  const e = s && Rx(s);
  return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(t) {
    return s.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
  } }) });
}
class VB extends Px {
  constructor(e, t, i, n, r, o, a = {}) {
    super(e, t, i, r, o, a), this.compressionDelegate = n, this.compressibleNodeMapper = new zC((l) => new ZC(l)), this.filter = a.filter;
  }
  createTree(e, t, i, n, r) {
    const o = new $C(i), a = n.map((c) => new FB(c, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = BB(r) || {};
    return new Ax(e, t, o, a, l);
  }
  asTreeElement(e, t) {
    return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(e.element) }, super.asTreeElement(e, t));
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t) {
    if (!this.identityProvider)
      return super.render(e, t);
    const i = (d) => this.identityProvider.getId(d).toString(), n = (d) => {
      const f = /* @__PURE__ */ new Set();
      for (const m of d) {
        const _ = this.tree.getCompressedTreeNode(m === this.root ? null : m);
        if (!!_.element)
          for (const b of _.element.elements)
            f.add(i(b.element));
      }
      return f;
    }, r = n(this.tree.getSelection()), o = n(this.tree.getFocus());
    super.render(e, t);
    const a = this.getSelection();
    let l = !1;
    const c = this.getFocus();
    let h = !1;
    const u = (d) => {
      const f = d.element;
      if (f)
        for (let m = 0; m < f.elements.length; m++) {
          const _ = i(f.elements[m].element), b = f.elements[f.elements.length - 1].element;
          r.has(_) && a.indexOf(b) === -1 && (a.push(b), l = !0), o.has(_) && c.indexOf(b) === -1 && (c.push(b), h = !0);
        }
      d.children.forEach(u);
    };
    u(this.tree.getCompressedTreeNode(e === this.root ? null : e)), l && this.setSelection(a), h && this.setFocus(c);
  }
  processChildren(e) {
    return this.filter && (e = ge.filter(e, (t) => {
      const i = this.filter.filter(t, 1), n = WB(i);
      if (n === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return n === 1;
    })), super.processChildren(e);
  }
}
function WB(s) {
  return typeof s == "boolean" ? s ? 1 : 0 : UC(s) ? fu(s.visibility) : fu(s);
}
class HB extends Nx {
  constructor(e, t, i, n, r, o = {}) {
    super(e, t, i, n, o), this.user = e, this.dataSource = r, this.identityProvider = o.identityProvider;
  }
  createModel(e, t, i) {
    return new jC(e, t, i);
  }
}
new ie("isMac", Ie, p("isMac", "Whether the operating system is macOS"));
new ie("isLinux", _i, p("isLinux", "Whether the operating system is Linux"));
new ie("isWindows", Vi, p("isWindows", "Whether the operating system is Windows"));
new ie("isWeb", rc, p("isWeb", "Whether the platform is a web browser"));
new ie("isMacNative", Ie && !rc, p("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
new ie("isIOS", Ml, p("isIOS", "Whether the operating system is iOS"));
new ie("isDevelopment", !1, !0);
new ie("productQualityType", "", p("productQualityType", "Quality type of VS Code"));
const Ox = "inputFocus";
new ie(Ox, !1, p("inputFocus", "Whether keyboard focus is inside an input box"));
var ws = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, pe = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Ss = Se("listService");
let I0 = class {
  constructor(e) {
    this._themeService = e, this.disposables = new le(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  setLastFocusedList(e) {
    var t, i;
    e !== this._lastFocusedWidget && ((t = this._lastFocusedWidget) === null || t === void 0 || t.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, (i = this._lastFocusedWidget) === null || i === void 0 || i.getHTMLElement().classList.add("last-focused"));
  }
  register(e, t) {
    if (!this._hasCreatedStyleController) {
      this._hasCreatedStyleController = !0;
      const n = new xx(Vn(), "");
      this.disposables.add(Jl(n, this._themeService));
    }
    if (this.lists.some((n) => n.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), e.getHTMLElement() === document.activeElement && this.setLastFocusedList(e), zr(e.onDidFocus(() => this.setLastFocusedList(e)), ze(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
};
I0 = ws([
  pe(0, vt)
], I0);
const Fx = new ie("listFocus", !0), wm = new ie("listSupportsMultiselect", !0);
Ut.and(Fx, Ut.not(Ox));
const YC = new ie("listHasSelectionOrFocus", !1), QC = new ie("listDoubleSelection", !1), XC = new ie("listMultiSelection", !1), Sm = new ie("listSelectionNavigation", !1), zB = new ie("listSupportsFind", !0), UB = new ie("treeElementCanCollapse", !1), $B = new ie("treeElementHasParent", !1), jB = new ie("treeElementCanExpand", !1), KB = new ie("treeElementHasChild", !1), qB = new ie("treeFindOpen", !1), Bx = "listTypeNavigationMode", Vx = "listAutomaticKeyboardNavigation";
function ym(s, e) {
  const t = s.createScoped(e.getHTMLElement());
  return Fx.bindTo(t), t;
}
const pa = "workbench.list.multiSelectModifier", N0 = "workbench.list.openMode", nn = "workbench.list.horizontalScrolling", JC = "workbench.list.defaultFindMode", ev = "workbench.list.keyboardNavigation", pu = "workbench.tree.indent", ug = "workbench.tree.renderIndentGuides", Hn = "workbench.list.smoothScrolling", ms = "workbench.list.mouseWheelScrollSensitivity", ps = "workbench.list.fastScrollSensitivity", dg = "workbench.tree.expandMode";
function _s(s) {
  return s.getValue(pa) === "alt";
}
class GB extends z {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = _s(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(pa) && (this.useAltAsMultipleSelectionModifier = _s(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : kx(e);
  }
  isSelectionRangeChangeEvent(e) {
    return Dx(e);
  }
}
function Lm(s, e) {
  var t;
  const i = s.get(gt), n = s.get(co), r = new le();
  return [Object.assign(Object.assign({}, e), { keyboardNavigationDelegate: { mightProducePrintableCharacter(a) {
    return n.mightProducePrintableCharacter(a);
  } }, smoothScrolling: Boolean(i.getValue(Hn)), mouseWheelScrollSensitivity: i.getValue(ms), fastScrollSensitivity: i.getValue(ps), multipleSelectionController: (t = e.multipleSelectionController) !== null && t !== void 0 ? t : r.add(new GB(i)), keyboardNavigationEventFilter: QB(n) }), r];
}
let T0 = class extends ar {
  constructor(e, t, i, n, r, o, a, l, c, h) {
    const u = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : Boolean(c.getValue(nn)), [d, f] = h.invokeFunction(Lm, r);
    super(e, t, i, n, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, kn(l.getColorTheme(), mm)), d), { horizontalScrolling: u })), this.disposables.add(f), this.contextKeyService = ym(o, this), this.themeService = l, this.listSupportsMultiSelect = wm.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== !1), Sm.bindTo(this.contextKeyService).set(Boolean(r.selectionNavigation)), this.listHasSelectionOrFocus = YC.bindTo(this.contextKeyService), this.listDoubleSelection = QC.bindTo(this.contextKeyService), this.listMultiSelection = XC.bindTo(this.contextKeyService), this.horizontalScrolling = r.horizontalScrolling, this._useAltAsMultipleSelectionModifier = _s(c), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), r.overrideStyles && this.updateStyles(r.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const _ = this.getSelection(), b = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(_.length > 0 || b.length > 0), this.listMultiSelection.set(_.length > 1), this.listDoubleSelection.set(_.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const _ = this.getSelection(), b = this.getFocus();
      this.listHasSelectionOrFocus.set(_.length > 0 || b.length > 0);
    })), this.disposables.add(c.onDidChangeConfiguration((_) => {
      _.affectsConfiguration(pa) && (this._useAltAsMultipleSelectionModifier = _s(c));
      let b = {};
      if (_.affectsConfiguration(nn) && this.horizontalScrolling === void 0) {
        const v = Boolean(c.getValue(nn));
        b = Object.assign(Object.assign({}, b), { horizontalScrolling: v });
      }
      if (_.affectsConfiguration(Hn)) {
        const v = Boolean(c.getValue(Hn));
        b = Object.assign(Object.assign({}, b), { smoothScrolling: v });
      }
      if (_.affectsConfiguration(ms)) {
        const v = c.getValue(ms);
        b = Object.assign(Object.assign({}, b), { mouseWheelScrollSensitivity: v });
      }
      if (_.affectsConfiguration(ps)) {
        const v = c.getValue(ps);
        b = Object.assign(Object.assign({}, b), { fastScrollSensitivity: v });
      }
      Object.keys(b).length > 0 && this.updateOptions(b);
    })), this.navigator = new Wx(this, Object.assign({ configurationService: c }, r)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = Jl(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), super.dispose();
  }
};
T0 = ws([
  pe(5, Qe),
  pe(6, Ss),
  pe(7, vt),
  pe(8, gt),
  pe(9, It)
], T0);
let _L = class extends lB {
  constructor(e, t, i, n, r, o, a, l, c, h) {
    const u = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : Boolean(c.getValue(nn)), [d, f] = h.invokeFunction(Lm, r);
    super(e, t, i, n, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, kn(l.getColorTheme(), mm)), d), { horizontalScrolling: u })), this.disposables = new le(), this.disposables.add(f), this.contextKeyService = ym(o, this), this.themeService = l, this.horizontalScrolling = r.horizontalScrolling, this.listSupportsMultiSelect = wm.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== !1), Sm.bindTo(this.contextKeyService).set(Boolean(r.selectionNavigation)), this._useAltAsMultipleSelectionModifier = _s(c), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), r.overrideStyles && this.updateStyles(r.overrideStyles), r.overrideStyles && this.disposables.add(Jl(this, l, r.overrideStyles)), this.disposables.add(c.onDidChangeConfiguration((_) => {
      _.affectsConfiguration(pa) && (this._useAltAsMultipleSelectionModifier = _s(c));
      let b = {};
      if (_.affectsConfiguration(nn) && this.horizontalScrolling === void 0) {
        const v = Boolean(c.getValue(nn));
        b = Object.assign(Object.assign({}, b), { horizontalScrolling: v });
      }
      if (_.affectsConfiguration(Hn)) {
        const v = Boolean(c.getValue(Hn));
        b = Object.assign(Object.assign({}, b), { smoothScrolling: v });
      }
      if (_.affectsConfiguration(ms)) {
        const v = c.getValue(ms);
        b = Object.assign(Object.assign({}, b), { mouseWheelScrollSensitivity: v });
      }
      if (_.affectsConfiguration(ps)) {
        const v = c.getValue(ps);
        b = Object.assign(Object.assign({}, b), { fastScrollSensitivity: v });
      }
      Object.keys(b).length > 0 && this.updateOptions(b);
    })), this.navigator = new Wx(this, Object.assign({ configurationService: c }, r)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = Jl(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
  }
};
_L = ws([
  pe(5, Qe),
  pe(6, Ss),
  pe(7, vt),
  pe(8, gt),
  pe(9, It)
], _L);
let bL = class extends vm {
  constructor(e, t, i, n, r, o, a, l, c, h, u) {
    const d = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : Boolean(h.getValue(nn)), [f, m] = u.invokeFunction(Lm, o);
    super(e, t, i, n, r, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, kn(c.getColorTheme(), mm)), f), { horizontalScrolling: d })), this.disposables.add(m), this.contextKeyService = ym(a, this), this.themeService = c, this.listSupportsMultiSelect = wm.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), Sm.bindTo(this.contextKeyService).set(Boolean(o.selectionNavigation)), this.listHasSelectionOrFocus = YC.bindTo(this.contextKeyService), this.listDoubleSelection = QC.bindTo(this.contextKeyService), this.listMultiSelection = XC.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = _s(h), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const b = this.getSelection(), v = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(b.length > 0 || v.length > 0), this.listMultiSelection.set(b.length > 1), this.listDoubleSelection.set(b.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const b = this.getSelection(), v = this.getFocus();
      this.listHasSelectionOrFocus.set(b.length > 0 || v.length > 0);
    })), this.disposables.add(h.onDidChangeConfiguration((b) => {
      b.affectsConfiguration(pa) && (this._useAltAsMultipleSelectionModifier = _s(h));
      let v = {};
      if (b.affectsConfiguration(nn) && this.horizontalScrolling === void 0) {
        const C = Boolean(h.getValue(nn));
        v = Object.assign(Object.assign({}, v), { horizontalScrolling: C });
      }
      if (b.affectsConfiguration(Hn)) {
        const C = Boolean(h.getValue(Hn));
        v = Object.assign(Object.assign({}, v), { smoothScrolling: C });
      }
      if (b.affectsConfiguration(ms)) {
        const C = h.getValue(ms);
        v = Object.assign(Object.assign({}, v), { mouseWheelScrollSensitivity: C });
      }
      if (b.affectsConfiguration(ps)) {
        const C = h.getValue(ps);
        v = Object.assign(Object.assign({}, v), { fastScrollSensitivity: C });
      }
      Object.keys(v).length > 0 && this.updateOptions(v);
    })), this.navigator = new ZB(this, Object.assign({ configurationService: h }, o)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = Jl(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
  }
};
bL = ws([
  pe(6, Qe),
  pe(7, Ss),
  pe(8, vt),
  pe(9, gt),
  pe(10, It)
], bL);
class tv extends z {
  constructor(e, t) {
    var i;
    super(), this.widget = e, this._onDidOpen = this._register(new A()), this.onDidOpen = this._onDidOpen.event, this._register(Q.filter(this.widget.onDidChangeSelection, (n) => n.browserEvent instanceof KeyboardEvent)((n) => this.onSelectionFromKeyboard(n))), this._register(this.widget.onPointer((n) => this.onPointer(n.element, n.browserEvent))), this._register(this.widget.onMouseDblClick((n) => this.onMouseDblClick(n.element, n.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t == null ? void 0 : t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(N0)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration(() => {
      this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(N0)) !== "doubleClick";
    }))) : this.openOnSingleClick = (i = t == null ? void 0 : t.openOnSingleClick) !== null && i !== void 0 ? i : !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, n = typeof t.pinned == "boolean" ? t.pinned : !i, r = !1;
    this._open(this.getSelectedElement(), i, n, r, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const n = t.button === 1, r = !0, o = n, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, r, o, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const r = !1, o = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, r, o, a, t);
  }
  _open(e, t, i, n, r) {
    !e || this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: n,
      element: e,
      browserEvent: r
    });
  }
}
class Wx extends tv {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class ZB extends tv {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class YB extends tv {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    var e;
    return (e = this.widget.getSelection()[0]) !== null && e !== void 0 ? e : void 0;
  }
}
function QB(s) {
  let e = !1;
  return (t) => {
    if (t.toKeybinding().isModifierKey())
      return !1;
    if (e)
      return e = !1, !1;
    const i = s.softDispatch(t, t.target);
    return i != null && i.enterChord ? (e = !0, !1) : (e = !1, !i);
  };
}
let CL = class extends qC {
  constructor(e, t, i, n, r, o, a, l, c, h) {
    const { options: u, getTypeNavigationMode: d, disposable: f } = o.invokeFunction(zu, r);
    super(e, t, i, n, u), this.disposables.add(f), this.internals = new na(this, r, d, r.overrideStyles, a, l, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
CL = ws([
  pe(5, It),
  pe(6, Qe),
  pe(7, Ss),
  pe(8, vt),
  pe(9, gt)
], CL);
let vL = class extends Ax {
  constructor(e, t, i, n, r, o, a, l, c, h) {
    const { options: u, getTypeNavigationMode: d, disposable: f } = o.invokeFunction(zu, r);
    super(e, t, i, n, u), this.disposables.add(f), this.internals = new na(this, r, d, r.overrideStyles, a, l, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
vL = ws([
  pe(5, It),
  pe(6, Qe),
  pe(7, Ss),
  pe(8, vt),
  pe(9, gt)
], vL);
let wL = class extends HB {
  constructor(e, t, i, n, r, o, a, l, c, h, u) {
    const { options: d, getTypeNavigationMode: f, disposable: m } = a.invokeFunction(zu, o);
    super(e, t, i, n, r, d), this.disposables.add(m), this.internals = new na(this, o, f, o.overrideStyles, l, c, h, u), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
wL = ws([
  pe(6, It),
  pe(7, Qe),
  pe(8, Ss),
  pe(9, vt),
  pe(10, gt)
], wL);
let SL = class extends Px {
  constructor(e, t, i, n, r, o, a, l, c, h, u) {
    const { options: d, getTypeNavigationMode: f, disposable: m } = a.invokeFunction(zu, o);
    super(e, t, i, n, r, d), this.disposables.add(m), this.internals = new na(this, o, f, o.overrideStyles, l, c, h, u), this.disposables.add(this.internals);
  }
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
SL = ws([
  pe(6, It),
  pe(7, Qe),
  pe(8, Ss),
  pe(9, vt),
  pe(10, gt)
], SL);
let yL = class extends VB {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d) {
    const { options: f, getTypeNavigationMode: m, disposable: _ } = l.invokeFunction(zu, a);
    super(e, t, i, n, r, o, f), this.disposables.add(_), this.internals = new na(this, a, m, a.overrideStyles, c, h, u, d), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
yL = ws([
  pe(7, It),
  pe(8, Qe),
  pe(9, Ss),
  pe(10, vt),
  pe(11, gt)
], yL);
function Hx(s) {
  const e = s.getValue(JC);
  if (e === "highlight")
    return ss.Highlight;
  if (e === "filter")
    return ss.Filter;
  const t = s.getValue(ev);
  if (t === "simple" || t === "highlight")
    return ss.Highlight;
  if (t === "filter")
    return ss.Filter;
}
function zu(s, e) {
  var t;
  const i = s.get(gt), n = s.get(um), r = s.get(Qe), o = s.get(It), a = () => {
    const d = r.getContextKeyValue(Bx);
    if (d === "automatic")
      return Qr.Automatic;
    if (d === "trigger" || r.getContextKeyValue(Vx) === !1)
      return Qr.Trigger;
  }, l = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : Boolean(i.getValue(nn)), [c, h] = o.invokeFunction(Lm, e), u = e.additionalScrollHeight;
  return {
    getTypeNavigationMode: a,
    disposable: h,
    options: Object.assign(Object.assign({
      keyboardSupport: !1
    }, c), {
      indent: typeof i.getValue(pu) == "number" ? i.getValue(pu) : void 0,
      renderIndentGuides: i.getValue(ug),
      smoothScrolling: Boolean(i.getValue(Hn)),
      defaultFindMode: Hx(i),
      horizontalScrolling: l,
      additionalScrollHeight: u,
      hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements,
      expandOnlyOnTwistieClick: (t = e.expandOnlyOnTwistieClick) !== null && t !== void 0 ? t : i.getValue(dg) === "doubleClick",
      contextViewProvider: n
    })
  };
}
let na = class {
  constructor(e, t, i, n, r, o, a, l) {
    var c;
    this.tree = e, this.themeService = a, this.disposables = [], this.contextKeyService = ym(r, e), this.listSupportsMultiSelect = wm.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== !1), Sm.bindTo(this.contextKeyService).set(Boolean(t.selectionNavigation)), this.listSupportFindWidget = zB.bindTo(this.contextKeyService), this.listSupportFindWidget.set((c = t.findWidgetEnabled) !== null && c !== void 0 ? c : !0), this.hasSelectionOrFocus = YC.bindTo(this.contextKeyService), this.hasDoubleSelection = QC.bindTo(this.contextKeyService), this.hasMultiSelection = XC.bindTo(this.contextKeyService), this.treeElementCanCollapse = UB.bindTo(this.contextKeyService), this.treeElementHasParent = $B.bindTo(this.contextKeyService), this.treeElementCanExpand = jB.bindTo(this.contextKeyService), this.treeElementHasChild = KB.bindTo(this.contextKeyService), this.treeFindOpen = qB.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = _s(l), this.updateStyleOverrides(n);
    const u = () => {
      const f = e.getFocus()[0];
      if (!f)
        return;
      const m = e.getNode(f);
      this.treeElementCanCollapse.set(m.collapsible && !m.collapsed), this.treeElementHasParent.set(!!e.getParentElement(f)), this.treeElementCanExpand.set(m.collapsible && m.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(f));
    }, d = /* @__PURE__ */ new Set();
    d.add(Bx), d.add(Vx), this.disposables.push(this.contextKeyService, o.register(e), e.onDidChangeSelection(() => {
      const f = e.getSelection(), m = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(f.length > 0 || m.length > 0), this.hasMultiSelection.set(f.length > 1), this.hasDoubleSelection.set(f.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const f = e.getSelection(), m = e.getFocus();
      this.hasSelectionOrFocus.set(f.length > 0 || m.length > 0), u();
    }), e.onDidChangeCollapseState(u), e.onDidChangeModel(u), e.onDidChangeFindOpenState((f) => this.treeFindOpen.set(f)), l.onDidChangeConfiguration((f) => {
      let m = {};
      if (f.affectsConfiguration(pa) && (this._useAltAsMultipleSelectionModifier = _s(l)), f.affectsConfiguration(pu)) {
        const _ = l.getValue(pu);
        m = Object.assign(Object.assign({}, m), { indent: _ });
      }
      if (f.affectsConfiguration(ug)) {
        const _ = l.getValue(ug);
        m = Object.assign(Object.assign({}, m), { renderIndentGuides: _ });
      }
      if (f.affectsConfiguration(Hn)) {
        const _ = Boolean(l.getValue(Hn));
        m = Object.assign(Object.assign({}, m), { smoothScrolling: _ });
      }
      if ((f.affectsConfiguration(JC) || f.affectsConfiguration(ev)) && e.updateOptions({ defaultFindMode: Hx(l) }), f.affectsConfiguration(nn) && t.horizontalScrolling === void 0) {
        const _ = Boolean(l.getValue(nn));
        m = Object.assign(Object.assign({}, m), { horizontalScrolling: _ });
      }
      if (f.affectsConfiguration(dg) && t.expandOnlyOnTwistieClick === void 0 && (m = Object.assign(Object.assign({}, m), { expandOnlyOnTwistieClick: l.getValue(dg) === "doubleClick" })), f.affectsConfiguration(ms)) {
        const _ = l.getValue(ms);
        m = Object.assign(Object.assign({}, m), { mouseWheelScrollSensitivity: _ });
      }
      if (f.affectsConfiguration(ps)) {
        const _ = l.getValue(ps);
        m = Object.assign(Object.assign({}, m), { fastScrollSensitivity: _ });
      }
      Object.keys(m).length > 0 && e.updateOptions(m);
    }), this.contextKeyService.onDidChangeContext((f) => {
      f.affectsSome(d) && e.updateOptions({ typeNavigationMode: i() });
    })), this.navigator = new YB(e, Object.assign({ configurationService: l }, t)), this.disposables.push(this.navigator);
  }
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyleOverrides(e) {
    je(this.styler), this.styler = e ? Jl(this.tree, this.themeService, e) : z.None;
  }
  dispose() {
    this.disposables = je(this.disposables), je(this.styler), this.styler = void 0;
  }
};
na = ws([
  pe(4, Qe),
  pe(5, Ss),
  pe(6, vt),
  pe(7, gt)
], na);
const XB = Ft.as(uc.Configuration);
XB.registerConfiguration({
  id: "workbench",
  order: 7,
  title: p("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [pa]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      markdownEnumDescriptions: [
        p("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        p("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: p({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [N0]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: p({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [nn]: {
      type: "boolean",
      default: !1,
      description: p("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [pu]: {
      type: "number",
      default: 8,
      minimum: 4,
      maximum: 40,
      description: p("tree indent setting", "Controls tree indentation in pixels.")
    },
    [ug]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: p("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [Hn]: {
      type: "boolean",
      default: !1,
      description: p("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [ms]: {
      type: "number",
      default: 1,
      markdownDescription: p("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
    },
    [ps]: {
      type: "number",
      default: 5,
      description: p("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
    },
    [JC]: {
      type: "string",
      enum: ["highlight", "filter"],
      enumDescriptions: [
        p("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
        p("defaultFindModeSettingKey.filter", "Filter elements when searching.")
      ],
      default: "highlight",
      description: p("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
    },
    [ev]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        p("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        p("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        p("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: p("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
      deprecated: !0,
      deprecationMessage: p("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' instead.")
    },
    [dg]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: p("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    }
  }
});
var M0;
(function(s) {
  s[s.PRESERVE = 0] = "PRESERVE", s[s.LAST = 1] = "LAST";
})(M0 || (M0 = {}));
const zx = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class JB {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), ze(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return VI([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
Ft.add(zx.Quickaccess, new JB());
const Ux = Se("quickInputService");
var eV = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, LL = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let A0 = class extends z {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = Ft.as(zx.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    var n;
    const [r, o] = this.getOrInstantiateProvider(e), a = this.visibleQuickAccess, l = a == null ? void 0 : a.descriptor;
    if (a && o && l === o) {
      e !== o.prefix && !(i != null && i.preserveValue) && (a.picker.value = e), this.adjustValueSelection(a.picker, o, i);
      return;
    }
    if (o && !(i != null && i.preserveValue)) {
      let f;
      if (a && l && l !== o) {
        const m = a.value.substr(l.prefix.length);
        m && (f = `${o.prefix}${m}`);
      }
      if (!f) {
        const m = r == null ? void 0 : r.defaultFilterValue;
        m === M0.LAST ? f = this.lastAcceptedPickerValues.get(o) : typeof m == "string" && (f = `${o.prefix}${m}`);
      }
      typeof f == "string" && (e = f);
    }
    const c = new le(), h = c.add(this.quickInputService.createQuickPick());
    h.value = e, this.adjustValueSelection(h, o, i), h.placeholder = o == null ? void 0 : o.placeholder, h.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, h.hideInput = !!h.quickNavigate && !a, (typeof (i == null ? void 0 : i.itemActivation) == "number" || (i == null ? void 0 : i.quickNavigateConfiguration)) && (h.itemActivation = (n = i == null ? void 0 : i.itemActivation) !== null && n !== void 0 ? n : Ln.SECOND), h.contextKey = o == null ? void 0 : o.contextKey, h.filterValue = (f) => f.substring(o ? o.prefix.length : 0), o != null && o.placeholder && (h.ariaLabel = o == null ? void 0 : o.placeholder);
    let u;
    t && (u = new T2(), c.add(Yo(h.onWillAccept)((f) => {
      f.veto(), h.hide();
    }))), c.add(this.registerPickerListeners(h, r, o, e));
    const d = c.add(new lc());
    if (r && c.add(r.provide(h, d.token)), Yo(h.onDidHide)(() => {
      h.selectedItems.length === 0 && d.cancel(), c.dispose(), u == null || u.complete(h.selectedItems.slice(0));
    }), h.show(), t)
      return u == null ? void 0 : u.p;
  }
  adjustValueSelection(e, t, i) {
    var n;
    let r;
    i != null && i.preserveValue ? r = [e.value.length, e.value.length] : r = [(n = t == null ? void 0 : t.prefix.length) !== null && n !== void 0 ? n : 0, e.value.length], e.valueSelection = r;
  }
  registerPickerListeners(e, t, i, n) {
    const r = new le(), o = this.visibleQuickAccess = { picker: e, descriptor: i, value: n };
    return r.add(ze(() => {
      o === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), r.add(e.onDidChangeValue((a) => {
      const [l] = this.getOrInstantiateProvider(a);
      l !== t ? this.show(a, { preserveValue: !0 }) : o.value = a;
    })), i && r.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), r;
  }
  getOrInstantiateProvider(e) {
    const t = this.registry.getQuickAccessProvider(e);
    if (!t)
      return [void 0, void 0];
    let i = this.mapProviderToDescriptor.get(t);
    return i || (i = this.instantiationService.createInstance(t.ctor), this.mapProviderToDescriptor.set(t, i)), [i, t];
  }
};
A0 = eV([
  LL(0, Ux),
  LL(1, It)
], A0);
var tV = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, zc = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let R0 = class extends nA {
  constructor(e, t, i, n, r) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.accessibilityService = n, this.layoutService = r, this.contexts = /* @__PURE__ */ new Map();
  }
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(A0))), this._quickAccess;
  }
  createController(e = this.layoutService, t) {
    const i = {
      idPrefix: "quickInput_",
      container: e.container,
      ignoreFocusOut: () => !1,
      isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),
      backKeybindingLabel: () => {
      },
      setContextKey: (r) => this.setContextKey(r),
      returnFocus: () => e.focus(),
      createList: (r, o, a, l, c) => this.instantiationService.createInstance(T0, r, o, a, l, c),
      styles: this.computeStyles()
    }, n = this._register(new Cm(Object.assign(Object.assign({}, i), t)));
    return n.layout(e.dimension, e.offset.quickPickTop), this._register(e.onDidLayout((r) => n.layout(r, e.offset.quickPickTop))), this._register(n.onShow(() => this.resetContextKeys())), this._register(n.onHide(() => this.resetContextKeys())), n;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new ie(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t == null || t.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t = {}, i = Ii.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  updateStyles() {
    this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: Object.assign({}, kn(this.theme, {
        quickInputBackground: Gw,
        quickInputForeground: FA,
        quickInputTitleBackground: BA,
        contrastBorder: ve,
        widgetShadow: Ao
      })),
      inputBox: kn(this.theme, {
        inputForeground: yD,
        inputBackground: SD,
        inputBorder: LD,
        inputValidationInfoBackground: kD,
        inputValidationInfoForeground: DD,
        inputValidationInfoBorder: ED,
        inputValidationWarningBackground: xD,
        inputValidationWarningForeground: ID,
        inputValidationWarningBorder: ND,
        inputValidationErrorBackground: TD,
        inputValidationErrorForeground: MD,
        inputValidationErrorBorder: AD
      }),
      countBadge: kn(this.theme, {
        badgeBackground: qc,
        badgeForeground: Gc,
        badgeBorder: ve
      }),
      button: kn(this.theme, {
        buttonForeground: Kc,
        buttonBackground: M1,
        buttonHoverBackground: IA,
        buttonBorder: ve
      }),
      progressBar: kn(this.theme, {
        progressBarBackground: NA
      }),
      keybindingLabel: kn(this.theme, {
        keybindingLabelBackground: HA,
        keybindingLabelForeground: zA,
        keybindingLabelBorder: UA,
        keybindingLabelBottomBorder: $A,
        keybindingLabelShadow: Ao
      }),
      list: kn(this.theme, {
        listBackground: Gw,
        listInactiveFocusForeground: w7,
        listInactiveSelectionIconForeground: S7,
        listInactiveFocusBackground: y7,
        listFocusOutline: ht,
        listInactiveFocusOutline: ht,
        pickerGroupBorder: WA,
        pickerGroupForeground: VA
      })
    };
  }
};
R0 = tV([
  zc(0, It),
  zc(1, Qe),
  zc(2, vt),
  zc(3, ha),
  zc(4, vc)
], R0);
var $x = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, To = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let P0 = class extends R0 {
  constructor(e, t, i, n, r, o) {
    super(t, i, n, r, new r0(e.getContainerDomNode(), o)), this.host = void 0;
    const a = tc.get(e);
    if (a) {
      const l = a.widget;
      this.host = {
        _serviceBrand: void 0,
        get hasContainer() {
          return !0;
        },
        get container() {
          return l.getDomNode();
        },
        get dimension() {
          return e.getLayoutInfo();
        },
        get onDidLayout() {
          return e.onDidLayoutChange;
        },
        focus: () => e.focus(),
        offset: { top: 0, quickPickTop: 0 }
      };
    } else
      this.host = void 0;
  }
  createController() {
    return super.createController(this.host);
  }
};
P0 = $x([
  To(1, It),
  To(2, Qe),
  To(3, vt),
  To(4, ha),
  To(5, Ct)
], P0);
let O0 = class {
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(P0, e);
      this.mapEditorToService.set(e, t), Yo(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  pick(e, t = {}, i = Ii.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
};
O0 = $x([
  To(0, It),
  To(1, Ct)
], O0);
class tc {
  constructor(e) {
    this.editor = e, this.widget = new km(this.editor);
  }
  static get(e) {
    return e.getContribution(tc.ID);
  }
  dispose() {
    this.widget.dispose();
  }
}
tc.ID = "editor.controller.quickInput";
class km {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return km.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return { preference: 2 };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
}
km.ID = "editor.contrib.quickInputWidget";
_D(tc.ID, tc);
class iV {
  constructor(e, t, i, n, r) {
    this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = r;
  }
}
function nV(s) {
  if (!s || !Array.isArray(s))
    return [];
  const e = [];
  let t = 0;
  for (let i = 0, n = s.length; i < n; i++) {
    const r = s[i];
    let o = -1;
    if (typeof r.fontStyle == "string") {
      o = 0;
      const c = r.fontStyle.split(" ");
      for (let h = 0, u = c.length; h < u; h++)
        switch (c[h]) {
          case "italic":
            o = o | 1;
            break;
          case "bold":
            o = o | 2;
            break;
          case "underline":
            o = o | 4;
            break;
          case "strikethrough":
            o = o | 8;
            break;
        }
    }
    let a = null;
    typeof r.foreground == "string" && (a = r.foreground);
    let l = null;
    typeof r.background == "string" && (l = r.background), e[t++] = new iV(r.token || "", i, o, a, l);
  }
  return e;
}
function sV(s, e) {
  s.sort((h, u) => {
    const d = cV(h.token, u.token);
    return d !== 0 ? d : h.index - u.index;
  });
  let t = 0, i = "000000", n = "ffffff";
  for (; s.length >= 1 && s[0].token === ""; ) {
    const h = s.shift();
    h.fontStyle !== -1 && (t = h.fontStyle), h.foreground !== null && (i = h.foreground), h.background !== null && (n = h.background);
  }
  const r = new oV();
  for (const h of e)
    r.getId(h);
  const o = r.getId(i), a = r.getId(n), l = new iv(t, o, a), c = new nv(l);
  for (let h = 0, u = s.length; h < u; h++) {
    const d = s[h];
    c.insert(d.token, d.fontStyle, r.getId(d.foreground), r.getId(d.background));
  }
  return new jx(r, c);
}
const rV = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class oV {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(rV);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = R.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class jx {
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(nV(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return sV(e, t);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      const n = this._match(t), r = lV(t);
      i = (n.metadata | r << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const aV = /\b(comment|string|regex|regexp)\b/;
function lV(s) {
  const e = s.match(aV);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function cV(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
class iv {
  constructor(e, t, i) {
    this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new iv(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
}
class nv {
  constructor(e) {
    this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    const t = e.indexOf(".");
    let i, n;
    t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
    const r = this._children.get(i);
    return typeof r < "u" ? r.match(n) : this._mainRule;
  }
  insert(e, t, i, n) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, n);
      return;
    }
    const r = e.indexOf(".");
    let o, a;
    r === -1 ? (o = e, a = "") : (o = e.substring(0, r), a = e.substring(r + 1));
    let l = this._children.get(o);
    typeof l > "u" && (l = new nv(this._mainRule.clone()), this._children.set(o, l)), l.insert(a, t, i, n);
  }
}
function hV(s) {
  const e = [];
  for (let t = 1, i = s.length; t < i; t++) {
    const n = s[t];
    e[t] = `.mtk${t} { color: ${n}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
}
const uV = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [$t]: "#FFFFFE",
    [mc]: "#000000",
    [Yb]: "#E5EBF1",
    [Pu]: "#D3D3D3",
    [Ou]: "#939393",
    [RD]: "#ADD6FF4D"
  }
}, dV = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [$t]: "#1E1E1E",
    [mc]: "#D4D4D4",
    [Yb]: "#3A3D41",
    [Pu]: "#404040",
    [Ou]: "#707070",
    [RD]: "#ADD6FF26"
  }
}, fV = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [$t]: "#000000",
    [mc]: "#FFFFFF",
    [Pu]: "#FFFFFF",
    [Ou]: "#FFFFFF"
  }
}, gV = {
  base: "hc-light",
  inherit: !1,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [$t]: "#FFFFFF",
    [mc]: "#292929",
    [Pu]: "#292929",
    [Ou]: "#292929"
  }
};
function mV(s) {
  const e = new A(), t = zE();
  return t.onDidChange(() => e.fire()), s == null || s.onDidProductIconThemeChange(() => e.fire()), {
    onDidChange: e.event,
    getCSS() {
      const i = s ? s.getProductIconTheme() : new Kx(), n = {}, r = (a) => {
        const l = i.getIcon(a);
        if (!l)
          return;
        const c = l.font;
        return c ? (n[c.id] = c.definition, `.codicon-${a.id}:before { content: '${l.fontCharacter}'; font-family: ${Hw(c.id)}; }`) : `.codicon-${a.id}:before { content: '${l.fontCharacter}'; }`;
      }, o = [];
      for (const a of t.getIcons()) {
        const l = r(a);
        l && o.push(l);
      }
      for (const a in n) {
        const l = n[a], c = l.weight ? `font-weight: ${l.weight};` : "", h = l.style ? `font-style: ${l.style};` : "", u = l.src.map((d) => `${D1(d.location)} format('${d.format}')`).join(", ");
        o.push(`@font-face { src: ${u}; font-family: ${Hw(a)};${c}${h} font-display: block; }`);
      }
      return o.join(`
`);
    }
  };
}
class Kx {
  getIcon(e) {
    const t = zE();
    let i = e.defaults;
    for (; ri.isThemeIcon(i); ) {
      const n = t.getIcon(i.id);
      if (!n)
        return;
      i = n.defaults;
    }
    return i;
  }
}
const Mr = "vs", Dh = "vs-dark", El = "hc-black", xl = "hc-light", qx = Ft.as(wD.ColorContribution), pV = Ft.as(uD.ThemingContribution);
class Gx {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    const i = t.base;
    e.length > 0 ? (sf(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (const t in this.themeData.colors)
        e.set(t, R.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        const t = F0(this.themeData.base);
        for (const i in t.colors)
          e.has(i) || e.set(i, R.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = qx.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return Object.prototype.hasOwnProperty.call(this.getColors(), e);
  }
  get type() {
    switch (this.base) {
      case Mr:
        return Qi.LIGHT;
      case El:
        return Qi.HIGH_CONTRAST_DARK;
      case xl:
        return Qi.HIGH_CONTRAST_LIGHT;
      default:
        return Qi.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        const r = F0(this.themeData.base);
        e = r.rules, r.encodedTokensColors && (t = r.encodedTokensColors);
      }
      const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
      if (i || n) {
        const r = { token: "" };
        i && (r.foreground = i), n && (r.background = n), e.push(r);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = jx.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const r = this.tokenTheme._match([e].concat(t).join(".")).metadata, o = ki.getForeground(r), a = ki.getFontStyle(r);
    return {
      foreground: o,
      italic: Boolean(a & 1),
      bold: Boolean(a & 2),
      underline: Boolean(a & 4),
      strikethrough: Boolean(a & 8)
    };
  }
}
function sf(s) {
  return s === Mr || s === Dh || s === El || s === xl;
}
function F0(s) {
  switch (s) {
    case Mr:
      return uV;
    case Dh:
      return dV;
    case El:
      return fV;
    case xl:
      return gV;
  }
}
function Od(s) {
  const e = F0(s);
  return new Gx(s, e);
}
class _V extends z {
  constructor() {
    super(), this._onColorThemeChange = this._register(new A()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new A()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new Kx(), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(Mr, Od(Mr)), this._knownThemes.set(Dh, Od(Dh)), this._knownThemes.set(El, Od(El)), this._knownThemes.set(xl, Od(xl));
    const e = mV(this);
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(Mr), this._onOSSchemeChanged(), e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    }), Nb("(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(e) {
    return k1(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = Vn(), this._globalStyleElement.className = "monaco-colors", this._globalStyleElement.textContent = this._allCSS, this._styleElements.push(this._globalStyleElement)), z.None;
  }
  _registerShadowDomContainer(e) {
    const t = Vn(e);
    return t.className = "monaco-colors", t.textContent = this._allCSS, this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!sf(t.base) && !sf(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new Gx(e, t)), sf(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(Mr), this._updateActualTheme(t);
  }
  _updateActualTheme(e) {
    !e || this._theme === e || (this._theme = e, this._updateThemeOrColorMap());
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const e = window.matchMedia("(forced-colors: active)").matches;
      if (e !== cs(this._theme.type)) {
        let t;
        tA(this._theme.type) ? t = e ? El : Dh : t = e ? xl : Mr, this._updateActualTheme(this._knownThemes.get(t));
      }
    }
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const e = [], t = {}, i = {
      addRule: (o) => {
        t[o] || (e.push(o), t[o] = !0);
      }
    };
    pV.getThemingParticipants().forEach((o) => o(this._theme, i, this._environment));
    const n = [];
    for (const o of qx.getColors()) {
      const a = this._theme.getColor(o.id, !0);
      a && n.push(`${yA(o.id)}: ${a.toString()};`);
    }
    i.addRule(`.monaco-editor { ${n.join(`
`)} }`);
    const r = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(hV(r)), this._themeCSS = e.join(`
`), this._updateCSS(), at.setColorMap(r), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
}
const Cn = Se("themeService");
var bV = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, i_ = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let B0 = class extends z {
  constructor(e, t, i) {
    super(), this._contextKeyService = e, this._layoutService = t, this._configurationService = i, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new A(), this._onDidChangeReducedMotion = new A(), this._accessibilityModeEnabledContext = mA.bindTo(this._contextKeyService);
    const n = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((o) => {
      o.affectsConfiguration("editor.accessibilitySupport") && (n(), this._onDidChangeScreenReaderOptimized.fire()), o.affectsConfiguration("workbench.reduceMotion") && (this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._onDidChangeReducedMotion.fire());
    })), n(), this._register(this.onDidChangeScreenReaderOptimized(() => n()));
    const r = window.matchMedia("(prefers-reduced-motion: reduce)");
    this._systemMotionReduced = r.matches, this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this.initReducedMotionListeners(r);
  }
  initReducedMotionListeners(e) {
    if (!this._layoutService.hasContainer)
      return;
    this._register(H(e, "change", () => {
      this._systemMotionReduced = e.matches, this._configMotionReduced === "auto" && this._onDidChangeReducedMotion.fire();
    }));
    const t = () => {
      const i = this.isMotionReduced();
      this._layoutService.container.classList.toggle("reduce-motion", i), this._layoutService.container.classList.toggle("enable-motion", !i);
    };
    t(), this._register(this.onDidChangeReducedMotion(() => t()));
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const e = this._configMotionReduced;
    return e === "on" || e === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
B0 = bV([
  i_(0, Qe),
  i_(1, vc),
  i_(2, gt)
], B0);
var th = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
}, ll;
(function(s) {
  s[s.None = 0] = "None", s[s.Initialized = 1] = "Initialized", s[s.Closed = 2] = "Closed";
})(ll || (ll = {}));
class Il extends z {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new A()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = ll.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = new W4(Il.DEFAULT_FLUSH_DELAY), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var t, i;
    (t = e.changed) === null || t === void 0 || t.forEach((n, r) => this.accept(r, n)), (i = e.deleted) === null || i === void 0 || i.forEach((n) => this.accept(n, void 0));
  }
  accept(e, t) {
    if (this.state === ll.Closed)
      return;
    let i = !1;
    Ki(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire(e);
  }
  get(e, t) {
    const i = this.cache.get(e);
    return Ki(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return Ki(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return Ki(i) ? t : parseInt(i, 10);
  }
  set(e, t) {
    return th(this, void 0, void 0, function* () {
      if (this.state === ll.Closed)
        return;
      if (Ki(t))
        return this.delete(e);
      const i = String(t);
      if (this.cache.get(e) !== i)
        return this.cache.set(e, i), this.pendingInserts.set(e, i), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire(e), this.doFlush();
    });
  }
  delete(e) {
    return th(this, void 0, void 0, function* () {
      if (!(this.state === ll.Closed || !this.cache.delete(e)))
        return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire(e), this.doFlush();
    });
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  flushPending() {
    return th(this, void 0, void 0, function* () {
      if (!this.hasPending)
        return;
      const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
      return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
        var t;
        if (!this.hasPending)
          for (; this.whenFlushedCallbacks.length; )
            (t = this.whenFlushedCallbacks.pop()) === null || t === void 0 || t();
      });
    });
  }
  doFlush(e) {
    return th(this, void 0, void 0, function* () {
      return this.flushDelayer.trigger(() => this.flushPending(), e);
    });
  }
  dispose() {
    this.flushDelayer.dispose(), super.dispose();
  }
}
Il.DEFAULT_FLUSH_DELAY = 100;
class n_ {
  constructor() {
    this.onDidChangeItemsExternal = Q.None, this.items = /* @__PURE__ */ new Map();
  }
  updateItems(e) {
    var t, i;
    return th(this, void 0, void 0, function* () {
      (t = e.insert) === null || t === void 0 || t.forEach((n, r) => this.items.set(r, n)), (i = e.delete) === null || i === void 0 || i.forEach((n) => this.items.delete(n));
    });
  }
}
const Fd = "__$__targetStorageMarker", sv = Se("storageService");
var kL;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SHUTDOWN = 1] = "SHUTDOWN";
})(kL || (kL = {}));
class Dm extends z {
  constructor(e = { flushInterval: Dm.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new uf()), this.onDidChangeValue = this._onDidChangeValue.event, this._onDidChangeTarget = this._register(new uf()), this._onWillSaveState = this._register(new A()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0;
  }
  emitDidChangeValue(e, t) {
    if (t === Fd) {
      switch (e) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope: e });
    } else
      this._onDidChangeValue.fire({ scope: e, key: t, target: this.getKeyTargets(e)[t] });
  }
  get(e, t, i) {
    var n;
    return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.get(e, i);
  }
  getBoolean(e, t, i) {
    var n;
    return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    var n;
    return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.getNumber(e, i);
  }
  store(e, t, i, n) {
    if (Ki(t)) {
      this.remove(e, i);
      return;
    }
    this.withPausedEmitters(() => {
      var r;
      this.updateKeyTarget(e, i, n), (r = this.getStorage(i)) === null || r === void 0 || r.set(e, t);
    });
  }
  remove(e, t) {
    this.withPausedEmitters(() => {
      var i;
      this.updateKeyTarget(e, t, void 0), (i = this.getStorage(t)) === null || i === void 0 || i.delete(e);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i) {
    var n, r;
    const o = this.getKeyTargets(t);
    typeof i == "number" ? o[e] !== i && (o[e] = i, (n = this.getStorage(t)) === null || n === void 0 || n.set(Fd, JSON.stringify(o))) : typeof o[e] == "number" && (delete o[e], (r = this.getStorage(t)) === null || r === void 0 || r.set(Fd, JSON.stringify(o)));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(1)), this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(0)), this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(-1)), this._applicationKeyTargets;
  }
  getKeyTargets(e) {
    switch (e) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(e) {
    const t = this.get(Fd, e);
    if (t)
      try {
        return JSON.parse(t);
      } catch {
      }
    return /* @__PURE__ */ Object.create(null);
  }
}
Dm.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
class CV extends Dm {
  constructor() {
    super(), this.applicationStorage = this._register(new Il(new n_())), this.profileStorage = this._register(new Il(new n_())), this.workspaceStorage = this._register(new Il(new n_())), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e))), this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
  }
  getStorage(e) {
    switch (e) {
      case -1:
        return this.applicationStorage;
      case 0:
        return this.profileStorage;
      default:
        return this.workspaceStorage;
    }
  }
}
var rv = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Nl = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let V0 = class {
  constructor(e, t) {
    this._commandService = e, this._hiddenStates = new fg(t);
  }
  createMenu(e, t, i) {
    return new W0(e, this._hiddenStates, Object.assign({ emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50 }, i), this._commandService, t, this);
  }
};
V0 = rv([
  Nl(0, an),
  Nl(1, sv)
], V0);
let fg = class ih {
  constructor(e) {
    this._storageService = e, this._disposables = new le(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._ignoreChangeEvent = !1;
    try {
      const t = e.get(ih._key, 0, "{}");
      this._data = JSON.parse(t);
    } catch {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(e.onDidChangeValue((t) => {
      if (t.key === ih._key) {
        if (!this._ignoreChangeEvent)
          try {
            const i = e.get(ih._key, 0, "{}");
            this._data = JSON.parse(i);
          } catch (i) {
            console.log("FAILED to read storage after UPDATE", i);
          }
        this._onDidChange.fire();
      }
    }));
  }
  dispose() {
    this._onDidChange.dispose(), this._disposables.dispose();
  }
  isHidden(e, t) {
    var i, n;
    return (n = (i = this._data[e.id]) === null || i === void 0 ? void 0 : i.includes(t)) !== null && n !== void 0 ? n : !1;
  }
  updateHidden(e, t, i) {
    const n = this._data[e.id];
    if (i)
      n ? n.indexOf(t) < 0 && n.push(t) : this._data[e.id] = [t];
    else if (n) {
      const r = n.indexOf(t);
      r >= 0 && OI(n, r), n.length === 0 && delete this._data[e.id];
    }
    this._persist();
  }
  _persist() {
    try {
      this._ignoreChangeEvent = !0;
      const e = JSON.stringify(this._data);
      this._storageService.store(ih._key, e, 0, 0);
    } finally {
      this._ignoreChangeEvent = !1;
    }
  }
};
fg._key = "menu.hiddenCommands";
fg = rv([
  Nl(0, sv)
], fg);
let W0 = class za {
  constructor(e, t, i, n, r, o) {
    this._id = e, this._hiddenStates = t, this._options = i, this._commandService = n, this._contextKeyService = r, this._menuService = o, this._disposables = new le(), this._menuGroups = [], this._contextKeys = /* @__PURE__ */ new Set(), this._build();
    const a = new oi(() => {
      this._build(), this._onDidChange.fire(this);
    }, i.eventDebounceDelay);
    this._disposables.add(a), this._disposables.add(_l.onDidChangeMenu((h) => {
      h.has(e) && a.schedule();
    }));
    const l = this._disposables.add(new le()), c = () => {
      const h = new oi(() => this._onDidChange.fire(this), i.eventDebounceDelay);
      l.add(h), l.add(r.onDidChangeContext((u) => {
        u.affectsSome(this._contextKeys) && h.schedule();
      })), l.add(t.onDidChange(() => {
        h.schedule();
      }));
    };
    this._onDidChange = new A({
      onFirstListenerAdd: c,
      onLastListenerRemove: l.clear.bind(l)
    }), this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose();
  }
  _build() {
    this._menuGroups.length = 0, this._contextKeys.clear();
    const e = _l.getMenuItems(this._id);
    let t;
    e.sort(za._compareMenuItems);
    for (const i of e) {
      const n = i.group || "";
      (!t || t[0] !== n) && (t = [n, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeys(i);
    }
  }
  _collectContextKeys(e) {
    if (za._fillInKbExprKeys(e.when, this._contextKeys), jc(e)) {
      if (e.command.precondition && za._fillInKbExprKeys(e.command.precondition, this._contextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        za._fillInKbExprKeys(t, this._contextKeys);
      }
    } else
      this._options.emitEventsForSubmenuChanges && _l.getMenuItems(e.submenu).forEach(this._collectContextKeys, this);
  }
  getActions(e) {
    const t = [];
    for (const i of this._menuGroups) {
      const [n, r] = i, o = [], a = [];
      for (const l of r)
        if (this._contextKeyService.contextMatchesRules(l.when)) {
          let c;
          if (jc(l)) {
            const u = vV(this._id, l.command, this._hiddenStates);
            c = new N1(l.command, l.alt, e, u, this._contextKeyService, this._commandService);
          } else
            c = new rA(l, this._menuService, this._contextKeyService, e), c.actions.length === 0 && (c.dispose(), c = void 0);
          c && a.push(c);
        }
      a.length > 0 && t.push([n, a]), o.length > 0;
    }
    return t;
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (const i of e.keys())
        t.add(i);
  }
  static _compareMenuItems(e, t) {
    const i = e.group, n = t.group;
    if (i !== n) {
      if (i) {
        if (!n)
          return -1;
      } else
        return 1;
      if (i === "navigation")
        return -1;
      if (n === "navigation")
        return 1;
      const a = i.localeCompare(n);
      if (a !== 0)
        return a;
    }
    const r = e.order || 0, o = t.order || 0;
    return r < o ? -1 : r > o ? 1 : za._compareTitles(jc(e) ? e.command.title : e.title, jc(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
    return i.localeCompare(n);
  }
};
W0 = rv([
  Nl(3, an),
  Nl(4, Qe),
  Nl(5, fD)
], W0);
function vV(s, e, t) {
  const i = `${s.id}/${e.id}`, n = typeof e.title == "string" ? e.title : e.title.value, r = Uw({
    id: i,
    label: p("hide.label", "Hide '{0}'", n),
    run() {
      t.updateHidden(s, e.id, !0);
    }
  }), o = Uw({
    id: i,
    label: n,
    get checked() {
      return !t.isHidden(s, e.id);
    },
    run() {
      const a = !t.isHidden(s, e.id);
      t.updateHidden(s, e.id, a);
    }
  });
  return {
    hide: r,
    toggle: o,
    get isHidden() {
      return !o.checked;
    }
  };
}
var wV = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, DL = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Fa = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
let H0 = class extends z {
  constructor(e, t) {
    super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", this.resources = [], (rr || Mb) && this.installWebKitWriteTextWorkaround();
  }
  installWebKitWriteTextWorkaround() {
    const e = () => {
      const t = new T2();
      this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, navigator.clipboard.write([new ClipboardItem({
        "text/plain": t.p
      })]).catch((i) => Fa(this, void 0, void 0, function* () {
        (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
      }));
    };
    this.layoutService.hasContainer && (this._register(H(this.layoutService.container, "click", e)), this._register(H(this.layoutService.container, "keydown", e)));
  }
  writeText(e, t) {
    return Fa(this, void 0, void 0, function* () {
      if (t) {
        this.mapTextToType.set(t, e);
        return;
      }
      if (this.webKitPendingClipboardWritePromise)
        return this.webKitPendingClipboardWritePromise.complete(e);
      try {
        return yield navigator.clipboard.writeText(e);
      } catch (r) {
        console.error(r);
      }
      const i = document.activeElement, n = document.body.appendChild(ae("textarea", { "aria-hidden": !0 }));
      n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), document.execCommand("copy"), i instanceof HTMLElement && i.focus(), document.body.removeChild(n);
    });
  }
  readText(e) {
    return Fa(this, void 0, void 0, function* () {
      if (e)
        return this.mapTextToType.get(e) || "";
      try {
        return yield navigator.clipboard.readText();
      } catch (t) {
        return console.error(t), "";
      }
    });
  }
  readFindText() {
    return Fa(this, void 0, void 0, function* () {
      return this.findText;
    });
  }
  writeFindText(e) {
    return Fa(this, void 0, void 0, function* () {
      this.findText = e;
    });
  }
  readResources() {
    return Fa(this, void 0, void 0, function* () {
      return this.resources;
    });
  }
};
H0 = wV([
  DL(0, vc),
  DL(1, ao)
], H0);
var SV = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, yV = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Eh = "data-keybinding-context";
class ov {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  get value() {
    return Object.assign({}, this._value);
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
}
class ic extends ov {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
}
ic.INSTANCE = new ic();
class _u extends ov {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = wh.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
      if (n.source === 7) {
        const r = Array.from(ge.map(this._values, ([o]) => o));
        this._values.clear(), i.fire(new xL(r));
      } else {
        const r = [];
        for (const o of n.affectedKeys) {
          const a = `config.${o}`, l = this._values.findSuperstr(a);
          l !== void 0 && (r.push(...ge.map(l, ([c]) => c)), this._values.deleteSuperstr(a)), this._values.has(a) && (r.push(a), this._values.delete(a));
        }
        i.fire(new xL(r));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(_u._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(_u._keyPrefix.length), i = this._configurationService.getValue(t);
    let n;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        n = i;
        break;
      default:
        Array.isArray(i) ? n = JSON.stringify(i) : n = i;
    }
    return this._values.set(e, n), n;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
}
_u._keyPrefix = "config.";
class LV {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class EL {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
  allKeysContainedIn(e) {
    return this.affectsSome(e);
  }
}
class xL {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.keys.every((t) => e.has(t));
  }
}
class kV {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.events.every((t) => t.allKeysContainedIn(e));
  }
}
function DV(s, e) {
  return s.allKeysContainedIn(new Set(Object.keys(e)));
}
class Zx {
  constructor(e) {
    this._onDidChangeContext = new uf({ merge: (t) => new kV(t) }), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new LV(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new EV(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return e ? e.evaluate(t) : !0;
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    !i || i.setValue(e, t) && this._onDidChangeContext.fire(new EL(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new EL(e));
  }
  getContext(e) {
    return this._isDisposed ? ic.INSTANCE : this.getContextValuesContainer(xV(e));
  }
}
let z0 = class extends Zx {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._toDispose = new le(), this._lastContextId = 0;
    const t = new _u(this._myContextId, e, this._onDidChangeContext);
    this._contexts.set(this._myContextId, t), this._toDispose.add(t);
  }
  dispose() {
    this._onDidChangeContext.dispose(), this._isDisposed = !0, this._toDispose.dispose();
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? ic.INSTANCE : this._contexts.get(e) || ic.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    const t = ++this._lastContextId;
    return this._contexts.set(t, new ov(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
z0 = SV([
  yV(0, gt)
], z0);
class EV extends Zx {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = new $k(), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(Eh)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(Eh, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const i = this._parent.getContextValuesContainer(this._myContextId).value;
      DV(e, i) || this._onDidChangeContext.fire(e);
    });
  }
  dispose() {
    this._isDisposed || (this._onDidChangeContext.dispose(), this._parent.disposeContext(this._myContextId), this._parentChangeListener.dispose(), this._domNode.removeAttribute(Eh), this._isDisposed = !0);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? ic.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function xV(s) {
  for (; s; ) {
    if (s.hasAttribute(Eh)) {
      const e = s.getAttribute(Eh);
      return e ? parseInt(e, 10) : NaN;
    }
    s = s.parentElement;
  }
  return 0;
}
function IV(s, e, t) {
  s.get(Qe).createKey(String(e), NV(t));
}
function NV(s) {
  return JI(s, (e) => {
    if (typeof e == "object" && e.$mid === 1)
      return Le.revive(e).toString();
    if (e instanceof Le)
      return e.toString();
  });
}
Bt.registerCommand(eA, IV);
Bt.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...ie.all()].sort((s, e) => s.key.localeCompare(e.key));
  },
  description: {
    description: p("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
Bt.registerCommand("_generateContextKeyInfo", function() {
  const s = [], e = /* @__PURE__ */ new Set();
  for (const t of ie.all())
    e.has(t.key) || (e.add(t.key), s.push(t));
  s.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(s, void 0, 2));
});
class TV {
  constructor(e) {
    this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map(), this.data = e;
  }
}
class MV {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (const t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
    i.outgoing.set(this._hashFn(t), n), n.incoming.set(this._hashFn(e), i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (const i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new TV(e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const e = [];
    for (const [t, i] of this._nodes)
      e.push(`${t}, (incoming)[${[...i.incoming.keys()].join(", ")}], (outgoing)[${[...i.outgoing.keys()].join(",")}]`);
    return e.join(`
`);
  }
  findCycleSlow() {
    for (const [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), n = this._findCycle(t, i);
      if (n)
        return n;
    }
  }
  _findCycle(e, t) {
    for (const [i, n] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const r = this._findCycle(n, t);
      if (r)
        return r;
      t.delete(i);
    }
  }
}
class IL extends Error {
  constructor(e) {
    var t;
    super("cyclic dependency between services"), this.message = (t = e.findCycleSlow()) !== null && t !== void 0 ? t : `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class av {
  constructor(e = new cm(), t = !1, i) {
    this._activeInstantiations = /* @__PURE__ */ new Set(), this._services = e, this._strict = t, this._parent = i, this._services.set(It, this);
  }
  createChild(e) {
    return new av(e, this._strict, this);
  }
  invokeFunction(e, ...t) {
    const i = fn.traceInvocation(e);
    let n = !1;
    try {
      return e({
        get: (o) => {
          if (n)
            throw WN("service accessor is only valid during the invocation of its target method");
          const a = this._getOrCreateServiceInstance(o, i);
          if (!a)
            throw new Error(`[invokeFunction] unknown service '${o}'`);
          return a;
        }
      }, ...t);
    } finally {
      n = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    let i, n;
    return e instanceof Yn ? (i = fn.traceCreation(e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = fn.traceCreation(e), n = this._createInstance(e, t, i)), i.stop(), n;
  }
  _createInstance(e, t = [], i) {
    const n = Nn.getServiceDependencies(e).sort((a, l) => a.index - l.index), r = [];
    for (const a of n) {
      const l = this._getOrCreateServiceInstance(a.id, i);
      l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), r.push(l);
    }
    const o = n.length > 0 ? n[0].index : t.length;
    if (t.length !== o) {
      console.trace(`[createInstance] First service dependency of ${e.name} at position ${o + 1} conflicts with ${t.length} static arguments`);
      const a = o - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, o);
    }
    return new e(...t, ...r);
  }
  _setServiceInstance(e, t) {
    if (this._services.get(e) instanceof Yn)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    const t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    const i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof Yn ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    const n = new MV((a) => a.id.toString());
    let r = 0;
    const o = [{ id: e, desc: t, _trace: i }];
    for (; o.length; ) {
      const a = o.pop();
      if (n.lookupOrInsertNode(a), r++ > 1e3)
        throw new IL(n);
      for (const l of Nn.getServiceDependencies(a.desc.ctor)) {
        const c = this._getServiceInstanceOrDescriptor(l.id);
        if (c || this._throwIfStrict(`[createInstance] ${e} depends on ${l.id} which is NOT registered.`, !0), c instanceof Yn) {
          const h = { id: l.id, desc: c, _trace: a._trace.branch(l.id, !0) };
          n.insertEdge(a, h), o.push(h);
        }
      }
    }
    for (; ; ) {
      const a = n.roots();
      if (a.length === 0) {
        if (!n.isEmpty())
          throw new IL(n);
        break;
      }
      for (const { data: l } of a) {
        if (this._getServiceInstanceOrDescriptor(l.id) instanceof Yn) {
          const h = this._createServiceInstanceWithOwner(l.id, l.desc.ctor, l.desc.staticArguments, l.desc.supportsDelayedInstantiation, l._trace);
          this._setServiceInstance(l.id, h);
        }
        n.removeNode(l);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], n, r) {
    if (this._services.get(e) instanceof Yn)
      return this._createServiceInstance(t, i, n, r);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, n, r);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t = [], i, n) {
    if (i) {
      const r = new Fg(() => this._createInstance(e, t, n));
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(o, a) {
          if (a in o)
            return o[a];
          const l = r.value;
          let c = l[a];
          return typeof c != "function" || (c = c.bind(l), o[a] = c), c;
        },
        set(o, a, l) {
          return r.value[a] = l, !0;
        }
      });
    } else
      return this._createInstance(e, t, n);
  }
  _throwIfStrict(e, t) {
    if (t && console.warn(e), this._strict)
      throw new Error(e);
  }
}
class fn {
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  static traceInvocation(e) {
    return fn._None;
  }
  static traceCreation(e) {
    return fn._None;
  }
  branch(e, t) {
    const i = new fn(2, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    const e = Date.now() - this._start;
    fn._totals += e;
    let t = !1;
    function i(r, o) {
      const a = [], l = new Array(r + 1).join("	");
      for (const [c, h, u] of o._dep)
        if (h && u) {
          t = !0, a.push(`${l}CREATES -> ${c}`);
          const d = i(r + 1, u);
          d && a.push(d);
        } else
          a.push(`${l}uses -> ${c}`);
      return a.join(`
`);
    }
    const n = [
      `${this.type === 0 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${fn._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && console.log(n.join(`
`));
  }
}
fn._None = new class extends fn {
  constructor() {
    super(-1, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
fn._totals = 0;
class AV {
  constructor() {
    this._byResource = new si(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let n = this._byResource.get(e);
    n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
    let r = this._byOwner.get(t);
    r || (r = new si(), this._byOwner.set(t, r)), r.set(e, i);
  }
  get(e, t) {
    const i = this._byResource.get(e);
    return i == null ? void 0 : i.get(t);
  }
  delete(e, t) {
    let i = !1, n = !1;
    const r = this._byResource.get(e);
    r && (i = r.delete(t));
    const o = this._byOwner.get(t);
    if (o && (n = o.delete(e)), i !== n)
      throw new Error("illegal state");
    return i && n;
  }
  values(e) {
    var t, i, n, r;
    return typeof e == "string" ? (i = (t = this._byOwner.get(e)) === null || t === void 0 ? void 0 : t.values()) !== null && i !== void 0 ? i : ge.empty() : Le.isUri(e) ? (r = (n = this._byResource.get(e)) === null || n === void 0 ? void 0 : n.values()) !== null && r !== void 0 ? r : ge.empty() : ge.map(ge.concat(...this._byOwner.values()), (o) => o[1]);
  }
}
class RV {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new si(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const n = this._resourceStats(t);
      this._add(n), this._data.set(t, n);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (e.scheme === we.inMemory || e.scheme === we.walkThrough || e.scheme === we.walkThroughSnippet || e.scheme === we.vscodeSourceControl)
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === Zi.Error ? t.errors += 1 : i === Zi.Warning ? t.warnings += 1 : i === Zi.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class kr {
  constructor() {
    this._onMarkerChanged = new YN({
      delay: 0,
      merge: kr._merge
    }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new AV(), this._stats = new RV(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (WI(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const n = [];
      for (const r of i) {
        const o = kr._toMarker(e, t, r);
        o && n.push(o);
      }
      this._data.set(t, e, n), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: n, severity: r, message: o, source: a, startLineNumber: l, startColumn: c, endLineNumber: h, endColumn: u, relatedInformation: d, tags: f } = i;
    if (!!o)
      return l = l > 0 ? l : 1, c = c > 0 ? c : 1, h = h >= l ? h : l, u = u > 0 ? u : c, {
        resource: t,
        owner: e,
        code: n,
        severity: r,
        message: o,
        source: a,
        startLineNumber: l,
        startColumn: c,
        endLineNumber: h,
        endColumn: u,
        relatedInformation: d,
        tags: f
      };
  }
  changeAll(e, t) {
    const i = [], n = this._data.values(e);
    if (n)
      for (const r of n) {
        const o = ge.first(r);
        o && (i.push(o.resource), this._data.delete(o.resource, e));
      }
    if (Lg(t)) {
      const r = new si();
      for (const { resource: o, marker: a } of t) {
        const l = kr._toMarker(e, o, a);
        if (!l)
          continue;
        const c = r.get(o);
        c ? c.push(l) : (r.set(o, [l]), i.push(o));
      }
      for (const [o, a] of r)
        this._data.set(o, e, a);
    }
    i.length > 0 && this._onMarkerChanged.fire(i);
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: n, take: r } = e;
    if ((!r || r < 0) && (r = -1), t && i) {
      const o = this._data.get(i, t);
      if (o) {
        const a = [];
        for (const l of o)
          if (kr._accept(l, n)) {
            const c = a.push(l);
            if (r > 0 && c === r)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const o = [];
      for (const a of this._data.values())
        for (const l of a)
          if (kr._accept(l, n)) {
            const c = o.push(l);
            if (r > 0 && c === r)
              return o;
          }
      return o;
    } else {
      const o = this._data.values(i != null ? i : t), a = [];
      for (const l of o)
        for (const c of l)
          if (kr._accept(c, n)) {
            const h = a.push(c);
            if (r > 0 && h === r)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  static _merge(e) {
    const t = new si();
    for (const i of e)
      for (const n of i)
        t.set(n, !0);
    return Array.from(t.keys());
  }
}
function Yx(s, e, t, i, n, r) {
  if (Array.isArray(s)) {
    let o = 0;
    for (const a of s) {
      const l = Yx(a, e, t, i, n, r);
      if (l === 10)
        return l;
      l > o && (o = l);
    }
    return o;
  } else {
    if (typeof s == "string")
      return i ? s === "*" ? 5 : s === t ? 10 : 0 : 0;
    if (s) {
      const { language: o, pattern: a, scheme: l, hasAccessToAllModels: c, notebookType: h } = s;
      if (!i && !c)
        return 0;
      h && n && (e = n);
      let u = 0;
      if (l)
        if (l === e.scheme)
          u = 10;
        else if (l === "*")
          u = 5;
        else
          return 0;
      if (o)
        if (o === t)
          u = 10;
        else if (o === "*")
          u = Math.max(u, 5);
        else
          return 0;
      if (h)
        if (h === r)
          u = 10;
        else if (h === "*" && r !== void 0)
          u = Math.max(u, 5);
        else
          return 0;
      if (a) {
        let d;
        if (typeof a == "string" ? d = a : d = Object.assign(Object.assign({}, a), { base: Yk(a.base) }), d === e.fsPath || I6(d, e.fsPath))
          u = 10;
        else
          return 0;
      }
      return u;
    } else
      return 0;
  }
}
function Qx(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.every(Qx) : !!s.exclusive;
}
class NL {
  constructor(e, t, i, n) {
    this.uri = e, this.languageId = t, this.notebookUri = i, this.notebookType = n;
  }
  equals(e) {
    var t, i;
    return this.notebookType === e.notebookType && this.languageId === e.languageId && this.uri.toString() === e.uri.toString() && ((t = this.notebookUri) === null || t === void 0 ? void 0 : t.toString()) === ((i = e.notebookUri) === null || i === void 0 ? void 0 : i.toString());
  }
}
class $e {
  constructor(e) {
    this._notebookInfoResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new A(), this.onDidChange = this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), ze(() => {
      if (i) {
        const n = this._entries.indexOf(i);
        n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e);
    const t = [];
    for (const i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e) {
    const t = [];
    return this._orderedForEach(e, (i) => t.push(i.provider)), t;
  }
  orderedGroups(e) {
    const t = [];
    let i, n;
    return this._orderedForEach(e, (r) => {
      i && n === r._score ? i.push(r.provider) : (n = r._score, i = [r.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t) {
    this._updateScores(e);
    for (const i of this._entries)
      i._score > 0 && t(i);
  }
  _updateScores(e) {
    var t, i;
    const n = (t = this._notebookInfoResolver) === null || t === void 0 ? void 0 : t.call(this, e.uri), r = n ? new NL(e.uri, e.getLanguageId(), n.uri, n.type) : new NL(e.uri, e.getLanguageId(), void 0, void 0);
    if (!(!((i = this._lastCandidate) === null || i === void 0) && i.equals(r))) {
      this._lastCandidate = r;
      for (const o of this._entries)
        if (o._score = Yx(o.selector, r.uri, r.languageId, XT(e), r.notebookUri, r.notebookType), Qx(o.selector) && o._score > 0) {
          for (const a of this._entries)
            a._score = 0;
          o._score = 1e3;
          break;
        }
      this._entries.sort($e._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
class PV {
  constructor() {
    this.referenceProvider = new $e(this._score.bind(this)), this.renameProvider = new $e(this._score.bind(this)), this.codeActionProvider = new $e(this._score.bind(this)), this.definitionProvider = new $e(this._score.bind(this)), this.typeDefinitionProvider = new $e(this._score.bind(this)), this.declarationProvider = new $e(this._score.bind(this)), this.implementationProvider = new $e(this._score.bind(this)), this.documentSymbolProvider = new $e(this._score.bind(this)), this.inlayHintsProvider = new $e(this._score.bind(this)), this.colorProvider = new $e(this._score.bind(this)), this.codeLensProvider = new $e(this._score.bind(this)), this.documentFormattingEditProvider = new $e(this._score.bind(this)), this.documentRangeFormattingEditProvider = new $e(this._score.bind(this)), this.onTypeFormattingEditProvider = new $e(this._score.bind(this)), this.signatureHelpProvider = new $e(this._score.bind(this)), this.hoverProvider = new $e(this._score.bind(this)), this.documentHighlightProvider = new $e(this._score.bind(this)), this.selectionRangeProvider = new $e(this._score.bind(this)), this.foldingRangeProvider = new $e(this._score.bind(this)), this.linkProvider = new $e(this._score.bind(this)), this.inlineCompletionsProvider = new $e(this._score.bind(this)), this.completionProvider = new $e(this._score.bind(this)), this.linkedEditingRangeProvider = new $e(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new $e(this._score.bind(this)), this.documentSemanticTokensProvider = new $e(this._score.bind(this)), this.documentOnDropEditProvider = new $e(this._score.bind(this)), this.documentPasteEditProvider = new $e(this._score.bind(this));
  }
  _score(e) {
    var t;
    return (t = this._notebookTypeResolver) === null || t === void 0 ? void 0 : t.call(this, e);
  }
}
Ee(De, PV, !0);
class OV extends Li {
  constructor(e = {}) {
    const t = Ft.as(uc.Configuration).getConfigurationProperties(), i = Object.keys(t), n = /* @__PURE__ */ Object.create(null), r = [];
    for (const o in t) {
      const a = e[o], l = a !== void 0 ? a : t[o].default;
      Ob(n, o, l, (c) => console.error(`Conflict in default settings: ${c}`));
    }
    for (const o of Object.keys(n))
      Rh.test(o) && r.push({
        identifiers: y2(o),
        keys: Object.keys(n[o]),
        contents: C2(n[o], (a) => console.error(`Conflict in default settings file: ${a}`))
      });
    super(n, i, r);
  }
}
var uo = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Yt = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Xx = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
class FV {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new A();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
let U0 = class {
  constructor(e) {
    this.modelService = e;
  }
  createModelReference(e) {
    const t = this.modelService.getModel(e);
    return t ? Promise.resolve(new jN(new FV(t))) : Promise.reject(new Error("Model not found"));
  }
};
U0 = uo([
  Yt(0, Kt)
], U0);
class Em {
  show() {
    return Em.NULL_PROGRESS_RUNNER;
  }
  showWhile(e, t) {
    return Xx(this, void 0, void 0, function* () {
      yield e;
    });
  }
}
Em.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
class BV {
  withProgress(e, t, i) {
    return t({
      report: () => {
      }
    });
  }
}
class VV {
  confirm(e) {
    return this.doConfirm(e).then((t) => ({
      confirmed: t,
      checkboxChecked: !1
    }));
  }
  doConfirm(e) {
    let t = e.message;
    return e.detail && (t = t + `

` + e.detail), Promise.resolve(window.confirm(t));
  }
  show(e, t, i, n) {
    return Promise.resolve({ choice: 0 });
  }
}
class xm {
  info(e) {
    return this.notify({ severity: pt.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: pt.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: pt.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case pt.Error:
        console.error(e.message);
        break;
      case pt.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return xm.NO_OP;
  }
  status(e, t) {
    return z.None;
  }
}
xm.NO_OP = new f3();
let $0 = class {
  constructor(e) {
    this._onWillExecuteCommand = new A(), this._onDidExecuteCommand = new A(), this.onWillExecuteCommand = this._onWillExecuteCommand.event, this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = Bt.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(n);
    } catch (n) {
      return Promise.reject(n);
    }
  }
};
$0 = uo([
  Yt(0, It)
], $0);
let nc = class extends r6 {
  constructor(e, t, i, n, r, o) {
    super(e, t, i, n, r), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
    const a = (f) => {
      const m = new le();
      m.add(H(f, $.KEY_DOWN, (_) => {
        const b = new nt(_);
        this._dispatch(b, b.target) && (b.preventDefault(), b.stopPropagation());
      })), m.add(H(f, $.KEY_UP, (_) => {
        const b = new nt(_);
        this._singleModifierDispatch(b, b.target) && b.preventDefault();
      })), this._domNodeListeners.push(new WV(f, m));
    }, l = (f) => {
      for (let m = 0; m < this._domNodeListeners.length; m++) {
        const _ = this._domNodeListeners[m];
        _.domNode === f && (this._domNodeListeners.splice(m, 1), _.dispose());
      }
    }, c = (f) => {
      f.getOption(56) || a(f.getContainerDomNode());
    }, h = (f) => {
      f.getOption(56) || l(f.getContainerDomNode());
    };
    this._register(o.onCodeEditorAdd(c)), this._register(o.onCodeEditorRemove(h)), o.listCodeEditors().forEach(c);
    const u = (f) => {
      a(f.getContainerDomNode());
    }, d = (f) => {
      l(f.getContainerDomNode());
    };
    this._register(o.onDiffEditorAdd(u)), this._register(o.onDiffEditorRemove(d)), o.listDiffEditors().forEach(u);
  }
  addDynamicKeybinding(e, t, i, n) {
    return zr(Bt.registerCommand(e, i), this.addDynamicKeybindings([{
      keybinding: t,
      command: e,
      when: n
    }]));
  }
  addDynamicKeybindings(e) {
    const t = e.map((i) => {
      var n, r;
      const o = w1(i.keybinding, dn);
      return {
        keybinding: (n = o == null ? void 0 : o.parts) !== null && n !== void 0 ? n : null,
        command: (r = i.command) !== null && r !== void 0 ? r : null,
        commandArgs: i.commandArgs,
        when: i.when,
        weight1: 1e3,
        weight2: 0,
        extensionId: null,
        isBuiltinExtension: !1
      };
    });
    return this._dynamicKeybindings = this._dynamicKeybindings.concat(t), this.updateResolver(), ze(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++)
        if (this._dynamicKeybindings[i] === t[0]) {
          this._dynamicKeybindings.splice(i, t.length), this.updateResolver();
          return;
        }
    });
  }
  updateResolver() {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(Jg.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new yh(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    const i = [];
    let n = 0;
    for (const r of e) {
      const o = r.when || void 0, a = r.keybinding;
      if (!a)
        i[n++] = new ky(void 0, r.command, r.commandArgs, o, t, null, !1);
      else {
        const l = au.resolveUserBinding(a, dn);
        for (const c of l)
          i[n++] = new ky(c, r.command, r.commandArgs, o, t, null, !1);
      }
    }
    return i;
  }
  resolveKeyboardEvent(e) {
    const t = new Wh(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode).toChord();
    return new au(t, dn);
  }
};
nc = uo([
  Yt(0, Qe),
  Yt(1, an),
  Yt(2, Mu),
  Yt(3, vs),
  Yt(4, ao),
  Yt(5, Ct)
], nc);
class WV extends z {
  constructor(e, t) {
    super(), this.domNode = e, this._register(t);
  }
}
function TL(s) {
  return s && typeof s == "object" && (!s.overrideIdentifier || typeof s.overrideIdentifier == "string") && (!s.resource || s.resource instanceof Le);
}
class Jx {
  constructor() {
    this._onDidChangeConfiguration = new A(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._configuration = new fm(new OV(), new Li(), new Li(), new Li());
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, n = TL(e) ? e : TL(t) ? t : {};
    return this._configuration.getValue(i, n, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() }, i = [];
    for (const n of e) {
      const [r, o] = n;
      this.getValue(r) !== o && (this._configuration.updateValue(r, o), i.push(r));
    }
    if (i.length > 0) {
      const n = new n6({ keys: i, overrides: [] }, t, this._configuration);
      n.source = 8, n.sourceConfig = null, this._onDidChangeConfiguration.fire(n);
    }
    return Promise.resolve();
  }
  updateValue(e, t, i, n) {
    return this.updateValues([[e, t]]);
  }
  inspect(e, t = {}) {
    return this._configuration.inspect(e, t, void 0);
  }
}
let j0 = class {
  constructor(e) {
    this.configurationService = e, this._onDidChangeConfiguration = new A(), this.configurationService.onDidChangeConfiguration((t) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: t.affectedKeys, affectsConfiguration: (i, n) => t.affectsConfiguration(n) });
    });
  }
  getValue(e, t, i) {
    const r = (O.isIPosition(t) ? t : null) ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0;
    return typeof r > "u" ? this.configurationService.getValue() : this.configurationService.getValue(r);
  }
};
j0 = uo([
  Yt(0, gt)
], j0);
let K0 = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && typeof i == "string" && i !== "auto" ? i : _i || Ie ? `
` : `\r
`;
  }
};
K0 = uo([
  Yt(0, gt)
], K0);
class HV {
  publicLog(e, t) {
    return Promise.resolve(void 0);
  }
  publicLog2(e, t) {
    return this.publicLog(e, t);
  }
}
class bu {
  constructor() {
    const e = Le.from({ scheme: bu.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82", folders: [new d6({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(e) {
    return e && e.scheme === bu.SCHEME ? this.workspace.folders[0] : null;
  }
}
bu.SCHEME = "inmemory";
function gg(s, e, t) {
  if (!e || !(s instanceof Jx))
    return;
  const i = [];
  Object.keys(e).forEach((n) => {
    JO(n) && i.push([`editor.${n}`, e[n]]), t && e6(n) && i.push([`diffEditor.${n}`, e[n]]);
  }), i.length > 0 && s.updateValues(i);
}
let q0 = class {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  apply(e, t) {
    return Xx(this, void 0, void 0, function* () {
      const i = /* @__PURE__ */ new Map();
      for (const o of e) {
        if (!(o instanceof Zo))
          throw new Error("bad edit - only text edits are supported");
        const a = this._modelService.getModel(o.resource);
        if (!a)
          throw new Error("bad edit - model not found");
        if (typeof o.versionId == "number" && a.getVersionId() !== o.versionId)
          throw new Error("bad state - model changed in the meantime");
        let l = i.get(a);
        l || (l = [], i.set(a, l)), l.push(i6.replaceMove(N.lift(o.textEdit.range), o.textEdit.text));
      }
      let n = 0, r = 0;
      for (const [o, a] of i)
        o.pushStackElement(), o.pushEditOperations([], a, () => []), o.pushStackElement(), r += 1, n += a.length;
      return {
        ariaSummary: e1(c0.bulkEditServiceSummary, n, r)
      };
    });
  }
};
q0 = uo([
  Yt(0, Kt)
], q0);
class zV {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
  getUriBasenameLabel(e) {
    return fC(e);
  }
}
let G0 = class extends h0 {
  constructor(e, t) {
    super(e), this._codeEditorService = t;
  }
  showContextView(e, t, i) {
    if (!t) {
      const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      n && (t = n.getContainerDomNode());
    }
    return super.showContextView(e, t, i);
  }
};
G0 = uo([
  Yt(0, vc),
  Yt(1, Ct)
], G0);
class UV {
  constructor() {
    this._neverEmitter = new A(), this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return !0;
  }
}
class $V extends cu {
  constructor() {
    super();
  }
}
class jV extends D5 {
  constructor() {
    super(new k5());
  }
}
let Z0 = class extends f0 {
  constructor(e, t, i, n, r) {
    super(e, t, i, n, r), this.configure({ blockMouse: !1 });
  }
};
Z0 = uo([
  Yt(0, Mu),
  Yt(1, vs),
  Yt(2, um),
  Yt(3, co),
  Yt(4, vt)
], Z0);
Ee(gt, Jx);
Ee(O2, j0);
Ee(F2, K0);
Ee(u6, bu);
Ee(h6, zV);
Ee(Mu, HV);
Ee(JE, VV);
Ee(vs, xm);
Ee(ga, kr);
Ee(Xt, $V);
Ee(Cn, _V);
Ee(ao, jV);
Ee(Kt, cg);
Ee(oD, b0);
Ee(Qe, z0);
Ee(xO, BV);
Ee(RC, Em);
Ee(sv, CV);
Ee(Cc, C1);
Ee(YO, q0);
Ee(g6, UV);
Ee(Ug, U0);
Ee(ha, B0);
Ee(Ss, I0);
Ee(an, $0);
Ee(co, nc);
Ee(Ux, O0);
Ee(um, G0);
Ee(jO, _0);
Ee(AC, H0);
Ee(MC, Z0);
Ee(fD, V0);
var X;
(function(s) {
  const e = new cm();
  for (const [o, a] of iw())
    e.set(o, a);
  const t = new av(e, !0);
  e.set(It, t);
  function i(o) {
    const a = e.get(o);
    if (!a)
      throw new Error("Missing service " + o);
    return a instanceof Yn ? t.invokeFunction((l) => l.get(o)) : a;
  }
  s.get = i;
  let n = !1;
  function r(o) {
    if (n)
      return t;
    n = !0;
    for (const [a, l] of iw())
      e.get(a) || e.set(a, l);
    for (const a in o)
      if (o.hasOwnProperty(a)) {
        const l = Se(a);
        e.get(l) instanceof Yn && e.set(l, o[a]);
      }
    return t;
  }
  s.initialize = r;
})(X || (X = {}));
var lv = globalThis && globalThis.__decorate || function(s, e, t, i) {
  var n = arguments.length, r = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, i);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, t, r) : o(e, t)) || r);
  return n > 3 && r && Object.defineProperty(e, t, r), r;
}, Pe = globalThis && globalThis.__param || function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let KV = 0, ML = !1;
function qV(s) {
  if (!s) {
    if (ML)
      return;
    ML = !0;
  }
  YM(s || document.body);
}
let mg = class extends ru {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d) {
    const f = Object.assign({}, t);
    f.ariaLabel = f.ariaLabel || sg.editorViewAccessibleLabel, f.ariaLabel = f.ariaLabel + ";" + sg.accessibilityHelpMessage, super(e, f, {}, i, n, r, o, l, c, h, u, d), a instanceof nc ? this._standaloneKeybindingService = a : this._standaloneKeybindingService = null, qV(f.ariaContainerElement);
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    const n = "DYNAMIC_" + ++KV, r = Ut.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, r), n;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), z.None;
    const t = e.id, i = e.label, n = Ut.and(Ut.equals("editorId", this.getId()), Ut.deserialize(e.precondition)), r = e.keybindings, o = Ut.and(n, Ut.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, c = (f, ...m) => Promise.resolve(e.run(this, ...m)), h = new le(), u = this.getId() + ":" + t;
    if (h.add(Bt.registerCommand(u, c)), a) {
      const f = {
        command: {
          id: u,
          title: i
        },
        when: n,
        group: a,
        order: l
      };
      h.add(_l.appendMenuItem(I.EditorContext, f));
    }
    if (Array.isArray(r))
      for (const f of r)
        h.add(this._standaloneKeybindingService.addDynamicKeybinding(u, f, c, o));
    const d = new dE(u, i, i, n, c, this._contextKeyService);
    return this._actions[t] = d, h.add(ze(() => {
      delete this._actions[t];
    })), h;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof eg)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
mg = lv([
  Pe(2, It),
  Pe(3, Ct),
  Pe(4, an),
  Pe(5, Qe),
  Pe(6, co),
  Pe(7, vt),
  Pe(8, vs),
  Pe(9, ha),
  Pe(10, bs),
  Pe(11, De)
], mg);
let Y0 = class extends mg {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _) {
    const b = Object.assign({}, t);
    gg(h, b, !1);
    const v = l.registerEditorContainer(e);
    typeof b.theme == "string" && l.setTheme(b.theme), typeof b.autoDetectHighContrast < "u" && l.setAutoDetectHighContrast(Boolean(b.autoDetectHighContrast));
    const C = b.model;
    delete b.model, super(e, b, i, n, r, o, a, l, c, u, m, _), this._configurationService = h, this._standaloneThemeService = l, this._register(v);
    let w;
    if (typeof C > "u") {
      const L = f.getLanguageIdByMimeType(b.language) || b.language || os;
      w = eI(d, f, b.value || "", L, void 0), this._ownsModel = !0;
    } else
      w = C, this._ownsModel = !1;
    if (this._attachModel(w), w) {
      const L = {
        oldModelUrl: null,
        newModelUrl: w.uri
      };
      this._onDidChangeModel.fire(L);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    gg(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(Boolean(e.autoDetectHighContrast)), super.updateOptions(e);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
Y0 = lv([
  Pe(2, It),
  Pe(3, Ct),
  Pe(4, an),
  Pe(5, Qe),
  Pe(6, co),
  Pe(7, Cn),
  Pe(8, vs),
  Pe(9, gt),
  Pe(10, ha),
  Pe(11, Kt),
  Pe(12, Xt),
  Pe(13, bs),
  Pe(14, De)
], Y0);
let Q0 = class extends so {
  constructor(e, t, i, n, r, o, a, l, c, h, u, d) {
    const f = Object.assign({}, t);
    gg(c, f, !0);
    const m = a.registerEditorContainer(e);
    typeof f.theme == "string" && a.setTheme(f.theme), typeof f.autoDetectHighContrast < "u" && a.setAutoDetectHighContrast(Boolean(f.autoDetectHighContrast)), super(e, f, {}, d, r, n, i, o, a, l, h, u), this._configurationService = c, this._standaloneThemeService = a, this._register(m);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    gg(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(Boolean(e.autoDetectHighContrast)), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(mg, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
Q0 = lv([
  Pe(2, It),
  Pe(3, Qe),
  Pe(4, Cc),
  Pe(5, Ct),
  Pe(6, Cn),
  Pe(7, vs),
  Pe(8, gt),
  Pe(9, MC),
  Pe(10, RC),
  Pe(11, AC)
], Q0);
function eI(s, e, t, i, n) {
  if (t = t || "", !i) {
    const r = t.indexOf(`
`);
    let o = t;
    return r !== -1 && (o = t.substring(0, r)), AL(s, t, e.createByFilepathOrFirstLine(n || null, o), n);
  }
  return AL(s, t, e.createById(i), n);
}
function AL(s, e, t, i) {
  return s.createModel(e, t, i);
}
function GV(s, e, t) {
  return X.initialize(t || {}).createInstance(Y0, s, e);
}
function ZV(s) {
  return X.get(Ct).onCodeEditorAdd((t) => {
    s(t);
  });
}
function YV(s) {
  return X.get(Ct).onDiffEditorAdd((t) => {
    s(t);
  });
}
function QV() {
  return X.get(Ct).listCodeEditors();
}
function XV() {
  return X.get(Ct).listDiffEditors();
}
function JV(s, e, t) {
  return X.initialize(t || {}).createInstance(Q0, s, e);
}
function eW(s, e) {
  return new GT(s, e);
}
function tW(s) {
  if (typeof s.id != "string" || typeof s.run != "function")
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  return Bt.registerCommand(s.id, s.run);
}
function iW(s) {
  if (typeof s.id != "string" || typeof s.label != "string" || typeof s.run != "function")
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  const e = Ut.deserialize(s.precondition), t = (n, ...r) => to.runEditorCommand(n, r, e, (o, a, l) => Promise.resolve(s.run(a, ...l))), i = new le();
  if (i.add(Bt.registerCommand(s.id, t)), s.contextMenuGroupId) {
    const n = {
      command: {
        id: s.id,
        title: s.label
      },
      when: e,
      group: s.contextMenuGroupId,
      order: s.contextMenuOrder || 0
    };
    i.add(_l.appendMenuItem(I.EditorContext, n));
  }
  if (Array.isArray(s.keybindings)) {
    const n = X.get(co);
    if (!(n instanceof nc))
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    else {
      const r = Ut.and(e, Ut.deserialize(s.keybindingContext));
      i.add(n.addDynamicKeybindings(s.keybindings.map((o) => ({
        keybinding: o,
        command: s.id,
        when: r
      }))));
    }
  }
  return i;
}
function nW(s) {
  return tI([s]);
}
function tI(s) {
  const e = X.get(co);
  return e instanceof nc ? e.addDynamicKeybindings(s.map((t) => ({
    keybinding: t.keybinding,
    command: t.command,
    commandArgs: t.commandArgs,
    when: Ut.deserialize(t.when)
  }))) : (console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), z.None);
}
function sW(s, e, t) {
  const i = X.get(Xt), n = i.getLanguageIdByMimeType(e) || e;
  return eI(X.get(Kt), i, s, n, t);
}
function rW(s, e) {
  const t = X.get(Xt);
  X.get(Kt).setMode(s, t.createById(e));
}
function oW(s, e, t) {
  s && X.get(ga).changeOne(e, s.uri, t);
}
function aW(s) {
  X.get(ga).changeAll(s, []);
}
function lW(s) {
  return X.get(ga).read(s);
}
function cW(s) {
  return X.get(ga).onMarkerChanged(s);
}
function hW(s) {
  return X.get(Kt).getModel(s);
}
function uW() {
  return X.get(Kt).getModels();
}
function dW(s) {
  return X.get(Kt).onModelAdded(s);
}
function fW(s) {
  return X.get(Kt).onModelRemoved(s);
}
function gW(s) {
  return X.get(Kt).onModelLanguageChanged((t) => {
    s({
      model: t.model,
      oldLanguage: t.oldLanguageId
    });
  });
}
function mW(s) {
  return T5(X.get(Kt), X.get(bs), s);
}
function pW(s, e) {
  const t = X.get(Xt), i = X.get(Cn);
  return i.registerEditorContainer(s), $b.colorizeElement(i, t, s, e);
}
function _W(s, e, t) {
  const i = X.get(Xt);
  return X.get(Cn).registerEditorContainer(document.body), $b.colorize(i, s, e, t);
}
function bW(s, e, t = 4) {
  return X.get(Cn).registerEditorContainer(document.body), $b.colorizeModelLine(s, e, t);
}
function CW(s) {
  const e = at.get(s);
  return e || {
    getInitialState: () => Cf,
    tokenize: (t, i, n) => E2(s, n)
  };
}
function vW(s, e) {
  at.getOrCreate(e);
  const t = CW(e), i = xu(s), n = [];
  let r = t.getInitialState();
  for (let o = 0, a = i.length; o < a; o++) {
    const l = i[o], c = t.tokenize(l, !0, r);
    n[o] = c.tokens, r = c.endState;
  }
  return n;
}
function wW(s, e) {
  X.get(Cn).defineTheme(s, e);
}
function SW(s) {
  X.get(Cn).setTheme(s);
}
function yW() {
  a1.clearAllFontInfos();
}
function LW(s, e) {
  return Bt.registerCommand({ id: s, handler: e });
}
function kW() {
  return {
    create: GV,
    getEditors: QV,
    getDiffEditors: XV,
    onDidCreateEditor: ZV,
    onDidCreateDiffEditor: YV,
    createDiffEditor: JV,
    createDiffNavigator: eW,
    addCommand: tW,
    addEditorAction: iW,
    addKeybindingRule: nW,
    addKeybindingRules: tI,
    createModel: sW,
    setModelLanguage: rW,
    setModelMarkers: oW,
    getModelMarkers: lW,
    removeAllMarkers: aW,
    onDidChangeMarkers: cW,
    getModels: uW,
    getModel: hW,
    onDidCreateModel: dW,
    onWillDisposeModel: fW,
    onDidChangeModelLanguage: gW,
    createWebWorker: mW,
    colorizeElement: pW,
    colorize: _W,
    colorizeModelLine: bW,
    tokenize: vW,
    defineTheme: wW,
    setTheme: SW,
    remeasureFonts: yW,
    registerCommand: LW,
    AccessibilitySupport: p_,
    ContentWidgetPositionPreference: S_,
    CursorChangeReason: y_,
    DefaultEndOfLine: L_,
    EditorAutoIndentStrategy: D_,
    EditorOption: E_,
    EndOfLinePreference: x_,
    EndOfLineSequence: I_,
    MinimapPosition: F_,
    MouseTargetType: B_,
    OverlayWidgetPositionPreference: V_,
    OverviewRulerLane: W_,
    RenderLineNumbersType: z_,
    RenderMinimap: U_,
    ScrollbarVisibility: j_,
    ScrollType: $_,
    TextEditorCursorBlinkingStyle: Y_,
    TextEditorCursorStyle: Q_,
    TrackedRangeStickiness: X_,
    WrappingIndent: J_,
    InjectedTextCursorStops: T_,
    PositionAffinity: H_,
    ConfigurationChangedEvent: Hk,
    BareFontInfo: $o,
    FontInfo: o1,
    TextModelResolvedOptions: $d,
    FindMatch: Ah,
    ApplyUpdateResult: rh,
    EditorType: Rb,
    EditorOptions: oa
  };
}
function DW(s, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!s(t))
      return !1;
  return !0;
}
function Bd(s, e) {
  return typeof s == "boolean" ? s : e;
}
function RL(s, e) {
  return typeof s == "string" ? s : e;
}
function EW(s) {
  const e = {};
  for (const t of s)
    e[t] = !0;
  return e;
}
function PL(s, e = !1) {
  e && (s = s.map(function(i) {
    return i.toLowerCase();
  }));
  const t = EW(s);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function X0(s, e) {
  e = e.replace(/@@/g, "");
  let t = 0, i;
  do
    i = !1, e = e.replace(/@(\w+)/g, function(r, o) {
      i = !0;
      let a = "";
      if (typeof s[o] == "string")
        a = s[o];
      else if (s[o] && s[o] instanceof RegExp)
        a = s[o].source;
      else
        throw s[o] === void 0 ? Ae(s, "language definition does not contain attribute '" + o + "', used at: " + e) : Ae(s, "attribute reference '" + o + "' must be a string, used at: " + e);
      return Ba(a) ? "" : "(?:" + a + ")";
    }), t++;
  while (i && t < 5);
  e = e.replace(/\x01/g, "@");
  const n = (s.ignoreCase ? "i" : "") + (s.unicode ? "u" : "");
  return new RegExp(e, n);
}
function xW(s, e, t, i) {
  if (i < 0)
    return s;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    const n = t.split(".");
    if (n.unshift(t), i < n.length)
      return n[i];
  }
  return null;
}
function IW(s, e, t, i) {
  let n = -1, r = t, o = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  o && (o[3] && (n = parseInt(o[3]), o[2] && (n = n + 100)), r = o[4]);
  let a = "~", l = r;
  !r || r.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (o = r.match(/^(@|!@|~|!~|==|!=)(.*)$/), o && (a = o[1], l = o[2]));
  let c;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    const h = PL(l.split("|"), s.ignoreCase);
    c = function(u) {
      return a === "~" ? h(u) : !h(u);
    };
  } else if (a === "@" || a === "!@") {
    const h = s[l];
    if (!h)
      throw Ae(s, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!DW(function(d) {
      return typeof d == "string";
    }, h))
      throw Ae(s, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    const u = PL(h, s.ignoreCase);
    c = function(d) {
      return a === "@" ? u(d) : !u(d);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      const h = X0(s, "^" + l + "$");
      c = function(u) {
        return a === "~" ? h.test(u) : !h.test(u);
      };
    } else
      c = function(h, u, d, f) {
        return X0(s, "^" + xr(s, l, u, d, f) + "$").test(h);
      };
  else if (l.indexOf("$") < 0) {
    const h = qr(s, l);
    c = function(u) {
      return a === "==" ? u === h : u !== h;
    };
  } else {
    const h = qr(s, l);
    c = function(u, d, f, m, _) {
      const b = xr(s, h, d, f, m);
      return a === "==" ? u === b : u !== b;
    };
  }
  return n === -1 ? {
    name: t,
    value: i,
    test: function(h, u, d, f) {
      return c(h, h, u, d, f);
    }
  } : {
    name: t,
    value: i,
    test: function(h, u, d, f) {
      const m = xW(h, u, d, n);
      return c(m || "", h, u, d, f);
    }
  };
}
function J0(s, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw Ae(s, "a 'token' attribute must be of type string, in rule: " + e);
      {
        const i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw Ae(s, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw Ae(s, "the next state must be a string value in rule: " + e);
          {
            let n = t.next;
            if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !Y5(s, xr(s, n, "", [], ""))))
              throw Ae(s, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = n;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, s.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      const i = [];
      for (let n = 0, r = t.length; n < r; n++)
        i[n] = J0(s, e, t[n]);
      return { group: i };
    } else if (t.cases) {
      const i = [];
      for (const r in t.cases)
        if (t.cases.hasOwnProperty(r)) {
          const o = J0(s, e, t.cases[r]);
          r === "@default" || r === "@" || r === "" ? i.push({ test: void 0, value: o, name: r }) : r === "@eos" ? i.push({ test: function(a, l, c, h) {
            return h;
          }, value: o, name: r }) : i.push(IW(s, e, r, o));
        }
      const n = s.defaultToken;
      return {
        test: function(r, o, a, l) {
          for (const c of i)
            if (!c.test || c.test(r, o, a, l))
              return c.value;
          return n;
        }
      };
    } else
      throw Ae(s, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else
    return { token: "" };
}
class NW {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw Ae(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = X0(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")");
  }
  setAction(e, t) {
    this.action = J0(e, this.name, t);
  }
}
function iI(s, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  const t = {};
  t.languageId = s, t.includeLF = Bd(e.includeLF, !1), t.noThrow = !1, t.maxStack = 100, t.start = typeof e.start == "string" ? e.start : null, t.ignoreCase = Bd(e.ignoreCase, !1), t.unicode = Bd(e.unicode, !1), t.tokenPostfix = RL(e.tokenPostfix, "." + t.languageId), t.defaultToken = RL(e.defaultToken, "source"), t.usesEmbedded = !1;
  const i = e;
  i.languageId = s, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function n(o, a, l) {
    for (const c of l) {
      let h = c.include;
      if (h) {
        if (typeof h != "string")
          throw Ae(t, "an 'include' attribute must be a string at: " + o);
        if (h[0] === "@" && (h = h.substr(1)), !e.tokenizer[h])
          throw Ae(t, "include target '" + h + "' is not defined at: " + o);
        n(o + "." + h, a, e.tokenizer[h]);
      } else {
        const u = new NW(o);
        if (Array.isArray(c) && c.length >= 1 && c.length <= 3)
          if (u.setRegex(i, c[0]), c.length >= 3)
            if (typeof c[1] == "string")
              u.setAction(i, { token: c[1], next: c[2] });
            else if (typeof c[1] == "object") {
              const d = c[1];
              d.next = c[2], u.setAction(i, d);
            } else
              throw Ae(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + o);
          else
            u.setAction(i, c[1]);
        else {
          if (!c.regex)
            throw Ae(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + o);
          c.name && typeof c.name == "string" && (u.name = c.name), c.matchOnlyAtStart && (u.matchOnlyAtLineStart = Bd(c.matchOnlyAtLineStart, !1)), u.setRegex(i, c.regex), u.setAction(i, c.action);
        }
        a.push(u);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw Ae(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (const o in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(o)) {
      t.start || (t.start = o);
      const a = e.tokenizer[o];
      t.tokenizer[o] = new Array(), n("tokenizer." + o, t.tokenizer[o], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw Ae(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  const r = [];
  for (const o of e.brackets) {
    let a = o;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw Ae(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      r.push({
        token: a.token + t.tokenPostfix,
        open: qr(t, a.open),
        close: qr(t, a.close)
      });
    else
      throw Ae(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = r, t.noThrow = !0, t;
}
var TW = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
function MW(s) {
  Fl.registerLanguage(s);
}
function AW() {
  let s = [];
  return s = s.concat(Fl.getLanguages()), s;
}
function RW(s) {
  return X.get(Xt).languageIdCodec.encodeLanguageId(s);
}
function PW(s, e) {
  const i = X.get(Xt).onDidEncounterLanguage((n) => {
    n === s && (i.dispose(), e());
  });
  return i;
}
function OW(s, e) {
  if (!X.get(Xt).isRegisteredLanguageId(s))
    throw new Error(`Cannot set configuration for unknown language ${s}`);
  return X.get(bs).register(s, e, 100);
}
class FW {
  constructor(e, t) {
    this._languageId = e, this._actual = t;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i) {
    if (typeof this._actual.tokenize == "function")
      return Cu.adaptTokenize(this._languageId, this._actual, e, i);
    throw new Error("Not supported!");
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenizeEncoded(e, i);
    return new Ig(n.tokens, n.endState);
  }
}
class Cu {
  constructor(e, t, i, n) {
    this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t) {
    const i = [];
    let n = 0;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r];
      let l = a.startIndex;
      r === 0 ? l = 0 : l < n && (l = n), i[r] = new Nh(l, a.scopes, t), n = l;
    }
    return i;
  }
  static adaptTokenize(e, t, i, n) {
    const r = t.tokenize(i, n), o = Cu._toClassicTokens(r.tokens, e);
    let a;
    return r.endState.equals(n) ? a = n : a = r.endState, new vb(o, a);
  }
  tokenize(e, t, i) {
    return Cu.adaptTokenize(this._languageId, this._actual, e, i);
  }
  _toBinaryTokens(e, t) {
    const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, r = [];
    let o = 0, a = 0;
    for (let c = 0, h = t.length; c < h; c++) {
      const u = t[c], d = n.match(i, u.scopes);
      if (o > 0 && r[o - 1] === d)
        continue;
      let f = u.startIndex;
      c === 0 ? f = 0 : f < a && (f = a), r[o++] = f, r[o++] = d, a = f;
    }
    const l = new Uint32Array(o);
    for (let c = 0; c < o; c++)
      l[c] = r[c];
    return l;
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenize(e, i), r = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
    let o;
    return n.endState.equals(i) ? o = i : o = n.endState, new Ig(r, o);
  }
}
function BW(s) {
  return typeof s.getInitialState == "function";
}
function VW(s) {
  return "tokenizeEncoded" in s;
}
function nI(s) {
  return s && typeof s.then == "function";
}
function WW(s) {
  const e = X.get(Cn);
  if (s) {
    const t = [null];
    for (let i = 1, n = s.length; i < n; i++)
      t[i] = R.fromHex(s[i]);
    e.setColorMapOverride(t);
  } else
    e.setColorMapOverride(null);
}
function sI(s, e) {
  return VW(e) ? new FW(s, e) : new Cu(s, e, X.get(Xt), X.get(Cn));
}
function cv(s, e) {
  const t = {
    createTokenizationSupport: () => TW(this, void 0, void 0, function* () {
      const i = yield Promise.resolve(e.create());
      return i ? BW(i) ? sI(s, i) : new Vh(X.get(Xt), X.get(Cn), s, iI(s, i), X.get(gt)) : null;
    })
  };
  return at.registerFactory(s, t);
}
function HW(s, e) {
  if (!X.get(Xt).isRegisteredLanguageId(s))
    throw new Error(`Cannot set tokens provider for unknown language ${s}`);
  return nI(e) ? cv(s, { create: () => e }) : at.register(s, sI(s, e));
}
function zW(s, e) {
  const t = (i) => new Vh(X.get(Xt), X.get(Cn), s, iI(s, i), X.get(gt));
  return nI(e) ? cv(s, { create: () => e }) : at.register(s, t(e));
}
function UW(s, e) {
  return X.get(De).referenceProvider.register(s, e);
}
function $W(s, e) {
  return X.get(De).renameProvider.register(s, e);
}
function jW(s, e) {
  return X.get(De).signatureHelpProvider.register(s, e);
}
function KW(s, e) {
  return X.get(De).hoverProvider.register(s, {
    provideHover: (i, n, r) => {
      const o = i.getWordAtPosition(n);
      return Promise.resolve(e.provideHover(i, n, r)).then((a) => {
        if (!!a)
          return !a.range && o && (a.range = new N(n.lineNumber, o.startColumn, n.lineNumber, o.endColumn)), a.range || (a.range = new N(n.lineNumber, n.column, n.lineNumber, n.column)), a;
      });
    }
  });
}
function qW(s, e) {
  return X.get(De).documentSymbolProvider.register(s, e);
}
function GW(s, e) {
  return X.get(De).documentHighlightProvider.register(s, e);
}
function ZW(s, e) {
  return X.get(De).linkedEditingRangeProvider.register(s, e);
}
function YW(s, e) {
  return X.get(De).definitionProvider.register(s, e);
}
function QW(s, e) {
  return X.get(De).implementationProvider.register(s, e);
}
function XW(s, e) {
  return X.get(De).typeDefinitionProvider.register(s, e);
}
function JW(s, e) {
  return X.get(De).codeLensProvider.register(s, e);
}
function eH(s, e, t) {
  return X.get(De).codeActionProvider.register(s, {
    providedCodeActionKinds: t == null ? void 0 : t.providedCodeActionKinds,
    documentation: t == null ? void 0 : t.documentation,
    provideCodeActions: (n, r, o, a) => {
      const c = X.get(ga).read({ resource: n.uri }).filter((h) => N.areIntersectingOrTouching(h, r));
      return e.provideCodeActions(n, r, { markers: c, only: o.only, trigger: o.trigger }, a);
    },
    resolveCodeAction: e.resolveCodeAction
  });
}
function tH(s, e) {
  return X.get(De).documentFormattingEditProvider.register(s, e);
}
function iH(s, e) {
  return X.get(De).documentRangeFormattingEditProvider.register(s, e);
}
function nH(s, e) {
  return X.get(De).onTypeFormattingEditProvider.register(s, e);
}
function sH(s, e) {
  return X.get(De).linkProvider.register(s, e);
}
function rH(s, e) {
  return X.get(De).completionProvider.register(s, e);
}
function oH(s, e) {
  return X.get(De).colorProvider.register(s, e);
}
function aH(s, e) {
  return X.get(De).foldingRangeProvider.register(s, e);
}
function lH(s, e) {
  return X.get(De).declarationProvider.register(s, e);
}
function cH(s, e) {
  return X.get(De).selectionRangeProvider.register(s, e);
}
function hH(s, e) {
  return X.get(De).documentSemanticTokensProvider.register(s, e);
}
function uH(s, e) {
  return X.get(De).documentRangeSemanticTokensProvider.register(s, e);
}
function dH(s, e) {
  return X.get(De).inlineCompletionsProvider.register(s, e);
}
function fH(s, e) {
  return X.get(De).inlayHintsProvider.register(s, e);
}
function gH() {
  return {
    register: MW,
    getLanguages: AW,
    onLanguage: PW,
    getEncodedLanguageId: RW,
    setLanguageConfiguration: OW,
    setColorMap: WW,
    registerTokensProviderFactory: cv,
    setTokensProvider: HW,
    setMonarchTokensProvider: zW,
    registerReferenceProvider: UW,
    registerRenameProvider: $W,
    registerCompletionItemProvider: rH,
    registerSignatureHelpProvider: jW,
    registerHoverProvider: KW,
    registerDocumentSymbolProvider: qW,
    registerDocumentHighlightProvider: GW,
    registerLinkedEditingRangeProvider: ZW,
    registerDefinitionProvider: YW,
    registerImplementationProvider: QW,
    registerTypeDefinitionProvider: XW,
    registerCodeLensProvider: JW,
    registerCodeActionProvider: eH,
    registerDocumentFormattingEditProvider: tH,
    registerDocumentRangeFormattingEditProvider: iH,
    registerOnTypeFormattingEditProvider: nH,
    registerLinkProvider: sH,
    registerColorProvider: oH,
    registerFoldingRangeProvider: aH,
    registerDeclarationProvider: lH,
    registerSelectionRangeProvider: cH,
    registerDocumentSemanticTokensProvider: hH,
    registerDocumentRangeSemanticTokensProvider: uH,
    registerInlineCompletionsProvider: dH,
    registerInlayHintsProvider: fH,
    DocumentHighlightKind: k_,
    CompletionItemKind: C_,
    CompletionItemTag: v_,
    CompletionItemInsertTextRule: b_,
    SymbolKind: G_,
    SymbolTag: Z_,
    IndentAction: N_,
    CompletionTriggerKind: w_,
    SignatureHelpTriggerKind: q_,
    InlayHintKind: M_,
    InlineCompletionTriggerKind: A_,
    CodeActionTriggerType: __,
    FoldingRangeKind: Qo
  };
}
const rI = Se("IEditorCancelService"), oI = new ie("cancellableOperation", !1, p("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
Ee(rI, class {
  constructor() {
    this._tokens = /* @__PURE__ */ new WeakMap();
  }
  add(s, e) {
    let t = this._tokens.get(s);
    t || (t = s.invokeWithinContext((n) => {
      const r = oI.bindTo(n.get(Qe)), o = new Ei();
      return { key: r, tokens: o };
    }), this._tokens.set(s, t));
    let i;
    return t.key.set(!0), i = t.tokens.push(e), () => {
      i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
    };
  }
  cancel(s) {
    const e = this._tokens.get(s);
    if (!e)
      return;
    const t = e.tokens.pop();
    t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
  }
}, !0);
se(new class extends to {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
      },
      precondition: oI
    });
  }
  runEditorCommand(s, e) {
    s.get(rI).cancel(e);
  }
}());
class s_ {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
var wc = globalThis && globalThis.__awaiter || function(s, e, t, i) {
  function n(r) {
    return r instanceof t ? r : new t(function(o) {
      o(r);
    });
  }
  return new (t || (t = Promise))(function(r, o) {
    function a(h) {
      try {
        c(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      try {
        c(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      h.done ? r(h.value) : n(h.value).then(a, l);
    }
    c((i = i.apply(s, e || [])).next());
  });
};
function mH(s, e, t) {
  const i = [], n = /* @__PURE__ */ new Set(), r = s.ordered(t);
  for (const a of r)
    i.push(a), a.extensionId && n.add(s_.toKey(a.extensionId));
  const o = e.ordered(t);
  for (const a of o) {
    if (a.extensionId) {
      if (n.has(s_.toKey(a.extensionId)))
        continue;
      n.add(s_.toKey(a.extensionId));
    }
    i.push({
      displayName: a.displayName,
      extensionId: a.extensionId,
      provideDocumentFormattingEdits(l, c, h) {
        return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), c, h);
      }
    });
  }
  return i;
}
class vu {
  static setFormatterSelector(e) {
    return { dispose: vu._selectors.unshift(e) };
  }
  static select(e, t, i) {
    return wc(this, void 0, void 0, function* () {
      if (e.length === 0)
        return;
      const n = ge.first(vu._selectors);
      if (n)
        return yield n(e, t, i);
    });
  }
}
vu._selectors = new Ei();
function pH(s, e, t, i, n, r) {
  return wc(this, void 0, void 0, function* () {
    const o = e.documentRangeFormattingEditProvider.ordered(t);
    for (const a of o) {
      const l = yield Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, r)).catch(Eg);
      if (Lg(l))
        return yield s.computeMoreMinimalEdits(t.uri, l);
    }
  });
}
function _H(s, e, t, i, n) {
  return wc(this, void 0, void 0, function* () {
    const r = mH(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
    for (const o of r) {
      const a = yield Promise.resolve(o.provideDocumentFormattingEdits(t, i, n)).catch(Eg);
      if (Lg(a))
        return yield s.computeMoreMinimalEdits(t.uri, a);
    }
  });
}
function bH(s, e, t, i, n, r, o) {
  const a = e.onTypeFormattingEditProvider.ordered(t);
  return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, r, o)).catch(Eg).then((l) => s.computeMoreMinimalEdits(t.uri, l));
}
Bt.registerCommand("_executeFormatRangeProvider", function(s, ...e) {
  return wc(this, void 0, void 0, function* () {
    const [t, i, n] = e;
    Pn(Le.isUri(t)), Pn(N.isIRange(i));
    const r = s.get(Ug), o = s.get(Cc), a = s.get(De), l = yield r.createModelReference(t);
    try {
      return pH(o, a, l.object.textEditorModel, N.lift(i), n, Ii.None);
    } finally {
      l.dispose();
    }
  });
});
Bt.registerCommand("_executeFormatDocumentProvider", function(s, ...e) {
  return wc(this, void 0, void 0, function* () {
    const [t, i] = e;
    Pn(Le.isUri(t));
    const n = s.get(Ug), r = s.get(Cc), o = s.get(De), a = yield n.createModelReference(t);
    try {
      return _H(r, o, a.object.textEditorModel, i, Ii.None);
    } finally {
      a.dispose();
    }
  });
});
Bt.registerCommand("_executeFormatOnTypeProvider", function(s, ...e) {
  return wc(this, void 0, void 0, function* () {
    const [t, i, n, r] = e;
    Pn(Le.isUri(t)), Pn(O.isIPosition(i)), Pn(typeof n == "string");
    const o = s.get(Ug), a = s.get(Cc), l = s.get(De), c = yield o.createModelReference(t);
    try {
      return bH(a, l, c.object.textEditorModel, O.lift(i), n, r, Ii.None);
    } finally {
      c.dispose();
    }
  });
});
var r_;
oa.wrappingIndent.defaultValue = 0;
oa.glyphMargin.defaultValue = !1;
oa.autoIndent.defaultValue = 3;
oa.overviewRulerLanes.defaultValue = 2;
vu.setFormatterSelector((s, e, t) => Promise.resolve(s[0]));
const ai = t2();
ai.editor = kW();
ai.languages = gH();
const CH = ai.CancellationTokenSource, aI = ai.Emitter, vH = ai.KeyCode, wH = ai.KeyMod, SH = ai.Position, hv = ai.Range, yH = ai.Selection, LH = ai.SelectionDirection, Ua = ai.MarkerSeverity, eb = ai.MarkerTag, uv = ai.Uri, kH = ai.Token, DH = ai.editor, Si = ai.languages;
(((r_ = it.MonacoEnvironment) === null || r_ === void 0 ? void 0 : r_.globalAPI) || typeof define == "function" && define.amd) && (self.monaco = ai);
typeof self.require < "u" && typeof self.require.config == "function" && self.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
const rf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CancellationTokenSource: CH,
  Emitter: aI,
  KeyCode: vH,
  KeyMod: wH,
  Position: SH,
  Range: hv,
  Selection: yH,
  SelectionDirection: LH,
  MarkerSeverity: Ua,
  MarkerTag: eb,
  Uri: uv,
  Token: kH,
  editor: DH,
  languages: Si
}, Symbol.toStringTag, { value: "Module" }));
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.34.1(547870b6881302c5b4ff32173c16d06009e3588f)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var EH = Object.defineProperty, xH = Object.getOwnPropertyDescriptor, IH = Object.getOwnPropertyNames, NH = Object.prototype.hasOwnProperty, OL = (s, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of IH(e))
      !NH.call(s, n) && n !== t && EH(s, n, { get: () => e[n], enumerable: !(i = xH(e, n)) || i.enumerable });
  return s;
}, TH = (s, e, t) => (OL(s, e, "default"), t && OL(t, e, "default")), nh = {};
TH(nh, rf);
var lI = {}, o_ = {}, cI = class {
  constructor(s) {
    La(this, "_languageId");
    La(this, "_loadingTriggered");
    La(this, "_lazyLoadPromise");
    La(this, "_lazyLoadPromiseResolve");
    La(this, "_lazyLoadPromiseReject");
    this._languageId = s, this._loadingTriggered = !1, this._lazyLoadPromise = new Promise((e, t) => {
      this._lazyLoadPromiseResolve = e, this._lazyLoadPromiseReject = t;
    });
  }
  static getOrCreate(s) {
    return o_[s] || (o_[s] = new cI(s)), o_[s];
  }
  load() {
    return this._loadingTriggered || (this._loadingTriggered = !0, lI[this._languageId].loader().then((s) => this._lazyLoadPromiseResolve(s), (s) => this._lazyLoadPromiseReject(s))), this._lazyLoadPromise;
  }
};
function MH(s) {
  const e = s.id;
  lI[e] = s, nh.languages.register(s);
  const t = cI.getOrCreate(e);
  nh.languages.registerTokensProviderFactory(e, {
    create: async () => (await t.load()).language
  }), nh.languages.onLanguage(e, async () => {
    const i = await t.load();
    nh.languages.setLanguageConfiguration(e, i.conf);
  });
}
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.34.1(547870b6881302c5b4ff32173c16d06009e3588f)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
MH({
  id: "yaml",
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml", "text/x-yaml"],
  loader: () => import("./yaml.b19ed735.js")
});
function FL(s, e, t) {
  const i = /* @__PURE__ */ new Map(), n = (c) => {
    if (e === "*")
      return !0;
    const h = c.getLanguageId();
    return Array.isArray(e) ? e.includes(h) : e === h;
  }, r = async (c) => {
    const h = await t.provideMarkerData(c);
    !c.isDisposed() && n(c) && s.editor.setModelMarkers(c, t.owner, h != null ? h : []);
  }, o = (c) => {
    if (!n(c))
      return;
    let h;
    i.set(String(c.uri), c.onDidChangeContent(() => {
      clearTimeout(h), h = setTimeout(() => {
        r(c);
      }, 500);
    })), r(c);
  }, a = (c) => {
    s.editor.setModelMarkers(c, t.owner, []);
    const h = String(c.uri), u = i.get(h);
    u && (u.dispose(), i.delete(h));
  }, l = [
    s.editor.onDidCreateModel(o),
    s.editor.onWillDisposeModel((c) => {
      var h;
      a(c), (h = t.doReset) == null || h.call(t, c);
    }),
    s.editor.onDidChangeModelLanguage((c) => {
      var h;
      a(c.model), o(c.model), (h = t.doReset) == null || h.call(t, c.model);
    })
  ];
  for (const c of s.editor.getModels())
    o(c);
  return {
    dispose() {
      for (const c of i.keys())
        a(s.editor.getModel(s.Uri.parse(c)));
      for (; l.length; )
        l.pop().dispose();
    }
  };
}
function AH(s, e) {
  let { createData: t, interval: i = 3e4, label: n, moduleId: r, stopWhenIdleFor: o = 12e4 } = e, a, l = 0, c = !1;
  const h = () => {
    a && (a.dispose(), a = void 0);
  }, u = setInterval(() => {
    if (!a)
      return;
    Date.now() - l > o && h();
  }, i);
  return {
    dispose() {
      c = !0, clearInterval(u), h();
    },
    getWorker(...d) {
      if (c)
        throw new Error("Worker manager has been disposed");
      return l = Date.now(), a || (a = s.editor.createWebWorker({
        createData: t,
        label: n,
        moduleId: r
      })), a.withSyncedResources(d);
    },
    updateCreateData(d) {
      t = d, h();
    }
  };
}
var BL;
(function(s) {
  function e(t) {
    return typeof t == "string";
  }
  s.is = e;
})(BL || (BL = {}));
var tb;
(function(s) {
  function e(t) {
    return typeof t == "string";
  }
  s.is = e;
})(tb || (tb = {}));
var VL;
(function(s) {
  s.MIN_VALUE = -2147483648, s.MAX_VALUE = 2147483647;
  function e(t) {
    return typeof t == "number" && s.MIN_VALUE <= t && t <= s.MAX_VALUE;
  }
  s.is = e;
})(VL || (VL = {}));
var pg;
(function(s) {
  s.MIN_VALUE = 0, s.MAX_VALUE = 2147483647;
  function e(t) {
    return typeof t == "number" && s.MIN_VALUE <= t && t <= s.MAX_VALUE;
  }
  s.is = e;
})(pg || (pg = {}));
var xn;
(function(s) {
  function e(i, n) {
    return i === Number.MAX_VALUE && (i = pg.MAX_VALUE), n === Number.MAX_VALUE && (n = pg.MAX_VALUE), { line: i, character: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && F.uinteger(n.line) && F.uinteger(n.character);
  }
  s.is = t;
})(xn || (xn = {}));
var xt;
(function(s) {
  function e(i, n, r, o) {
    if (F.uinteger(i) && F.uinteger(n) && F.uinteger(r) && F.uinteger(o))
      return { start: xn.create(i, n), end: xn.create(r, o) };
    if (xn.is(i) && xn.is(n))
      return { start: i, end: n };
    throw new Error("Range#create called with invalid arguments[".concat(i, ", ").concat(n, ", ").concat(r, ", ").concat(o, "]"));
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && xn.is(n.start) && xn.is(n.end);
  }
  s.is = t;
})(xt || (xt = {}));
var _g;
(function(s) {
  function e(i, n) {
    return { uri: i, range: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && xt.is(n.range) && (F.string(n.uri) || F.undefined(n.uri));
  }
  s.is = t;
})(_g || (_g = {}));
var WL;
(function(s) {
  function e(i, n, r, o) {
    return { targetUri: i, targetRange: n, targetSelectionRange: r, originSelectionRange: o };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && xt.is(n.targetRange) && F.string(n.targetUri) && xt.is(n.targetSelectionRange) && (xt.is(n.originSelectionRange) || F.undefined(n.originSelectionRange));
  }
  s.is = t;
})(WL || (WL = {}));
var ib;
(function(s) {
  function e(i, n, r, o) {
    return {
      red: i,
      green: n,
      blue: r,
      alpha: o
    };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && F.numberRange(n.red, 0, 1) && F.numberRange(n.green, 0, 1) && F.numberRange(n.blue, 0, 1) && F.numberRange(n.alpha, 0, 1);
  }
  s.is = t;
})(ib || (ib = {}));
var HL;
(function(s) {
  function e(i, n) {
    return {
      range: i,
      color: n
    };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && xt.is(n.range) && ib.is(n.color);
  }
  s.is = t;
})(HL || (HL = {}));
var zL;
(function(s) {
  function e(i, n, r) {
    return {
      label: i,
      textEdit: n,
      additionalTextEdits: r
    };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && F.string(n.label) && (F.undefined(n.textEdit) || nr.is(n)) && (F.undefined(n.additionalTextEdits) || F.typedArray(n.additionalTextEdits, nr.is));
  }
  s.is = t;
})(zL || (zL = {}));
var UL;
(function(s) {
  s.Comment = "comment", s.Imports = "imports", s.Region = "region";
})(UL || (UL = {}));
var $L;
(function(s) {
  function e(i, n, r, o, a, l) {
    var c = {
      startLine: i,
      endLine: n
    };
    return F.defined(r) && (c.startCharacter = r), F.defined(o) && (c.endCharacter = o), F.defined(a) && (c.kind = a), F.defined(l) && (c.collapsedText = l), c;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && F.uinteger(n.startLine) && F.uinteger(n.startLine) && (F.undefined(n.startCharacter) || F.uinteger(n.startCharacter)) && (F.undefined(n.endCharacter) || F.uinteger(n.endCharacter)) && (F.undefined(n.kind) || F.string(n.kind));
  }
  s.is = t;
})($L || ($L = {}));
var nb;
(function(s) {
  function e(i, n) {
    return {
      location: i,
      message: n
    };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && _g.is(n.location) && F.string(n.message);
  }
  s.is = t;
})(nb || (nb = {}));
var cl;
(function(s) {
  s.Error = 1, s.Warning = 2, s.Information = 3, s.Hint = 4;
})(cl || (cl = {}));
var bg;
(function(s) {
  s.Unnecessary = 1, s.Deprecated = 2;
})(bg || (bg = {}));
var jL;
(function(s) {
  function e(t) {
    var i = t;
    return F.objectLiteral(i) && F.string(i.href);
  }
  s.is = e;
})(jL || (jL = {}));
var Cg;
(function(s) {
  function e(i, n, r, o, a, l) {
    var c = { range: i, message: n };
    return F.defined(r) && (c.severity = r), F.defined(o) && (c.code = o), F.defined(a) && (c.source = a), F.defined(l) && (c.relatedInformation = l), c;
  }
  s.create = e;
  function t(i) {
    var n, r = i;
    return F.defined(r) && xt.is(r.range) && F.string(r.message) && (F.number(r.severity) || F.undefined(r.severity)) && (F.integer(r.code) || F.string(r.code) || F.undefined(r.code)) && (F.undefined(r.codeDescription) || F.string((n = r.codeDescription) === null || n === void 0 ? void 0 : n.href)) && (F.string(r.source) || F.undefined(r.source)) && (F.undefined(r.relatedInformation) || F.typedArray(r.relatedInformation, nb.is));
  }
  s.is = t;
})(Cg || (Cg = {}));
var sc;
(function(s) {
  function e(i, n) {
    for (var r = [], o = 2; o < arguments.length; o++)
      r[o - 2] = arguments[o];
    var a = { title: i, command: n };
    return F.defined(r) && r.length > 0 && (a.arguments = r), a;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.string(n.title) && F.string(n.command);
  }
  s.is = t;
})(sc || (sc = {}));
var nr;
(function(s) {
  function e(r, o) {
    return { range: r, newText: o };
  }
  s.replace = e;
  function t(r, o) {
    return { range: { start: r, end: r }, newText: o };
  }
  s.insert = t;
  function i(r) {
    return { range: r, newText: "" };
  }
  s.del = i;
  function n(r) {
    var o = r;
    return F.objectLiteral(o) && F.string(o.newText) && xt.is(o.range);
  }
  s.is = n;
})(nr || (nr = {}));
var Tl;
(function(s) {
  function e(i, n, r) {
    var o = { label: i };
    return n !== void 0 && (o.needsConfirmation = n), r !== void 0 && (o.description = r), o;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && F.string(n.label) && (F.boolean(n.needsConfirmation) || n.needsConfirmation === void 0) && (F.string(n.description) || n.description === void 0);
  }
  s.is = t;
})(Tl || (Tl = {}));
var gi;
(function(s) {
  function e(t) {
    var i = t;
    return F.string(i);
  }
  s.is = e;
})(gi || (gi = {}));
var Dr;
(function(s) {
  function e(r, o, a) {
    return { range: r, newText: o, annotationId: a };
  }
  s.replace = e;
  function t(r, o, a) {
    return { range: { start: r, end: r }, newText: o, annotationId: a };
  }
  s.insert = t;
  function i(r, o) {
    return { range: r, newText: "", annotationId: o };
  }
  s.del = i;
  function n(r) {
    var o = r;
    return nr.is(o) && (Tl.is(o.annotationId) || gi.is(o.annotationId));
  }
  s.is = n;
})(Dr || (Dr = {}));
var vg;
(function(s) {
  function e(i, n) {
    return { textDocument: i, edits: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && wg.is(n.textDocument) && Array.isArray(n.edits);
  }
  s.is = t;
})(vg || (vg = {}));
var wu;
(function(s) {
  function e(i, n, r) {
    var o = {
      kind: "create",
      uri: i
    };
    return n !== void 0 && (n.overwrite !== void 0 || n.ignoreIfExists !== void 0) && (o.options = n), r !== void 0 && (o.annotationId = r), o;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n && n.kind === "create" && F.string(n.uri) && (n.options === void 0 || (n.options.overwrite === void 0 || F.boolean(n.options.overwrite)) && (n.options.ignoreIfExists === void 0 || F.boolean(n.options.ignoreIfExists))) && (n.annotationId === void 0 || gi.is(n.annotationId));
  }
  s.is = t;
})(wu || (wu = {}));
var Su;
(function(s) {
  function e(i, n, r, o) {
    var a = {
      kind: "rename",
      oldUri: i,
      newUri: n
    };
    return r !== void 0 && (r.overwrite !== void 0 || r.ignoreIfExists !== void 0) && (a.options = r), o !== void 0 && (a.annotationId = o), a;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n && n.kind === "rename" && F.string(n.oldUri) && F.string(n.newUri) && (n.options === void 0 || (n.options.overwrite === void 0 || F.boolean(n.options.overwrite)) && (n.options.ignoreIfExists === void 0 || F.boolean(n.options.ignoreIfExists))) && (n.annotationId === void 0 || gi.is(n.annotationId));
  }
  s.is = t;
})(Su || (Su = {}));
var yu;
(function(s) {
  function e(i, n, r) {
    var o = {
      kind: "delete",
      uri: i
    };
    return n !== void 0 && (n.recursive !== void 0 || n.ignoreIfNotExists !== void 0) && (o.options = n), r !== void 0 && (o.annotationId = r), o;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n && n.kind === "delete" && F.string(n.uri) && (n.options === void 0 || (n.options.recursive === void 0 || F.boolean(n.options.recursive)) && (n.options.ignoreIfNotExists === void 0 || F.boolean(n.options.ignoreIfNotExists))) && (n.annotationId === void 0 || gi.is(n.annotationId));
  }
  s.is = t;
})(yu || (yu = {}));
var sb;
(function(s) {
  function e(t) {
    var i = t;
    return i && (i.changes !== void 0 || i.documentChanges !== void 0) && (i.documentChanges === void 0 || i.documentChanges.every(function(n) {
      return F.string(n.kind) ? wu.is(n) || Su.is(n) || yu.is(n) : vg.is(n);
    }));
  }
  s.is = e;
})(sb || (sb = {}));
var Vd = function() {
  function s(e, t) {
    this.edits = e, this.changeAnnotations = t;
  }
  return s.prototype.insert = function(e, t, i) {
    var n, r;
    if (i === void 0 ? n = nr.insert(e, t) : gi.is(i) ? (r = i, n = Dr.insert(e, t, i)) : (this.assertChangeAnnotations(this.changeAnnotations), r = this.changeAnnotations.manage(i), n = Dr.insert(e, t, r)), this.edits.push(n), r !== void 0)
      return r;
  }, s.prototype.replace = function(e, t, i) {
    var n, r;
    if (i === void 0 ? n = nr.replace(e, t) : gi.is(i) ? (r = i, n = Dr.replace(e, t, i)) : (this.assertChangeAnnotations(this.changeAnnotations), r = this.changeAnnotations.manage(i), n = Dr.replace(e, t, r)), this.edits.push(n), r !== void 0)
      return r;
  }, s.prototype.delete = function(e, t) {
    var i, n;
    if (t === void 0 ? i = nr.del(e) : gi.is(t) ? (n = t, i = Dr.del(e, t)) : (this.assertChangeAnnotations(this.changeAnnotations), n = this.changeAnnotations.manage(t), i = Dr.del(e, n)), this.edits.push(i), n !== void 0)
      return n;
  }, s.prototype.add = function(e) {
    this.edits.push(e);
  }, s.prototype.all = function() {
    return this.edits;
  }, s.prototype.clear = function() {
    this.edits.splice(0, this.edits.length);
  }, s.prototype.assertChangeAnnotations = function(e) {
    if (e === void 0)
      throw new Error("Text edit change is not configured to manage change annotations.");
  }, s;
}(), KL = function() {
  function s(e) {
    this._annotations = e === void 0 ? /* @__PURE__ */ Object.create(null) : e, this._counter = 0, this._size = 0;
  }
  return s.prototype.all = function() {
    return this._annotations;
  }, Object.defineProperty(s.prototype, "size", {
    get: function() {
      return this._size;
    },
    enumerable: !1,
    configurable: !0
  }), s.prototype.manage = function(e, t) {
    var i;
    if (gi.is(e) ? i = e : (i = this.nextId(), t = e), this._annotations[i] !== void 0)
      throw new Error("Id ".concat(i, " is already in use."));
    if (t === void 0)
      throw new Error("No annotation provided for id ".concat(i));
    return this._annotations[i] = t, this._size++, i;
  }, s.prototype.nextId = function() {
    return this._counter++, this._counter.toString();
  }, s;
}();
(function() {
  function s(e) {
    var t = this;
    this._textEditChanges = /* @__PURE__ */ Object.create(null), e !== void 0 ? (this._workspaceEdit = e, e.documentChanges ? (this._changeAnnotations = new KL(e.changeAnnotations), e.changeAnnotations = this._changeAnnotations.all(), e.documentChanges.forEach(function(i) {
      if (vg.is(i)) {
        var n = new Vd(i.edits, t._changeAnnotations);
        t._textEditChanges[i.textDocument.uri] = n;
      }
    })) : e.changes && Object.keys(e.changes).forEach(function(i) {
      var n = new Vd(e.changes[i]);
      t._textEditChanges[i] = n;
    })) : this._workspaceEdit = {};
  }
  return Object.defineProperty(s.prototype, "edit", {
    get: function() {
      return this.initDocumentChanges(), this._changeAnnotations !== void 0 && (this._changeAnnotations.size === 0 ? this._workspaceEdit.changeAnnotations = void 0 : this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()), this._workspaceEdit;
    },
    enumerable: !1,
    configurable: !0
  }), s.prototype.getTextEditChange = function(e) {
    if (wg.is(e)) {
      if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
        throw new Error("Workspace edit is not configured for document changes.");
      var t = { uri: e.uri, version: e.version }, i = this._textEditChanges[t.uri];
      if (!i) {
        var n = [], r = {
          textDocument: t,
          edits: n
        };
        this._workspaceEdit.documentChanges.push(r), i = new Vd(n, this._changeAnnotations), this._textEditChanges[t.uri] = i;
      }
      return i;
    } else {
      if (this.initChanges(), this._workspaceEdit.changes === void 0)
        throw new Error("Workspace edit is not configured for normal text edit changes.");
      var i = this._textEditChanges[e];
      if (!i) {
        var n = [];
        this._workspaceEdit.changes[e] = n, i = new Vd(n), this._textEditChanges[e] = i;
      }
      return i;
    }
  }, s.prototype.initDocumentChanges = function() {
    this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0 && (this._changeAnnotations = new KL(), this._workspaceEdit.documentChanges = [], this._workspaceEdit.changeAnnotations = this._changeAnnotations.all());
  }, s.prototype.initChanges = function() {
    this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0 && (this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null));
  }, s.prototype.createFile = function(e, t, i) {
    if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
      throw new Error("Workspace edit is not configured for document changes.");
    var n;
    Tl.is(t) || gi.is(t) ? n = t : i = t;
    var r, o;
    if (n === void 0 ? r = wu.create(e, i) : (o = gi.is(n) ? n : this._changeAnnotations.manage(n), r = wu.create(e, i, o)), this._workspaceEdit.documentChanges.push(r), o !== void 0)
      return o;
  }, s.prototype.renameFile = function(e, t, i, n) {
    if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
      throw new Error("Workspace edit is not configured for document changes.");
    var r;
    Tl.is(i) || gi.is(i) ? r = i : n = i;
    var o, a;
    if (r === void 0 ? o = Su.create(e, t, n) : (a = gi.is(r) ? r : this._changeAnnotations.manage(r), o = Su.create(e, t, n, a)), this._workspaceEdit.documentChanges.push(o), a !== void 0)
      return a;
  }, s.prototype.deleteFile = function(e, t, i) {
    if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
      throw new Error("Workspace edit is not configured for document changes.");
    var n;
    Tl.is(t) || gi.is(t) ? n = t : i = t;
    var r, o;
    if (n === void 0 ? r = yu.create(e, i) : (o = gi.is(n) ? n : this._changeAnnotations.manage(n), r = yu.create(e, i, o)), this._workspaceEdit.documentChanges.push(r), o !== void 0)
      return o;
  }, s;
})();
var qL;
(function(s) {
  function e(i) {
    return { uri: i };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.string(n.uri);
  }
  s.is = t;
})(qL || (qL = {}));
var GL;
(function(s) {
  function e(i, n) {
    return { uri: i, version: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.string(n.uri) && F.integer(n.version);
  }
  s.is = t;
})(GL || (GL = {}));
var wg;
(function(s) {
  function e(i, n) {
    return { uri: i, version: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.string(n.uri) && (n.version === null || F.integer(n.version));
  }
  s.is = t;
})(wg || (wg = {}));
var ZL;
(function(s) {
  function e(i, n, r, o) {
    return { uri: i, languageId: n, version: r, text: o };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.string(n.uri) && F.string(n.languageId) && F.integer(n.version) && F.string(n.text);
  }
  s.is = t;
})(ZL || (ZL = {}));
var rb;
(function(s) {
  s.PlainText = "plaintext", s.Markdown = "markdown";
  function e(t) {
    var i = t;
    return i === s.PlainText || i === s.Markdown;
  }
  s.is = e;
})(rb || (rb = {}));
var Lu;
(function(s) {
  function e(t) {
    var i = t;
    return F.objectLiteral(t) && rb.is(i.kind) && F.string(i.value);
  }
  s.is = e;
})(Lu || (Lu = {}));
var Nt;
(function(s) {
  s.Text = 1, s.Method = 2, s.Function = 3, s.Constructor = 4, s.Field = 5, s.Variable = 6, s.Class = 7, s.Interface = 8, s.Module = 9, s.Property = 10, s.Unit = 11, s.Value = 12, s.Enum = 13, s.Keyword = 14, s.Snippet = 15, s.Color = 16, s.File = 17, s.Reference = 18, s.Folder = 19, s.EnumMember = 20, s.Constant = 21, s.Struct = 22, s.Event = 23, s.Operator = 24, s.TypeParameter = 25;
})(Nt || (Nt = {}));
var ob;
(function(s) {
  s.PlainText = 1, s.Snippet = 2;
})(ob || (ob = {}));
var YL;
(function(s) {
  s.Deprecated = 1;
})(YL || (YL = {}));
var QL;
(function(s) {
  function e(i, n, r) {
    return { newText: i, insert: n, replace: r };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n && F.string(n.newText) && xt.is(n.insert) && xt.is(n.replace);
  }
  s.is = t;
})(QL || (QL = {}));
var XL;
(function(s) {
  s.asIs = 1, s.adjustIndentation = 2;
})(XL || (XL = {}));
var JL;
(function(s) {
  function e(t) {
    var i = t;
    return i && (F.string(i.detail) || i.detail === void 0) && (F.string(i.description) || i.description === void 0);
  }
  s.is = e;
})(JL || (JL = {}));
var ek;
(function(s) {
  function e(t) {
    return { label: t };
  }
  s.create = e;
})(ek || (ek = {}));
var tk;
(function(s) {
  function e(t, i) {
    return { items: t || [], isIncomplete: !!i };
  }
  s.create = e;
})(tk || (tk = {}));
var Sg;
(function(s) {
  function e(i) {
    return i.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  s.fromPlainText = e;
  function t(i) {
    var n = i;
    return F.string(n) || F.objectLiteral(n) && F.string(n.language) && F.string(n.value);
  }
  s.is = t;
})(Sg || (Sg = {}));
var ik;
(function(s) {
  function e(t) {
    var i = t;
    return !!i && F.objectLiteral(i) && (Lu.is(i.contents) || Sg.is(i.contents) || F.typedArray(i.contents, Sg.is)) && (t.range === void 0 || xt.is(t.range));
  }
  s.is = e;
})(ik || (ik = {}));
var nk;
(function(s) {
  function e(t, i) {
    return i ? { label: t, documentation: i } : { label: t };
  }
  s.create = e;
})(nk || (nk = {}));
var sk;
(function(s) {
  function e(t, i) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var o = { label: t };
    return F.defined(i) && (o.documentation = i), F.defined(n) ? o.parameters = n : o.parameters = [], o;
  }
  s.create = e;
})(sk || (sk = {}));
var rk;
(function(s) {
  s.Text = 1, s.Read = 2, s.Write = 3;
})(rk || (rk = {}));
var ok;
(function(s) {
  function e(t, i) {
    var n = { range: t };
    return F.number(i) && (n.kind = i), n;
  }
  s.create = e;
})(ok || (ok = {}));
var Tt;
(function(s) {
  s.File = 1, s.Module = 2, s.Namespace = 3, s.Package = 4, s.Class = 5, s.Method = 6, s.Property = 7, s.Field = 8, s.Constructor = 9, s.Enum = 10, s.Interface = 11, s.Function = 12, s.Variable = 13, s.Constant = 14, s.String = 15, s.Number = 16, s.Boolean = 17, s.Array = 18, s.Object = 19, s.Key = 20, s.Null = 21, s.EnumMember = 22, s.Struct = 23, s.Event = 24, s.Operator = 25, s.TypeParameter = 26;
})(Tt || (Tt = {}));
var ak;
(function(s) {
  s.Deprecated = 1;
})(ak || (ak = {}));
var lk;
(function(s) {
  function e(t, i, n, r, o) {
    var a = {
      name: t,
      kind: i,
      location: { uri: r, range: n }
    };
    return o && (a.containerName = o), a;
  }
  s.create = e;
})(lk || (lk = {}));
var ck;
(function(s) {
  function e(t, i, n, r) {
    return r !== void 0 ? { name: t, kind: i, location: { uri: n, range: r } } : { name: t, kind: i, location: { uri: n } };
  }
  s.create = e;
})(ck || (ck = {}));
var hk;
(function(s) {
  function e(i, n, r, o, a, l) {
    var c = {
      name: i,
      detail: n,
      kind: r,
      range: o,
      selectionRange: a
    };
    return l !== void 0 && (c.children = l), c;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n && F.string(n.name) && F.number(n.kind) && xt.is(n.range) && xt.is(n.selectionRange) && (n.detail === void 0 || F.string(n.detail)) && (n.deprecated === void 0 || F.boolean(n.deprecated)) && (n.children === void 0 || Array.isArray(n.children)) && (n.tags === void 0 || Array.isArray(n.tags));
  }
  s.is = t;
})(hk || (hk = {}));
var uk;
(function(s) {
  s.Empty = "", s.QuickFix = "quickfix", s.Refactor = "refactor", s.RefactorExtract = "refactor.extract", s.RefactorInline = "refactor.inline", s.RefactorRewrite = "refactor.rewrite", s.Source = "source", s.SourceOrganizeImports = "source.organizeImports", s.SourceFixAll = "source.fixAll";
})(uk || (uk = {}));
var yg;
(function(s) {
  s.Invoked = 1, s.Automatic = 2;
})(yg || (yg = {}));
var dk;
(function(s) {
  function e(i, n, r) {
    var o = { diagnostics: i };
    return n != null && (o.only = n), r != null && (o.triggerKind = r), o;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.typedArray(n.diagnostics, Cg.is) && (n.only === void 0 || F.typedArray(n.only, F.string)) && (n.triggerKind === void 0 || n.triggerKind === yg.Invoked || n.triggerKind === yg.Automatic);
  }
  s.is = t;
})(dk || (dk = {}));
var fk;
(function(s) {
  function e(i, n, r) {
    var o = { title: i }, a = !0;
    return typeof n == "string" ? (a = !1, o.kind = n) : sc.is(n) ? o.command = n : o.edit = n, a && r !== void 0 && (o.kind = r), o;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n && F.string(n.title) && (n.diagnostics === void 0 || F.typedArray(n.diagnostics, Cg.is)) && (n.kind === void 0 || F.string(n.kind)) && (n.edit !== void 0 || n.command !== void 0) && (n.command === void 0 || sc.is(n.command)) && (n.isPreferred === void 0 || F.boolean(n.isPreferred)) && (n.edit === void 0 || sb.is(n.edit));
  }
  s.is = t;
})(fk || (fk = {}));
var gk;
(function(s) {
  function e(i, n) {
    var r = { range: i };
    return F.defined(n) && (r.data = n), r;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && xt.is(n.range) && (F.undefined(n.command) || sc.is(n.command));
  }
  s.is = t;
})(gk || (gk = {}));
var mk;
(function(s) {
  function e(i, n) {
    return { tabSize: i, insertSpaces: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && F.uinteger(n.tabSize) && F.boolean(n.insertSpaces);
  }
  s.is = t;
})(mk || (mk = {}));
var pk;
(function(s) {
  function e(i, n, r) {
    return { range: i, target: n, data: r };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && xt.is(n.range) && (F.undefined(n.target) || F.string(n.target));
  }
  s.is = t;
})(pk || (pk = {}));
var _k;
(function(s) {
  function e(i, n) {
    return { range: i, parent: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && xt.is(n.range) && (n.parent === void 0 || s.is(n.parent));
  }
  s.is = t;
})(_k || (_k = {}));
var bk;
(function(s) {
  s.namespace = "namespace", s.type = "type", s.class = "class", s.enum = "enum", s.interface = "interface", s.struct = "struct", s.typeParameter = "typeParameter", s.parameter = "parameter", s.variable = "variable", s.property = "property", s.enumMember = "enumMember", s.event = "event", s.function = "function", s.method = "method", s.macro = "macro", s.keyword = "keyword", s.modifier = "modifier", s.comment = "comment", s.string = "string", s.number = "number", s.regexp = "regexp", s.operator = "operator", s.decorator = "decorator";
})(bk || (bk = {}));
var Ck;
(function(s) {
  s.declaration = "declaration", s.definition = "definition", s.readonly = "readonly", s.static = "static", s.deprecated = "deprecated", s.abstract = "abstract", s.async = "async", s.modification = "modification", s.documentation = "documentation", s.defaultLibrary = "defaultLibrary";
})(Ck || (Ck = {}));
var vk;
(function(s) {
  function e(t) {
    var i = t;
    return F.objectLiteral(i) && (i.resultId === void 0 || typeof i.resultId == "string") && Array.isArray(i.data) && (i.data.length === 0 || typeof i.data[0] == "number");
  }
  s.is = e;
})(vk || (vk = {}));
var wk;
(function(s) {
  function e(i, n) {
    return { range: i, text: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n != null && xt.is(n.range) && F.string(n.text);
  }
  s.is = t;
})(wk || (wk = {}));
var Sk;
(function(s) {
  function e(i, n, r) {
    return { range: i, variableName: n, caseSensitiveLookup: r };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n != null && xt.is(n.range) && F.boolean(n.caseSensitiveLookup) && (F.string(n.variableName) || n.variableName === void 0);
  }
  s.is = t;
})(Sk || (Sk = {}));
var yk;
(function(s) {
  function e(i, n) {
    return { range: i, expression: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return n != null && xt.is(n.range) && (F.string(n.expression) || n.expression === void 0);
  }
  s.is = t;
})(yk || (yk = {}));
var Lk;
(function(s) {
  function e(i, n) {
    return { frameId: i, stoppedLocation: n };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.defined(n) && xt.is(i.stoppedLocation);
  }
  s.is = t;
})(Lk || (Lk = {}));
var ab;
(function(s) {
  s.Type = 1, s.Parameter = 2;
  function e(t) {
    return t === 1 || t === 2;
  }
  s.is = e;
})(ab || (ab = {}));
var lb;
(function(s) {
  function e(i) {
    return { value: i };
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && (n.tooltip === void 0 || F.string(n.tooltip) || Lu.is(n.tooltip)) && (n.location === void 0 || _g.is(n.location)) && (n.command === void 0 || sc.is(n.command));
  }
  s.is = t;
})(lb || (lb = {}));
var kk;
(function(s) {
  function e(i, n, r) {
    var o = { position: i, label: n };
    return r !== void 0 && (o.kind = r), o;
  }
  s.create = e;
  function t(i) {
    var n = i;
    return F.objectLiteral(n) && xn.is(n.position) && (F.string(n.label) || F.typedArray(n.label, lb.is)) && (n.kind === void 0 || ab.is(n.kind)) && n.textEdits === void 0 || F.typedArray(n.textEdits, nr.is) && (n.tooltip === void 0 || F.string(n.tooltip) || Lu.is(n.tooltip)) && (n.paddingLeft === void 0 || F.boolean(n.paddingLeft)) && (n.paddingRight === void 0 || F.boolean(n.paddingRight));
  }
  s.is = t;
})(kk || (kk = {}));
var Dk;
(function(s) {
  function e(t) {
    var i = t;
    return F.objectLiteral(i) && tb.is(i.uri) && F.string(i.name);
  }
  s.is = e;
})(Dk || (Dk = {}));
var Ek;
(function(s) {
  function e(r, o, a, l) {
    return new RH(r, o, a, l);
  }
  s.create = e;
  function t(r) {
    var o = r;
    return !!(F.defined(o) && F.string(o.uri) && (F.undefined(o.languageId) || F.string(o.languageId)) && F.uinteger(o.lineCount) && F.func(o.getText) && F.func(o.positionAt) && F.func(o.offsetAt));
  }
  s.is = t;
  function i(r, o) {
    for (var a = r.getText(), l = n(o, function(m, _) {
      var b = m.range.start.line - _.range.start.line;
      return b === 0 ? m.range.start.character - _.range.start.character : b;
    }), c = a.length, h = l.length - 1; h >= 0; h--) {
      var u = l[h], d = r.offsetAt(u.range.start), f = r.offsetAt(u.range.end);
      if (f <= c)
        a = a.substring(0, d) + u.newText + a.substring(f, a.length);
      else
        throw new Error("Overlapping edit");
      c = d;
    }
    return a;
  }
  s.applyEdits = i;
  function n(r, o) {
    if (r.length <= 1)
      return r;
    var a = r.length / 2 | 0, l = r.slice(0, a), c = r.slice(a);
    n(l, o), n(c, o);
    for (var h = 0, u = 0, d = 0; h < l.length && u < c.length; ) {
      var f = o(l[h], c[u]);
      f <= 0 ? r[d++] = l[h++] : r[d++] = c[u++];
    }
    for (; h < l.length; )
      r[d++] = l[h++];
    for (; u < c.length; )
      r[d++] = c[u++];
    return r;
  }
})(Ek || (Ek = {}));
var RH = function() {
  function s(e, t, i, n) {
    this._uri = e, this._languageId = t, this._version = i, this._content = n, this._lineOffsets = void 0;
  }
  return Object.defineProperty(s.prototype, "uri", {
    get: function() {
      return this._uri;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(s.prototype, "languageId", {
    get: function() {
      return this._languageId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(s.prototype, "version", {
    get: function() {
      return this._version;
    },
    enumerable: !1,
    configurable: !0
  }), s.prototype.getText = function(e) {
    if (e) {
      var t = this.offsetAt(e.start), i = this.offsetAt(e.end);
      return this._content.substring(t, i);
    }
    return this._content;
  }, s.prototype.update = function(e, t) {
    this._content = e.text, this._version = t, this._lineOffsets = void 0;
  }, s.prototype.getLineOffsets = function() {
    if (this._lineOffsets === void 0) {
      for (var e = [], t = this._content, i = !0, n = 0; n < t.length; n++) {
        i && (e.push(n), i = !1);
        var r = t.charAt(n);
        i = r === "\r" || r === `
`, r === "\r" && n + 1 < t.length && t.charAt(n + 1) === `
` && n++;
      }
      i && t.length > 0 && e.push(t.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }, s.prototype.positionAt = function(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    var t = this.getLineOffsets(), i = 0, n = t.length;
    if (n === 0)
      return xn.create(0, e);
    for (; i < n; ) {
      var r = Math.floor((i + n) / 2);
      t[r] > e ? n = r : i = r + 1;
    }
    var o = i - 1;
    return xn.create(o, e - t[o]);
  }, s.prototype.offsetAt = function(e) {
    var t = this.getLineOffsets();
    if (e.line >= t.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    var i = t[e.line], n = e.line + 1 < t.length ? t[e.line + 1] : this._content.length;
    return Math.max(Math.min(i + e.character, n), i);
  }, Object.defineProperty(s.prototype, "lineCount", {
    get: function() {
      return this.getLineOffsets().length;
    },
    enumerable: !1,
    configurable: !0
  }), s;
}(), F;
(function(s) {
  var e = Object.prototype.toString;
  function t(f) {
    return typeof f < "u";
  }
  s.defined = t;
  function i(f) {
    return typeof f > "u";
  }
  s.undefined = i;
  function n(f) {
    return f === !0 || f === !1;
  }
  s.boolean = n;
  function r(f) {
    return e.call(f) === "[object String]";
  }
  s.string = r;
  function o(f) {
    return e.call(f) === "[object Number]";
  }
  s.number = o;
  function a(f, m, _) {
    return e.call(f) === "[object Number]" && m <= f && f <= _;
  }
  s.numberRange = a;
  function l(f) {
    return e.call(f) === "[object Number]" && -2147483648 <= f && f <= 2147483647;
  }
  s.integer = l;
  function c(f) {
    return e.call(f) === "[object Number]" && 0 <= f && f <= 2147483647;
  }
  s.uinteger = c;
  function h(f) {
    return e.call(f) === "[object Function]";
  }
  s.func = h;
  function u(f) {
    return f !== null && typeof f == "object";
  }
  s.objectLiteral = u;
  function d(f, m) {
    return Array.isArray(f) && f.every(m);
  }
  s.typedArray = d;
})(F || (F = {}));
var un = "yaml";
function PH(s) {
  switch (s) {
    case cl.Error:
      return Ua.Error;
    case cl.Warning:
      return Ua.Warning;
    case cl.Information:
      return Ua.Info;
    case cl.Hint:
      return Ua.Hint;
    default:
      return Ua.Info;
  }
}
function OH(s) {
  switch (s) {
    case bg.Deprecated:
      return eb.Deprecated;
    case bg.Unnecessary:
      return eb.Unnecessary;
  }
}
function hI(s) {
  var e;
  return {
    severity: PH(s.severity),
    startLineNumber: s.range.start.line + 1,
    startColumn: s.range.start.character + 1,
    endLineNumber: s.range.end.line + 1,
    endColumn: s.range.end.character + 1,
    message: s.message,
    code: String(s.code),
    source: s.source,
    tags: (e = s.tags) == null ? void 0 : e.map(OH)
  };
}
function xk(s) {
  return {
    owner: un,
    async provideMarkerData(e) {
      return (await (await s(e.uri)).doValidation(String(e.uri))).map(hI);
    },
    async doReset(e) {
      await (await s(e.uri)).resetSchema(String(e.uri));
    }
  };
}
function dv(s) {
  if (!!s)
    return { character: s.column - 1, line: s.lineNumber - 1 };
}
function us(s) {
  if (!!s)
    return new hv(
      s.start.line + 1,
      s.start.character + 1,
      s.end.line + 1,
      s.end.character + 1
    );
}
function uI(s) {
  return {
    start: { line: s.startLineNumber - 1, character: s.startColumn - 1 },
    end: { line: s.endLineNumber - 1, character: s.endColumn - 1 }
  };
}
function FH(s) {
  return {
    message: s.message,
    range: uI(s),
    code: typeof s.code == "object" ? s.code.value : s.code,
    source: s.source
  };
}
function BH(s) {
  const e = Si.CompletionItemKind;
  switch (s) {
    case Nt.Text:
      return e.Text;
    case Nt.Method:
      return e.Method;
    case Nt.Function:
      return e.Function;
    case Nt.Constructor:
      return e.Constructor;
    case Nt.Field:
      return e.Field;
    case Nt.Variable:
      return e.Variable;
    case Nt.Class:
      return e.Class;
    case Nt.Interface:
      return e.Interface;
    case Nt.Module:
      return e.Module;
    case Nt.Property:
      return e.Property;
    case Nt.Unit:
      return e.Unit;
    case Nt.Value:
      return e.Value;
    case Nt.Enum:
      return e.Enum;
    case Nt.Keyword:
      return e.Keyword;
    case Nt.Snippet:
      return e.Snippet;
    case Nt.Color:
      return e.Color;
    case Nt.File:
      return e.File;
    case Nt.Reference:
      return e.Reference;
    default:
      return e.Property;
  }
}
function dI(s) {
  if (!!s)
    return {
      range: us(s.range),
      text: s.newText
    };
}
function VH(s) {
  return {
    triggerCharacters: [" ", ":"],
    async provideCompletionItems(e, t) {
      const i = e.uri, r = await (await s(i)).doComplete(String(i), dv(t));
      if (!r)
        return;
      const o = e.getWordUntilPosition(t), a = new hv(
        t.lineNumber,
        o.startColumn,
        t.lineNumber,
        o.endColumn
      ), l = r.items.map((c) => {
        const h = {
          label: c.label,
          insertText: c.insertText || c.label,
          sortText: c.sortText,
          filterText: c.filterText,
          documentation: c.documentation,
          detail: c.detail,
          kind: BH(c.kind),
          range: a
        };
        return c.textEdit && (h.range = us(
          "range" in c.textEdit ? c.textEdit.range : c.textEdit.replace
        ), h.insertText = c.textEdit.newText), c.additionalTextEdits && (h.additionalTextEdits = c.additionalTextEdits.map(dI)), c.insertTextFormat === ob.Snippet && (h.insertTextRules = Si.CompletionItemInsertTextRule.InsertAsSnippet), h;
      });
      return {
        incomplete: r.isIncomplete,
        suggestions: l
      };
    }
  };
}
function WH(s) {
  return {
    originSelectionRange: us(s.originSelectionRange),
    range: us(s.targetRange),
    targetSelectionRange: us(s.targetSelectionRange),
    uri: uv.parse(s.targetUri)
  };
}
function HH(s) {
  return {
    async provideDefinition(e, t) {
      const i = e.uri, r = await (await s(i)).doDefinition(String(i), dv(t));
      return r == null ? void 0 : r.map(WH);
    }
  };
}
function zH(s) {
  return {
    async provideHover(e, t) {
      const i = e.uri, r = await (await s(i)).doHover(String(i), dv(t));
      if (!!r)
        return {
          range: us(r.range),
          contents: [{ value: r.contents.value }]
        };
    }
  };
}
function UH(s) {
  const e = Si.SymbolKind;
  switch (s) {
    case Tt.File:
      return e.Array;
    case Tt.Module:
      return e.Module;
    case Tt.Namespace:
      return e.Namespace;
    case Tt.Package:
      return e.Package;
    case Tt.Class:
      return e.Class;
    case Tt.Method:
      return e.Method;
    case Tt.Property:
      return e.Property;
    case Tt.Field:
      return e.Field;
    case Tt.Constructor:
      return e.Constructor;
    case Tt.Enum:
      return e.Enum;
    case Tt.Interface:
      return e.Interface;
    case Tt.Function:
      return e.Function;
    case Tt.Variable:
      return e.Variable;
    case Tt.Constant:
      return e.Constant;
    case Tt.String:
      return e.String;
    case Tt.Number:
      return e.Number;
    case Tt.Boolean:
      return e.Boolean;
    case Tt.Array:
      return e.Array;
    default:
      return e.Function;
  }
}
function fI(s) {
  return {
    detail: s.detail || "",
    range: us(s.range),
    name: s.name,
    kind: UH(s.kind),
    selectionRange: us(s.selectionRange),
    children: s.children.map(fI),
    tags: []
  };
}
function $H(s) {
  return {
    async provideDocumentSymbols(e) {
      const t = e.uri, n = await (await s(t)).findDocumentSymbols(String(t));
      if (!!n)
        return n.map(fI);
    }
  };
}
function jH(s) {
  return {
    tabSize: s.tabSize,
    insertSpaces: s.insertSpaces,
    ...s
  };
}
function KH(s) {
  return {
    async provideDocumentFormattingEdits(e, t) {
      const i = e.uri, r = await (await s(i)).format(String(i), jH(t));
      if (!(!r || r.length === 0))
        return r.map(dI);
    }
  };
}
function qH(s) {
  return {
    range: us(s.range),
    tooltip: s.tooltip,
    url: s.target
  };
}
function GH(s) {
  return {
    async provideLinks(e) {
      const t = e.uri;
      return {
        links: (await (await s(t)).findLinks(String(t))).map(qH)
      };
    }
  };
}
function ZH(s) {
  const e = [];
  for (const [t, i] of Object.entries(s.changes))
    for (const n of i)
      e.push({
        resource: uv.parse(t),
        edit: {
          text: n.newText,
          range: us(n.range)
        }
      });
  return {
    edits: e
  };
}
function YH(s) {
  var e;
  return {
    title: s.title,
    diagnostics: s.diagnostics.map(hI),
    disabled: (e = s.disabled) == null ? void 0 : e.reason,
    edit: ZH(s.edit),
    kind: s.kind,
    isPreferred: s.isPreferred
  };
}
function QH(s) {
  return {
    async provideCodeActions(e, t, i) {
      const n = e.uri;
      return {
        actions: (await (await s(n)).getCodeAction(
          String(n),
          uI(t),
          i.markers.map(FH)
        )).map(YH),
        dispose() {
        }
      };
    }
  };
}
var XH = {
  comments: {
    lineComment: "#"
  },
  brackets: [
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ],
  autoClosingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"', close: '"' },
    { open: "'", close: "'" }
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"', close: '"' },
    { open: "'", close: "'" }
  ],
  onEnterRules: [
    {
      beforeText: /:\s*$/,
      action: { indentAction: Si.IndentAction.Indent }
    }
  ]
};
function JH(s) {
  const e = AH(rf, {
    label: "yaml",
    moduleId: "monaco-yaml/yaml.worker",
    createData: {
      languageSettings: s.diagnosticsOptions,
      enableSchemaRequest: s.diagnosticsOptions.enableSchemaRequest
    }
  });
  s.onDidChange(() => {
    e.updateCreateData({
      languageSettings: s.diagnosticsOptions,
      enableSchemaRequest: s.diagnosticsOptions.enableSchemaRequest
    });
  }), Si.registerCompletionItemProvider(
    un,
    VH(e.getWorker)
  ), Si.registerHoverProvider(un, zH(e.getWorker)), Si.registerDefinitionProvider(
    un,
    HH(e.getWorker)
  ), Si.registerDocumentSymbolProvider(
    un,
    $H(e.getWorker)
  ), Si.registerDocumentFormattingEditProvider(
    un,
    KH(e.getWorker)
  ), Si.registerLinkProvider(un, GH(e.getWorker)), Si.registerCodeActionProvider(
    un,
    QH(e.getWorker)
  ), Si.setLanguageConfiguration(un, XH);
  let t = FL(
    rf,
    un,
    xk(e.getWorker)
  );
  s.onDidChange(() => {
    t.dispose(), t = FL(
      rf,
      un,
      xk(e.getWorker)
    );
  });
}
var gI = {
  completion: !0,
  customTags: [],
  enableSchemaRequest: !1,
  format: !0,
  isKubernetes: !1,
  hover: !0,
  schemas: [],
  validate: !0,
  yamlVersion: "1.2"
};
function ez(s) {
  const e = new aI();
  let t = s;
  const i = {
    get onDidChange() {
      return e.event;
    },
    get diagnosticsOptions() {
      return t;
    },
    setDiagnosticsOptions(n) {
      t = { ...gI, ...n }, e.fire(i);
    }
  };
  return i;
}
var mI = ez(gI);
Si.register({
  id: un,
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml"]
});
Si.onLanguage("yaml", () => {
  JH(mI);
});
function Xz(s = {}) {
  mI.setDiagnosticsOptions(s);
}
function tz() {
  return new Worker("/assets/yaml.worker.6bcd1e42.js");
}
self.MonacoEnvironment = {
  getWorker(s, e) {
    return new tz();
  }
};
export {
  uv as U,
  DH as e,
  rf as m,
  Xz as s,
  mI as y
};
